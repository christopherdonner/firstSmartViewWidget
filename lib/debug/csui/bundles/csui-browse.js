csui.define('csui/behaviors/item.name/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/behaviors/item.name/impl/nls/root/lang',{

  nameErrorEmptyValue: 'This is a required field.',
  nameErrorMaxLegthExceed: 'Name cannot be longer than 248 characters.',
  nameErrorContainSemiColon: 'Name cannot contain a colon.',
  error: "Unable to complete this request. Please try again later.",
  nameExists: "An item with the name '{name}' already exists.",
  renameTitle: "Rename",
  addFolderTitle: "Add folder"
});


csui.define('csui/behaviors/item.name/item.name.behavior',['csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/utils/base', 'csui/models/version', 'csui/models/namequery',
  'csui/utils/commands',
  'i18n!csui/behaviors/item.name/impl/nls/lang'
], function ($, _, Backbone, Marionette, base, VersionModel, NameQuery, commands, lang) {

  var ItemNameBehavior = Marionette.Behavior.extend({

    ui: {
      inputName: '.title-input',
      saveButton: '.cs-add-button'
    },

    events: {
      'click @ui.name': 'onClickName',
      'click @ui.nameInput': 'cancelEvent',
      'keyup @ui.nameInput': 'onKeyReleased',
      'paste @ui.inputName': 'mouseRightCicked',
      'cut @ui.inputName': 'mouseRightCicked',
      'blur @ui.nameInput': 'onBlurNameInput',
      'mousedown @ui.nameEditCancelIcon': 'cancelNameEdit',
      'click @ui.nameEditCancelIcon': 'cancelEvent',
      'click @ui.nameEditDiv': 'cancelEvent'
    },

    constructor: function ItemNameBehavior(options, view) {
      Marionette.Behavior.prototype.constructor.apply(this, arguments);
      this._nameSchema = _.extend({
        required: true,
        readonly: false
      }, this.options.nameSchema);
      this.view = view;
      this.view.ItemNameBehavior = this;
      this.listenTo(this.view.model || this.view.options.model, "change:name", this.toggleButton);
    },

    updateNameSchema: function (nameSchema) {
      this._nameSchema = _.extend({
        required: true,
        readonly: false
      }, nameSchema);
      this.toggleButton();
    },

    toggleButton: function (event) {
      // can be called if widget was destroyed before completely rendered.
      // to avoid crash must check for valid ui field.
      if (!this.ui || !this.ui.inputName || !this.ui.inputName.val) {
        return;
      }
      var currentInputElementVal = this.ui.inputName.val().trim(),
          disableButton          = true;
      if (!this._isEditMode() || this._isCopyMoveAction()) { // only in create mode or while Copying/Moving operation

        // Check the name field and disable the primary dialog button,
        // if the field is required, but empty
        disableButton = this._nameSchema.required && currentInputElementVal.length == 0;
        this.view.trigger("update:button", {disabled: disableButton});
      }
    },

    _isEditMode: function () {
      return this.view.model.get('id') !== undefined;
    },

    _isCopyMoveAction: function () {
      return this.view.model.get('action') === "copy" || "move";
    },

    mouseRightCicked: function (event) {
      var that = this;
      setTimeout(function () {
        that.toggleButton(event);
      }, 100);
    },

    onBeforeDestroy: function () {
      if (this.view._nodeIconView) {
        this.view._nodeIconView.destroy();
      }
      if (this.view.dropdownMenuView) {
        this.view.cancelEventsToViewsPropagation(this.view.dropdownMenuView);
        this.view.dropdownMenuView.destroy();
      }
    },

    onKeyInView: function (e) {
      if (this.view.readonly) {
        return;
      }
      var event = e || window.event;

      if (event.keyCode === 9 && this.getInputBoxValue() === "") {
        // tab while the input value is still empty, keep the focus on the input box
        event.preventDefault();
        event.stopPropagation();
        this.validate('');  // show error
        setTimeout(_.bind(function () {
          this.view.ui.nameInput.focus();
        }, this), 100);
        return;
      }

      if (event.keyCode === 27) {
        // escape
        this.cancelNameEdit(event);
        return;
      }

      if (event.keyCode === 32 || event.keyCode === 13) {
        // space(32) or enter(13)
        var menuItemClick = this.view.dropdownMenuView &&
                            this.view.dropdownMenuView.$el.find(event.target).length > 0 ?
                            true : false;
        // Rename needs timeOut to not change the editing mode on Enter keypress
        var timeOut = event.keyCode === 13 ? 200 : 0;
        var target = event.target || event.srcElement;
        if (menuItemClick) {
          event.preventDefault();
          event.stopPropagation();
          if (base.isMozilla() || base.isEdge()) {
            $(target).click();
          } else {
            setTimeout(function () {
              $(target).click();
            }, timeOut);
          }
        } else if (this.view.editing !== true) {
          event.preventDefault();
          event.stopPropagation();
          setTimeout(_.bind(function () {
            this._toggleEditMode(true);
          }, this), timeOut);
        }
      }
    },

    setEditModeFocus: function () {
      if (this.view.readonly) {
        return;
      }
      // workaround for the lost focus sometimes due to modal dialog animation or something else
      setTimeout(_.bind(function () {
        if (this.view.ui.nameInput instanceof Object) {
          this._toggleEditMode(true);
          this.view.ui.nameInput.focus();
          //this.view.ui.nameInput[0].setSelectionRange(0, 0);
          this.view.ui.nameInput[0].select();
        }
      }, this), 500);
    },

    showInlineError: function (error) {
      this.view.ui.titleError.attr('title', error);
      this.view.ui.titleError.text(error);
      this.view.ui.titleError.attr('role', 'alert');
    },

    clearInlineError: function () {
      this.view.ui.titleError.attr('title', '');
      this.view.ui.titleError.text('');
      this.view.ui.titleError.removeAttr('role');
    },

    validateInputName: function (iName) {
      var deferred = $.Deferred(),
          success  = true;
      if (this.view.readonly) {
        this.clearInlineError();
        return true;
      }
      var name = iName === undefined ? this.getValue() : iName;
      name = name.trim();
      var self = this;
      this._isValidName(name)
          .done(function (exists) {
            if (exists) {
              self._displayInlineError(name, exists);
              success = false;
              deferred.resolve(success);
            } else {
              self.clearInlineError();
              deferred.resolve(success);
            }

          }).fail(function () {
        //if query failed (no connectivity, parent folder doesn't exist, etc)
        deferred.reject();
      });
      return deferred.promise();

    },
    validate: function (iName) {
      if (this.view.readonly) {
        this.clearInlineError();
        return true;
      }
      var name = iName === undefined ? this.getValue() : iName;
      name = name.trim();
      if (name.length < 1) {
        this.showInlineError(lang.nameErrorEmptyValue);
        return false;
      } else if (name.length > 248) {
        this.showInlineError(lang.nameErrorMaxLegthExceed);
        return false;
      } else if (name.indexOf(':') >= 0) {
        this.showInlineError(lang.nameErrorContainSemiColon);
        return false;
      }
      this.clearInlineError();
      return true;
    },

    //check for validity of new name
    _isValidName: function (newName) {
      var exists = true; //a flag variable used when checking for existing item names
      var deferred = $.Deferred();

      if (newName && newName.length <= 248 && newName.indexOf(":") === -1) {
        var model = this.view.model;
        var container = model.parent || this.view.options.container;
        if (!!container && (!container.get('id') || container.get('id') === -1)) {
          deferred.resolve(false);
        } else {
          this.checkNameExists(newName)
              .done(function (data, result, request) {
                if (null === data.results[0].id) {
                  exists = false;
                }
                deferred.resolve(exists);
              })
              .fail(deferred.reject);
        }

        return deferred.promise();
      }

      deferred.resolve(exists);
      return deferred.promise();

    },

    //check for existence of item name
    checkNameExists: function (name) {
      var model     = this.view.model,
          container = model.parent || this.view.options.container,
          connector = container.connector,
          deferred  = $.Deferred(),

          nameQuery = new NameQuery(null, {container: container, connector: connector});
      nameQuery.runQuery(container.get('id'), [name])
          .done(deferred.resolve)
          .fail(deferred.reject);

      return deferred.promise();
    },

    //display the appropriate inline error
    _displayInlineError: function (newName, exists) {
      var message;
      if (newName.length < 1) {
        message = lang.nameErrorEmptyValue;
      } else if (newName.length > 248) {
        message = lang.nameErrorMaxLegthExceed;
      } else if (newName.indexOf(":") !== -1) {
        message = lang.nameErrorContainSemiColon;
      } else if (exists) {
        message = lang.nameExists.replace('{name}', newName);
      }
      this.showInlineError(message);
    },

    getValue: function () {
      return this.view.ui.name.text();
    },

    getInputBoxValue: function () {
      if (this.view.modelHasEmptyName && this.view.inputBoxNameChange !== true) {
        return '';
      } else {
        return this.view.ui.nameInput.val();
      }
    },

    setValue: function (value) {
      this.view.ui.name.text(value);
      this.view.ui.name.attr('title', value);
    },

    setInputBoxValue: function (value) {
      if (!value) {
        value = '';
      }
      this.view.ui.nameInput.val(value);
    },

    _toggleEditMode: function (edit, setFocus) {
      setFocus === undefined && (setFocus = true);
      if (this.view.readonly) {
        edit = false;
      }
      // edit = true: switch to edit mode
      if (edit) {
        // If renaming is not permitted do not show the edit box
        if (this._isEditingEnabled()) {
          this.view.editing = true;
          this.view.ui.name.addClass('binf-hidden');
          this.view.ui.nameEditIconDiv && this.view.ui.nameEditIconDiv.addClass('binf-hidden');
          this.view.ui.nameEditIcon && this.view.ui.nameEditIcon.addClass('binf-hidden');
          this.view.ui.nameDropdownMenuDiv &&
          this.view.ui.nameDropdownMenuDiv.addClass('binf-hidden');
          this.view.ui.nameEditDiv.removeClass('binf-hidden');
          setFocus && this.view.ui.nameInput.focus();

          // Begin - highlight the complete text.
          var currentInputElement    = this.view.ui.nameInput[0],
              currentInputElementVal = currentInputElement.value,
              selEnd                 = !!currentInputElementVal ? currentInputElementVal.length : 0;
          currentInputElement.selectionEnd = 0;

          // for documents, highlight text till last dot.
          if (this.view.model.get("type") === 144 && currentInputElementVal.lastIndexOf('.') > 0 &&
              currentInputElementVal.lastIndexOf('.') < currentInputElementVal.length - 1) {
            selEnd = currentInputElementVal.lastIndexOf('.');
          }
          currentInputElement.selectionEnd = selEnd;
          // End - highlight the complete text.
          if (currentInputElementVal.length === 0) {
            this.view.ui.nameInput[0].placeholder = this.view.placeHolderName;
          }
          this.view.trigger('changed:editmode', this.view.editing);
        }
      } else {  // switch back to readonly mode
        if (this.view.$el.is(":visible")) {
          this.view.editing = false;
          this.view.ui.nameEditDiv.addClass('binf-hidden');
          this.view.ui.name.removeClass('binf-hidden');
          setFocus && this.view.ui.name.focus();
          this.view.ui.nameDropdownMenuDiv &&
          this.view.ui.nameDropdownMenuDiv.removeClass('binf-hidden');
          this.view.ui.nameEditIconDiv && this.view.ui.nameEditIconDiv.removeClass('binf-hidden');
          this.view.ui.nameEditIcon && this.view.ui.nameEditIcon.removeClass('binf-hidden');
          this.view.trigger('changed:editmode', this.view.editing);
        }
      }
    },

    _isEditing: function () {
      return this.view.editing;
    },

    _isEditingEnabled: function () {
      if (this.view.readonly) {
        return false;
      }
      // add item's new model does not have an id yet
      if (this.view.model.get('id') === undefined) {
        return true;
      }

      var renameCommand = commands.get('Rename');
      return renameCommand && renameCommand.enabled({
            nodes: new Backbone.Collection([this.view.model]),
            context: this.view.options.context
          });
    },

    onClickName: function (event) {
      if (this.view.readonly) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();

      // for version metadata, the fields are read-only
      if (this.view.options.model instanceof VersionModel) {
        return;
      }

      this._toggleEditMode(true);
    },

    cancelEvent: function (event) {
      event.preventDefault();
      event.stopPropagation();
    },

    onKeyReleased: function (event) {
      if (this.view.readonly) {
        return;
      }
      // delegate control to it's parent view, generally in creation mode it is dialog view.
      // so that dialog will close upon pressing escape key.
      if (!(!!this.view.options && this.view.options.mode === 'create')) {
        event.preventDefault();
        event.stopPropagation();

        if (event.keyCode === 27) {
          // escape
          this.cancelNameEdit(event);
        } else if (event.keyCode === 13) {
          // enter
          // TODO: Do not call private methods outside their object.
          if (!!this.view.options.originatingView &&
              _.isFunction(this.view.options.originatingView._validateAndSave)) {
            this.view.options.originatingView._validateAndSave();
          } else {
            this.view._validateAndSave();
          }
        } else if (this.getInputBoxValue() === "") {
          //this.setInputBoxValue(this.view.placeHolderName);
          // this.view.ui.nameInput.addClass('csui-empty-with-placeholder');
          this.view.ui.nameInput[0].placeholder = this.view.placeHolderName ?
                                                  this.view.placeHolderName : '';
          this.view.inputBoxNameChange = false;
        }
      }
      this.toggleButton(event);
    },

    onBlurNameInput: function (event) {
      if (this.view.readonly) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if (this.view.cancelEdit === true) {
        this.view.cancelEdit = false;
        return;
      }

      if (this.view.modelHasEmptyName && this.view.inputBoxNameChange !== true) {
        this.setInputBoxValue(this.placeHolderName);
        this.validate('');
      } else {
        // TODO: Do not call private methods outside their object.
        if (!!this.view.options.originatingView &&
            _.isFunction(this.view.options.originatingView._validateAndSave)) {
          this.view.options.originatingView._validateAndSave();
        } else {
          this.view._validateAndSave();
        }
      }
    },

    cancelNameEdit: function (event) {
      if (this.view.readonly) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();

      this.cancelEdit = true;
      this.clearInlineError();

      this.view.inputBoxNameChange = this.view.modelHasEmptyName ? false : true;
      if (this.view.modelHasEmptyName && this.view.inputBoxNameChange !== true) {
        this.setInputBoxValue('');
        this.validate('');
        this.toggleButton(event);
      } else {
        this.setInputBoxValue(this.getValue());
        this._toggleEditMode(false);
        this.toggleButton();
      }
    },

    _getErrorMessageFromResponse: function (err) {
      var errorMessage;
      if (err && err.responseJSON && err.responseJSON.error) {
        errorMessage = err.responseJSON.error;
        base.MessageHelper.hasMessages() && (base.MessageHelper.reset());
      } else if (base.MessageHelper.hasMessages()) {
        var errorHtml = base.MessageHelper.toHtml();
        base.MessageHelper.reset();
        errorMessage = $(errorHtml).text();
      }
      return errorMessage;
    }

  });

  return ItemNameBehavior;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.rowselection.toolbar/impl/right.toolbar',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-condensed-header-toggle-container\">\r\n    <button type=\"button\" class=\"csui-condensed-header-toggle\"\r\n            title=\""
    + this.escapeExpression(((helper = (helper = helpers.toggleCondensedHeaderTooltip || (depth0 != null ? depth0.toggleCondensedHeaderTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"toggleCondensedHeaderTooltip","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.toggleCondensedHeaderTooltip || (depth0 != null ? depth0.toggleCondensedHeaderTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"toggleCondensedHeaderTooltip","hash":{}}) : helper)))
    + "\">\r\n      <span class=\"icon icon-condensed-header\"></span>\r\n    </button>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.showCondensedHeaderToggle : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table.rowselection.toolbar_impl_right.toolbar', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table.rowselection.toolbar/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table.rowselection.toolbar/impl/nls/root/localized.strings',{
  showCondensedHeaderTooltip: 'Show header',
  hideCondensedHeaderTooltip: 'Hide header'
});



csui.define('css!csui/controls/table.rowselection.toolbar/impl/right.toolbar',[],function(){});
csui.define('csui/controls/table.rowselection.toolbar/impl/right.toolbar.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/controls/table.rowselection.toolbar/impl/right.toolbar',
  'i18n!csui/controls/table.rowselection.toolbar/impl/nls/localized.strings',
  'css!csui/controls/table.rowselection.toolbar/impl/right.toolbar'
], function (_, $, Marionette, ViewEventsPropagationMixin, TabableRegionBehavior, template, lang) {
  'use strict';

  var RightToolbarView = Marionette.ItemView.extend({

    className: 'csui-right-toolbar-view',

    template: template,
    templateHelpers: function () {
      return {
        showCondensedHeaderToggle: this.options.showCondensedHeaderToggle,
        toggleCondensedHeaderTooltip: lang.showCondensedHeaderTooltip
      };
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    ui: {
      condensedHeaderToggleButton: '.csui-condensed-header-toggle',
      condensedHeaderToggleIcon: '.icon-condensed-header'
    },

    events: {
      'keydown': 'onKeyInView',
      'click .csui-condensed-header-toggle-container': 'onClickCondensedHeaderToggle'
    },

    constructor: function RightToolbarView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.call(this, options);
      this._toolbarVisible = false;
    },

    onRender: function () {
      this.delegateEvents();
    },

    onToolbarActivity: function (toolbarVisible, headerVisible) {
      this._toolbarVisible = toolbarVisible;
      if (this.options.showCondensedHeaderToggle) {
        this.ui.condensedHeaderToggleButton.attr('tabindex', toolbarVisible ? '0' : '-1');
        if (headerVisible) {
          this.ui.condensedHeaderToggleIcon.addClass('icon-rotate180');
          this.ui.condensedHeaderToggleButton.attr('aria-label', lang.hideCondensedHeaderTooltip);
          this.ui.condensedHeaderToggleButton.attr('title', lang.hideCondensedHeaderTooltip);
        } else {
          this.ui.condensedHeaderToggleIcon.removeClass('icon-rotate180');
          this.ui.condensedHeaderToggleButton.attr('aria-label', lang.showCondensedHeaderTooltip);
          this.ui.condensedHeaderToggleButton.attr('title', lang.showCondensedHeaderTooltip);
        }
      }
    },

    onClickCondensedHeaderToggle: function (event) {
      // trigger the event for the parent NodesTable to show/hide condensed header
      this.trigger('toggle:condensed:header');
      this.ui.condensedHeaderToggleButton.focus();
    },

    currentlyFocusedElement: function () {
      if (this._toolbarVisible) {
        return this.ui.condensedHeaderToggleButton;
      } else {
        return $();
      }
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {  // space or enter key
        event.preventDefault();
        event.stopPropagation();
        $(event.target).click();
      }
    }

  });

  _.extend(RightToolbarView.prototype, ViewEventsPropagationMixin);

  return RightToolbarView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.rowselection.toolbar/impl/table.rowselection.toolbar',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-toolbar-region\"></div>\r\n<div class=\"csui-right-toolbar-region\"></div>\r\n";
}});
Handlebars.registerPartial('csui_controls_table.rowselection.toolbar_impl_table.rowselection.toolbar', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table.rowselection.toolbar/impl/table.rowselection.toolbar',[],function(){});
csui.define('csui/controls/table.rowselection.toolbar/table.rowselection.toolbar.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/toolbar/toolitems.filtered.model',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/controls/toolbar/toolbar.view',
  'csui/controls/toolbar/delayed.toolbar.view',
  'csui/controls/table.rowselection.toolbar/impl/right.toolbar.view',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/mixins/global.alert/global.alert.mixin',
  'hbs!csui/controls/table.rowselection.toolbar/impl/table.rowselection.toolbar',
  'css!csui/controls/table.rowselection.toolbar/impl/table.rowselection.toolbar'
], function ($, _,
    Backbone, Marionette, base,
    FilteredToolItemsCollection,
    ToolbarCommandController,
    ToolbarView,
    DelayedToolbarView,
    RightToolbarView,
    TabableRegionBehavior,
    GlobalAlertMixin,
    template) {
  'use strict';

  var TableRowSelectionToolbarView = Marionette.LayoutView.extend({
    template: template,
    className: 'csui-table-rowselection-toolbar-view',

    regions: {
      toolbarRegion: '.csui-toolbar-region',
      rightToolbarRegion: '.csui-right-toolbar-region'
    },

    events: {
      'keydown': 'onKey'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    currentlyFocusedElement: function () {
      return $(this._focusableElements[this._focusedToolbarItemIndex]);
    },

    constructor: function TableRowSelectionToolbarView(options) {
      options || (options = {});

      Marionette.LayoutView.prototype.constructor.apply(this, arguments);

      this._focusedToolbarItemIndex = 0;
    },

    initialize: function (options) {

      var status = {
        nodes: options.selectedChildren,
        context: options.context,
        collection: options.collection,
        container: options.collection.node
      };

      this._commandController = options.toolbarCommandController ||
                                new ToolbarCommandController({
                                  commands: options.commands
                                });

      // actions on the 'other' toolbar can be loaded later
      // make filtered collection of toolbar items
      this._filteredToolItemsCollection = new FilteredToolItemsCollection(
          options.toolItemFactory, {
            status: status,
            commands: this._commandController.commands,
            delayedActions: options.collection.delayedActions,
            mask: options.toolbarItemsMask
          });

      // create toolbar view
      var toolbarViewOptions = _.extend({
        originatingView: options.originatingView,
        collection: this._filteredToolItemsCollection,
        toolbarName: 'tableHeader'
      }, options.toolItemFactory.options, {role: 'menu'});

      if (options.collection.delayedActions) {
        this._toolbarView = new DelayedToolbarView(toolbarViewOptions);
      } else {
        this._toolbarView = new ToolbarView(toolbarViewOptions);
      }

      // attach event listener for clicked toolbar items
      this.listenTo(this._toolbarView, 'childview:toolitem:action', this._toolbarItemClicked);
      this.listenTo(this._toolbarView, 'render render:lazy:actions', function () {
        this._updateCounts();
        if (this._focusableElements.length) {
          this._focusedToolbarItemIndex = 0;
          this._moveTabindexToFocusedElement();
        }
      });

      this._rightToolbarView = new RightToolbarView(options);
      this.listenTo(this._rightToolbarView, 'toggle:condensed:header', function () {
        this.trigger('toggle:condensed:header');
      });
      this.listenTo(this, 'toolbar:activity', function (toolbarVisible, headerVisible) {
        this._rightToolbarView.triggerMethod('toolbar:activity', toolbarVisible, headerVisible);
      });

      this.listenTo(this._commandController, 'before:execute:command', function (eventArgs) {
        this._toolbarView.trigger('before:execute:command', eventArgs);
      });
      this.listenTo(this._commandController, 'after:execute:command', function (eventArgs) {
        this._toolbarView.trigger('after:execute:command', eventArgs);
      });

      this.listenTo(this, 'render', function () {
        this.toolbarRegion.show(this._toolbarView);
        this.rightToolbarRegion.show(this._rightToolbarView);
      });

      this.listenTo(this, 'dom:refresh', function () {
        this._toolbarView.triggerMethod('dom:refresh');
        this._rightToolbarView.triggerMethod('dom:refresh');
      });

    },

    _toolbarItemClicked: function (toolItemView, args) {
      var executionContext = {
        context: this.options.context,
        nodes: this.options.selectedChildren,
        container: this.options.collection.node,
        collection: this.options.collection,
        originatingView: this.options.originatingView,
        toolItemView: toolItemView
      };

      this._commandController.toolitemClicked(args.toolItem, executionContext);
    },

    onKey: function (event) {
      switch (event.keyCode) {
      case 37:
        // left arrow
          this._updateCounts();
        if (this._focusedToolbarItemIndex > 0) {
          this._focusedToolbarItemIndex--;
          // even if the calculated focus moved to the left, check if it moved enough, because
          // in the meanwhile the number of toolbar items could have been changed
          if (this._focusedToolbarItemIndex >= this._visibleToolitemsCount) {
            this._focusedToolbarItemIndex = this._visibleToolitemsCount - 1;
          }
        } else {
          this._focusedToolbarItemIndex = 0;
        }
        this._moveTabindexToFocusedElement();
        this._moveFocus();
        event.preventDefault();
        event.stopPropagation();
        break;
      case 39:
        // right arrow:
        this._updateCounts();
        if (this._focusedToolbarItemIndex < this._visibleToolitemsCount - 1) {
          this._focusedToolbarItemIndex++;
        } else {
          // re-set the index of the focused toolbar item to the rightmost, because the
          // toolbar items could have been changed in the meanwhile
          this._focusedToolbarItemIndex = this._visibleToolitemsCount - 1;
        }
        this._moveTabindexToFocusedElement();
        this._moveFocus();
        event.preventDefault();
        event.stopPropagation();
        break;
      }
    },

    _updateCounts: function () {
      this._focusableElements = base.findFocusables(this._toolbarView.el);
      this._visibleToolitemsCount = this._toolbarView.getVisibleToolitemsCount();
    },

    _moveTabindexToFocusedElement: function () {
      for (var i = 0; i < this._focusableElements.length; i++) {
        if (i === this._focusedToolbarItemIndex) {
          this._focusableElements[i].setAttribute('tabindex', '0');
        } else {
          this._focusableElements[i].setAttribute('tabindex', '-1');
        }
      }
    },

    _moveFocus: function () {
      this.trigger('changed:focus');
      if (this._toolbarView) {
        this._toolbarView.setFocusByIndex(this._focusedToolbarItemIndex);
      }
    }

  });

  _.extend(TableRowSelectionToolbarView.prototype, GlobalAlertMixin);

  return TableRowSelectionToolbarView;

});


csui.define('css!csui/behaviors/table.rowselection.toolbar/impl/table.rowselection.toolbar',[],function(){});
// Shows the table toolbar on selecting rows in table view
csui.define('csui/behaviors/table.rowselection.toolbar/table.rowselection.toolbar.behavior',[
  'csui/lib/underscore', 'csui/lib/marionette',
  'csui/controls/table.rowselection.toolbar/table.rowselection.toolbar.view',
  'csui/lib/jquery.redraw',
  'css!csui/behaviors/table.rowselection.toolbar/impl/table.rowselection.toolbar'
], function (_, Marionette, ToolbarView) {
 'use strict';

  var accessibleTable = /\baccessibleTable\b(?:=([^&]*)?)?/i.exec(location.search);
  accessibleTable = accessibleTable && accessibleTable[1] !== 'false';

  var TableRowSelectionToolbarBehavior = Marionette.Behavior.extend({
    initialize: function () {
      this.listenTo(this.view, {
        'before:render': this.setToolbar,
        'render': this.renderToolbar
      });
    },

    setToolbar: function () {
      this.toolbarRegion = this.view[getOption(this.options, 'toolbarRegionName', this.view)] || this.view.toolbarRegion;
      if (!this.toolbarRegion || !this.view.tableView) {
        return;
      }

      var visibleClassName = getOption(this.options, 'visibleClassName', this.view) || 'csui-rowselection-toolbar-visible',
        toolbarViewOptions = getOption(this.options, 'toolbarViewOptions', this.view);

      this.toolbarView = new ToolbarView(_.extend({
        toolItemFactory: this.view.options.toolbarItems.tableHeaderToolbar,
        toolbarItemsMask: this.view.options.toolbarItemsMasks.toolbars.tableHeaderToolbar,
        toolbarCommandController: this.view.commandController,
        // if toolbarCommandController is not defined, a new ToolbarCommandController with the following commands is created
        commands: this.view.defaultActionController.commands,
        selectedChildren: this.view.tableView.selectedChildren,
        container: this.view.collection.node,
        context: this.view.options.context,
        originatingView: this.view, // used for blocking and modal dialogs
        collection: this.view.collection
      }, toolbarViewOptions));

      this.listenTo(this.view.tableView.selectedChildren, 'reset', function () {
        var $el = this.toolbarRegion.$el;
        if (this.view.tableView.selectedChildren.length > 0) {
          if (!$el.hasClass(visibleClassName)) {
            if (accessibleTable) {
              $el.removeClass('binf-hidden')
                 .addClass('csui-no-animation')
                 .addClass(visibleClassName);
            } else {
              $el.removeClass('binf-hidden')
                 .redraw()
                 .addClass(visibleClassName);
            }
          }
        } else {
          if ($el.hasClass(visibleClassName)) {
            if (accessibleTable) {
              $el.addClass('binf-hidden')
                 .addClass('csui-no-animation')
                 .removeClass(visibleClassName);
            } else {
              $el.one('transitionend', function () {
                $el.addClass('binf-hidden');
              })
              .removeClass(visibleClassName);
            }
          }
        }
        this.toolbarView && this.toolbarView.triggerMethod('dom:refresh');
      });
    },

    renderToolbar: function () {
      if (this.toolbarRegion && this.toolbarView) {
        this.toolbarRegion.show(this.toolbarView);
        this.toolbarRegion.$el.addClass('binf-hidden');
      }
    }
  });

  function getOption(object, property, context) {
    if (object == null) {
      return void 0;
    }
    var value = object[property];
    return _.isFunction(value) ? object[property].call(context) : value;
  }

  return TableRowSelectionToolbarBehavior;
});
csui.define('csui/controls/dialog/impl/footer.view',['csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior'
], function (Marionette, TabableRegion) {

  var ButtonView = Marionette.ItemView.extend({

    tagName: 'button',

    className: 'binf-btn',

    template: false,

    triggers: {
      'click': 'click'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    constructor: function ButtonView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);
    },

    isTabable: function () {
      return this.$el.is(':not(:disabled)') && this.$el.is(':not(:hidden)');
    },
    currentlyFocusedElement: function () {
      if (this.$el.prop('tabindex') === -1) {
        this.$el.prop('tabindex', 0);
      }
      return this.$el;
    },

    onRender: function () {
      var button     = this.$el,
          attributes = this.model.attributes;
      button.text(attributes.label);
      button.addClass(
          attributes['default'] ? 'binf-btn-primary cs-add-button' : 'binf-btn-default');
      if (attributes.toolTip) {
        button.attr('title', attributes.toolTip);
      }
      if (attributes.separate) {
        button.addClass('cs-separate');
      }
      this.updateButton(attributes);
    },

    updateButton: function (attributes) {

      var $button = this.$el;
      attributes || (attributes = {});
      if (attributes.hidden !== undefined) {
        if (attributes.hidden) {
          $button.addClass('binf-hidden');
        } else {
          $button.removeClass('binf-hidden');
        }
      }
      if (attributes.disabled !== undefined) {
        $button.prop('disabled', attributes.disabled);
      }
    }

  });

  var DialogFooterView = Marionette.CollectionView.extend({

    childView: ButtonView,

    constructor: function DialogFooterView(options) {
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
    },
    onDomRefresh: function () {
      this.children.each(function (buttonView) {
        buttonView.trigger('dom:refresh');
      });
    },

    getButtons: function () {
      return this.children.toArray();
    },

    updateButton: function (id, attributes) {
      var button = this.collection.get(id);
      if (button) {
        this.children
            .findByModel(button)
            .updateButton(attributes);
      } else {
        // If the footer comes from the dialog template including the buttons,
        // the collection of dynamically created buttons is empty.
        // The template has to provide correct initial classes for the buttons
        // and their identifiers must be present in the "data-cs-id" attribute.
        ButtonView.updateButton(this.$('[data-cs-id="' + id + '"]'), attributes);
      }
    }

  });

  return DialogFooterView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/dialog/impl/dialog.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.actionIconLeft : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.iconLeft : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "    <h2 class=\"tile-title binf-modal-title csui-heading\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2>\r\n  </div>\r\n\r\n    <div class=\"cs-header-control\"></div>\r\n\r\n    <div class=\"cs-close\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.dialogCloseButtonTooltip || (depth0 != null ? depth0.dialogCloseButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"dialogCloseButtonTooltip","hash":{}}) : helper)))
    + "\"\r\n         tabindex=\"0\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.dialogCloseAria || (depth0 != null ? depth0.dialogCloseAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"dialogCloseAria","hash":{}}) : helper)))
    + "\" role=\"button\">\r\n      <div class=\"icon circular "
    + this.escapeExpression(((helper = (helper = helpers.iconRight || (depth0 != null ? depth0.iconRight : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconRight","hash":{}}) : helper)))
    + "\"></div>\r\n    </div>\r\n\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "    <span class=\"tile-type-action-icon cs-icon-left "
    + this.escapeExpression(((helper = (helper = helpers.actionIconLeft || (depth0 != null ? depth0.actionIconLeft : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"actionIconLeft","hash":{}}) : helper)))
    + "\" tabindex=\"0\"></span>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "    <span class=\"tile-type-icon cs-icon-left "
    + this.escapeExpression(((helper = (helper = helpers.iconLeft || (depth0 != null ? depth0.iconLeft : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconLeft","hash":{}}) : helper)))
    + "\"></span>\r\n    <div class=\"tile-title\">\r\n";
},"6":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.imageLeftUrl : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "");
},"7":function(depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"tile-type-image "
    + this.escapeExpression(((helper = (helper = helpers.imageLeftClass || (depth0 != null ? depth0.imageLeftClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageLeftClass","hash":{}}) : helper)))
    + "\">\r\n          <span class=\"tile-type-icon tile-type-icon-img\">\r\n           <img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imageLeftUrl || (depth0 != null ? depth0.imageLeftUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageLeftUrl","hash":{}}) : helper)))
    + "\" alt=\"\" aria-hidden=\"true\">\r\n          </span>\r\n        </div>\r\n      <div class=\"tile-title\">\r\n";
},"9":function(depth0,helpers,partials,data) {
    return "      <div class=\"tile-title cs-text-only\">\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.expandedHeader : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_dialog_impl_dialog.header', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/dialog/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/dialog/impl/nls/root/lang',{

  dialogCloseButtonTooltip: 'Close',
  dialogCloseAria: 'Close dialog'

});



csui.define('css!csui/controls/dialog/impl/dialog',[],function(){});
csui.define('csui/controls/dialog/impl/header.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/controls/dialog/impl/dialog.header',
  'i18n!csui/controls/dialog/impl/nls/lang',
  'css!csui/controls/dialog/impl/dialog'
], function (_, $, Marionette, TabableRegion, headerTemplate, lang) {

  var DialogHeaderView = Marionette.ItemView.extend({

    template: headerTemplate,

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    ui: {
      headerControl: '.cs-header-control'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    templateHelpers: function () {
      return {
        iconLeft: this.options.iconLeft,
        actionIconLeft: this.options.actionIconLeft,
        imageLeftUrl: this.options.imageLeftUrl,
        imageLeftClass: this.options.imageLeftClass,
        title: this.options.title,
        iconRight: this.options.iconRight || 'cs-icon-cross',
        expandedHeader: this.options.expandedHeader,
        dialogCloseButtonTooltip: lang.dialogCloseButtonTooltip,
        dialogCloseAria: lang.dialogCloseAria
      };
    },

    constructor: function DialogHeaderView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);
    },

    isTabable: function () {
      return this.$('*[tabindex]').length > 0;
    },

    currentlyFocusedElement: function (event) {
      var tabElements = this.$('*[tabindex]');
      if (tabElements.length) {
        tabElements.prop('tabindex', 0);
      }
      if (!!event && event.shiftKey) {
        return $(tabElements[tabElements.length - 1]);
      } else {
        return $(tabElements[0]) && $(tabElements[0]).focus();
      }
    },

    onLastTabElement: function (shiftTab, event) {
      // return true if focus is on last tabable element else false.
      return (shiftTab && event.target === this.$('*[tabindex]')[0]);
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode;

      //Enter/space
      if (keyCode === 13 || keyCode === 32) {
        $(event.target).click();
      }
    },

    onRender: function () {
      var headers = this.options.headers || [];
      if (headers.length) {
        _.each(headers, function (header) {
          var $header = this._renderHeader(header);
          this.$el.append($header);
        }, this);
      }
      var headerControl = this.options.headerControl;
      if (headerControl) {
        this.ui.headerControl.append(headerControl.$el);
        headerControl.render();
        headerControl.trigger('dom:refresh');
      }

      if (!!this.options.actionIconLeft) {
        this._adjustTitleCSS();
      }
    },
    onDomRefresh: function () {
      var headerControl = this.options.headerControl;
      if (headerControl) {
        headerControl.triggerMethod('dom:refresh');
        headerControl.triggerMethod('after:show');
      }
    },

    _renderHeader: function (options) {
      var div = $('<div class="modal-header-item"></div>')
          .text(options.label);
      if (options.class) {
        div.addClass(options.class);
      }
      return div;
    },

    _adjustTitleCSS: function (options) {
      this.$el.find('div.tile-title').addClass('tile-action-icon-tittle');
    }

  });

  return DialogHeaderView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/dialog/impl/dialog',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"binf-modal-body cs-dialog cs-dialog-bodymessage\">"
    + this.escapeExpression(((helper = (helper = helpers.bodyMessage || (depth0 != null ? depth0.bodyMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"bodyMessage","hash":{}}) : helper)))
    + "</div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    return "      <div class=\"binf-modal-body\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"binf-modal-dialog "
    + this.escapeExpression(((helper = (helper = helpers.binfDialogSizeClassName || (depth0 != null ? depth0.binfDialogSizeClassName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"binfDialogSizeClassName","hash":{}}) : helper)))
    + "\" role=\"dialog\" aria-hidden=\"false\">\r\n  <div class=\"binf-modal-content\" >\r\n    <div class=\"tile-header binf-modal-header\"></div>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.bodyMessage : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "    <div class=\"binf-modal-footer binf-hidden\"></div>\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_dialog_impl_dialog', t);
return t;
});
/* END_TEMPLATE */
;
// Renders a view in a modal dialog and waits for the user to close it
csui.define('csui/controls/dialog/dialog.view',['module', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/keyboard.navigation/tabables.behavior',
  'csui/controls/dialog/impl/footer.view',
  'csui/controls/dialog/impl/header.view',
  'hbs!csui/controls/dialog/impl/dialog',
  'csui/utils/non-emptying.region/non-emptying.region',
  'csui/utils/log',
  'i18n',
  'css!csui/controls/dialog/impl/dialog',
  'csui/lib/binf/js/binf'
], function (module, _, $, Backbone, Marionette, LayoutViewEventsPropagationMixin,
    TabablesBehavior, DialogFooterView, DialogHeaderView, dialogTemplate,
    NonEmptyingRegion, log, i18n) {

  log = log(module.id);

  var DialogView = Marionette.LayoutView.extend({

    className: function () {
      var className = 'cs-dialog binf-modal binf-fade';
      if (this.options.className) {
        className += ' ' + _.result(this.options, 'className');
      }
      return className;
    },

    attributes: {
      'tabindex': '-1', // prevent focus to move outside dialog when tabbing through
      'aria-hidden': 'true'
    },

    template: dialogTemplate,

    behaviors: {
      TabablesBehavior: {
        behaviorClass: TabablesBehavior,
        recursiveNavigation: true,
        containTabFocus: true
      }
    },

    regions: {
      body: '.binf-modal-body',
      header: '.binf-modal-header',
      footer: '.binf-modal-footer'
    },

    ui: {
      header: '.binf-modal-header',
      footer: '.binf-modal-footer',
      body: '.binf-modal-body'
    },

    events: {
      'hide.binf.modal': 'onHiding',
      'hidden.binf.modal': 'onHidden',
      'click .cs-close': 'onClickClose',
      'shown.binf.modal': 'onShown',
      'keyup': 'onKeyInView', // must be keyup, because subviews want to intercept too
      'setCurrentTabFocus': 'setCurrentTabFocus',
      'tabNextRegion': 'tabNextRegion',
      'click .tile-type-action-icon': 'onClickActionIcon'
    },

    templateHelpers: function () {
      var binfDialogSizeClassName = !!this.options.largeSize ? 'binf-modal-lg' :
                                    (!!this.options.midSize ? 'binf-modal-md' : '');
      return {
        binfDialogSizeClassName: binfDialogSizeClassName,
        bodyMessage: this.options.bodyMessage
      };
    },

    constructor: function DialogView() {
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);
      this.listenToOnce(this, 'before:hide', TabablesBehavior.popTabableHandler);
      this.propagateEventsToRegions();
      if (this.options.headerControl) {
        // log.warn('"headerControl" option has been deprecated and is ' +
        //          'going to be removed. Use "headerView" instead.') &&
        // console.warn(log.last);
        // log.warn('Occurred ' + log.getStackTrace(2)) && console.warn(log.last);
      }
    },

    onKeyInView: function (event) {
      // Don't close the Modal dialog if the default is prevented by subview.
      // Subviews such as popover or open menu would just close itself but not close Modal dialog.
      if (event.keyCode === 27 && !event.isDefaultPrevented()) {
        this.destroy();
      }
    },

    setCurrentTabFocus: function () {
      this.focusOnLastRegion = true;
      this.$el.focus();
    },

    tabNextRegion: function () {
      this.trigger('changed:focus');
    },

    show: function () {
      var container = $.fn.binf_modal.getDefaultContainer(),
          region    = new NonEmptyingRegion({el: container});
      region.show(this);
      return this;
    },

    onRender: function () {
      // FIXME: Do not use className for additional classes; it overrides the prototype
      this.$el.addClass(DialogView.prototype.className.call(this))
          .attr({'tabindex': 0, 
                  'aria-label': this.options.dialogTxtAria || this.options.title || ''
                });
      this._renderHeader();

      if (this.options.view) {
        this.body.show(this.options.view);
      }

      this._renderFooter();
    },

    onShow: function () {
      // Firefox workaround for absolute modal dialogs, it does not position to active element.
      // Scroll the main-body down e.g. 2/3 and open an absolute modal dialog and in Firefox it will start at window position 0.
      // => navigate to pos 0    (Firefox likes window instead of 'body')
      $(window).scrollTop(0);

      this.$el.binf_modal({
        backdrop: 'static',
        keyboard: false,
        paddingWhenOverflowing: false
      });
    },

    kill: function () {
      DialogView.__super__.destroy.apply(this, arguments);
      this._scrollToBegin();
      return true;
    },

    destroy: function () {
      // If destroying was not triggered by the modal plugin, hide the
      // dialog first using that interface to prevent memory leaks
      if (this.$el.is(':visible')) {
        this.$el.binf_modal('hide');
      } else {
        DialogView.__super__.destroy.apply(this, arguments);
      }
      this._scrollToBegin();
      return this;
    },

    updateButton: function (id, options) {
      var footerView = this.footerView;
      if (!footerView.updateButton) {
        throw new Error('Dialog footer does not support button updating.');
      }
      footerView.updateButton(id, options);
    },

    showView: function (view) {
      this.body.show(view);
      view.triggerMethod('after:show');
    },

    onShown: function () {
      if (this.options.view && this.options.view.triggerMethod) {
        this.options.view.triggerMethod('dom:refresh');
        this.options.view.triggerMethod('after:show');
      }
      if (this.headerView && this.headerView.triggerMethod) {
        this.headerView.triggerMethod('dom:refresh');
        this.headerView.triggerMethod('after:show');
      }
      if (this.footerView && this.footerView.triggerMethod) {
        this.footerView.triggerMethod('dom:refresh');
        this.footerView.triggerMethod('after:show');
      }
    },

    onHiding: function () {
      this.triggerMethod('before:hide');
    },

    onHidden: function () {
      this.triggerMethod('hide');
      this.destroy();
    },

    onClickClose: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.destroy();
    },

    onClickActionIcon: function (event) {
      //originating view listens this event and then executes their call back function
      this.options.view.trigger("click:actionIcon");
    },

    onClickButton: function (view) {
      var attributes = view.model.attributes;
      if (attributes.click) {
        attributes.click({
          dialog: this,
          button: this.$el,
          buttonAttributes: attributes
        });
      }
      if (attributes.close) {
        this.destroy();
      }
    },

    _scrollToBegin: function () {
      // move the scrollbar of the "body" to the leftmost or rightmost position
      if (i18n.settings.rtl === true) {
        var pos = $('body').width();
        $('body').scrollLeft(pos);
      } else {
        $('body').scrollLeft(0);
      }
    },

    _renderHeader: function () {
      var headerView = this.headerView = this.options.headerView,
          expandedHeader = this.options.standardHeader !== undefined ?
                           this.options.standardHeader : !this.options.template;
      if (headerView) {
        this.header.show(headerView);
      }
      else {
        var options = {
          iconLeft: this.options.iconLeft,
          actionIconLeft: this.options.actionIconLeft,
          imageLeftUrl: this.options.imageLeftUrl,
          imageLeftClass: this.options.imageLeftClass,
          title: this.options.title,
          iconRight: this.options.iconRight || 'cs-icon-cross',
          headers: this.options.headers,
          headerControl: this.options.headerControl,
          expandedHeader: expandedHeader,
          el: this.ui.header[0]
        };
        headerView = this.headerView = new DialogHeaderView(options);
        headerView.render();
        this.header.attachView(headerView);
        this.headerView.trigger('dom:refresh');
      }
    },

    _renderFooter: function () {
      var footerView = this.footerView = this.options.footerView;
      if (footerView) {
        this.ui.footer.removeClass('binf-hidden');
        this.footer.show(footerView);
      } else {
        var buttons = this.options.buttons || [];
        if (buttons.length) {
          this.ui.footer.removeClass('binf-hidden');
        }
        footerView = this.footerView = new DialogFooterView({
          collection: new Backbone.Collection(buttons),
          el: this.ui.footer[0]
        });
        this.listenTo(footerView, 'childview:click', this.onClickButton);
        footerView.render();
        this.footer.attachView(footerView);
      }
    }

  });

  _.extend(DialogView.prototype, LayoutViewEventsPropagationMixin);

  return DialogView;

});

csui.define('csui/controls/conflict.resolver/impl/conflict.dialog/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/conflict.resolver/impl/conflict.dialog/impl/nls/root/lang',{
  conflictCount: '{0} Conflicts',
  oneConflict: '1 Conflict',
  upload: 'Upload',
  cancel: 'Cancel',
  inputPlaceHolder: 'Enter filename',
  nameConflict: 'This file already exists.',
  nameConflictVersionAria: 'A file {0} already exists. Add a new version',
  nameConflictRenameAria: 'A file {0} already exists. Rename',
  nameConflictSkipAria: 'A file {0} already exists. Skip',
  rename: 'Rename',
  addVersion: 'Add version',
  skip: 'Skip',
  conflict: 'Conflict',
  cancelUpload: 'Cancel Upload',
  renamed: 'Renamed',
  undo:'Undo',
  undoAria: 'File {0} has state {1}. Undo',
  retry: 'Retry',
  serverError: 'File(s) not uploaded due to server error.'
});




/* START_TEMPLATE */
csui.define('hbs!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "          <div class=\"csui-msg\" title=\""
    + this.escapeExpression(((helper = (helper = helpers['conflict-error-msg'] || (depth0 != null ? depth0['conflict-error-msg'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"conflict-error-msg","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers['conflict-error-msg'] || (depth0 != null ? depth0['conflict-error-msg'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"conflict-error-msg","hash":{}}) : helper)))
    + "</div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.excludeAddVersion : depth0),{"name":"unless","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "    <button type=\"button\" class=\"binf-btn btn-rename conflict-field "
    + this.escapeExpression(((helper = (helper = helpers.multiRowClass || (depth0 != null ? depth0.multiRowClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"multiRowClass","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.renameAria || (depth0 != null ? depth0.renameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"renameAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\"\r\n            title=\""
    + this.escapeExpression(((helper = (helper = helpers.rename || (depth0 != null ? depth0.rename : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"rename","hash":{}}) : helper)))
    + "\" data-cs-id=\"rename\">"
    + this.escapeExpression(((helper = (helper = helpers.rename || (depth0 != null ? depth0.rename : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"rename","hash":{}}) : helper)))
    + "</button>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "      <button type=\"button\" class=\"binf-btn btn-version conflict-field\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.versionAria || (depth0 != null ? depth0.versionAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"versionAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.version || (depth0 != null ? depth0.version : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"version","hash":{}}) : helper)))
    + "\"\r\n            data-cs-id=\"version\">"
    + this.escapeExpression(((helper = (helper = helpers.version || (depth0 != null ? depth0.version : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"version","hash":{}}) : helper)))
    + "</button>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.noServerError : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"7":function(depth0,helpers,partials,data) {
    var helper;

  return "      <button type=\"button\" class=\"binf-btn btn-undo "
    + this.escapeExpression(((helper = (helper = helpers.multiRowClass || (depth0 != null ? depth0.multiRowClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"multiRowClass","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.undoAria || (depth0 != null ? depth0.undoAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"undoAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.undo || (depth0 != null ? depth0.undo : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"undo","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.undo || (depth0 != null ? depth0.undo : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"undo","hash":{}}) : helper)))
    + "</button>\r\n";
},"9":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.multiConflicts : depth0),{"name":"if","hash":{},"fn":this.program(10, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"10":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.statusNotSkip : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"11":function(depth0,helpers,partials,data) {
    var helper;

  return "        <span class=\"cs-icon circle_delete conflict-field\" tabindex=\"0\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.skip || (depth0 != null ? depth0.skip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"skip","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.skipAria || (depth0 != null ? depth0.skipAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"skipAria","hash":{}}) : helper)))
    + "\" role=\"button\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "\r\n<span class=\"csui-icon csui-status-icon "
    + this.escapeExpression(((helper = (helper = helpers['status-icon'] || (depth0 != null ? depth0['status-icon'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status-icon","hash":{}}) : helper)))
    + " \" aria-hidden=\"true\"></span>\r\n\r\n\r\n      <div class=\"csui-icon "
    + this.escapeExpression(((helper = (helper = helpers['file-icon'] || (depth0 != null ? depth0['file-icon'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"file-icon","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\"></div>\r\n\r\n\r\n      <div class=\"csui-description\">\r\n        <div class=\"csui-name\">\r\n          <span class=\"folder-name conflict-field "
    + this.escapeExpression(((helper = (helper = helpers['status-ok'] || (depth0 != null ? depth0['status-ok'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status-ok","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n          <input class=\"binf-form-control cs-input rename-field binf-hidden\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.inputPlaceHolder || (depth0 != null ? depth0.inputPlaceHolder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"inputPlaceHolder","hash":{}}) : helper)))
    + "\" tabindex=\"-1\">\r\n          <span class=\"csui-undo edit-cancel inline-edit-icon  rename-field binf-hidden\" tabindex=\"-1\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.cancel || (depth0 != null ? depth0.cancel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cancel","hash":{}}) : helper)))
    + "\"></span>\r\n        </div>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.conflict : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "      </div>\r\n\r\n    <div class=\"csui-status conflict-field "
    + this.escapeExpression(((helper = (helper = helpers['status-ok'] || (depth0 != null ? depth0['status-ok'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status-ok","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.status || (depth0 != null ? depth0.status : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.status || (depth0 != null ? depth0.status : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status","hash":{}}) : helper)))
    + "</div>\r\n\r\n\r\n\r\n<div class=\"csui-button-container\" style=\""
    + this.escapeExpression(((helper = (helper = helpers.resolvedStyle || (depth0 != null ? depth0.resolvedStyle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"resolvedStyle","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.conflict : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.noServerError : depth0),{"name":"if","hash":{},"fn":this.program(9, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n\r\n<div class='csui-internal-placeholder rename-field binf-hidden'>\r\n  <div class=\"csui-progress-container binf-hidden\">\r\n    <div class=\"loader\">\r\n      <div class=\"inner-border\"></div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_conflict.resolver_impl_conflict.dialog_impl_conflict.item_conflict.item', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item',[],function(){});

csui.define('css!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/progress.wheel',[],function(){});
// Shows a list of links
csui.define('csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/utils/nodesprites',
  'csui/models/namequery',
  'i18n!csui/controls/conflict.resolver/impl/conflict.dialog/impl/nls/lang',
  'csui/controls/progressblocker/blocker',
  "csui/utils/base",
  "csui/utils/log",
  'hbs!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item',
  'css!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item',
  'css!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/progress.wheel',
  'css!csui/controls/globalmessage/globalmessage_icons'
], function (_,
  $,
  Marionette,
  NodeSpriteCollection,
  NameQuery,
  lang,
  ProgressIndicator,
  base,
  log,
  itemTemplate) {


  var ConflictListItem = Marionette.ItemView.extend({

    constructor: function ConflictListItem(options) {
      Marionette.ItemView.call(this, options);
      this._onDynamicPlacment = _.bind(this._setDynamicPlacement, this);
      $(window).bind("resize.app", this._onDynamicPlacment);
      //Keep original name, reset newName;
      if(!this.model.get('newName')){
        var name = this.model.get('name');
        this.model.set('newName', name);
      }
    },

    ui: {
      'inputField': 'input',
      'fileDescription': '.csui-description',
      'versionBtn': '.btn-version',
      'renameBtn': '.btn-rename',
      'cancelIcon': '.circle_delete',
      'progressWheel': '.csui-progress-container',
      'errorMessage': '.csui-msg',
      'statusText': '.csui-status',
      'cancelEdit': '.edit-cancel',

      'conflictFields': '.conflict-field',
      'renameFields': '.rename-field'

    },

    triggers: {
      'click @ui.versionBtn': 'click:version',
      'mouseleave': 'hide:cancel',
      'click @ui.cancelEdit': 'cancel:input'
    },

    events: {
      'click @ui.renameBtn': 'onRename',
      'focusout @ui.renameFields': '_queryName',
      'click @ui.cancelIcon': 'onCancelUpload',
      'keydown @ui.cancelIcon': 'onCancelUpload',
      'click .btn-undo': 'undo',
      'mouseenter': 'onHover',
      'focus *[tabindex]': 'onFocus',
      'keydown': 'onKeyInView'
    },

    tagName: 'div',
    className: 'binf-list-group-item',
    template: itemTemplate,

    templateHelpers: function () {
      var multiRowClass = this.options.multiConflicts && (this.model.status !== 'skip') ? '' : 'no-cancel-icon',
          newName = this.model.get('newName');
      return {
        'file-icon': this.getMimeTypeIcon(),
        'name': newName,
        'conflict-error-msg': lang.nameConflict,
        'conflict': !this.model.status,
        'status': this.getStatus(),
        'excludeAddVersion': this.model.excludeAddVersion || this.model.get('versioned') === false,
        'version': lang.addVersion,
        'versionAria': _.str.sformat(lang.nameConflictVersionAria, newName),
        'rename': lang.rename,
        'renameAria': _.str.sformat(lang.nameConflictRenameAria, newName),
        'skip': lang.skip,
        'skipAria': _.str.sformat(lang.nameConflictSkipAria, newName),
        'multiConflicts': this.options.multiConflicts,
        'multiRowClass': multiRowClass,
        'undo': lang.undo,
        'undoAria': _.str.sformat(lang.undoAria, newName, this.getStatus()),
        'status-ok': this.getResolveStatus(),
        'status-icon': this.getStatusIcon(),
        'cancel': lang.cancel,
        'inputPlaceHolder': lang.inputPlaceHolder,
        'statusNotSkip': this.model.status !== 'skip',
        'noServerError': this.model.status !== 'serverError',
        'resolvedStyle': this.resolvedStyle

      };
    },
    onKeyInView: function (event) {
      var keyCode = event.keyCode,
          target = $(event.target),
          retVal = true;
      switch (keyCode) {
        //tab
        case 9:
          if (target.hasClass('cs-input')) {
            this.ui.cancelEdit.focus();
            retVal = false;
          }
          if (target.hasClass('edit-cancel')) {
            this.ui.inputField.focus();
            retVal = false;
          }
          break;
        //escape
        case 27:
          if (target.hasClass('cs-input')) {
            this.onCancelInput();
            this.$el.trigger('setCurrentTabFocus');
            retVal = false;
          }
          break;
        //Enter and space
        case 32:
        case 13:
          if (target.hasClass('edit-cancel')) {
            this.onCancelInput();
          }
          if (target.hasClass('cs-input') && keyCode === 13) {
            this._queryName();
            retVal = false;
          }
      }
      return retVal;
    },

    onFocus: function (event) {
      this.trigger('item:focus', event.target);
    },

    getStatus: function () {
      switch (this.model.status) {
        case 'renamed':
          return lang.renamed;
        case 'skip':
          return lang.skip;
        case 'version':
          return lang.addVersion;
        case 'serverError':
          return lang.serverError;
      }
      return lang.conflict;
    },

    getStatusIcon: function () {
      var icon = 'csui-icon-notification-warning';
      switch (this.model.status) {
        case 'version':
        case 'renamed':
        case 'skip':
          icon = 'csui-icon-notification-success';
          break;
        case 'serverError':
          icon = 'category_delete';
          break;
      }
      return icon;
    },

    getMimeTypeIcon: function () {
      var mimeType;
      if ((this.model.get('mime_type') === undefined) && (this.model.get('file') !== undefined)) {
        mimeType = this.model.get('file').type;
      } else if (this.model.get('mime_type') !== null) {
        mimeType = this.model.get('mime_type');
      } else {
        mimeType = this.model.get('type');
      }
      this.model.set('mime_type', mimeType);
      return NodeSpriteCollection.findClassByNode(this.model);
    },


    getResolveStatus: function () {
      var status = '';
      switch (this.model.status) {
        case 'version':
        case 'renamed':
        case 'skip':
          status = 'ok';
          break;
        case 'serverError':
          status = 'error';
          break;
      }
      return status;
    },

    onDestroy: function () {
      $(window).unbind("resize.app", this._onDynamicPlacment);
    },

    onClickVersion: function (model) {
      this.model.status = 'version';
      this.model.set('newVersion', true);
      this.setResolveStatus(true);
      this.render();
    },

    onRename: function (event) {
      event.preventDefault();
      event.stopPropagation();
      var name = this.model.get('newName');
      this.ui.inputField.val(name);
      this.ui.conflictFields.addClass('binf-hidden');
      this.ui.renameFields.removeClass('binf-hidden');
      this.ui.inputField.focus();

      this.ui.fileDescription.addClass('edit-mode');
      this.$el.addClass('edit-mode');
      this.$el.find('.csui-status-icon').addClass('edit-mode');
    },

    onCancelInput: function () {
      this.render();
    },

    onCancelUpload: function (event) {
      if (event.keyCode === undefined || event.keyCode === 32 || event.keyCode === 13) {
        event.stopPropagation();
        event.preventDefault();
      this.options.removeItemList[this.model.get('id')] = this.model;
      this.previousState = this.model.status;
      this.model.status = 'skip';
      this.setResolveStatus(true);
      this.render();
      }
    },

    setResolveStatus: function(resolved){
      if (this._resolved && !resolved){
        this.trigger('resolved', false);
      }
      if (!this._resolved && resolved){
        this.trigger('resolved', true);
      }

      this._resolved = resolved;
    },

    onHover: function () {
      if (!this.resolvedStyle){
        this.resolvedStyle = "width:" + $('.csui-button-container').width() + 'px;';
      }
      this.ui.cancelIcon.addClass('binf-show');
    },

    onHideCancel: function () {
      this.ui.cancelIcon.removeClass('binf-show');
    },

    onRender: function () {
      var node = this.model;

      if (node.get('first')) {
        this.$el.addClass('no-border');
      }

      this._setDynamicPlacement();
    },

    undo: function (event) {
      event.preventDefault();
      event.stopPropagation();

      var id = this.model.get('id');
      this.model.status = this.previousState;

      if (this.previousState) {
        delete this.options.removeItemList[id];
        this.previousState = undefined;
      }
      else {
        this.oldName && this.model.set('newName', this.oldName);
        this.oldId && this.model.set('id', this.oldId);
        this.oldName = this.Id = undefined;
        this.model.set('newVersion', undefined);
        delete this.options.removeItemList[id];
        this.model.status = undefined;
        this.setResolveStatus(false);
      }
      this.render();
    },

    _queryName: function () {
      var newName = this.ui.inputField.val(),
        oldName = this.model.get('newName');
      newName = newName && newName.trim();
      if (newName && newName !== oldName) {
        this.oldName = oldName;
        this.oldId = this.model.get('id');
        this.model.set('id', undefined);
        this.model.set('newName', newName);
        this.ui.progressWheel.removeClass('binf-hidden');
        this._runNameQuery([{name: newName}]);
      }
      else{
        this.onCancelInput();
      }
    },

    _runNameQuery: function (name) {
      var self = this,
          nameQuery = new NameQuery({containerId: this.options.parentId},
              {connector: this.options.connector});

      nameQuery.queryNames(name)
        .done(function (cleanFileName, conflictFileName) {
          //self.ui.progressWheel.addClass('binf-hidden');
          if (conflictFileName && conflictFileName.length > 0) {
            self._resetConflictStatus(conflictFileName);
          }
          else {
            self._setRenameStatus();
          }
        })
        .fail(function (resp) {
          self.ui.progressWheel.addClass('binf-hidden');
          self._processServerError(resp);
        });
    },

    _processServerError: function (response) {
      this.options.removeItemList[this.model.get('id')] = this.model;
      this.model.status = 'serverError';
      this.$el.removeClass('edit-mode');
      this._setErrorMsg(response);
      this.setResolveStatus(true);
      this.render();
    },

    _setErrorMsg: function (response) {
      var msg = lang.serverError,
        logMsg = 'Conflict.Item.View: Server returned error during name query';

      if (response) {
        logMsg = new base.RequestErrorMessage(response);
      }

      log.error(logMsg) && console.error(log.last);
    },

    _setRenameStatus: function () {
      this.model.status = 'renamed';
      this.$el.removeClass('edit-mode');
      this.setResolveStatus(true);
      this.render();
    },

    _resetConflictStatus: function (newConflictFile) {
      this.model.set('id', newConflictFile[0].id);
      this.render();
    },

    _setDynamicPlacement: function () {
      var acceptedWidth = $(window).width() - (88 * 2);

      if (acceptedWidth < 600) {
        this.$el.addClass('sm');
        this.ui.statusText.addClass('sm');
        this.ui.fileDescription.addClass('sm');
      }
      else {
        this.$el.removeClass('sm');
        this.ui.statusText.removeClass('sm');
        this.ui.fileDescription.removeClass('sm');
      }
    }
  });


  return ConflictListItem;

});


csui.define('csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.list.navigation',['csui/lib/jquery', 'csui/behaviors/keyboard.navigation/tabable.region.behavior',
], function ($, TabableRegionBehavior) {
  'use strict';

  var KeyNavigation = {

    currentlyFocusedElement: function (shiftTab) {
      //change the input and icons back to tabindex = 0. Tabable behavior sets all tabindex to -1, which doesn't work for
      //this scenario
      shiftTab = typeof shiftTab === 'object' ? shiftTab.shiftKey : shiftTab;
      var focusables = this.$('button[tabindex=-1]');
      if (focusables.length) {
        focusables.prop('tabindex', 0);
        this.$('.circle_delete').prop('tabindex', 0);
      }

      if (shiftTab) {
        return this.$('[tabindex]:visible').last();
      } else {
        return this.$('[tabindex]:visible').first();
      }
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode,
          target  = $(event.target),
          retVal  = false;

      switch (keyCode) {
        //right/left arrow
      case 39:
      case 37:
        if (target.hasClass('cs-input')) {
          return true;
        }
        this.navigateLeftRight(keyCode);
        break;
        //up/down arrow
      case 38:
      case 40:
        this.navigateUpDown(keyCode);
        break;
      default:
        retVal = true;
      }
      return retVal;
    },

    navigateUpDown: function (keyCode) {
      var activeElement    = this.focusedElement,
          classMatches     = activeElement.hasClass('btn-version') ? '.btn-version' :
                             (activeElement.hasClass('btn-rename') ||
                              activeElement.hasClass('btn-undo')) ? '.btn-rename, .btn-undo' :
                             '.circle_delete',
          collectionLength = this.collection.length,
          nextIndex, i, nextChild, nextItem;

      //up
      if (keyCode === 38 && this.activeChildIndex > 0) {
        for (i = this.activeChildIndex - 1; i >= 0; i--) {
          nextChild = this.children.findByIndex(i);
          nextItem = nextChild.$(classMatches);
          if (nextItem.length > 0) {
            nextIndex = i;
            break;
          }
        }
      }
      else if (keyCode === 40 && this.activeChildIndex < collectionLength - 1) {
        for (i = this.activeChildIndex + 1; i < collectionLength; i++) {
          nextChild = this.children.findByIndex(i);
          nextItem = nextChild.$(classMatches);
          if (nextItem.length > 0) {
            nextIndex = i;
            break;
          }
        }
      }

      if (nextIndex !== undefined) {
        this.$('.csui-focus').removeClass('csui-focus');
        $(this.children.findByIndex(nextIndex).$(classMatches)).focus();
      }
    },

    navigateLeftRight: function (keyCode) {
      var tabItems    = this.activeChildView.$('[tabindex=0]'),
          activeIndex = this._getActiveIndex(tabItems),
          nextIndex;

      if (activeIndex !== undefined) {
        if (keyCode === 37 && activeIndex > 0) {
          nextIndex = activeIndex - 1;
        }
        else if (keyCode === 39 && activeIndex < tabItems.length - 1) {
          nextIndex = activeIndex + 1;
        }

        if (nextIndex !== undefined) {
          $(tabItems[nextIndex]).focus();
        }
      }
    },

    onLastTabElement: function (shiftTab) {
      var activeIndex    = this.activeElementIndex === undefined ? 0 : this.activeElementIndex,
          activeListItem = this.children.findByIndex(activeIndex),
          tabItems       = this.$('[tabindex=0]'),
          lastItem       = tabItems.length - 1;

      if (tabItems.length) {
        var focusElement = shiftTab ? tabItems[0] : tabItems[lastItem];
        this.$('.csui-focus').removeClass('csui-focus');
        return $(focusElement).hasClass(TabableRegionBehavior.accessibilityActiveElementClass);
      }

      return true;
    },

    setItemFocus: function (childView, target) {
      this.activeChildView = childView;
      this.$('.csui-focus').removeClass('csui-focus');
      childView.$el.addClass('csui-focus');

      this.focusedElement &&
      this.focusedElement.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
      this.focusedElement = $(target);
      this.focusedElement.addClass(TabableRegionBehavior.accessibilityActiveElementClass);

      this.activeChildIndex = childView.model.index;
    },

    //used to remove tab focus is mouse comes into play
    clearTabFocus: function () {
      // this.$('.csui-focus').removeClass('csui-focus');
      // this.$el.focus();
    }
  };

  return KeyNavigation;
});

// Shows a simply list of items with scrollbar
csui.define('csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.list.view',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/utils/base', 'csui/controls/list/simplelist.view',
  'csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item.view',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.list.navigation',
], function (_, $, base, SimpleListView, ConflictItemView,
    TabableRegionBehavior, KeyNavigation) {

  var ConflictListView = SimpleListView.extend({

    childView: ConflictItemView,

    childEvents: {
      'resolved': 'trackResolved',
      'item:focus': 'setItemFocus'
    },

    events: {
      'keydown': 'onKeyInView',
      'mouseenter': 'clearTabFocus'
    },
    behaviors: {
      TabableRegionBehavior: {
        behaviorClass: TabableRegionBehavior
      }
    },

    constructor: function ConflictListView(options) {
      options || (options = {});
      SimpleListView.prototype.constructor.apply(this, arguments);
      this.multiList = options.numConflicts > 1;
      this.removeItemList = [];
      this.listenToOnce(this, 'mouseenter', this.onUpdateScroll);
      this._onSetContaintListHeight = _.bind(this._setContainerListHeight, this);
      $(window).bind("resize.app", this._onSetContaintListHeight);
    },

    childViewOptions: function () {
      return {
        multiConflicts: this.multiList,
        connector: this.options.connector,
        parentId: this.options.parentId,
        removeItemList: this.options.removeItemList
      };
    },

    onDomRefresh: function () {
      this._setContainerListHeight();
    },
    onUpdateScroll: function () {
      this.triggerMethod('update:scrollbar', this);
    },

    onDestroy: function () {
      $(window).unbind("resize.app", this._onSetContaintListHeight);
    },

    trackResolved: function () {
      var resolved = arguments[1];
      this.options.trackResolved(resolved);
    },
    _setContainerListHeight: function () {
      var winHeight = ($(window).height() * 0.9 - 100 - 60 - 130) + 'px'; // 10% top margin - 30px for bottom margin - 130 for header/foooter
      this.$el.find('.cs-content').css('max-height', winHeight);
    },

    _getActiveIndex: function(tabItems) {
      var lastIndex = tabItems.length - 1;
      for (var i = 0; i <= lastIndex; i++) {
        if ($(tabItems[i]).hasClass(TabableRegionBehavior.accessibilityActiveElementClass)) {
          return i;
    }
      }
    }
  });

  _.extend(ConflictListView.prototype, KeyNavigation);
  return ConflictListView;

});


csui.define('css!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.dialog',[],function(){});
csui.define('csui/controls/conflict.resolver/impl/conflict.dialog/conflict.dialog',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/controls/dialog/dialog.view',
  'i18n!csui/controls/conflict.resolver/impl/conflict.dialog/impl/nls/lang', 'csui/utils/log',
  'csui/controls/list/simplelist.view',
  'csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.item/conflict.item.view',
  'csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.list.view',
  'css!csui/controls/conflict.resolver/impl/conflict.dialog/impl/conflict.dialog'
], function (_, $, Backbone, DialogView, lang, log, SimpleListView, ConflictItemView, ConflictListView) {
  "use strict";

  function ConflictDialog(options) {
    this.options = options || {};
    this.deferred = $.Deferred();
    this.removeItemList = {};
    this._resolveCount = this.options.conflictFiles.length;
    this.deferred.then(_.bind(this.destroy, this), _.bind(this.destroy, this));
  }

  _.extend(ConflictDialog.prototype, Backbone.Events, {

    destroy: function () {
      this._view.destroy();
      this._view.off();
      this._dialog.destroy();
    },

    show: function () {
      var conflictFiles = this.options.conflictFiles;

      conflictFiles[0].first = true;
      this._view = this._getListView(conflictFiles);
      this._dialog = this._createDialog(conflictFiles);
      this._view.$el.hover(function(){
        $('.cs-content').trigger('scroll');
      });
      return this.deferred;
    },

    _createDialog: function (conflictFiles) {
      var options = this.options,
        self = this,
        conflictMsg = conflictFiles.length > 1? lang.conflictCount: lang.oneConflict,
        h2Label = _.str.sformat(conflictMsg, conflictFiles.length);

      var dialog = new DialogView({
        standardHeader: false,
        view: this._view,
        className: 'csui-conflict-dialog csui-individual',
        attributes:{
          'data-backdrop': "static"
        },
        headers: [
          {
            id: 'h1',
            label: this.options.h1Label,
            class: 'csui-numUploads'
          },
          {
            id: 'h2',
            label: h2Label,
            class: 'csui-numConflicts'
          }],
        buttons: [
        {
          id: 'upload',
          label: options.actionBtnLabel,
          toolTip: options.actionBtnLabel,
          disabled: true,
          click: function(){
            dialog.destroy();
            self._resolutionComplete();
          }
        },
        {
          id: 'cancel',
          label: lang.cancel,
          toolTip: lang.cancel,
          click: function() {
            dialog.destroy();
            self.cancel();
          }
        }
        ],
        dialogTxtAria: this.options.h1Label + '. ' + h2Label
      });

      dialog.on('hide', function () {
        dialog.off();
        this.cancel();
      }, this);

      dialog.show();
      return dialog;
    },


    _getListView: function (conflictFiles) {

      var self = this,
        listView = new ConflictListView({
          data: {
            items: conflictFiles
          },
        numConflicts:conflictFiles.length,
        removeItemList : this.removeItemList,
        connector: this.options.connector,
        parentId: this.options.parentId,
        trackResolved: function(complete){
          self.trackResolved(complete);
        }
      });

      return listView;
    },

    cancel: function () {
      this.deferred.reject();
      return true;
    },

    trackResolved: function(resolved) {
      var header = $('.csui-conflict-dialog.csui-individual .csui-numConflicts');

      if (!resolved) {
        this._resolveCount++;
        this._dialog.updateButton('upload', {disabled: true});
      }
      else if (--this._resolveCount === 0) {
        this._dialog.updateButton('upload', {disabled: false});
      }

      var conflictMsg = (this._resolveCount > 1) || this._resolveCount === 0 ? lang.conflictCount: lang.oneConflict;
      header.text(_.str.sformat(conflictMsg, this._resolveCount));
      return true;
    },


    _resolutionComplete: function () {
      this.deferred.resolve(this._view.collection.models, this.removeItemList);
      return true;
    }

  });

  ConflictDialog.version = "1.0";
  return ConflictDialog;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/conflict.resolver/impl/collection.conflicts/collection.conflicts',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<span id=\"csui-collection-conflicts-title\"\r\n      class=\"csui-collection-conflicts-title\">"
    + this.escapeExpression(((helper = (helper = helpers.conflictsItemsTitle || (depth0 != null ? depth0.conflictsItemsTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"conflictsItemsTitle","hash":{}}) : helper)))
    + "</span>\r\n<ul id=\"csui-collection-conflict-items\" class=\"csui-collection-conflict-items\"></ul>\r\n";
}});
Handlebars.registerPartial('csui_controls_conflict.resolver_impl_collection.conflicts_collection.conflicts', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/conflict.resolver/impl/collection.conflicts/collection.conflict.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<span class=\"csui-type-icon "
    + this.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"icon","hash":{}}) : helper)))
    + "\" /><span class=\"item-name\">"
    + this.escapeExpression(((helper = (helper = helpers.conflictsItemsName || (depth0 != null ? depth0.conflictsItemsName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"conflictsItemsName","hash":{}}) : helper)))
    + "</span>\r\n";
}});
Handlebars.registerPartial('csui_controls_conflict.resolver_impl_collection.conflicts_collection.conflict.item', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/conflict.resolver/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/conflict.resolver/impl/nls/root/lang',{
  batchMessage: "These files already exist. How do you want to proceed?",
  skipConflicts: 'Skip conflicts',
  resolveIndividual: 'Resolve individually',
  conflictCount: '{0} Conflicts',
  upload: 'Upload',
  cancel: 'Cancel',
  addVersion: 'Add version',
  conflictsItemsHeader: 'Listed items will not be added'
});



csui.define('css!csui/controls/conflict.resolver/impl/collection.conflicts/conflicts.dialog',[],function(){});
// Shows a list of items
csui.define('csui/controls/conflict.resolver/impl/collection.conflicts/collection.conflicts.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'hbs!csui/controls/conflict.resolver/impl/collection.conflicts/collection.conflicts',
  'hbs!csui/controls/conflict.resolver/impl/collection.conflicts/collection.conflict.item',
  'csui/controls/node-type.icon/node-type.icon.view',
  'i18n!csui/controls/conflict.resolver/impl/nls/lang',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'css!csui/controls/conflict.resolver/impl/collection.conflicts/conflicts.dialog'
], function (_, $, Marionette, template, conflictItemTemplate, NodeTypeIconView, lang,
    PerfectScrollingBehavior) {
  'use strict';

  var CollectionConflictItemView = Marionette.ItemView.extend({
    tagName: 'li',
    template: conflictItemTemplate,
    className: "csui-conflict-item",

    templateHelpers: function () {
      var data = {
        conflictsItemsName: this.model.get('name')
      };
      return data;
    },

    constructor: function CollectionConflictItemView(options) {
      options || (options = {});

      Marionette.ItemView.prototype.constructor.call(this, options);

    },

    onRender: function () {
      this._nodeIconView = new NodeTypeIconView({
        el: this.$('.csui-type-icon').get(0),
        node: this.model.node
      });
      this._nodeIconView.render();
    }

  });

  var CollectionConflictsView = Marionette.CompositeView.extend({
    template: template,
    className: 'csui-conflicts-items-data',

    childView: CollectionConflictItemView,
    childViewContainer: '#csui-collection-conflict-items',

    ui: {
      conflictItems: '#csui-collection-conflict-items'
    },

    templateHelpers: function () {
      var data = {
        conflictsItemsTitle: lang.conflictsItemsHeader
      };
      return data;
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: 'ul.csui-collection-conflict-items',
        suppressScrollX: true,
        scrollYMarginOffset: 15
      }
    },

    constructor: function CollectionConflictsView(options) {
      options || (options = {});
      this.collection = options.collection || {};
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this._onSetContaintListHeight = _.bind(this._setContainerListHeight, this);
      $(window).bind("resize.app", this._onSetContaintListHeight);
    },

    onDomRefresh: function () {
      this._setContainerListHeight();
    },

    _setContainerListHeight: function () {
      var winHeight = ($(window).height() * 0.9 - 100 - 60 - 112) + 'px'; // 10% top margin -
      // 30px for bottom margin - 112 for header/foooter
      $('.csui-collection-conflict-items').css('max-height', winHeight);
    },

    onDestroy: function () {
      $(window).unbind("resize.app", this._onSetContaintListHeight);
    },

  });

  return CollectionConflictsView;

});


csui.define('css!csui/controls/conflict.resolver/impl/conflict.resolver',[],function(){});
csui.define('csui/controls/conflict.resolver/conflict.resolver',[
  "csui/lib/underscore",
  "csui/lib/jquery",
  "csui/lib/backbone",
  "csui/controls/dialog/dialog.view",
  "i18n!csui/controls/conflict.resolver/impl/nls/lang",
  "csui/utils/log",
  "csui/controls/conflict.resolver/impl/conflict.dialog/conflict.dialog",
  "csui/models/namequery",
  "csui/utils/base",
  'csui/models/fileuploads',
  "css!csui/controls/conflict.resolver/impl/conflict.resolver"
], function (
  _,
  $,
  Backbone,
  DialogView,
  lang,
  log,
  ConflictDialog,
  NameQuery,
  base,
  UploadFileCollection) {
  "use strict";

  function ConflictResolver(options) {
    this.options = options || {};
    this.deferred = $.Deferred();
    this.container = options.container;
    this.actionBtnLabel = options.actionBtnLabel || lang.upload;
    this.excludeAddVersion = options.excludeAddVersion || false;
    this.files = options.files instanceof UploadFileCollection? options.files:
      new UploadFileCollection(options.files);
    this.deferred.then(_.bind(this.destroy, this), _.bind(this.destroy, this));
  }

  _.extend(ConflictResolver.prototype, {

    destroy: function(){
      if (this._dialog) {
        this._dialog.destroy();
      }
    },
    run: function (options) {
      var self = this;

      _.extend(this.options, options);


      //query Server for naming conflicts
      this.queryNames(this.files)
        .done(function (nonConflictfiles, conflictFiles) {
          self._resolveConflicts(nonConflictfiles, conflictFiles);
        })
        .fail(function (resp) {
          var msgResp = self.getMsgResponse(resp);
          self.deferred.reject(new Error(msgResp));
        });

      return this.deferred.promise();
    },


    queryNames: function (files) {
      var deferred = $.Deferred(),
        nameQuery = new NameQuery({containerId: this.container.get('id')}, {connector: this.container.connector});

      nameQuery.queryNames(files)
        .done(function (cleanFiles, conflictFiles) {
          deferred.resolve(cleanFiles, conflictFiles);
        })
        .fail(function (resp) {
          var error = new base.Error(resp);
          deferred.reject(error);
        });
      return deferred;
    },

    getMsgResponse: function (response) {
      var errorMsg = lang.fileNameQueryFailed;

      if (response) {
        errorMsg = new base.RequestErrorMessage(response);
        errorMsg = errorMsg.message;
      }

      return errorMsg;
    },




    showBatchResolve: function (conflictFiles) {
      var deferred = $.Deferred(),
        bodyMessage = lang.batchMessage,
        buttons = [
          {
            id: 'versions',
            label: lang.addVersion,
            toolTip: lang.addVersion,
            click: function (args) {
              deferred.resolve('versions', args.dialog);
            }
          },
          {
            id: 'skip',
            label: lang.skipConflicts,
            toolTip: lang.skipConflicts,
            click: function (args) {
              deferred.resolve('skip', args.dialog);
            }
          },

          {
            id: 'individual',
            label: lang.resolveIndividual,
            toolTip: lang.resolveIndividual,
            click: function (args) {
              deferred.resolve('individual', args.dialog);
            }
          }
        ];

      if (this.excludeAddVersion) {
        buttons.shift();
      }
      this._createDialog('csui-conflict-dialog csui-batch', conflictFiles, buttons, bodyMessage);
      return deferred;
    },

    showIndividualResolve: function (conflictFiles) {
      var self = this;
      var conflictDialog;

      _.each(conflictFiles, function(file) {
        file.excludeAddVersion = self.excludeAddVersion;
      });

      conflictDialog = this._conflictDialog = new ConflictDialog({
        parentId: this.container.get('id'),
        connector: this.container.connector,
        totalNumFiles: this.options.files.length,
        conflictFiles: conflictFiles,
        actionBtnLabel: this.actionBtnLabel,
        h1Label: this.options.h1Label
      });

      conflictDialog.show()
        .done(function (resolvedFiles, removedFiles) {
          self._removeDeletedFiles(removedFiles);
          self._returnFiles();
        })
        .fail(function () {
          self.deferred.reject({ userAction: "cancelResolveNamingConflicts" });
        });

      return conflictDialog;
    },

    _createDialog: function (className, conflictFiles, buttons, bodyMessage, view) {
      var h2Label = _.str.sformat(lang.conflictCount, conflictFiles.length),
        dialogTxtAria = this.options.h1Label + ". " + h2Label + ". " + bodyMessage,
        dialog = this._dialog = new DialogView({
        bodyMessage: bodyMessage,
        standardHeader: false,
        view: view,
        className: className,
        attributes:{
          'data-backdrop': "static"
        },
        headers: [
          {
            id: 'h1',
            label: this.options.h1Label,
            class: 'csui-numUploads'
          },
          {
            id: 'h2',
            label: h2Label,
            class: 'csui-numConflicts'
          }],
        buttons: buttons,
        dialogTxtAria: dialogTxtAria
      });

      dialog.listenTo(dialog, 'hide', _.bind(this.deferred.reject, this));

      dialog.show();
      return dialog;
    },


    _resolveConflicts: function (nonConflictFiles, conflictFiles) {
      var self = this;
      this.nonConflictFiles = nonConflictFiles;

      if (conflictFiles && conflictFiles.length > 0) {
        if (conflictFiles.length > 1) {
          this.showBatchResolve(conflictFiles)
            .then(function (resolveOption, dialog) {
              dialog.kill();
              switch (resolveOption) {
                case 'versions':
                  self._addVersions(conflictFiles);
                  self._returnFiles();
                  break;
                case 'individual':
                  self.showIndividualResolve(conflictFiles);
                  break;
                case 'skip':
                  self._removeConnflicts(conflictFiles);
                  self._returnFiles();
                }
              });
        }
        else {
          this.showIndividualResolve(conflictFiles);
        }
      }
      else {
        this.deferred.resolve(this.options.files, conflictFiles.length > 0);
      }

      return true;
    },

    _returnFiles: function () {
      if (this.options.files.length && this.options.files instanceof UploadFileCollection) {
        this.deferred.resolve(this.files);
      }
      else if (this.files.length) {
        var files = [];
        _.each(this.files.models, function (file) {
          files.push(file.attributes);
        });
        this.deferred.resolve(files);
      }
      else {
        this.deferred.reject();
      }
    },
    _removeConnflicts: function(conflictFiles){
      var completeFileList = this.files;
      _.each(conflictFiles, function(file){
        completeFileList.remove(file);
      });
    },
    _addVersions: function (files) {
      _.each(files, function (file) {
        file.set('newVersion', true);
      });
    },

    _removeDeletedFiles: function (removedFiles) {

      _.each(removedFiles, function (item) {

        this.files.remove(item);
      }, this);

    },
    _getArrayOfFileNames: function(files){
      var fileNames = [];
      _.each(files, function(file){
        var name = file.newName || file.name;
        fileNames.push({name:name});
      });
      return fileNames;
    }

  });

  ConflictResolver.version = '1.0';
  return ConflictResolver;

});

csui.define('csui/controls/draganddrop/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/draganddrop/impl/nls/root/lang',{
  dropMessage: 'Drop your file(s) into {0}.',
  dropNotPermitted: 'No files can be dropped here.',
  dropInvalid: 'Only files can be dropped here.',
  noFiles: 'No files were dropped.',
  addTypeDenied: 'Cannot add documents to {0}.'
});


csui.define('csui/controls/fileupload/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/fileupload/impl/nls/root/lang',{
  uploadCounts: 'Uploading {0} files',
  uploadCount: 'Uploading 1 file',
  OneFileSuccessfullyUploaded: '{0} file was successfully uploaded.',
  AllFilesSuccessfullyUploaded: '{0} files were successfully uploaded.',
  over500Items: 'Cannot add more than 500 items.',
  invalidFileList: 'Invalid file list',
  fileNameQueryFailed: 'File name query failed - reason unknown.',
  MessageVersionAdded: 'Version added',
  pageLeavingWarning: 'If you leave the page now, pending files will not be uploaded.'
});


csui.define('csui/controls/fileupload/impl/fileupload.collection',['require', 'module', 'csui/lib/jquery', 'csui/lib/underscore',
  'csui/lib/backbone', 'csui/utils/log', "i18n!csui/controls/fileupload/impl/nls/lang",
  'csui/controls/fileupload/impl/upload.controller',
  'csui/models/fileuploads', 'csui/controls/globalmessage/globalmessage',
  'csui/controls/conflict.resolver/conflict.resolver',
  'csui/dialogs/modal.alert/modal.alert', 'csui/utils/page.leaving.blocker'
], function (require, module, $, _, Backbone, log, lang, UploadController,
    UploadFileCollection, GlobalMessage, ConflictResolver, ModalAlert,
    PageLeavingBlocker) {
  'use strict';

  var FileUploadModel = Backbone.Model.extend({

    // We can pass it default values.
    defaults: {
      parentCollection: null,
      container: null
    },

    constructor: function FileUploadModel(attributes, options) {
      attributes || (attributes = {});

      Backbone.Model.prototype.constructor.call(this, attributes, options);

      var container = this.container = this.get('container'),
          parentCollection = this.get('parentCollection');

      // FileUploadCollection to serve as connection between the FileUploadView
      // and the UploadController; pending documents are added there.
      this.uploadFiles = new UploadFileCollection();

      // Controller which will actually upload the files.
      this.controller = new UploadController({
        container: container
      });

      // To be able to check if the collection has changed by navigation, filtering etc.
      // The URL has all parameters in the query and can work as a natural "status digest".
      if (parentCollection) {
        this.originalCollectionUrl = parentCollection.url();
        this.listenTo(parentCollection, 'reset', this._stopCollectionUpdate); //stop collection update after a collection reset
        this.listenTo(parentCollection.node, 'request', this._stopCollectionUpdate); //stop collection update after node change
      }

      this._uploadCounts = {failed: 0, success: 0, complete: 0};
    },

    close: function () {
      this.onDestroy();
      this.trigger('destroy');
      return true;
    },

    onDestroy: function () {
      this.uploadView && this.uploadView.destroy();
      return true;
    },

    onUploadFileAdded: function (fileUpload) {
      fileUpload.promise()
          .done(_.bind(this.onFileUploadProcessed, this))
          .fail(_.bind(this.onFileUploadFailed, this));
    },

    addFilesToUpload: function (files, options) {
      var self = this;

      // Check for folders or other invalid dropped items
      if (this._validateFileList(files)) {
        // It take some time before the resolving or metadata dialog comes
        // up; the user should see some feedback
        var originatingView = this.setBlocker();

        //create a backbone collection of file models.
        this.addFilesToUploadCollection(files, options);

        //Check for naming conflicts
        this.resolveNamingConflicts(options)
        //once conflicts are resolved upload the files
            .then(_.bind(this.checkAndHandleRequiredMetadata, this, options))
            .then(_.bind(this.addToUpload, this))
            .fail(function (args) {
              if (args) {
                if (args.error) {
                  GlobalMessage.showMessage('error', args.error.message);
                }
                else if (args.userAction && args.userAction === "cancelAddOneItemWithRequiredMetadata") {
                  self.trigger("metadata:cancelled");
                }
                else if (args.userAction && args.userAction === "closeMetadataActionView") {
                  self.trigger("metadata:closed");
                }
                else if (args.userAction && args.userAction === "cancelResolveNamingConflicts") {
                  self.trigger("resolve:naming:conflicts:cancelled");
                }
              }
            })
            .always(function () {
              if (originatingView) {
                originatingView.unblockActions();
              }
              self.close();
            });
        return true;
      }

      this.close();
      return false;
    },

    addFilesToUploadCollection: function (files, options) {
      _.each(files, function (file) {
        // File is either a File object or a POJO
        // with the file and other parameters
        var parameters = file,
            // Container and collection are either defaults from the
            // controller, or specific to the file upload model
            container = parameters.container ||
                        options && options.container ||
                        this.container,
            collection = options && options.collection ||
                         this.get('parentCollection');
        // Enable passing a File object or a POJO with parameters
        // including 'file' with the File object
        parameters.file && (file = parameters.file);
        // Compatibility with passing the new name on the file object
        var newName = parameters.newName || file.newName;
        this.uploadFiles.add({
              file: file,
              newName: newName,
              name: newName || file.name,
              extended_data: parameters.data || {},
              collection: collection,
              subType: this.get('addableType')
            },
            {
              container: container,
              connector: container.connector,
              enforcedRequiredAttrs: true
            });
      }, this);
    },

    setBlocker: function () {
      var originatingView = this.get('originatingView');
      if (!(originatingView && originatingView.blockActions)) {
        originatingView = undefined;
      }
      if (originatingView) {
        originatingView.blockActions();
      }
      return originatingView;
    },

    resolveNamingConflicts: function (options) {
      var uploadCollection = this.uploadFiles;
      var h1 = uploadCollection.length === 1 ? lang.uploadCount : lang.uploadCounts,
          conflictResolver = new ConflictResolver({
            h1Label: _.str.sformat(h1, uploadCollection.length),
            // Container is either the default one from the
            // controller, or the specific one in the file upload model
            container: options && options.container || this.container,
            files: uploadCollection
          });
      return conflictResolver.run();
    },

    _validateFileList: function (files) {
      if (!files || files.length === 0) {
        log.debug("No upload files selected")
        && console.log(log.last);
        return false;
      }
      var firstFile = files[0],
          name = firstFile.name || firstFile.file && firstFile.file.name ||
                 firstFile.get && firstFile.get('name');
      if (!name) {
        GlobalMessage.showMessage('error', lang.invalidFileList);
        return false;
      }
      return true;
    },

    checkAndHandleRequiredMetadata: function (options, fileCollection) {
      var self = this,
          deferred = $.Deferred();
      csui.require(['csui/widgets/metadata/metadata.add.document.controller'
      ], function (MetadataAddDocumentController) {
        var metadataController = new MetadataAddDocumentController();
        metadataController
            .addItemsRequiredMetadata(fileCollection, {
              // Container is either the default one from the
              // controller, or the specific one in the file upload model
              container: options && options.container || self.container,
              addableType: 144,
              context: self.get('context')
            })
            .then(function () {
              return fileCollection;
            })
            .done(deferred.resolve)
            .fail(deferred.reject);
      }, function (error) {
        log.warn('Failed to load MetadataAddDocumentController. {0}', error)
        && console.warn(log.last);
        deferred.reject(error);
      });
      return deferred.promise();
    },

    addToUpload: function (files) {
      if (files && files.length > 0) {
        var fileAdded;
        _.each(files.models, function (file) {
          if (!file.get('id') || file.get('newName') || file.get('newVersion')) {
            var name = file.get('newName') || file.get('file').name;
            //Set the node file type so the correct icon can be displayed in the progress panel
            file.set('mime_type', file.get('file').type);
            log.debug("Object was added - {0}", name)
            && console.log(log.last);
            // Enable the blocker when the very first file has been scheduled
            // for upload; disabling is done when the last file in the queue
            // gets uploaded
            if (!fileAdded) {
              fileAdded = true;
              var pageLeavingWarning = this.get('pageLeavingWarning') ||
                                       lang.pageLeavingWarning;
              PageLeavingBlocker.enable(pageLeavingWarning);
            }
            this.controller.scheduleFileForUpload(file);
            this.onUploadFileAdded(file);
          }
          else {
            log.debug("Object was skipped - {0}", file.name);
          }
        }, this);
      }
      else {
        log.debug("No files were upload. All have naming conflict")
        && console.log(log.last);
      }

      this.showProgress(files);
    },

    onFileUploadProcessed: function (file) {
      if (!this.stopParentUpdate) {
        var collection = file.get('collection'),
            parentCollection = this.get('parentCollection');
        collection || (collection = parentCollection);
        if (collection !== parentCollection ||
            parentCollection && parentCollection.url() == this.originalCollectionUrl) {
          var newFile = !file.get('newVersion');
          if (newFile) {
            file.node.isLocallyCreated = true;
            collection.unshift(file.node);
            // FIXME: Move this to TableView
            $(".csui-new-item").closest("tbody").scrollTop(0);
          }
        }
      }
      this._increaseUploadCount('success');
    },

    onFileUploadFailed: function (file, errorMsg) {
      this._increaseUploadCount('failed');
    },

    showProgress: function (files) {
      this.uploadView && this.uploadView.destroy();
      var options = {
        originatingView: this.get('originatingView')
      };
      GlobalMessage.showFileUploadProgress(files, options);
    },

    _stopCollectionUpdate: function () {
      this.stopParentUpdate = false;
    },

    _increaseUploadCount: function (status) {
      var totalUpload = this.uploadFiles.length,
          uploadCounts = this._uploadCounts;

      if (status === 'failed') {
        uploadCounts.failed++;
      }
      else {
        uploadCounts.success++;
      }

      if (++(uploadCounts.complete) === totalUpload) {
        PageLeavingBlocker.disable();
        // Progress panel stays open as status message in case of failure(s)
        if (uploadCounts.failed === 0) {
          GlobalMessage.hideFileUploadProgress();
          var langMessage = (totalUpload === 1) ? lang.OneFileSuccessfullyUploaded :
                            lang.AllFilesSuccessfullyUploaded;
          GlobalMessage.showMessage("success",
              _.str.sformat(langMessage, totalUpload));
        }
      }

      this.close();
    }

  });

  var FileUploadCollection = Backbone.Collection.extend({
    model: FileUploadModel
  });

  return FileUploadCollection;

});

csui.define('csui/controls/fileupload/fileupload',['module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/controls/fileupload/impl/fileupload.collection'
], function (module, _, Backbone, FileUploadCollection) {
  'use strict';

  return {

    newUpload: function (status, options) {
      status || (status = {});
      options || (options = {});
      _.extend(options, {
        //This collection will be updated once a successful file upload has completed.
        //Anyone listening to 'insert' event will be notified.
        parentCollection: status.collection,

        // NodeModel to upload the files to; the node it points to can change
        // during the lifetime of this widget.
        container: status.container,

        // Extents of this view can be covered by additional dialogs or wizards,
        // or its surface can be blocked from actions until the upload ends
        originatingView: status.originatingView,
        context: status.context || (options && options.context)
      });

      if (!this.collection) {
        this.collection = new FileUploadCollection();
      }

      var uploadControlModel = this.collection.add(options);
      uploadControlModel.listenToOnce(uploadControlModel, 'destroy', function () {
        this.collection.remove(uploadControlModel);
      }, this);

      return uploadControlModel;
    }

  };

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/draganddrop/impl/draganddrop',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "\r\n  <span class=\"csui-messageBox\">"
    + this.escapeExpression(((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"message","hash":{}}) : helper)))
    + "</span>\r\n";
}});
Handlebars.registerPartial('csui_controls_draganddrop_impl_draganddrop', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/draganddrop/impl/draganddrop',[],function(){});
csui.define('csui/controls/draganddrop/draganddrop.view',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/marionette",
  "csui/lib/backbone", "csui/utils/log", "i18n!csui/controls/draganddrop/impl/nls/lang",
  'csui/controls/globalmessage/globalmessage', 'csui/controls/fileupload/fileupload',
  "hbs!csui/controls/draganddrop/impl/draganddrop",
  "css!csui/controls/draganddrop/impl/draganddrop", 'csui/lib/jquery.when.all'
], function (module, $, _, Marionette, Backbone, log, lang, GlobalMessage,
    fileUploadHelper, template) {

  var config = _.defaults({}, module.config(), {
    detectLeaveDelay: 100
  });

  var DragAndDropView = Marionette.ItemView.extend({

    template: template,
    className: "csui-dropMessage",

    ui: {
      message: '.csui-messageBox'
    },

    templateHelpers: function () {
      return {
        message: this._getDropPossibleMessage()
      };
    },

    constructor: function DragAndDropView(options) {
      Marionette.ItemView.prototype.constructor.call(this, options);

      this.collection = options.collection;
      this.container = options.container;
      this.addableTypes = options.addableTypes;
      this.wantDragAndDrop = true;
      this.visible = false;
      this.listenTo(this.options.container, "change:name", this._restMessage);
    },

    setDragParentView: function (parentView, selector) {
      this.parentView = parentView;
      // Accept a selector within the parent view, a jQuery object,
      // a HTML DOM element, or default to the parent view itself,
      // when choosing the drop-active area
      this._parentEl = _.isString(selector) && parentView.$(selector) ||
                       selector.length !== undefined && selector ||
                       selector && $(selector) ||
                       parentView.$el;
      this.render();
      this._parentEl.append(this.el);
      if (this.shouldDragAndDrop()) {
        this.disable();
        this._setDragEvents();
      }
      return true;
    },

    onDestroy: function () {
      if (this.shouldDragAndDrop()) {
        if (this._parentEl) {
          this._parentEl
              .off("dragover", this.dragOver)
              .off("dragleave", this.dragLeave)
              .off("drop", this.dragDrop);
        }
      }
    },

    _setDragEvents: function () {
      this.dragOver = _.bind(this.onOverView, this);
      this.dragLeave = _.bind(this.onLeaveView, this);
      this.dragDrop = _.bind(this.onDropView, this);
      this._parentEl
          .on("dragover", this.dragOver)
          .on("dragleave", this.dragLeave)
          .on("drop", this.dragDrop);
    },

    getSupportedSubType: function () {
      // right now support only files-type.
      var supportedType = {
        type: 144,
        type_name: "Document"
      };
      return supportedType;
    },

    enable: function (triggerEvent) {
      if (!this.visible) {
        if (triggerEvent !== false) {
          this.trigger('drag:over');
        }
        this.$el.show();
        this.visible = true;
      }
      if (this.canAdd()) {
        var node = this.getSupportedSubType();
        this.options.addableType = node.type;
        this.options.addableTypeName = node.type_name;
      }
    },

    disable: function () {
      this.$el.hide();
      this.trigger('drag:leave');
      this.visible = false;
    },

    shouldDragAndDrop: function () {
      // Check browser support
      var browserSupported = false,
          sampleDiv        = document.createElement('div');

      // Check to see if this browser supports drag and drop
      if ((window.File && window.FileReader && window.FileList && window.Blob) &&
          (('draggable' in sampleDiv) ||
           ('ondragstart' in sampleDiv && 'ondrop' in sampleDiv))) {
        browserSupported = true;
      }

      return browserSupported && this.wantDragAndDrop;
    },

    canAdd: function () {
      // TODO: Allow other subtypes like 749; we may need a help
      // from the server for this

      // If no addable types have been specified, allow anything
      // and let the server perform the permission check
      return !this.addableTypes || !!this.addableTypes.get(144);
    },

    onOverView: function (currentEvent) {
      // TODO: Show something else or show nothing if the user
      // has no permission to upload

      currentEvent.preventDefault();
      currentEvent.stopPropagation();

      if (this.leaveViewTimeout) {
        clearTimeout(this.leaveViewTimeout);
        this.leaveViewTimeout = undefined;
      }
      else {
        this.enable(false);
      }

      // MIME type is not reliable - it is guessed just by the file extension
      // and thus often empty - and more about the dragged object cannot be
      // learnt from security reasons
      var dataTransfer   = currentEvent.originalEvent &&
                           currentEvent.originalEvent.dataTransfer,
          // Check using items is more reliable, but not available in IE11
          items          = dataTransfer.items,
          validItems     = items && items.length && _.all(items, function (item) {
                return item.kind === 'file';
              }),
          types          = dataTransfer && dataTransfer.types,
          // Firefox contains both 'Files' and application/x-moz-file;
          // it is covered by items above, this is for IE11
          validTypes     = types && types.length && _.any(types, function (type) {
                return type === 'Files';
              }),
          valid          = items && validItems || validTypes,
          invalidMessage = lang.dropInvalid;

      if (!this.canAdd()) {
        valid = false;
        invalidMessage = lang.dropNotPermitted;
      }

      if (valid) {
        if (this.$el.hasClass('csui-disabled')) {
          this._restMessage();
          this.$el.removeClass('csui-disabled');
        }
        this.trigger('drag:over', this, {disabled: false});
      } else {
        if (!this.$el.hasClass('csui-disabled')) {
          this.ui.message.text(invalidMessage);
          this.$el.addClass('csui-disabled');
        }
        this.trigger('drag:over', this, {disabled: true});
      }
    },

    onLeaveView: function (currentEvent) {
      currentEvent.preventDefault();
      currentEvent.stopPropagation();
      if (!this.leaveViewTimeout) {
        this.leaveViewTimeout = setTimeout(_.bind(function () {
          this.leaveViewTimeout = undefined;
          this.disable();
        }, this), config.detectLeaveDelay);
      }
    },

    onDropView: function (currentEvent) {
      currentEvent.preventDefault();
      currentEvent.stopPropagation();
      var self         = this,
          dataTransfer = currentEvent.originalEvent &&
                         currentEvent.originalEvent.dataTransfer ||
              {
                files: currentEvent.originalEvent &&
                       currentEvent.originalEvent.target &&
                       currentEvent.originalEvent.target.files || []
              };
      this._selectFiles(dataTransfer)
          .always(function (files) {
            files = _.reject(files, function (file) {
              return file instanceof Error;
            });
            if (files.length) {
              if (self.canAdd()) {
                var fileUploadModel = fileUploadHelper.newUpload(
                    _.extend({
                      originatingView: self.parentView
                    }, _.clone(self.options)), self.options);
                fileUploadModel.addFilesToUpload(files, {
                  collection: self.collection
                });
              } else {
                var nodeName = self.container.get('name');
                GlobalMessage.showMessage('error', _.str.sformat(lang.addTypeDenied, nodeName));
              }
            } else {
              GlobalMessage.showMessage('error', lang.noFiles);
            }
          });
      this.disable();
    },

    _selectFiles: function (dataTransfer) {
      var filesFromItems = false,
          wrongEntries   = false,
          items          = dataTransfer.items,
          // Prefer the synchronous check available in Chrome
          files          = items && items.length && _.chain(items)
                  .map(function (item) {
                    var entry  = item.webkitGetAsEntry && item.webkitGetAsEntry(),
                        isFile = entry && entry.isFile;
                    if (isFile) {
                      filesFromItems = true;
                      return item.getAsFile();
                    } else {
                      wrongEntries = true;
                    }
                  })
                  .compact()
                  .value() || dataTransfer.files;
      if (filesFromItems) {
        var resolveMethod = wrongEntries ? 'reject' : 'resolve';
        return $
            .Deferred()
            [resolveMethod](files)
            .promise();
      }

      // Check the files by trying to load them
      files = dataTransfer.files;
      if (files) {
        return $.whenAll
            .apply($, _.map(files, checkFile))
            .then(function (results) {
              return results;
            }, function (files) {
              return $
                  .Deferred()
                  .reject(files)
                  .promise();
            });
      }

      // Bail out if no files were dropped
      return $
          .Deferred()
          .reject([])
          .promise();

      function checkFile(file) {
        var reader   = new FileReader(),
            deferred = $.Deferred(),
            aborted;
        reader.addEventListener('load', function () {
          deferred.resolve(file);
          // The abort event comes after the error event
          aborted = true;
          reader.abort();
        });
        reader.addEventListener('error', function () {
          if (!aborted) {
            var error = new Error('No file');
            error.file = file;
            deferred.reject(error);
          }
        });
        reader.readAsArrayBuffer(file);
        return deferred.promise();
      }
    },

    _restMessage: function () {
      if (this._isRendered) {
        this.ui.message.text(this._getDropPossibleMessage());
      }
    },

    _getDropPossibleMessage: function () {
      var fileName = this.options.container.get('name'),
          message  = '';
      if (fileName) {
        message = _.str.sformat(lang.dropMessage, fileName);
      }
      return message;
    }

  });

  return DragAndDropView;

});

csui.define('csui/controls/fileupload/impl/addversion.controller',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'i18n!csui/controls/fileupload/impl/nls/lang',
  'csui/controls/fileupload/impl/upload.controller',
  'csui/models/fileupload',
  'csui/controls/globalmessage/globalmessage',
  'csui/models/fileuploads'
], function (_,
    $,
    lang,
    UploadController,
    FileUploadModel,
    GlobalMessage,
    UploadFileCollection) {
  'use strict';

  function AddVersionController(options) {
    this.view = options.view;
    this.selectedNode = options.selectedNode;

    this.uploadController = new UploadController();
  }

  _.extend(AddVersionController.prototype, {

    uploadFile: function (file) {
      this._blockActions();
      var fileModel = new FileUploadModel({
            file: file
          }, {
            node: this.selectedNode
          }),
          uploadFiles = new UploadFileCollection([fileModel]);
      this.uploadController.scheduleFileForUpload(fileModel);
      GlobalMessage.showFileUploadProgress(uploadFiles);
      return fileModel
          .promise()
          .always(_.bind(this._unblockActions, this))
          .done(function (fileUploadModel) {
            GlobalMessage.hideFileUploadProgress();
            GlobalMessage.showMessage('success', lang.MessageVersionAdded);
          });
    },

    _blockActions: function () {
      this.view && this.view.blockActions && this.view.blockActions();
    },

    _unblockActions: function () {
      this.view && this.view.unblockActions && this.view.unblockActions();
    }

  });

  return AddVersionController;

});

csui.define('csui/controls/pagination/impl/keyevent.navigation',['csui/lib/underscore', 'csui/lib/jquery', 'csui/utils/base'
], function (_, $, base) {
  'use strict';

  var KeyEventNavigation = {
    isTabable: function(){
      if (base.isVisibleInWindowViewport(this.ui.pageSizeMenu) &&
          base.isVisibleInWindowViewport(this.ui.navPagingMenu)){
        return true;
      }
    },

    currentlyFocusedElement: function () {
      var activeChild = this.getActiveChild();
      return activeChild;
    },

    accActivateTabableRegion: function () {
      this.activateChild(true);
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode;
      var activeChild = this.getActiveChild();
      this.activeChild || (this.activeChild = this.ui.dropDownMenu);

      switch (keyCode) {
          //Enter and space
      case 32:
      case 13:
        if (this.activeChild === this.ui.dropDownMenu) {
          return true;
        }
        this.executeAction(this.activeChild);
        break;
          //right arrow
      case 39:
        var nextChild = this._getNextActiveChild();
        this.setNextActiveChild(nextChild);
        break;
          //left arrow
      case 37:
        var prevChild = this._getPrevActiveChild();
        this.setNextActiveChild(prevChild);
        break;
          //up arrow
      case 38:
        if (this.activeChild === this.ui.dropDownMenu) {
          return true;
        }
        this._pageUp();
        break;
          //page up
      case 33:
        this._pageUp();
        break;
          //down arrow
      case 40:
        if (this.activeChild === this.ui.dropDownMenu) {
          return true;
        }
        this._pageDown();
        break;
          //page down
      case 34:
        this._pageDown();
        break;
          //home
      case 36:
        this._activateHomeElem();
        break;
          //end
      case 35:
        this._activateEndElem();
        break;
      }
    },

    executeAction: function (activeChild) {
      if (activeChild) {
        var pageId = activeChild.attr('data-pageid');
        var nextPageMenu = activeChild.attr('data-slidepage');

        if (nextPageMenu) {
          var pageMenu = parseInt(nextPageMenu, 10);
          this.slidePageMenu(pageMenu);
          this.activeChild = this.ui.navPagingMenu.find('a').first();
          this.activateChild(true, this.activeChild);
        }
        else if (pageId) {
          var pageNum = parseInt(pageId, 10);
          this.changePage(pageNum);
          this.activeChild.removeClass('csui-acc-focusable-active');
        }
      }
    },

    activateChild: function (setActive, activeChild) {
      activeChild || (activeChild = this.getActiveChild());
      if (setActive) {
        activeChild.addClass('csui-acc-focusable-active');
        activeChild.focus();
      }
      else {
        activeChild.removeClass('csui-acc-focusable-active');
      }
    },

    setActiveChild: function (child) {
      this.activeChild = child;
    },

    getActiveChild: function () {
      this.activeChild || (this.activeChild = this.ui.dropDownMenu);
      return this.activeChild;
    },

    setNextActiveChild: function (nextChild) {
      if (nextChild !== this.activeChild) {
        this.activateChild(false, this.activeChild);
        this.activateChild(true, nextChild);
        this.activeChild = nextChild;
      }
    },

    resetActiveChild: function () {
      var activeChild = this.activeChild;
      this.activateChild(false);
      this.activeChild = null;
      if (activeChild) {

        var pageId = activeChild.attr('data-pageid');
        var pageMenu = activeChild.attr('data-slidepage');

        if (pageId) {
          this.activeChild = this._updatedChildPosition(pageId, activeChild);
        }
        else if (pageMenu && (this.numSlideMenus > 1)) {
          var nextPageTab = activeChild.parent().prev();
          if (nextPageTab.length > 0) {
            nextPageTab = nextPageTab.find('a');
          }
          else {
            nextPageTab = activeChild.parent().next().find('a');
          }
          pageId = nextPageTab.attr('data-pageid');
          this.activeChild = this._updatedChildPosition(pageId, nextPageTab);
        }
      }

      this.activeChild || (this.activeChild = this.ui.dropDownMenu);
    },

    _updatedChildPosition: function (pageId, activeChild) {
      pageId = parseInt(pageId, 10);
      if (this.totalCount > this.pageSize) {
        var numPages = this.numPages - 1;
        pageId = pageId > (numPages) ? numPages : pageId;
        var pageMenu = Math.floor(pageId / this.pageTabsPerMenu);
        if (pageMenu > 0) {
          this._initializePageTabMenu(true, true, pageMenu);
        }

        pageId += '';
        activeChild = _.find(this.ui.navPagingMenu.find('a'), function (child) {
          return $(child).attr('data-pageid') === pageId;
        });

        return $(activeChild);
      }
      return null;
    },

    _getPrevActiveChild: function () {
      var nextChild = this.ui.dropDownMenu;
      var activeChild = this.activeChild;

      //account for no paging tabs
      if (activeChild === this.ui.dropDownMenu) {
        nextChild = this.ui.navPagingMenu.find('a').last();
      }
      else {
        var pageId = activeChild.attr('data-pageid');
        var nextPageMenu = activeChild.attr('data-slidepage');

        if (pageId || nextPageMenu) {
          var nextSibling = activeChild.parent().prev().find('a');

          if (nextSibling.length > 0) {
            nextChild = nextSibling;
          }
        }
      }
      return nextChild;
    },

    _getNextActiveChild: function () {
      var nextChild = this.ui.dropDownMenu;
      var activeChild = this.activeChild;

      //account for no paging tabs
      if (activeChild === this.ui.dropDownMenu) {
        nextChild = this.ui.navPagingMenu.find('a').first();
      }
      else {
        var pageId = activeChild.attr('data-pageid');
        var nextPageMenu = activeChild.attr('data-slidepage');

        if (pageId || nextPageMenu) {
          var nextSibling = activeChild.parent().next().find('a');

          if (nextSibling.length > 0) {
            nextChild = nextSibling;
          }
        }
      }
      return nextChild;
    },

    _activateHomeElem: function () {
      this.activeChild = this.ui.dropDownMenu;
      this.activateChild(true, this.activeChild);
    },

    _activateEndElem: function () {
      this.activeChild = this._getLastElem();
      this.activateChild(true, this.activeChild);
    },

    _getLastElem: function () {
      return this.ui.navPagingMenu.find('a').last();
    },

    _pageUp: function () {
      var pageTab = this.ui.navPagingMenu.find('a').last();
      this._page(pageTab);
    },

    _page: function (activeChild) {
      var nextPageMenu = activeChild.attr('data-slidepage');
      if (nextPageMenu) {
        this.activateChild(false, this.activeChild);
        this.activeChild = activeChild;
        this.executeAction(this.activeChild);
      }
    },

    _pageDown: function () {
      var pageTab = this.ui.navPagingMenu.find('a').first();
      this._page(pageTab);
    }

  };

  return KeyEventNavigation;

});

csui.define('csui/controls/pagination/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/pagination/nls/root/localized.strings',{
  // controls/pagination
  PageNavBarAboutItems: "About {0} items"
});


csui.define('csui/controls/pagination/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/pagination/impl/nls/root/localized.strings',{
  // controls/pagination
  PageNavBarTotalItems: "{0} items",
  PageNavBarSingleItem: "1 item",
  PageNavBarItemsPerPage: "{0} per page",
  PageNavBarShowAll: "Show all",
  PageNTotalsAria: "Showing page {0} of {1}, {2} items overall",
  ShowPageNAria: "Show page {0}",
  PreviousPagesAria: "Show previous pages",
  NextPagesAria: "Show next pages",
  SinglePageTotalsAria: "Showing {0} items",
  PageSizeMenuAria: "Select page size, currently {0}",
  PageSizeChoiceAria: "Pagination, show {0} per page",
  PaginationLandmarkAria: "Pagination"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/pagination/impl/nodespagination',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-total-container-items\">"
    + this.escapeExpression(((helper = (helper = helpers.totalItems || (depth0 != null ? depth0.totalItems : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"totalItems","hash":{}}) : helper)))
    + "</div>\r\n<div class=\"binf-nav expanded-pager pager-filter csui-pagesize-menu\">\r\n  <div class=\"binf-dropdown csui-dropdown\">\r\n    <a href=\"\" class=\"binf-dropdown-toggle\"  data-binf-toggle=\"dropdown\" role=\"button\" aria-expanded=\"false\" tabindex=\"0\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.pageSizeMenuAria || (depth0 != null ? depth0.pageSizeMenuAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"pageSizeMenuAria","hash":{}}) : helper)))
    + "\">\r\n      <div class=\"csui-pageSize\">"
    + this.escapeExpression(((helper = (helper = helpers.itemsPerPage || (depth0 != null ? depth0.itemsPerPage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"itemsPerPage","hash":{}}) : helper)))
    + "</div>\r\n      <div class=\"csui-icon icon-expandArrowDown\"></div>\r\n    </a>\r\n    <ul class=\"binf-dropdown-menu binf-dropdown-menu-right csui-dropdown-list\" role=\"menu\">\r\n    </ul>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"csui-pagination\">\r\n  <div class=\"csui-paging-navbar\">\r\n    <ul class=\"binf-hidden\">\r\n      <li class=\"csui-overflow\"></li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_pagination_impl_nodespagination', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/pagination/impl/nodespagination',[],function(){});
csui.define('csui/controls/pagination/nodespagination.view',[
  "csui/lib/jquery", "csui/lib/underscore", "csui/lib/marionette",
  'csui/utils/log',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/pagination/impl/keyevent.navigation',
  'csui/controls/mixins/global.alert/global.alert.mixin',
  'i18n!csui/controls/pagination/nls/localized.strings',
  'i18n!csui/controls/pagination/impl/nls/localized.strings',
  'hbs!csui/controls/pagination/impl/nodespagination',
  'css!csui/controls/pagination/impl/nodespagination'
], function ($, _, Marionette, log, TabableRegionBehavior, KeyEventNavigation,
    GlobalAlertMixin, publicLang, lang, template) {
  'use strict';

  var NodesPaginationView = Marionette.ItemView.extend({

    template: template,
    className: 'csui-pager',
    ui: {
      totalCount: '> .csui-total-container-items',
      pageSizeMenu: '> .csui-pagesize-menu',
      dropDownMenu: '> .csui-pagesize-menu > .csui-dropdown > .binf-dropdown-toggle',
      dropDownList: '> .csui-pagesize-menu .csui-dropdown-list',
      navPagingMenu: '> .csui-pagination > .csui-paging-navbar',
      dropDownListItem: '> .csui-pagesize-menu ul.csui-dropdown-list a'
    },

    templateHelpers: function () {
      var totalCount = this._getTotalCount();
      var pageSize = this.pageSize && this.pageSize > 0 ? this.pageSize : 30;
      this.pageTotalAria = totalCount <= pageSize ? _.str.sformat(lang.SinglePageTotalsAria, totalCount) :
        _.str.sformat(lang.PageNTotalsAria, this.currentPageNum, 1 + Math.floor(totalCount / pageSize), totalCount);

      this.nextPagesAria = lang.NextPagesAria;
      this.previousPagesAria = lang.PreviousPagesAria;

      return {
        totalItems: this._getTotalDisplayCount(),
        itemsPerPage: _.str.sformat(lang.PageNavBarItemsPerPage, this.pageSize),
        pageSizeMenuAria: _.str.sformat(lang.PageSizeMenuAria, this.pageSize)
      };
    },

    events: {
      'keyup @ui.dropDownListItem': 'resetPageSizeKeyUp',
      'click .csui-pagesize-menu ul.csui-dropdown-list a': 'resetPageSize',
      'click .csui-paging-navbar > ul > li:not(.csui-overflow) > a': 'onChangePage',
      'click .csui-pagination  li.csui-overflow > a': 'onSlidePageMenu',
      'keydown': 'onKeyInView'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    constructor: function NodesPaginationView(options) {
      options || (options = {});
      options.pageSize || (options.pageSize = 30);

      Marionette.ItemView.prototype.constructor.call(this, options);

      this.addPaging = true;
      this.currentPageNum = 1;
      this.ddList = this.defaultDDList = options.defaultDDList || [30, 50, 100];
      this.skipCollectionRequest = false;
      //For Versions, we get all the versions at a time and doing pagination at client side
      //when ever we delete and add version skip the immediate pagination
      this.skipPaginationUpdateRequest = !!options.skipPaginationUpdateRequest;
      this.pageSize = this.selectedPageSize = this.options.pageSize;
      this.rendered = false;
      this.pageTotalAriaLast = undefined;
      this.pageTotalTimeoutHandle = undefined;

      if (this.collection) {
        this.collection.setLimit(0, this.options.pageSize, false);
        this.listenTo(this.collection, 'reset', this.collectionChange); // render after reset of collection
        this.listenTo(this.collection, 'add', this._maintainPageSize); // render after an item upload
        this.listenTo(this.collection, 'remove', this._maintainPageSize); // render after a delete item

        //Refresh setting for new node before request is made.
        if (this.collection.node) {
          this.listenTo(this.collection.node, 'change:id', this.nodeChange); // render after reset of collection
        }
      }

      this.onWinRefresh = _.bind(this.windowRefresh, this);
      $(window).bind("resize.app", this.onWinRefresh);
      this.prepareForGlobalAlert();
    },

    onDestroy: function () {
      $(window).unbind("resize.app", this.onWinRefresh);
    },

    windowRefresh: function () {
      if (this._isRendered) {
        this._initializePageTabMenu(false, true);
        this.resetActiveChild();
      }
    },

    collectionChange: function () {
      var slideBars = this.$el.find('.csui-paging-navbar ul');

      this.totalCount = 0;
      //In JQuery 'remove' and 'empty' behave the same. They both clean events and caching of the childNodes.
      //The only difference with 'empty' is that it also removes each child element of the slideBar using 'removeChild',
      //where 'remove' just removes the parentNode. If was found using Chrome Profiler that UL Li elements were not getting
      //cleaned up by GC if just 'remove' was call. This appears to be related to some system caching of the element. Also
      //if we grab the '.csui-paging-navbar' element in attempt to empty it, again LI elements do not get cleaned up and show
      //as detached.
      slideBars.empty();
      slideBars.remove();

      //revert back to the last page size set before collections was updated
      if (this.lastAction !== 'setPageSize') {
        this._reCalculatePageSizes();
      }

      this.lastAction = '';
      this.render();
    },

    //This function is called when a node module change is made. It refreshes all setting for the new node.
    nodeChange: function () {
      this.pageSize = this.selectedPageSize = this.options.pageSize;
      this.totalCount = 0;
      this.resetRenderFlags();
      this.resetCollection(0, this.pageSize, false);
      if (this._isRendered) {
        this.setActiveChild(this.ui.dropDownMenu);
      }
    },

    resetRenderFlags: function () {
      this.addPaging = true;
    },

    // event handler, called when user clicked the page-number-link: remove the 'active' class
    // at li elements with active class set and add the 'active' class to the clicked element.
    // Then call setLimit at the collection to request the new data from the server.
    onChangePage: function (e) {
      e.preventDefault();
      e.stopPropagation();
      var targetPageTab = $(e.currentTarget),
          pageNum       = parseInt(targetPageTab.attr('data-pageid'), 10);
      this.changePage(pageNum);
      this.setActiveChild(targetPageTab);
    },
    changePage: function (pageNum) {
      var pageSize = this.pageSize;
      this.currentPageNum = pageNum + 1;
      var skipCount = pageNum * pageSize;
      this.collection.pagination = this.addPaging;
      this.collection.trigger('new:page');
      this.resetCollection(skipCount, pageSize, true);

      this.templateHelpers();
    },

    // Set the new offset to the children collection and let it load new data from server.
    // Note: the view is rendered automatically when the collection gets filled with new
    // data, because in the constructor we registered on the reset event at the collection
    resetCollection: function (skipItems, pageSize, autoFetch) {
      this.collection.setLimit(skipItems, pageSize, autoFetch);
    },

    resetPageSizeKeyUp: function(e) {
      if(e.keyCode === 32) {
        this.resetPageSize(e);
      }
      return true;
    },

    resetPageSize: function (e) {
      e.preventDefault();
      e.stopPropagation();
      this.collection.pagination = this.addPaging;
      var newPageSize = parseInt($(e.currentTarget).attr('data-pagesize'), 10);
      this.setPageSize(newPageSize, true);
    },

    setPageSize: function (size, autoFetch) {
      this.pageSize = this.selectedPageSize = size;
      if (this.skipCollectionRequest || !autoFetch) {
        this.skipCollectionRequest = false;
      }
      else {
        this.rendered = false;
        this.resetCollection(0, size, autoFetch);
      }
      this.lastAction = 'setPageSize';
      this.currentPageNum = 1;
    },

    _setPageTotalAria: function() {
      if (this.pageTotalAria!=this.pageTotalAriaLast){
        // avoid writing the same value again to avoid repetitive spoken info which might mask other texts
        this.$el.parent().children(".binf-sr-only").html(this.pageTotalAria);
        this.pageTotalAriaLast = this.pageTotalAria;
        this.pageTotalTimeoutHandle = undefined;
      }
    },

    onRender: function () {
      var collection = this.collection;

      // add the binf-sr-only div near the top so it is not covered by the binf-hidden for empty folders
      var sronlyExists = this.$el.parent().children(".binf-sr-only");
      if (!(sronlyExists && sronlyExists.length)) {
        this.$el.before('<div class="binf-sr-only" aria-live="polite"></div>');
      }

      //Check that all data needed has been received and initialized. DropDown list
      //is looked at to see if one will appear or not. Both Node container size and collection sizes
      //are used to account for cases where node data is known before collection is received, and collection is known
      //and node data is not (i.e. Favorites view).
      if (this._validCollection(collection)) {
        this.pageSize = (this.pageSize > this.options.pageSize) &&
                        (this.pageSize > this.totalCount) ? this.totalCount : this.pageSize;
        this.rendered = true;
        this.$el.removeClass('binf-hidden');
        this._initializeDDList();
        if (this.pageTotalTimeoutHandle){
          clearTimeout(this.pageTotalTimeoutHandle);
        }
        this.pageTotalTimeoutHandle = setTimeout(this._setPageTotalAria.bind(this), 1200);
      }
      else {
        this.$el.addClass('binf-hidden');
        if (!this.pageTotalTimeoutHandle) {
          this.pageTotalTimeoutHandle = setTimeout(this._setPageTotalAria.bind(this), 2400);
        }
      }

      this.trigger('render:complete');
    },

    //Account for Window resizing effecting the appearance of the pagination bar
    onDomRefresh: function () {

      //Wait for render command to finish successfully first, before sizing.
      if (this._validCollection(this.collection) && this.rendered) {
        var totalCount = this.totalCount;
        if (totalCount > this.options.pageSize) {
          this._setPageSizeMenu();
          if (totalCount > this.pageSize) {
            this._initializePageTabMenu(true, true);
          }
        }
        else {
          this._showTotalOnly();
        }
        this.resetActiveChild();
      }
    },

    //Hides the pagination tab bar
    hidePaging: function () {
      this.$el.find('.csui-pagination').addClass('binf-hidden');
      return true;
    },

    onSlidePageMenu: function (e) {
      e.preventDefault();
      e.stopPropagation();
      var nextPgMenu = parseInt($(e.currentTarget).attr('data-slidepage'), 10);
      this.slidePageMenu(nextPgMenu);
    },
    slidePageMenu: function (nextPgMenu) {
      var el = this.$el;
      this._initializePageTabMenu(true, true, nextPgMenu);
      el.find('.csui-pages-' + nextPgMenu).addClass('csui-slide');

    },

    getDDList: function (tt) {
      var ddItemLists  = this.defaultDDList,
          ddListLength = ddItemLists.length,
          ddList       = [];

      for (var i = 0; i < ddListLength; i++) {
        if (ddItemLists[i] >= tt) {
          ddList.push(tt);
          break;
        }
        ddList.push(ddItemLists[i]);
      }

      return ddList;
    },

    _getOverflowIconWidth: function () {
      if (!this.overFlowIcon || this.overFlowIcon === 0) {
        //To avoid possible memory leaks due to a retained reference to the csui-overflow in the
        //view's 'ui' collection, a direct jquery find is used instead.
        var overFlowIcon = this.$el.find('.csui-paging-navbar > ul > li.csui-overflow');
        this.overFlowIcon = parseInt(overFlowIcon.css('width'), 10);
      }
      return this.overFlowIcon;
    },

    _getPageTabMinWidth: function () {
      // var pageTabs = this.$el.find('.csui-paging-navbar ul li');
      if (!this.pageTabMinWidth || this.pageTabMinWidth === 0) {
        //To avoid possible memory leaks due to a retained reference to the csui-overflow in the
        //view's 'ui' collection, a direct jquery find is used instead.
        var pageTab = this.$el.find('.csui-paging-navbar > ul > li');
        this.pageTabMinWidth = parseInt(pageTab.css('min-width'), 10);
        pageTab = null;
      }
      this.pageTabMinWidth = 64;
      return this.pageTabMinWidth;
    },

    //Initialize the options for the drop down page size. The maximum
    //size should not exceed the total collection count.
    _initializeDDList: function () {

      this.ddList = this.getDDList(this.totalCount);
    },

    _validCollection: function (collection) {
      var retVal     = false,
          totalCount = this.totalCount;

      if (!collection) {
        log.error('Pagination won\'t be rendered (collection is not set)') &&
        console.error(log.last);
      }
      else {
        var collectionCount = this._getTotalCount(collection);
        this.totalCount = totalCount && totalCount < collectionCount ? totalCount : collectionCount;

        if (collectionCount && collectionCount > 0) {
          retVal = true;
        }
      }

      return retVal;
    },

    _showTotalOnly: function () {
      this.$el.parent().removeAttr('role');
      this.$el.find('.csui-pagesize-menu').addClass('binf-hidden');
      this.$el.find('.csui-pagination').addClass('binf-hidden');
      this.$el.find('.csui-total-container-items').addClass('csui-pagination-top-bottom-padding');
      this.triggerMethod("tabable:not", this);
    },

    _getTotalDisplayCount: function () {
      var collection   = this.collection,
          totalCount   = this._getTotalCount(),
          displayCount = '';

      if (totalCount > 0) {
        displayCount = totalCount === 1 ? lang.PageNavBarSingleItem :
                       totalCount === collection.skipCount + collection.length ?
                       lang.PageNavBarTotalItems : publicLang.PageNavBarAboutItems;

        displayCount = _.str.sformat(displayCount, totalCount);
      }

      return displayCount;
    },

    _setPageSizeMenu: function () {
      var totalCount = this.totalCount;
      if (totalCount > this.options.pageSize) {
        if (this.ddList.length > 1) {
          this._addPageSizeOptions(totalCount);
          this.ui.pageSizeMenu.removeClass('binf-hidden');
        }
        else {
          this.ui.pageSizeMenu.addClass('binf-hidden');
        }
      }
    },

    _addPageSizeOptions: function (tt) {
      var html      = '',
          listArray = [],
          ddList    = this.ddList,
          pageSize  = this.pageSize;

      this.ui.dropDownList[0].innerHTML = '';
      for (var i = ddList.length - 1; i >= 0; i--) {
        var ddListItem = ddList[i],
          txt = (ddListItem === tt) ? lang.PageNavBarShowAll : _.str.sformat(lang.PageNavBarItemsPerPage, ddListItem),
          ariaTxt = _.str.sformat(lang.PageSizeChoiceAria, ddListItem),
          className = (ddListItem === pageSize) ? 'csui-select' : '',
          ariaCurrent = (ddListItem === pageSize) ? ' aria-current="true" ' : '',
          str = '<li role="menuitem">' +
            '<a href="#" class="' +
            className + '" data-pagesize=' + ddListItem + ariaCurrent +
            ' aria-label="' + ariaTxt + '"><span class="csui-pagination-checked icon-listview-checkmark"></span>' +
            txt + '</a></li>';

        listArray.push(str);
        html += str;
      }

      this.ui.dropDownList.append(html);
      return true;
    },

    _initializePageTabMenu: function (forceReset, activateMenu, activeMenu) {
      // create a navigation landmark with proper label as navigation alternative for screenreader users.
      // will not be there when pagination items are not shown.
      this.$el.parent().attr('role', 'navigation').attr('aria-label', lang.PaginationLandmarkAria);

      var minPageTabWidth   = this._getPageTabMinWidth(),
          overflowIconWidth = this._getOverflowIconWidth();
      this._setPageTabMenu(minPageTabWidth, overflowIconWidth, forceReset, activateMenu,
          activeMenu);
    },
    // use the values from the server response to calculate the pagination
    //  topCount: page size
    //  actualSkipCount: number of items skipped for a specific page
    //  totalCount: total number of items in the container node
    _setPageTabMenu: function (minPageTabWidth, nextIconWidth, forceReset, activateMenu,
        activeMenu) {
      var numPages = this.numPages = Math.ceil(this.totalCount / this.pageSize);
      var pageTabsPerMenu = this._getPageTabsPerSlideMenu(minPageTabWidth, nextIconWidth, numPages);
      this.numSlideMenus = Math.ceil(numPages / pageTabsPerMenu);

      if (forceReset || (pageTabsPerMenu !== this.pageTabsPerMenu)) {
        this.pageTabsPerMenu = pageTabsPerMenu;
        //If activate new menu then destroy old menu
        activateMenu && this.ui.navPagingMenu.html('');
        this._addSideMenu(this.numSlideMenus, pageTabsPerMenu, numPages, activateMenu, activeMenu);
      }
    },

    _getPageTabsPerSlideMenu: function (minPageTabWidth, nextIconWidth, numPages) {
      var navMenuWidth = this.ui.navPagingMenu.width(),
          pageTabs     = Math.floor(navMenuWidth / minPageTabWidth);

      //If more than on page menu, then reduce tab count based on the appearance of
      //next and previous icon
      if (pageTabs < numPages) {
        pageTabs = Math.floor((navMenuWidth - nextIconWidth) / minPageTabWidth);
        pageTabs = (pageTabs * 2 < numPages ) ? pageTabs - 1 : pageTabs;
        (pageTabs <= 0) && (pageTabs = 1);
      }
      return pageTabs;
    },

    _addSideMenu: function (numSlideMenus, pageTabsPerMenu, numPages, activate, currSlideMenu) {

      var navPagingMenu = this.ui.navPagingMenu,
          skipCount     = this.collection.skipCount,
          totalCount    = this.totalCount,
          pageSize      = this.pageSize,
          currPage      = skipCount > totalCount ? numPages - 1 : skipCount / pageSize;

      currSlideMenu = currSlideMenu == null ? Math.floor(currPage / pageTabsPerMenu) :
                      currSlideMenu;
      var startPageNum = currSlideMenu * pageTabsPerMenu;

      var html     = '',
          slideBar = $(
              '<ul class="binf-nav expanded-pager pager-tabs csui-pages csui-pages-' +
              currSlideMenu + '"></ul>');

      if (currSlideMenu > 0) {
        html += '<li class="csui-overflow"><a href="#" tabindex="-1" class="csui-overflow-left" data-slidePage="'
                + (currSlideMenu - 1) +
                '" aria-label="' + this.previousPagesAria + '" title="' + this.previousPagesAria +'"><span class="csui-icon goto_previous_page"></span></a></li>';
      }

      html += this._addPageTabs(startPageNum, currPage, pageTabsPerMenu, numPages);
      if (activate) {
        slideBar.addClass('csui-active');
      }

      if (currSlideMenu < numSlideMenus - 1) {
        html += '<li class="csui-overflow"><a href="#" tabindex="-1" class="csui-overflow-right" data-slidePage="'
                + (currSlideMenu + 1) +
                '" aria-label="' + this.nextPagesAria + '" title="' + this.nextPagesAria + '"><span class="csui-icon goto_next_page"></span></a></li>';
      }
      // Added below code to remove space is displayed on last slide page
      if (currSlideMenu === numSlideMenus - 1) {
        this.$el.find(".csui-pagination").find(".csui-paging-navbar").addClass(
            "csui-last-slidePage");
      } else {
        this.$el.find(".csui-pagination").find(".csui-paging-navbar").removeClass(
            "csui-last-slidePage");
      }

      slideBar.append(html);
      navPagingMenu.html(slideBar);
    },

    _addPageTabs: function (startPage, currPage, pageTabsPerMenu, numPages) {
      var retVal = false;
      var endPage = ((startPage + pageTabsPerMenu) >= numPages) ? numPages :
                    startPage + pageTabsPerMenu;
      var html = '';

      for (var pageNum = startPage; pageNum < endPage; pageNum++) {
        var txt = pageNum + 1;
        html += '<li><a href="#" tabindex="-1" class="';

        if (( pageNum ) === currPage) {
          html += 'csui-activePage" aria-current="page';
        }

        var showAria = _.str.sformat(lang.ShowPageNAria, txt);
        html += '" data-pageid="' + pageNum + '" aria-label="' + showAria + '" title="' + showAria +'"><span>' + txt + '</span></a></li>';
      }

      return html;

    },

    _reCalculatePageSizes: function () {
      this._calculateSelectPageSize();
      this._reCalculatePageSize();
    },

    //Determine what the page size should be based on the last user selected size and available
    //drop-down page sizes.
    _calculateSelectPageSize: function () {

      var selectedPageSize = this.selectedPageSize,
          collectionTotal  = this._getTotalCount(),
          sizeList         = this.defaultDDList;

      this.selectedPageSize = _.indexOf(sizeList, selectedPageSize) > -1 ? selectedPageSize :
                              (selectedPageSize >= collectionTotal) ? collectionTotal :
                              _.find(sizeList, function (size) {
                                return selectedPageSize < size;
                              });
    },

    _reCalculatePageSize: function () {
      var defaultPageSize = this.options.pageSize,
          collectionCount = this._getTotalCount();

      this.pageSize = collectionCount === 0 ? defaultPageSize :
                      ((this.selectedPageSize > collectionCount) ? collectionCount :
                       this.selectedPageSize);
    },

    //Maintain page size as items are being uploaded and added to the top of the table list.
    _maintainPageSize: function (model, collection, trigger) {
      //Set csuiIsSelected property to false for newly added models
      if (model.get('csuiIsSelected')) { model.set('csuiIsSelected', false);}
      //maintain collection count after add or remove
      this._updateTotalCount(trigger);

      this.resetRenderFlags();
      this._initializeDDList(false);

      if (!this.skipPaginationUpdateRequest &&
          this.collection.models.length > this.selectedPageSize) {
        this.stopListening(this.collection, 'remove');
        this.collection.pop();
        this.listenTo(this.collection, 'remove', this._maintainPageSize); // render after a delete item
      } else if (this.skipPaginationUpdateRequest && !!this.collection.allModels &&
                 this.collection.allModels.length === this.collection.skipCount) {
        // update skipCount when we delete all the items in last page
        this.collection.skipCount = this.collection.skipCount - this.collection.topCount;
      }

      //Skip collection request as page size is re-configured on new collection size. We don't want to force a new collection call, with
      //a new page size, as items are being added to the table during an upload. We just
      //want to increase the display total and pagination tabs.
      this.skipCollectionRequest = true;
      this._reCalculatePageSizes();
      this.render();
      return true;
    },

    _getTotalCount: function (collection) {
      var totalCount = 0;
      if (!collection) {
        collection = this.collection;
      }
      if (collection) {
        totalCount = collection.filteredCount;
        if (totalCount == null) {
          totalCount = collection.totalCount;
        }
        if (totalCount == null) {
          totalCount = collection.length;
        }
      }
      return totalCount;
    },

    _updateTotalCount: function (trigger) {
      var difference = trigger.add ? 1 : -1;
      this.totalCount += difference;
      if (this.collection.filteredCount != null) {
        this.collection.filteredCount += difference;
      }
      if (this.collection.totalCount != null) {
        this.collection.totalCount += difference;
      }
    }
  });

  _.extend(NodesPaginationView.prototype, KeyEventNavigation);
  _.extend(NodesPaginationView.prototype, GlobalAlertMixin);
  return NodesPaginationView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/tableactionbar/impl/tableactionbar',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<ul class=\"tile-nav binf-nav binf-nav-pills\" role=\"menu\"></ul>\r\n";
}});
Handlebars.registerPartial('csui_controls_tableactionbar_impl_tableactionbar', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/tableactionbar/impl/lazy.loading.template',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<li role=\"menuitem\" class=\"csui-loading-parent-wrapper binf-disabled csui-disbaled\">\r\n  <span class=\"csui-loading-dots-wrapper\">\r\n    <span class=\"csui-loading-dot\"></span>\r\n    <span class=\"csui-loading-dot\"></span>\r\n    <span class=\"csui-loading-dot\"></span>\r\n  </span>\r\n</li>";
}});
Handlebars.registerPartial('csui_controls_tableactionbar_impl_lazy.loading.template', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/tableactionbar/impl/tableactionbar',[],function(){});
csui.define('csui/controls/tableactionbar/tableactionbar.view',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/utils/log', 'csui/utils/base', 'i18n',
  'csui/controls/toolbar/toolitem.model',
  'csui/controls/toolbar/toolitem.view',
  'csui/controls/toolbar/toolbar.view',
  'csui/models/nodes', 'csui/controls/toolbar/toolitems.filtered.model',
  'csui/controls/toolbar/toolbar.state.behavior',
  'csui/utils/commandhelper', 'csui/utils/commands',
  'hbs!csui/controls/tableactionbar/impl/tableactionbar',
  'hbs!csui/controls/tableactionbar/impl/lazy.loading.template',
  "csui/controls/tile/behaviors/perfect.scrolling.behavior",
  'css!csui/controls/tableactionbar/impl/tableactionbar'
], function (module, _, $, Backbone, Marionette, log, base, i18n,
    ToolItemModel, ToolItemView, ToolbarView, NodeCollection,
    FilteredToolItemsCollection, ToolbarStateBehavior, CommandHelper,
    commands, template, lazyLoadingTemplate, PerfectScrollingBehavior) {
  'use strict';

  var TableActionBarView = Marionette.CompositeView.extend({

    className: "csui-table-actionbar",

    template: template,

    childView: ToolItemView,

    childViewContainer: "ul",

    behaviors: {

      ToolbarState: {
        behaviorClass: ToolbarStateBehavior
      }

    },

    constructor: function TableActionBarView(options) {
      this.container = options.container;
      this.containerCollection = options.containerCollection;
      this.originatingView = options.originatingView;
      this.commandExecutionOptions = options.commandExecutionOptions;

      options.status || (options.status = {});
      var status = _.defaults(options.status, {
        nodes: new NodeCollection([options.model]),
        container: this.container,
        context: this.originatingView.context // todo get context from creating view
      });

      this.commands = options.commands || commands;

      // replace collection with ToolItemModels with filtered collection
      options.collection = new FilteredToolItemsCollection(
          options.collection, {
            status: status,
            commands: this.commands,
            delayedActions: options.delayedActions,
            mask: options.toolItemsMask
          });

      Marionette.CompositeView.prototype.constructor.apply(this, arguments);

      //if promoted actions are less than 2, show the default loading state and after fetch the
      // nonpromoted actions if not yet fetched
      //    1. if total collection is lessthan two dont show inline action bar and remove
      // loading message
      //    2. if total collection 2 or more than show inline action bar
      if (this.model.nonPromotedActionCommands && this.model.nonPromotedActionCommands.length &&
          options.collection.length <= 1) {
        this.actionState.set('state', 'loading');
      }
      // Passing the el to the ctor prevents creating an own el, including
      // setting its attributes.  The caller must ensure the right tag.

      if (options.el) {
        $(options.el).addClass(_.result(this, "className"));
      }
    },

    isEmpty: function (options) {
      return this.collection.length <= 1;
    },

    onBeforeDestroy: function () {
      this.originatingView = null;
      //Since this view is responsible for creating its own collection, it is also responsible for
      //cleaning up its memory. In FilterToolItemsCollection there are event listeners that need to be removed after
      //each view destroy.
      this.collection.stopListening();
    },

    onBeforeRenderCollection: function () {
      this.destroyChildren();
      if (this.$childViewContainer) {
        this.$childViewContainer.empty();
      }
    },

    onRenderCollection: function () {
      // If action bar is refreshed while being visible, because delayed
      // actions have been received, re-adjust the buttons
      this._adjusted = false;
      if (base.isVisibleInWindowViewport(this.$el)) {
        this._layoutButtons();
      }
    },

    onRender: function () {
      // add an additional style after rendered
      if (this.options.inlineBarStyle) {
        this.$el.addClass(this.options.inlineBarStyle);
      }
      if (this._isBlocked) {
        this.$el.addClass('binf-disabled');
      }
    },

    onShow: function () {
      this._layoutButtons();
    },

    _layoutButtons: function () {
      // What it does:
      // Iterate through all toolbar items and compare the vertical position with the vertical
      // position of the first item. If it changes it is the toolbar item the browser wrapped
      // into the next line because of lack of horizontal width.
      // The toolbar item before, which is still rendered correctly and all following toolbar
      // items are moved into an inserted dropdown menu.

      // Actions have not yet been loaded; do not show even actions,
      // which are always allowed and let the empty collection cause
      // the toolbar (empty) state view to be shown
      var delayedActions = this.options.delayedActions;
      if (delayedActions && (delayedActions.fetching ||
                             delayedActions.error)) {
        return;
      }

      if (this._adjusted) {
        return true;
      }

      this._adjusting = true;

      var node                 = this.model,
          lazyActionsRetrieved = !!node && !!node.get('csuiLazyActionsRetrieved'),
          isLocallyCreatedNode = !!node.isLocallyCreated,
          itemViews            = _.sortBy(this.children.toArray(), 'cid'); //IE11, returns wrong index and view in each loop
      itemViews = itemViews.filter(function (view) {
        return view instanceof ToolItemView;
      }); //filters toolItemViews
      this.actionbarOptions = {
        toolItemCounter: 0,
        cntItemsFit: 0,
        index: 0,
        dropDownMenuEl: undefined,
        separatorView: undefined,
      };
      //In Tile Views, to stop fetching non-promoted actions
      this.enabledNonPomotedCommands = node.collection.enableNonPromotedCommands === false ?
                                       node.collection.enableNonPromotedCommands : true;

      if (itemViews.length > 1) {
        this.firstOffsetY = this.children.first().$el.offset().top;

        _.each(itemViews, _.bind(function (toolItemView, index) {
          this.actionbarOptions.index = index;
          this._wrapToolItemView(toolItemView);
        }, this));

        if (!!node && !lazyActionsRetrieved && node.nonPromotedActionCommands &&
            this.enabledNonPomotedCommands &&
            node.nonPromotedActionCommands.length && !isLocallyCreatedNode) { // append loading
          // visual and fetch lazy actions.
          if (this.$childViewContainer.find('.binf-dropdown').length) {
            this.$childViewContainer.find('.binf-dropdown ul').append(lazyLoadingTemplate);
          } else {
            if (this.actionbarOptions.toolItemCounter === this.options.maxItemsShown) {
              if (this.$childViewContainer.find('li:last').length > 0) {
                this.$childViewContainer.find('li:last').addClass('csui-actionbar-hide-child');
              }
            }
            this.$childViewContainer.append(lazyLoadingTemplate);
            this._renderLazyActions().always(_.bind(function () {
              this._checkInlineActionBarShouldAlive();
            }, this));
          }
        } else {
          this._checkInlineActionBarShouldAlive();
        }

      } else {
        if (!!node && !lazyActionsRetrieved && node.nonPromotedActionCommands &&
            node.nonPromotedActionCommands.length && !isLocallyCreatedNode &&
            this.enabledNonPomotedCommands) {
          this._renderLazyActions().always(_.bind(function () {
            this._checkInlineActionBarShouldAlive();
          }, this));
        } else {
          this._checkInlineActionBarShouldAlive();

        }
      }

      this._adjusting = false;
      this._adjusted = true;
    },

    _checkInlineActionBarShouldAlive: function () {
      if (this.actionbarOptions.cntItemsFit < 2 && this.options.maxItemsShown !== 1) {
        this.destroy();
      }
    },

    _wrapToolItemView: function (toolItemView) {
      // Skip empty (state) view
      if (!(toolItemView instanceof ToolItemView)) {
        return;
      }
      var isSeparator = toolItemView.model.isSeparator();
      if (!isSeparator) {
        this.actionbarOptions.toolItemCounter++;
      }
      if (this.actionbarOptions.dropDownMenuEl) {
        // move the remaining toolbar items into the ul of the dropdown menu
        // but not the last item if it is a separator
        if (!(isSeparator && this.actionbarOptions.index + 1 === this.children.length)) {
          toolItemView.renderTextOnly();
          toolItemView.$el.attr('role', 'menuitem');
          this.actionbarOptions.dropDownMenuEl.append(toolItemView.$el);
        }
      } else {
        if (isSeparator) {
          this.actionbarOptions.separatorView = toolItemView;
        } else {
          var currentOffsetY = toolItemView.$el.offset().top;
          // check if element already wrapped because not enough space to render it in one line
          if (currentOffsetY !== this.firstOffsetY ||
              (this.actionbarOptions.toolItemCounter > this.options.maxItemsShown)) {
            // the previous toolbar item will be replaced by dropdown menu and moved into it
            if (this.actionbarOptions.prevToolItemView) {
              this.actionbarOptions.prevToolItemView.$el.attr('role', 'menuitem');
              this.actionbarOptions.dropDownMenuEl = this._wrapWithDropDown(
                  this.actionbarOptions.prevToolItemView, toolItemView,
                  this.actionbarOptions.separatorView);
            } else {
              // there is no previous toolbar item -> wrap the current toolbar item into a
              // dropdown menu at the beginning of the toolbar
              this.actionbarOptions.dropDownMenuEl = this._wrapWithDropDown(
                  toolItemView.$el, toolItemView);
            }
          }
          else {
            this.actionbarOptions.cntItemsFit++;
          }
          this.actionbarOptions.prevToolItemView = toolItemView;
        }
      }
    },

    _renderLazyActions: function () {
      var self      = this,
          node      = this.model,
          derferred = $.Deferred();
      !!node && node.setEnabledLazyActionCommands(true).done(_.bind(function () {

        var newCollection = new FilteredToolItemsCollection(
            self.options.collection.unfilteredModels, {
              status: self.options.status,
              commands: self.commands,
              delayedActions: self.model.delayedActions,
              mask: self.options.toolItemsMask
            });

        // as per UX, we have to hide/remove loading element after 300ms.
        var blockingEle = self.$childViewContainer.find('.csui-loading-parent-wrapper');
        if (blockingEle.length) {

          //As per UX review comments, 300 ms given before rendering lazy actions
          blockingEle.animate("width: 0", 300, function () {
            self.$childViewContainer.find('.csui-actionbar-hide-child').removeClass(
                'csui-actionbar-hide-child');
            blockingEle.addClass('binf-hidden');
            if (self.actionbarOptions.toolItemCounter < self.options.maxItemsShown) {
              blockingEle.addClass('binf-maxtoolitems-not-reached');
            }
            //render only lazy action Items
            if (self.collection.models.length !== newCollection.models.length) {
              _.filter(newCollection.models, function (model) {
                if (self.isDestroyed === true || self._isDestroyed) {
                  self.children = undefined;
                } else {
                  var signature = model.get("signature");
                  if (!self.collection.find({signature: signature})) {
                    self.actionbarOptions.index++;
                    var lazyToolItemView = self.addChild(model, ToolItemView,
                        self.actionbarOptions.index);
                    self._wrapToolItemView(lazyToolItemView);
                  }
                }
              });
            }
            derferred.resolve();
          });
        } else {
          if (self.isDestroyed === true || self._isDestroyed) {
            self.children = undefined;
          } else {
            //if the promoted action items are less than two then inline toolbar is not rendered not
            // yet, so we can reset existing collection render entire inline toolbar iff total
            // actions are more than two.
            self.collection.refilter();
          }
          derferred.resolve();
        }

      }), self).fail(function () {
        self.$childViewContainer.find('.csui-loading-parent-wrapper').remove();
        self.$childViewContainer.find('.csui-actionbar-hide-child').removeClass(
            'csui-actionbar-hide-child');
        derferred.reject();
      });
      return derferred.promise();
    },

    _wrapWithDropDown: function (prevToolItemView, toolItemView, separatorView) {
      prevToolItemView.renderTextOnly();
      prevToolItemView.$el.wrap('<li class="binf-dropdown"><ul class="binf-dropdown-menu"' +
                                ' role="menu"></ul></li>');
      var e = this._makeDropDown();
      this.$el.find('li.binf-dropdown').prepend(e);
      var dropdownToggler = this.$el.find('li.binf-dropdown > a.binf-dropdown-toggle');

      dropdownToggler.bind('binf.dropdown.before.show', _.bind(function () {
        $(this.nextElementSibling).addClass('binf-invisible');
        var node                 = this.model,
            lazyActionsRetrieved = !!node.get('csuiLazyActionsRetrieved'),
            isLocallyCreatedNode = !!node.isLocallyCreated;

        if (!!node && !lazyActionsRetrieved && node.nonPromotedActionCommands &&
            node.nonPromotedActionCommands.length && !isLocallyCreatedNode &&
            this.enabledNonPomotedCommands) {
          this._renderLazyActions();
        }
      }, this));

      var $inlineActionBarView = toolItemView._parent;

      $inlineActionBarView.listenTo($inlineActionBarView, 'destroy', function () {
        $(".csui-zero-zindex").removeClass("csui-zero-zindex");
      });

      var that = this;

      dropdownToggler.bind('binf.dropdown.after.show', function () {
        var scrollSelector = $(this).closest('.csui-perfect-scrolling').length > 0 ?
                             '.csui-perfect-scrolling' : '.csui-normal-scrolling'; //.csui-normal-scrolling for touch devices (MS Surface)
        var el = $(this).closest(scrollSelector);
        var $dropdown = $(this).nextAll('.binf-dropdown-menu');
        base.autoAlignDropDowns($(this), $dropdown, true, $dropdown, base.isIE11());
        var css = {};
        if (el.width() < $dropdown.offset().left + $dropdown.width()) {
          css.left = ($dropdown[0].offsetLeft + $(this).outerWidth()) - $dropdown.width();
        }
        if (i18n.settings.rtl &&
            ($dropdown.siblings(".binf-dropdown-toggle").offset().left - el.offset().left) <
            $dropdown.width()) {
          css.right = 'auto';
          //In IE11, left position of dropdown is from window left while in other browser it is from dialog left
          if (base.isIE11()) {
            css.left = ($dropdown.siblings(".binf-dropdown-toggle").offset().left);
          } else {
            css.left = ($dropdown.siblings(".binf-dropdown-toggle").offset().left - el.offset().left);
          }
        }
        if ($dropdown.prop('style').top === 'auto') { //dropup, added by base.autoAlignDropDowns
          css.maxHeight = Math.floor(window.innerHeight -
                          (window.innerHeight - $dropdown.closest('.binf-dropdown').offset().top)) -
                          5;
          if (!!that.model.get('csuiDelayedActionsRetrieved') &&
              !that.model.get('csuiLazyActionsRetrieved') && that.model.nonPromotedActionCommands &&
              that.model.nonPromotedActionCommands.length && that.enabledNonPomotedCommands) {
            var dropdownEle = $dropdown.closest('.binf-dropdown'),
                blockingEle = $(dropdownEle).find('.csui-loading-parent-wrapper');
            blockingEle.length && blockingEle.remove(); //Remove existing loading icons from
            // dropdown menu and replace more menu icon with loading icons
            dropdownEle.addClass('csui-actionbar-hide-child');
            $dropdown.closest('.csui-table-actionbar .binf-nav').append(lazyLoadingTemplate);
          }
          if ($("#breadcrumb-wrap").length > 0) {
            $("#breadcrumb-wrap").addClass("csui-zero-zindex");
            $(".csui-navbar.binf-navbar.binf-navbar-default").addClass("csui-zero-zindex");
            if ($('.csui-search-tool-container').length > 0) {
              $('.csui-search-tool-container').addClass('csui-zero-zindex');
            }
          }
        } else {
          css.maxHeight = Math.floor(
                          window.innerHeight - $dropdown.closest('.binf-dropdown').offset().top) -
                          $dropdown.closest('.binf-dropdown').height() - 5;
          if ($("#breadcrumb-wrap").length > 0) {
            $("#breadcrumb-wrap").removeClass("csui-zero-zindex");
            $(".csui-navbar.binf-navbar.binf-navbar-default").removeClass("csui-zero-zindex");
            if ($('.csui-search-tool-container').length > 0) {
              $('.csui-search-tool-container').removeClass('csui-zero-zindex');
            }
          }
        }

        $dropdown.css(css);

        var $scrollParent;
        if (that.usePerfectScrollbar()) {
          $dropdown.addClass('csui-perfect-scrolling');
          $dropdown.perfectScrollbar({
            suppressScrollX: true,
            includePadding: true
          });
          // scrollParent is not correct when using perfect scrollbar, so taking the ps-container which is scrollable
          $scrollParent = $dropdown.closest('.binf-dropdown').closest(
              '.csui-perfect-scrolling.ps-container');
        } else {
          // donot bind on $dropdown as it has fixed position and scrollParent will return document for it.        
          $scrollParent = $dropdown.closest('.binf-dropdown').scrollParent();
        }
        $scrollParent.bind('scroll.csui.inline.actions', function (event) {
          !$dropdown.is(':hidden') && $dropdown.binf_dropdown('toggle');
          $(event.target).unbind('scroll.csui.inline.actions');
        });
      });

      var dropDownMenuEl = this.$el.find('li.binf-dropdown>ul.binf-dropdown-menu');

      if (separatorView) {
        separatorView.renderTextOnly();
        dropDownMenuEl.append(separatorView.$el);
      }

      toolItemView.renderTextOnly();
      toolItemView.$el.attr('role', 'menuitem');
      dropDownMenuEl.append(toolItemView.$el);  // move current toolitem into dropdown
      return dropDownMenuEl;
    },

    _makeDropDown: function () {
      var e = '<a role="button" href="#" tabindex="-1" class="binf-dropdown-toggle" data-binf-toggle="dropdown"' +
              ' aria-expanded="false"';
      if (this.options.dropDownText) {
        e += ' title="' + this.options.dropDownText + '" aria-label="' + this.options.dropDownText +
             '">';
      } else {
        e += '>';
      }
      if (this.options.dropDownIcon) {
        e += '<span class="' + this.options.dropDownIcon + '"></span>';
      } else {
        if (this.options.dropDownText) {
          e += this.options.dropDownText;
        }
      }
      e += "</a>";
      return e;
    },

    _setBlocked: function () {
      var self = this;
      this._blockedTimer = setTimeout(function () {
        // if in the meanwhile _setUnblock was called, then do the unblocking now after the delay
        if (self._isBlocked === false) {
          self.$el.removeClass('binf-disabled');
        }
        self._blockedTimer = undefined;
      }, 500);
      this._isBlocked = true;
      this.$el.addClass('binf-disabled');
    },

    _setUnblocked: function () {
      this._isBlocked = false;
      if (!this._blockedTimer) {
        // unblock immediately if delay is already over
        this.$el.removeClass('binf-disabled');
      }
    },

    // This method is triggered as a nested 'childview:...' event; such
    // events always get the childView as the first argument.
    onChildviewToolitemAction: function (toolItemView, args) {
      var self = this;
      var signature = args.toolItem.get("signature");
      var command = this.commands.findWhere({signature: signature});
      var status = _.defaults(this.options.status, {
        nodes: new NodeCollection([this.model]),
        container: this.container,
        originatingView: this.originatingView,
        context: this.originatingView.context // todo get context from creating view
      });
      status.collection = this.containerCollection;
      status.data = args.toolItem.get('commandData') || {};

      var eventArgs = {
        status: status,
        commandSignature: signature
      };
      this.trigger('before:execute:command', eventArgs);
      this._setBlocked();
      Backbone.trigger('closeToggleAction');
      // a command must be found because otherwise the toolbar item would not be in this bar
      var promisesFromCommands = command.execute(status, this.commandExecutionOptions);
      CommandHelper.handleExecutionResults(promisesFromCommands,
          {
            command: command,
            suppressSuccessMessage: status.suppressSuccessMessage,
            suppressFailMessage: status.suppressFailMessage,
            customError: this.options.customError
          }).done(function (nodes) {
        // reducing performance to somewhat extent,
        // such that collection will be refetched iff it meets the following condtions
        // 1) if the current command allows to refetch from it's own implementation
        // 2) if the total count is > current page size.
        if (!!command.allowCollectionRefetch &&
            self.options.originatingView.collection.totalCount >
            self.options.originatingView.collection.topCount) {
          self.options.originatingView.collection.fetch();
        }
      })
          .always(function () {
            self._setUnblocked();
            self.trigger('after:execute:command', eventArgs);
          });
    },

    usePerfectScrollbar: function () {
      return PerfectScrollingBehavior.usePerfectScrollbar();
    }

  });

  TableActionBarView.version = '1.0';

  return TableActionBarView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/item.title/impl/name/name',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-item-name-readonly title csui-acc-focusable\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" role=\"button\"\r\n     aria-expanded=\"false\">\r\n  <h2 class=\"csui-item-name-block\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</h2>\r\n</div>\r\n<div class=\"csui-item-name-edit title-edit-div\">\r\n  <input class=\"title-input\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.placeholderName || (depth0 != null ? depth0.placeholderName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"placeholderName","hash":{}}) : helper)))
    + "\" type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\"\r\n         title=\""
    + this.escapeExpression(((helper = (helper = helpers.edit_name_tooltip || (depth0 != null ? depth0.edit_name_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"edit_name_tooltip","hash":{}}) : helper)))
    + "\">\r\n  <span class=\"csui-undo edit-cancel inline-edit-icon\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.cancel_edit_name_tooltip || (depth0 != null ? depth0.cancel_edit_name_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cancel_edit_name_tooltip","hash":{}}) : helper)))
    + "\"></span>\r\n  <div class=\"csui-item-name-error title-error binf-text-danger\" title=\"\"></div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_item.title_impl_name_name', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/item.title/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/item.title/impl/nls/root/localized.strings',{
  editNameTooltip: 'Edit Name',
  cancelEditNameTooltip: 'Cancel Name edit',
  placeHolderName: 'Enter name',
  showMore: 'Show more',
  showMoreAria: 'Show more commands'
});



csui.define('css!csui/controls/item.title/impl/name/name',[],function(){});
csui.define('csui/controls/item.title/impl/name/name.view',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/utils/log',
  'hbs!csui/controls/item.title/impl/name/name',
  'i18n!csui/controls/item.title/impl/nls/localized.strings',
  'csui/utils/commandhelper', 'csui/behaviors/item.name/item.name.behavior',
  'csui/utils/contexts/factories/ancestors',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'css!csui/controls/item.title/impl/name/name'
], function ($, _, Backbone, Marionette, log, template, lang,
    CommandHelper, ItemNameBehavior, AncestorCollectionFactory,
    ViewEventsPropagationMixin) {

  var ItemTitleNameView = Marionette.ItemView.extend({

    className: 'csui-item-name',
    template: template,

    templateHelpers: function () {
      return {
        name: this.model.get("name"),
        edit_name_tooltip: lang.editNameTooltip,
        cancel_edit_name_tooltip: lang.cancelEditNameTooltip,
        placeholderName: lang.placeHolderName
      };
    },

    ui: {
      // note: if you change the template or this mapping, be sure not to break the behavior code
      name: '.csui-item-name-readonly', // for compatibility with item.name.behavior
      nameReadonly: '.csui-item-name-readonly',
      nameEdit: '.csui-item-name-edit',
      nameEditDiv: '.csui-item-name-edit',  // for compatibility with item.name.behavior
      nameInput: '.csui-item-name-edit>input',
      inputName: '.csui-item-name-edit>input',  // for compatibility with item.name.behavior
      nameEditCancelIcon: '.csui-item-name-edit>.edit-cancel',
      titleError: '.csui-item-name-error'
    },

    modelEvents: {
      'change': 'render'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    behaviors: {
      ItemName: {
        behaviorClass: ItemNameBehavior
      }
    },

    constructor: function ItemTitleNameView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.call(this, options);
    },

    onRender: function () {
      this.editing = false;
      this.ui.nameEdit.addClass('binf-hidden');

      // this._setNodeIconView();
      // this._setDropDownMenuView();
    },

    // _setNodeIconView: function () {
    //   //Each time render is called a new Icon view is created.
    //   //Since NodeTypeIconView has internal event listeners, this object
    //   //will not be removed for GC unless those listeners are removed.
    //   if (this._nodeIconView) {
    //     this._nodeIconView.destroy();
    //   }
    //   this._nodeIconView = new NodeTypeIconView({
    //     el: this.$('.csui-type-icon').get(0),
    //     node: this.options.model
    //   });
    //   this._nodeIconView.render();
    // },

    // _setDropDownMenuView: function () {
    //   this.dropdownMenuView.render();
    //   Marionette.triggerMethodOn(this.dropdownMenuView, 'before:show', this.dropdownMenuView, this);
    //   this.ui.nameDropdownMenuDiv.append(this.dropdownMenuView.el);
    //   Marionette.triggerMethodOn(this.dropdownMenuView, 'show', this.dropdownMenuView, this);
    // },

    _validateAndSave: function () {
      var currentValue = this.model.get('name');
      var inputValue = this.getInputBoxValue();
      inputValue = inputValue.trim();

      if (currentValue !== inputValue) {

        var success = this.validate(inputValue);
        if (success === true) {
          var self = this;
          this.setInputBoxValue(inputValue);
          this.setValue(inputValue);

          self._blockActions();
          var attributes = {name: inputValue};
          var context = this.options.context;
          var node = self.options.model;
          node.save(attributes, {
                wait: true,
                patch: true,
                // prevent early refresh of views when the server sends nothing;
                // wait for the update caused by the model re-fetch below
                silent: !!attributes.name
              })
              .then(function () {
                // See the angry comment above about why we not only get the
                // modifications from the PUT request, but we cannot event
                // fetch the node info, because CS REST API is inconsistent.
                node.fetch()
                    .done(function (resp) {
                      if (context) {
                        context.trigger('current:folder:changed', node);
                      }
                      self._unblockActions();
                      self.options.originatingView.unblockActions();
                    })
                    .fail(function (error) {
                      self._unblockActions();
                      var errorMsg = self._getErrorMessageFromResponse(error);
                      log.error('Saving failed. ', errorMsg) && console.error(errorMsg);
                    });
                self._toggleEditMode(false);
              })
              .fail(function (err) {
                self._unblockActions();
                var errorMessage = self._getErrorMessageFromResponse(err);
                self.setValue(currentValue);
                self._toggleEditMode(true);
                self.showInlineError(errorMessage);
              });
        }
      } else {
        this.clearInlineError();
        this._toggleEditMode(false);
      }
    },

    _blockActions: function () {
      var origView = this.options.originatingView;
      origView && origView.blockActions && origView.blockActions();
    },

    _unblockActions: function () {
      var origView = this.options.originatingView;
      origView && origView.unblockActions && origView.unblockActions();
    },

    // call proxies
    onKeyInView: function (event) {
      return this.ItemNameBehavior.onKeyInView(event);
    },

    _toggleEditMode: function (edit) {
      this.ItemNameBehavior._toggleEditMode(edit);
    },

    onClickName: function (event) {
      return this.ItemNameBehavior.onClickName(event);
    },

    getValue: function () {
      return this.ItemNameBehavior.getValue();
    },

    setValue: function (value) {
      return this.ItemNameBehavior.setValue(value);
    },

    getInputBoxValue: function () {
      return this.ItemNameBehavior.getInputBoxValue();
    },

    setInputBoxValue: function (value) {
      return this.ItemNameBehavior.setInputBoxValue(value);
    },

    validate: function (iName) {
      return this.ItemNameBehavior.validate(iName);
    },

    setEditModeFocus: function () {
      return this.ItemNameBehavior.setEditModeFocus();
    },

    showInlineError: function (error) {
      return this.ItemNameBehavior.showInlineError(error);
    },

    clearInlineError: function () {
      return this.ItemNameBehavior.clearInlineError();
    },

    _getErrorMessageFromResponse: function (err) {
      return this.ItemNameBehavior._getErrorMessageFromResponse(err);
    }
    // end of: proxies

  });

  _.extend(ItemTitleNameView.prototype, ViewEventsPropagationMixin);

  return ItemTitleNameView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/item.title/impl/dropdown.menu/dropdown.menu',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"binf-dropdown\">\r\n    <button id=\""
    + this.escapeExpression(((helper = (helper = helpers.btnId || (depth0 != null ? depth0.btnId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"btnId","hash":{}}) : helper)))
    + "\" type=\"button\" class=\"binf-btn binf-dropdown-toggle csui-acc-focusable\"\r\n            data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\r\n            aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.showMoreAria || (depth0 != null ? depth0.showMoreAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showMoreAria","hash":{}}) : helper)))
    + "\">\r\n      <span class=\"csui-button-icon icon-expandArrowDown\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.showMoreTooltip || (depth0 != null ? depth0.showMoreTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showMoreTooltip","hash":{}}) : helper)))
    + "\">\r\n      </span>\r\n    </button>\r\n    <ul class=\"binf-dropdown-menu\" role=\"menu\"></ul>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.hasCommands : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_item.title_impl_dropdown.menu_dropdown.menu', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/item.title/impl/dropdown.menu/dropdown.menu',[],function(){});
csui.define('csui/controls/item.title/impl/dropdown.menu/dropdown.menu.view',["module",
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/toolbar/toolitem.model',
  'csui/controls/toolbar/toolitem.view',
  'csui/models/nodes',
  'csui/controls/toolbar/toolitems.filtered.model',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/behaviors/dropdown.menu/dropdown.menu.behavior',
  'csui/utils/commands',
  'hbs!csui/controls/item.title/impl/dropdown.menu/dropdown.menu',
  'i18n!csui/controls/item.title/impl/nls/localized.strings',
  'css!csui/controls/item.title/impl/dropdown.menu/dropdown.menu'

], function (module, $, _, Backbone, Marionette,
    ToolItemModel,
    ToolItemView,
    NodeCollection,
    FilteredToolItemsCollection,
    TabableRegionBehavior,
    DropdownMenuBehavior,
    commands,
    template, lang) {
  'use strict';

  var DropdownMenuView = Marionette.CompositeView.extend({

    className: "csui-item-title-dropdown-menu",

    template: template,
    templateHelpers: function () {
      return {
        hasCommands: !!this.collection.length,
        btnId: _.uniqueId('dropdownMenuButton'),
        showMoreTooltip: lang.showMore,
        showMoreAria: lang.showMoreAria
      };
    },

    childView: ToolItemView,
    childViewContainer: "ul.binf-dropdown-menu",
    childViewOptions: function (model) {
      return {
        role: 'menuitem'
      };
    },

    ui: {
      dropdownToggle: '.binf-dropdown-toggle'
    },

    behaviors: {
      TabableRegionBehavior: {
        behaviorClass: TabableRegionBehavior
      },
      DropdownMenuBehavior: {
        behaviorClass: DropdownMenuBehavior
      }
    },

    constructor: function DropdownMenuView(options) {
      options.collection = new FilteredToolItemsCollection(
          options.toolItems, {
            status: this._createCommandStatus(options),
            commands: this.commands,
            mask: options.toolItemsMask
          });

      options.reorderOnSort = true;
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      _.defaults(this.options, options.toolItems.options);  // set options from ToolItemFactory

      this.commands = options.commands || commands;

      // Passing the el to the ctor prevents creating an own el, including
      // setting its attributes.  The caller must ensure the right tag.
      if (options.el) {
        $(options.el).addClass(_.result(this, "className"));
      }

      this.listenTo(this, "childview:toolitem:action", this._triggerMenuItemAction)
          .listenTo(this.model, "sync", this.render)
          .listenTo(this, 'close:menu', this._closeToggle)
          .listenTo(Backbone, 'closeToggleAction', this._closeToggle)
          .listenTo(this.model, "change", this.render);
    },

    _createCommandStatus: function (options) {
      return {
        nodes: new NodeCollection([options.model]),
        container: options.model,
        context: options.context
      };
    },

    _updateCollectionStatus: function () {
      var status = this._createCommandStatus(this.options);
      this.options.collection.setStatus(status);
    },

    onBeforeRender: function () {
      this._updateCollectionStatus();
    },

    onRender: function () {
      this.ui.dropdownToggle.binf_dropdown();
      this.delegateEvents();
    },

    currentlyFocusedElement: function () {
      return $(this.ui.dropdownToggle);
    },

    _closeToggle: function () {
      if (this.ui.dropdownToggle.parent().hasClass('binf-open')) {
        this.ui.dropdownToggle.binf_dropdown('toggle');
      }
      this.ui.dropdownToggle.attr('aria-expanded', 'false');
    },

    _triggerMenuItemAction: function (toolItemView, args) {
      this.ui.dropdownToggle.binf_dropdown('toggle');  // close the dropdown menu before triggering the event

      var signature = args.toolItem.get("signature");
      var command = this.commands.findWhere({signature: signature});

      if (signature === 'Rename') {
        // IE is picky with Enter keypress triggered by Bootstrap not it was not stopped fast enough
        setTimeout(_.bind(function () {
          this.trigger('rename', this);
        }, this), 200);
      } else {
        var status = {
          context: this.options.context,
          nodes: new NodeCollection([this.model]),
          container: this.model,
          originatingView: this.options.originatingView
        };
        if (command && command.enabled(status)) {
          command.execute(status);
        }
      }
    }
  });

  return DropdownMenuView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/item.title/impl/item.title',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-item-title-icon\"></div>\r\n<div class=\"csui-item-title-name\"></div>\r\n<div class=\"csui-item-title-menu\" role=\"menuitem\"></div>\r\n";
}});
Handlebars.registerPartial('csui_controls_item.title_impl_item.title', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/item.title/impl/item.title',[],function(){});
csui.define('csui/controls/item.title/item.title.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/log',
  // 'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/controls/item.title/impl/name/name.view',
  'csui/controls/item.title/impl/dropdown.menu/dropdown.menu.view',
  'hbs!csui/controls/item.title/impl/item.title',
  'css!csui/controls/item.title/impl/item.title'
], function ($, _, Backbone, Marionette, log,
    // ViewEventsPropagationMixin,
    NodeTypeIconView,
    ItemTitleNameView,
    DropdownMenuView,
    template) {
  'use strict';

  var ItemTitleView = Marionette.LayoutView.extend({
    className: 'csui-item-title',
    template: template,

    ui: {
      icon: '.csui-item-title-icon',
      name: '.csui-item-title-name',
      menu: '.csui-item-title-menu'
    },

    regions: {
      iconRegion: '@ui.icon',
      nameRegion: '@ui.name',
      menuRegion: '@ui.menu'
    },

    constructor: function ItemTitleView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
    },

    initialize: function () {
      this.iconView = new NodeTypeIconView({
        node: this.options.model
      });

      this.nameView = new ItemTitleNameView({
        context: this.options.context,
        model: this.options.model,
        originatingView: this.options.originatingView
      });

      this.menuView = new DropdownMenuView({
        context: this.options.context,
        model: this.options.model,
        originatingView: this.options.originatingView,
        toolItems: this.options.toolItems,
        toolItemsMask: this.options.toolItemsMask,
        commands: this.options.commands
      });

      this.listenTo(this.menuView, 'rename', function () {
        this.nameView._toggleEditMode.call(this.nameView, true);
      });
      this.listenTo(this.nameView, 'changed:editmode', function (modeIsEditing) {
        if (modeIsEditing) {
          this.ui.menu.addClass('binf-hidden');
        } else {
          this.ui.menu.removeClass('binf-hidden');
        }
      });
    },

    onRender: function () {
      this.iconRegion.show(this.iconView);
      this.nameRegion.show(this.nameView);
      this.menuRegion.show(this.menuView);
    },

    onShow: function () {
      _.each(this.regionManager._regions, function (region) {
        if (region.currentView) {
          region.currentView.triggerMethod('show');
        }
      });
    },

    onAfterShow: function () {
      _.each(this.regionManager._regions, function (region) {
        if (region.currentView) {
          region.currentView.triggerMethod('after:show');
        }
      });
    },

    closeMenu: function () {
      this.menuView && this.menuView.trigger('close:menu');
    }

  });
  // _.extend(ItemTitleView.prototype, ViewEventsPropagationMixin);

  return ItemTitleView;
});

csui.define('csui/controls/table/table.columns',["csui/lib/backbone"], function (Backbone) {

  var TableColumnModel = Backbone.Model.extend({

    idAttribute: "key",

    defaults: {
      key: null,  // key from the resource definitions
      sequence: 0 // smaller number moves the column to the front
    }

  });

  var TableColumnCollection = Backbone.Collection.extend({

    model: TableColumnModel,
    comparator: "sequence",

    getColumnKeys: function () {
      return this.pluck('key');
    },

    deepClone: function () {
      return new TableColumnCollection(
          this.map(function (column) {
            return column.attributes;
          }));
    }

  });

  // columns delivered from server get sequence set to 500

  var tableColumns = new TableColumnCollection([
    {
      key: 'type',
      sequence: 2,
      permanentColumn: true // don't wrap column due to responsiveness into details row
    },
    {
      key: 'name',
      sequence: 3,
      permanentColumn: true, // don't wrap column due to responsiveness into details row
      isNaming: true  // use this column as a starting point for the inline forms
    },
    {
      key: 'reserved',
      sequence: 4,
      title: 'State', // "reserved"" is just to bind the column to some property
      noTitleInHeader: true // don't display a column header
    },
    {
      key: 'wnd_comments',
      sequence: 900,
      noTitleInHeader: true,
      permanentColumn: true // don't wrap column due to responsiveness into details row
    },
    {
      key: 'favorite',
      sequence: 910,
      noTitleInHeader: true,
      permanentColumn: true // don't wrap column due to responsivenes into details row
    }
  ]);

  return tableColumns;

});

/*! DataTables 1.10.4
 * 2008-2014 SpryMedia Ltd - datatables.net/license
 */
csui.define('csui/lib/jquery.dataTables/js/jquery.dataTables',['csui/lib/jquery'], function(jQuery) {

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.4
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2008-2014 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(/** @lends <global> */function( window, document, undefined ) {

(function( factory ) {
	"use strict";

	/*
	if ( typeof csui.define === 'function' && csui.define.amd ) {
		// Define as an AMD module if possible
		define( 'datatables', ['jquery'], factory );
	}
    else if ( typeof exports === 'object' ) {
        // Node/CommonJS
        factory( require( 'jquery' ) );
    }
	else */
	if ( jQuery && !jQuery.fn.dataTable ) {
		// Define using browser globals otherwise
		// Prevent multiple instantiations if the script is loaded twice
		factory( jQuery );
	}
}
(/** @lends <global> */function( $ ) {
	"use strict";

	/**
	 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	 * flexible tool, based upon the foundations of progressive enhancement,
	 * which will add advanced interaction controls to any HTML table. For a
	 * full list of features please refer to
	 * [DataTables.net](href="http://datatables.net).
	 *
	 * Note that the `DataTable` object is not a global variable but is aliased
	 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
	 * be  accessed.
	 *
	 *  @class
	 *  @param {object} [init={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.7+
	 *
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
	 *
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "paginate": false,
	 *        "sort": false
	 *      } );
	 *    } );
	 */
	var DataTable;

	
	/*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don't leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
	
	
	// Defined else where
	//  _selector_run
	//  _selector_opts
	//  _selector_first
	//  _selector_row_indexes
	
	var _ext; // DataTable.ext
	var _Api; // DataTable.Api
	var _api_register; // DataTable.Api.register
	var _api_registerPlural; // DataTable.Api.registerPlural
	
	var _re_dic = {};
	var _re_new_lines = /[\r\n]/g;
	var _re_html = /<.*?>/g;
	var _re_date_start = /^[\w\+\-]/;
	var _re_date_end = /[\w\+\-]$/;
	
	// Escape regular expression special characters
	var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
	
	// U+2009 is thin space and U+202F is narrow no-break space, both used in many
	// standards as thousands separators
	var _re_formatted_numeric = /[',$%\u2009\u202F]/g;
	
	
	var _empty = function ( d ) {
		return !d || d === true || d === '-' ? true : false;
	};
	
	
	var _intVal = function ( s ) {
		var integer = parseInt( s, 10 );
		return !isNaN(integer) && isFinite(s) ? integer : null;
	};
	
	// Convert from a formatted number with characters other than `.` as the
	// decimal place, to a Javascript number
	var _numToDecimal = function ( num, decimalPoint ) {
		// Cache created regular expressions for speed as this function is called often
		if ( ! _re_dic[ decimalPoint ] ) {
			_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
		}
		return typeof num === 'string' && decimalPoint !== '.' ?
			num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
			num;
	};
	
	
	var _isNumber = function ( d, decimalPoint, formatted ) {
		var strType = typeof d === 'string';
	
		if ( decimalPoint && strType ) {
			d = _numToDecimal( d, decimalPoint );
		}
	
		if ( formatted && strType ) {
			d = d.replace( _re_formatted_numeric, '' );
		}
	
		return _empty( d ) || (!isNaN( parseFloat(d) ) && isFinite( d ));
	};
	
	
	// A string without HTML in it can be considered to be HTML still
	var _isHtml = function ( d ) {
		return _empty( d ) || typeof d === 'string';
	};
	
	
	var _htmlNumeric = function ( d, decimalPoint, formatted ) {
		if ( _empty( d ) ) {
			return true;
		}
	
		var html = _isHtml( d );
		return ! html ?
			null :
			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
				true :
				null;
	};
	
	
	var _pluck = function ( a, prop, prop2 ) {
		var out = [];
		var i=0, ien=a.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[i] && a[i][ prop ] ) {
					out.push( a[i][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				if ( a[i] ) {
					out.push( a[i][ prop ] );
				}
			}
		}
	
		return out;
	};
	
	
	// Basically the same as _pluck, but rather than looping over `a` we use `order`
	// as the indexes to pick from `a`
	var _pluck_order = function ( a, order, prop, prop2 )
	{
		var out = [];
		var i=0, ien=order.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[ order[i] ][ prop ] ) {
					out.push( a[ order[i] ][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	
		return out;
	};
	
	
	var _range = function ( len, start )
	{
		var out = [];
		var end;
	
		if ( start === undefined ) {
			start = 0;
			end = len;
		}
		else {
			end = start;
			start = len;
		}
	
		for ( var i=start ; i<end ; i++ ) {
			out.push( i );
		}
	
		return out;
	};
	
	
	var _removeEmpty = function ( a )
	{
		var out = [];
	
		for ( var i=0, ien=a.length ; i<ien ; i++ ) {
			if ( a[i] ) { // careful - will remove all falsy values!
				out.push( a[i] );
			}
		}
	
		return out;
	};
	
	
	var _stripHtml = function ( d ) {
		return d.replace( _re_html, '' );
	};
	
	
	/**
	 * Find the unique elements in a source array.
	 *
	 * @param  {array} src Source array
	 * @return {array} Array of unique items
	 * @ignore
	 */
	var _unique = function ( src )
	{
		// A faster unique method is to use object keys to identify used values,
		// but this doesn't work with arrays or objects, which we must also
		// consider. See jsperf.com/compare-array-unique-versions/4 for more
		// information.
		var
			out = [],
			val,
			i, ien=src.length,
			j, k=0;
	
		again: for ( i=0 ; i<ien ; i++ ) {
			val = src[i];
	
			for ( j=0 ; j<k ; j++ ) {
				if ( out[j] === val ) {
					continue again;
				}
			}
	
			out.push( val );
			k++;
		}
	
		return out;
	};
	
	
	
	/**
	 * Create a mapping object that allows camel case parameters to be looked up
	 * for their Hungarian counterparts. The mapping is stored in a private
	 * parameter called `_hungarianMap` which can be accessed on the source object.
	 *  @param {object} o
	 *  @memberof DataTable#oApi
	 */
	function _fnHungarianMap ( o )
	{
		var
			hungarian = 'a aa ai ao as b fn i m o s ',
			match,
			newKey,
			map = {};
	
		$.each( o, function (key, val) {
			match = key.match(/^([^A-Z]+?)([A-Z])/);
	
			if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
			{
				newKey = key.replace( match[0], match[2].toLowerCase() );
				map[ newKey ] = key;
	
				if ( match[1] === 'o' )
				{
					_fnHungarianMap( o[key] );
				}
			}
		} );
	
		o._hungarianMap = map;
	}
	
	
	/**
	 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	 * created by _fnHungarianMap.
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 *  @memberof DataTable#oApi
	 */
	function _fnCamelToHungarian ( src, user, force )
	{
		if ( ! src._hungarianMap ) {
			_fnHungarianMap( src );
		}
	
		var hungarianKey;
	
		$.each( user, function (key, val) {
			hungarianKey = src._hungarianMap[ key ];
	
			if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
			{
				// For objects, we need to buzz down into the object to copy parameters
				if ( hungarianKey.charAt(0) === 'o' )
				{
					// Copy the camelCase options over to the hungarian
					if ( ! user[ hungarianKey ] ) {
						user[ hungarianKey ] = {};
					}
					$.extend( true, user[hungarianKey], user[key] );
	
					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
				}
				else {
					user[hungarianKey] = user[ key ];
				}
			}
		} );
	}
	
	
	/**
	 * Language compatibility - when certain options are given, and others aren't, we
	 * need to duplicate the values over, in order to provide backwards compatibility
	 * with older language files.
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnLanguageCompat( lang )
	{
		var defaults = DataTable.defaults.oLanguage;
		var zeroRecords = lang.sZeroRecords;
	
		/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
		 * sZeroRecords - assuming that is given.
		 */
		if ( ! lang.sEmptyTable && zeroRecords &&
			defaults.sEmptyTable === "No data available in table" )
		{
			_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
		}
	
		/* Likewise with loading records */
		if ( ! lang.sLoadingRecords && zeroRecords &&
			defaults.sLoadingRecords === "Loading..." )
		{
			_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
		}
	
		// Old parameter name of the thousands separator mapped onto the new
		if ( lang.sInfoThousands ) {
			lang.sThousands = lang.sInfoThousands;
		}
	
		var decimal = lang.sDecimal;
		if ( decimal ) {
			_addNumericSort( decimal );
		}
	}
	
	
	/**
	 * Map one parameter onto another
	 *  @param {object} o Object to map
	 *  @param {*} knew The new parameter name
	 *  @param {*} old The old parameter name
	 */
	var _fnCompatMap = function ( o, knew, old ) {
		if ( o[ knew ] !== undefined ) {
			o[ old ] = o[ knew ];
		}
	};
	
	
	/**
	 * Provide backwards compatibility for the main DT options. Note that the new
	 * options are mapped onto the old parameters, so this is an external interface
	 * change only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatOpts ( init )
	{
		_fnCompatMap( init, 'ordering',      'bSort' );
		_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
		_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
		_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
		_fnCompatMap( init, 'order',         'aaSorting' );
		_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
		_fnCompatMap( init, 'paging',        'bPaginate' );
		_fnCompatMap( init, 'pagingType',    'sPaginationType' );
		_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
		_fnCompatMap( init, 'searching',     'bFilter' );
	
		// Column search objects are in an array, so it needs to be converted
		// element by element
		var searchCols = init.aoSearchCols;
	
		if ( searchCols ) {
			for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
				if ( searchCols[i] ) {
					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
				}
			}
		}
	}
	
	
	/**
	 * Provide backwards compatibility for column options. Note that the new options
	 * are mapped onto the old parameters, so this is an external interface change
	 * only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatCols ( init )
	{
		_fnCompatMap( init, 'orderable',     'bSortable' );
		_fnCompatMap( init, 'orderData',     'aDataSort' );
		_fnCompatMap( init, 'orderSequence', 'asSorting' );
		_fnCompatMap( init, 'orderDataType', 'sortDataType' );
	}
	
	
	/**
	 * Browser feature detection for capabilities, quirks
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBrowserDetect( settings )
	{
		var browser = settings.oBrowser;
	
		// Scrolling feature / quirks detection
		var n = $('<div/>')
			.css( {
				position: 'absolute',
				top: 0,
				left: 0,
				height: 1,
				width: 1,
				overflow: 'hidden'
			} )
			.append(
				$('<div/>')
					.css( {
						position: 'absolute',
						top: 1,
						left: 1,
						width: 100,
						overflow: 'scroll'
					} )
					.append(
						$('<div class="test"/>')
							.css( {
								width: '100%',
								height: 10
							} )
					)
			)
			.appendTo( 'body' );
	
		var test = n.find('.test');
	
		// IE6/7 will oversize a width 100% element inside a scrolling element, to
		// include the width of the scrollbar, while other browsers ensure the inner
		// element is contained without forcing scrolling
		browser.bScrollOversize = test[0].offsetWidth === 100;
	
		// In rtl text layout, some browsers (most, but not all) will place the
		// scrollbar on the left, rather than the right.
		browser.bScrollbarLeft = test.offset().left !== 1;
	
		n.remove();
	}
	
	
	/**
	 * Array.prototype reduce[Right] method, used for browsers which don't support
	 * JS 1.6. Done this way to reduce code size, since we iterate either way
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnReduce ( that, fn, init, start, end, inc )
	{
		var
			i = start,
			value,
			isSet = false;
	
		if ( init !== undefined ) {
			value = init;
			isSet = true;
		}
	
		while ( i !== end ) {
			if ( ! that.hasOwnProperty(i) ) {
				continue;
			}
	
			value = isSet ?
				fn( value, that[i], i, that ) :
				that[i];
	
			isSet = true;
			i += inc;
		}
	
		return value;
	}
	
	/**
	 * Add a column to the list used for the table with default values
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nTh The th element for this column
	 *  @memberof DataTable#oApi
	 */
	function _fnAddColumn( oSettings, nTh )
	{
		// Add column to aoColumns array
		var oDefaults = DataTable.defaults.column;
		var iCol = oSettings.aoColumns.length;
		var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
			"nTh": nTh ? nTh : document.createElement('th'),
			"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
			"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			"mData": oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		} );
		oSettings.aoColumns.push( oCol );
	
		// Add search object for column specific search. Note that the `searchCols[ iCol ]`
		// passed into extend can be undefined. This allows the user to give a default
		// with only some of the parameters defined, and also not give a default
		var searchCols = oSettings.aoPreSearchCols;
		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
	
		// Use the default column options function to initialise classes etc
		_fnColumnOptions( oSettings, iCol, null );
	}
	
	
	/**
	 * Apply options for a column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iCol column index to consider
	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnOptions( oSettings, iCol, oOptions )
	{
		var oCol = oSettings.aoColumns[ iCol ];
		var oClasses = oSettings.oClasses;
		var th = $(oCol.nTh);
	
		// Try to get width information from the DOM. We can't get it from CSS
		// as we'd need to parse the CSS stylesheet. `width` option can override
		if ( ! oCol.sWidthOrig ) {
			// Width attribute
			oCol.sWidthOrig = th.attr('width') || null;
	
			// Style attribute
			var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
			if ( t ) {
				oCol.sWidthOrig = t[1];
			}
		}
	
		/* User specified column options */
		if ( oOptions !== undefined && oOptions !== null )
		{
			// Backwards compatibility
			_fnCompatCols( oOptions );
	
			// Map camel case parameters to their Hungarian counterparts
			_fnCamelToHungarian( DataTable.defaults.column, oOptions );
	
			/* Backwards compatibility for mDataProp */
			if ( oOptions.mDataProp !== undefined && !oOptions.mData )
			{
				oOptions.mData = oOptions.mDataProp;
			}
	
			if ( oOptions.sType )
			{
				oCol._sManualType = oOptions.sType;
			}
	
			// `class` is a reserved word in Javascript, so we need to provide
			// the ability to use a valid name for the camel case input
			if ( oOptions.className && ! oOptions.sClass )
			{
				oOptions.sClass = oOptions.className;
			}
	
			$.extend( oCol, oOptions );
			_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
	
			/* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
			if ( typeof oOptions.iDataSort === 'number' )
			{
				oCol.aDataSort = [ oOptions.iDataSort ];
			}
			_fnMap( oCol, oOptions, "aDataSort" );
		}
	
		/* Cache the data get and set functions for speed */
		var mDataSrc = oCol.mData;
		var mData = _fnGetObjectDataFn( mDataSrc );
		var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
	
		var attrTest = function( src ) {
			return typeof src === 'string' && src.indexOf('@') !== -1;
		};
		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
		);
	
		oCol.fnGetData = function (rowData, type, meta) {
			var innerData = mData( rowData, type, undefined, meta );
	
			return mRender && type ?
				mRender( innerData, type, rowData, meta ) :
				innerData;
		};
		oCol.fnSetData = function ( rowData, val, meta ) {
			return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
		};
	
		// Indicate if DataTables should read DOM data as an object or array
		// Used in _fnGetRowElements
		if ( typeof mDataSrc !== 'number' ) {
			oSettings._rowReadObject = true;
		}
	
		/* Feature sorting overrides column specific when off */
		if ( !oSettings.oFeatures.bSort )
		{
			oCol.bSortable = false;
			th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
		}
	
		/* Check that the class assignment is correct for sorting */
		var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
		var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
		if ( !oCol.bSortable || (!bAsc && !bDesc) )
		{
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = "";
		}
		else if ( bAsc && !bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		}
		else if ( !bAsc && bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		}
		else
		{
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}
	
	
	/**
	 * Adjust the table column widths for new data. Note: you would probably want to
	 * do a redraw after calling this function!
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAdjustColumnSizing ( settings )
	{
		/* Not interested in doing column width calculation if auto-width is disabled */
		if ( settings.oFeatures.bAutoWidth !== false )
		{
			var columns = settings.aoColumns;
	
			_fnCalculateColumnWidths( settings );
			for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}
	
		var scroll = settings.oScroll;
		if ( scroll.sY !== '' || scroll.sX !== '')
		{
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, null, 'column-sizing', [settings] );
	}
	
	
	/**
	 * Covert the index of a visible column to the index in the data array (take account
	 * of hidden columns)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iMatch Visible column index to lookup
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnVisibleToColumnIndex( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	
		return typeof aiVis[iMatch] === 'number' ?
			aiVis[iMatch] :
			null;
	}
	
	
	/**
	 * Covert the index of an index in the data array and convert it to the visible
	 *   column index (take account of hidden columns)
	 *  @param {int} iMatch Column index to lookup
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnIndexToVisible( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		var iPos = $.inArray( iMatch, aiVis );
	
		return iPos !== -1 ? iPos : null;
	}
	
	
	/**
	 * Get the number of visible columns
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the number of visible columns
	 *  @memberof DataTable#oApi
	 */
	function _fnVisbleColumns( oSettings )
	{
		return _fnGetColumns( oSettings, 'bVisible' ).length;
	}
	
	
	/**
	 * Get an array of column indexes that match a given property
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sParam Parameter in aoColumns to look for - typically
	 *    bVisible or bSearchable
	 *  @returns {array} Array of indexes with matched properties
	 *  @memberof DataTable#oApi
	 */
	function _fnGetColumns( oSettings, sParam )
	{
		var a = [];
	
		$.map( oSettings.aoColumns, function(val, i) {
			if ( val[sParam] ) {
				a.push( i );
			}
		} );
	
		return a;
	}
	
	
	/**
	 * Calculate the 'type' of a column
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnTypes ( settings )
	{
		var columns = settings.aoColumns;
		var data = settings.aoData;
		var types = DataTable.ext.type.detect;
		var i, ien, j, jen, k, ken;
		var col, cell, detectedType, cache;
	
		// For each column, spin over the 
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			col = columns[i];
			cache = [];
	
			if ( ! col.sType && col._sManualType ) {
				col.sType = col._sManualType;
			}
			else if ( ! col.sType ) {
				for ( j=0, jen=types.length ; j<jen ; j++ ) {
					for ( k=0, ken=data.length ; k<ken ; k++ ) {
						// Use a cache array so we only need to get the type data
						// from the formatter once (when using multiple detectors)
						if ( cache[k] === undefined ) {
							cache[k] = _fnGetCellData( settings, k, i, 'type' );
						}
	
						detectedType = types[j]( cache[k], settings );
	
						// If null, then this type can't apply to this column, so
						// rather than testing all cells, break out. There is an
						// exception for the last type which is `html`. We need to
						// scan all rows since it is possible to mix string and HTML
						// types
						if ( ! detectedType && j !== types.length-1 ) {
							break;
						}
	
						// Only a single match is needed for html type since it is
						// bottom of the pile and very similar to string
						if ( detectedType === 'html' ) {
							break;
						}
					}
	
					// Type is valid for all data points in the column - use this
					// type
					if ( detectedType ) {
						col.sType = detectedType;
						break;
					}
				}
	
				// Fall back - if no type was detected, always use string
				if ( ! col.sType ) {
					col.sType = 'string';
				}
			}
		}
	}
	
	
	/**
	 * Take the column definitions and static columns arrays and calculate how
	 * they relate to column indexes. The callback function will then apply the
	 * definition found for a column to a suitable configuration object.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	 *  @param {array} aoCols The aoColumns array that defines columns individually
	 *  @param {function} fn Callback function - takes two parameters, the calculated
	 *    column index and the definition for that column.
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
	{
		var i, iLen, j, jLen, k, kLen, def;
		var columns = oSettings.aoColumns;
	
		// Column definitions with aTargets
		if ( aoColDefs )
		{
			/* Loop over the definitions array - loop in reverse so first instance has priority */
			for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
			{
				def = aoColDefs[i];
	
				/* Each definition can target multiple columns, as it is an array */
				var aTargets = def.targets !== undefined ?
					def.targets :
					def.aTargets;
	
				if ( ! $.isArray( aTargets ) )
				{
					aTargets = [ aTargets ];
				}
	
				for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
				{
					if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
					{
						/* Add columns that we don't yet know about */
						while( columns.length <= aTargets[j] )
						{
							_fnAddColumn( oSettings );
						}
	
						/* Integer, basic index */
						fn( aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
					{
						/* Negative integer, right to left column counting */
						fn( columns.length+aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'string' )
					{
						/* Class name matching on TH element */
						for ( k=0, kLen=columns.length ; k<kLen ; k++ )
						{
							if ( aTargets[j] == "_all" ||
							     $(columns[k].nTh).hasClass( aTargets[j] ) )
							{
								fn( k, def );
							}
						}
					}
				}
			}
		}
	
		// Statically defined columns array
		if ( aoCols )
		{
			for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
			{
				fn( i, aoCols[i] );
			}
		}
	}
	
	/**
	 * Add a data array to the table, creating DOM node etc. This is the parallel to
	 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	 * DOM source.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aData data array to be added
	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	 *  @memberof DataTable#oApi
	 */
	function _fnAddData ( oSettings, aDataIn, nTr, anTds )
	{
		/* Create the object for storing information about this new row */
		var iRow = oSettings.aoData.length;
		var oData = $.extend( true, {}, DataTable.models.oRow, {
			src: nTr ? 'dom' : 'data'
		} );
	
		oData._aData = aDataIn;
		oSettings.aoData.push( oData );
	
		/* Create the cells */
		var nTd, sThisType;
		var columns = oSettings.aoColumns;
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			// When working with a row, the data source object must be populated. In
			// all other cases, the data source object is already populated, so we
			// don't overwrite it, which might break bindings etc
			if ( nTr ) {
				_fnSetCellData( oSettings, iRow, i, _fnGetCellData( oSettings, iRow, i ) );
			}
			columns[i].sType = null;
		}
	
		/* Add to the display array */
		oSettings.aiDisplayMaster.push( iRow );
	
		/* Create the DOM information, or register it if already present */
		if ( nTr || ! oSettings.oFeatures.bDeferRender )
		{
			_fnCreateTr( oSettings, iRow, nTr, anTds );
		}
	
		return iRow;
	}
	
	
	/**
	 * Add one or more TR elements to the table. Generally we'd expect to
	 * use this for reading data from a DOM sourced table, but it could be
	 * used for an TR element. Note that if a TR is given, it is used (i.e.
	 * it is not cloned).
	 *  @param {object} settings dataTables settings object
	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	 *  @returns {array} Array of indexes for the added rows
	 *  @memberof DataTable#oApi
	 */
	function _fnAddTr( settings, trs )
	{
		var row;
	
		// Allow an individual node to be passed in
		if ( ! (trs instanceof $) ) {
			trs = $(trs);
		}
	
		return trs.map( function (i, el) {
			row = _fnGetRowElements( settings, el );
			return _fnAddData( settings, row.data, el, row.cells );
		} );
	}
	
	
	/**
	 * Take a TR element and convert it to an index in aoData
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n the TR element to find
	 *  @returns {int} index if the node is found, null if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToDataIndex( oSettings, n )
	{
		return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
	}
	
	
	/**
	 * Take a TD element and convert it into a column data index (not the visible index)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow The row number the TD/TH can be found in
	 *  @param {node} n The TD/TH element to find
	 *  @returns {int} index if the node is found, -1 if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToColumnIndex( oSettings, iRow, n )
	{
		return $.inArray( n, oSettings.aoData[ iRow ].anCells );
	}
	
	
	/**
	 * Get the data for a given cell from the internal cache, taking into account data mapping
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
	 *  @returns {*} Cell data
	 *  @memberof DataTable#oApi
	 */
	function _fnGetCellData( settings, rowIdx, colIdx, type )
	{
		var draw           = settings.iDraw;
		var col            = settings.aoColumns[colIdx];
		var rowData        = settings.aoData[rowIdx]._aData;
		var defaultContent = col.sDefaultContent;
		var cellData       = col.fnGetData( rowData, type, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		} );
	
		if ( cellData === undefined ) {
			if ( settings.iDrawError != draw && defaultContent === null ) {
				_fnLog( settings, 0, "Requested unknown parameter "+
					(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
					" for row "+rowIdx, 4 );
				settings.iDrawError = draw;
			}
			return defaultContent;
		}
	
		/* When the data source is null, we can use default column data */
		if ( (cellData === rowData || cellData === null) && defaultContent !== null ) {
			cellData = defaultContent;
		}
		else if ( typeof cellData === 'function' ) {
			// If the data source is a function, then we run it and use the return,
			// executing in the scope of the data object (for instances)
			return cellData.call( rowData );
		}
	
		if ( cellData === null && type == 'display' ) {
			return '';
		}
		return cellData;
	}
	
	
	/**
	 * Set the value for a specific cell, into the internal data cache
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {*} val Value to set
	 *  @memberof DataTable#oApi
	 */
	function _fnSetCellData( settings, rowIdx, colIdx, val )
	{
		var col     = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;
	
		col.fnSetData( rowData, val, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		}  );
	}
	
	
	// Private variable that is used to match action syntax in the data property object
	var __reArray = /\[.*?\]$/;
	var __reFn = /\(\)$/;
	
	/**
	 * Split string on periods, taking into account escaped periods
	 * @param  {string} str String to split
	 * @return {array} Split string
	 */
	function _fnSplitObjNotation( str )
	{
		return $.map( str.match(/(\\.|[^\.])+/g), function ( s ) {
			return s.replace(/\\./g, '.');
		} );
	}
	
	
	/**
	 * Return a function that can be used to get data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data get function
	 *  @memberof DataTable#oApi
	 */
	function _fnGetObjectDataFn( mSource )
	{
		if ( $.isPlainObject( mSource ) )
		{
			/* Build an object of get functions, and wrap them in a single call */
			var o = {};
			$.each( mSource, function (key, val) {
				if ( val ) {
					o[key] = _fnGetObjectDataFn( val );
				}
			} );
	
			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ?
					t(data, type, row, meta) :
					data;
			};
		}
		else if ( mSource === null )
		{
			/* Give an empty string for rendering / sorting etc */
			return function (data) { // type, row and meta also passed, but not used
				return data;
			};
		}
		else if ( typeof mSource === 'function' )
		{
			return function (data, type, row, meta) {
				return mSource( data, type, row, meta );
			};
		}
		else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
			      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
		{
			/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
			var fetchData = function (data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;
	
				if ( src !== "" )
				{
					var a = _fnSplitObjNotation( src );
	
					for ( var i=0, iLen=a.length ; i<iLen ; i++ )
					{
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						if ( arrayNotation )
						{
							// Array notation
							a[i] = a[i].replace(__reArray, '');
	
							// Condition allows simply [] to be passed in
							if ( a[i] !== "" ) {
								data = data[ a[i] ];
							}
							out = [];
	
							// Get the remainder of the nested object to get
							a.splice( 0, i+1 );
							innerSrc = a.join('.');
	
							// Traverse each entry in the array getting the properties requested
							for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
								out.push( fetchData( data[j], type, innerSrc ) );
							}
	
							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
							data = (join==="") ? out : out.join(join);
	
							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						}
						else if ( funcNotation )
						{
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]();
							continue;
						}
	
						if ( data === null || data[ a[i] ] === undefined )
						{
							return undefined;
						}
						data = data[ a[i] ];
					}
				}
	
				return data;
			};
	
			return function (data, type) { // row and meta also passed, but not used
				return fetchData( data, type, mSource );
			};
		}
		else
		{
			/* Array or flat object mapping */
			return function (data, type) { // row and meta also passed, but not used
				return data[mSource];
			};
		}
	}
	
	
	/**
	 * Return a function that can be used to set data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data set function
	 *  @memberof DataTable#oApi
	 */
	function _fnSetObjectDataFn( mSource )
	{
		if ( $.isPlainObject( mSource ) )
		{
			/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
			return _fnSetObjectDataFn( mSource._ );
		}
		else if ( mSource === null )
		{
			/* Nothing to do when the data source is null */
			return function () {};
		}
		else if ( typeof mSource === 'function' )
		{
			return function (data, val, meta) {
				mSource( data, 'set', val, meta );
			};
		}
		else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
			      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
		{
			/* Like the get, we need to get data from a nested object */
			var setData = function (data, val, src) {
				var a = _fnSplitObjNotation( src ), b;
				var aLast = a[a.length-1];
				var arrayNotation, funcNotation, o, innerSrc;
	
				for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
				{
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					if ( arrayNotation )
					{
						a[i] = a[i].replace(__reArray, '');
						data[ a[i] ] = [];
	
						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice( 0, i+1 );
						innerSrc = b.join('.');
	
						// Traverse each entry in the array setting the properties requested
						for ( var j=0, jLen=val.length ; j<jLen ; j++ )
						{
							o = {};
							setData( o, val[j], innerSrc );
							data[ a[i] ].push( o );
						}
	
						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					}
					else if ( funcNotation )
					{
						// Function call
						a[i] = a[i].replace(__reFn, '');
						data = data[ a[i] ]( val );
					}
	
					// If the nested object doesn't currently exist - since we are
					// trying to set the value - create it
					if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
					{
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	
				// Last item in the input - i.e, the actual set
				if ( aLast.match(__reFn ) )
				{
					// Function call
					data = data[ aLast.replace(__reFn, '') ]( val );
				}
				else
				{
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[ aLast.replace(__reArray, '') ] = val;
				}
			};
	
			return function (data, val) { // meta is also passed in, but not used
				return setData( data, val, mSource );
			};
		}
		else
		{
			/* Array or flat object mapping */
			return function (data, val) { // meta is also passed in, but not used
				data[mSource] = val;
			};
		}
	}
	
	
	/**
	 * Return an array with the full table data
	 *  @param {object} oSettings dataTables settings object
	 *  @returns array {array} aData Master data array
	 *  @memberof DataTable#oApi
	 */
	function _fnGetDataMaster ( settings )
	{
		return _pluck( settings.aoData, '_aData' );
	}
	
	
	/**
	 * Nuke the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnClearTable( settings )
	{
		settings.aoData.length = 0;
		settings.aiDisplayMaster.length = 0;
		settings.aiDisplay.length = 0;
	}
	
	
	 /**
	 * Take an array of integers (index array) and remove a target integer (value - not
	 * the key!)
	 *  @param {array} a Index array to target
	 *  @param {int} iTarget value to find
	 *  @memberof DataTable#oApi
	 */
	function _fnDeleteIndex( a, iTarget, splice )
	{
		var iTargetIndex = -1;
	
		for ( var i=0, iLen=a.length ; i<iLen ; i++ )
		{
			if ( a[i] == iTarget )
			{
				iTargetIndex = i;
			}
			else if ( a[i] > iTarget )
			{
				a[i]--;
			}
		}
	
		if ( iTargetIndex != -1 && splice === undefined )
		{
			a.splice( iTargetIndex, 1 );
		}
	}
	
	
	/**
	 * Mark cached data as invalid such that a re-read of the data will occur when
	 * the cached data is next requested. Also update from the data source object.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {int}    rowIdx   Row index to invalidate
	 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	 *     or 'data'
	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	 *     row will be invalidated
	 * @memberof DataTable#oApi
	 *
	 * @todo For the modularisation of v1.11 this will need to become a callback, so
	 *   the sort and filter methods can subscribe to it. That will required
	 *   initialisation options for sorting, which is why it is not already baked in
	 */
	function _fnInvalidate( settings, rowIdx, src, colIdx )
	{
		var row = settings.aoData[ rowIdx ];
		var i, ien;
		var cellWrite = function ( cell, col ) {
			// This is very frustrating, but in IE if you just write directly
			// to innerHTML, and elements that are overwritten are GC'ed,
			// even if there is a reference to them elsewhere
			while ( cell.childNodes.length ) {
				cell.removeChild( cell.firstChild );
			}
	
			cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
		};
	
		// Are we reading last data from DOM or the data object?
		if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
			// Read the data from the DOM
			row._aData = _fnGetRowElements(
					settings, row, colIdx, colIdx === undefined ? undefined : row._aData
				)
				.data;
		}
		else {
			// Reading from data object, update the DOM
			var cells = row.anCells;
	
			if ( cells ) {
				if ( colIdx !== undefined ) {
					cellWrite( cells[colIdx], colIdx );
				}
				else {
					for ( i=0, ien=cells.length ; i<ien ; i++ ) {
						cellWrite( cells[i], i );
					}
				}
			}
		}
	
		// For both row and cell invalidation, the cached data for sorting and
		// filtering is nulled out
		row._aSortData = null;
		row._aFilterData = null;
	
		// Invalidate the type for a specific column (if given) or all columns since
		// the data might have changed
		var cols = settings.aoColumns;
		if ( colIdx !== undefined ) {
			cols[ colIdx ].sType = null;
		}
		else {
			for ( i=0, ien=cols.length ; i<ien ; i++ ) {
				cols[i].sType = null;
			}
	
			// Update DataTables special `DT_*` attributes for the row
			_fnRowAttributes( row );
		}
	}
	
	
	/**
	 * Build a data source object from an HTML row, reading the contents of the
	 * cells that are in the row.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {node|object} TR element from which to read data or existing row
	 *   object from which to re-read the data from the cells
	 * @param {int} [colIdx] Optional column index
	 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	 *   parameter should also be given and will be used to write the data into.
	 *   Only the column in question will be written
	 * @returns {object} Object with two parameters: `data` the data read, in
	 *   document order, and `cells` and array of nodes (they can be useful to the
	 *   caller, so rather than needing a second traversal to get them, just return
	 *   them from here).
	 * @memberof DataTable#oApi
	 */
	function _fnGetRowElements( settings, row, colIdx, d )
	{
		var
			tds = [],
			td = row.firstChild,
			name, col, o, i=0, contents,
			columns = settings.aoColumns,
			objectRead = settings._rowReadObject;
	
		// Allow the data object to be passed in, or construct
		d = d || objectRead ? {} : [];
	
		var attr = function ( str, td  ) {
			if ( typeof str === 'string' ) {
				var idx = str.indexOf('@');
	
				if ( idx !== -1 ) {
					var attr = str.substring( idx+1 );
					var setter = _fnSetObjectDataFn( str );
					setter( d, td.getAttribute( attr ) );
				}
			}
		};
	
		// Read data from a cell and store into the data object
		var cellProcess = function ( cell ) {
			if ( colIdx === undefined || colIdx === i ) {
				col = columns[i];
				contents = $.trim(cell.innerHTML);
	
				if ( col && col._bAttrSrc ) {
					var setter = _fnSetObjectDataFn( col.mData._ );
					setter( d, contents );
	
					attr( col.mData.sort, cell );
					attr( col.mData.type, cell );
					attr( col.mData.filter, cell );
				}
				else {
					// Depending on the `data` option for the columns the data can
					// be read to either an object or an array.
					if ( objectRead ) {
						if ( ! col._setter ) {
							// Cache the setter function
							col._setter = _fnSetObjectDataFn( col.mData );
						}
						col._setter( d, contents );
					}
					else {
						d[i] = contents;
					}
				}
			}
	
			i++;
		};
	
		if ( td ) {
			// `tr` element was passed in
			while ( td ) {
				name = td.nodeName.toUpperCase();
	
				if ( name == "TD" || name == "TH" ) {
					cellProcess( td );
					tds.push( td );
				}
	
				td = td.nextSibling;
			}
		}
		else {
			// Existing row object passed in
			tds = row.anCells;
			
			for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
				cellProcess( tds[j] );
			}
		}
	
		return {
			data: d,
			cells: tds
		};
	}
	/**
	 * Create a new TR element (and it's TD children) for a row
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow Row to consider
	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @memberof DataTable#oApi
	 */
	function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
	{
		var
			row = oSettings.aoData[iRow],
			rowData = row._aData,
			cells = [],
			nTr, nTd, oCol,
			i, iLen;
	
		if ( row.nTr === null )
		{
			nTr = nTrIn || document.createElement('tr');
	
			row.nTr = nTr;
			row.anCells = cells;
	
			/* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
			nTr._DT_RowIndex = iRow;
	
			/* Special parameters can be given by the data source to be used on the row */
			_fnRowAttributes( row );
	
			/* Process each column */
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
	
				nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
				cells.push( nTd );
	
				// Need to create the HTML if new, or if a rendering function is defined
				if ( !nTrIn || oCol.mRender || oCol.mData !== i )
				{
					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
				}
	
				/* Add user defined class */
				if ( oCol.sClass )
				{
					nTd.className += ' '+oCol.sClass;
				}
	
				// Visibility - add or remove as required
				if ( oCol.bVisible && ! nTrIn )
				{
					nTr.appendChild( nTd );
				}
				else if ( ! oCol.bVisible && nTrIn )
				{
					nTd.parentNode.removeChild( nTd );
				}
	
				if ( oCol.fnCreatedCell )
				{
					oCol.fnCreatedCell.call( oSettings.oInstance,
						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
					);
				}
			}
	
			_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );
		}

	}
	
	
	/**
	 * Add attributes to a row based on the special `DT_*` parameters in a data
	 * source object.
	 *  @param {object} DataTables row object for the row to be modified
	 *  @memberof DataTable#oApi
	 */
	function _fnRowAttributes( row )
	{
		var tr = row.nTr;
		var data = row._aData;
	
		if ( tr ) {
			if ( data.DT_RowId ) {
				tr.id = data.DT_RowId;
			}
	
			if ( data.DT_RowClass ) {
				// Remove any classes added by DT_RowClass before
				var a = data.DT_RowClass.split(' ');
				row.__rowc = row.__rowc ?
					_unique( row.__rowc.concat( a ) ) :
					a;
	
				$(tr)
					.removeClass( row.__rowc.join(' ') )
					.addClass( data.DT_RowClass );
			}
	
			if ( data.DT_RowData ) {
				$(tr).data( data.DT_RowData );
			}
		}
	}
	
	
	/**
	 * Create the HTML header for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBuildHead( oSettings )
	{
		var i, ien, cell, row, column;
		var thead = oSettings.nTHead;
		var tfoot = oSettings.nTFoot;
		var createHeader = $('th, td', thead).length === 0;
		var classes = oSettings.oClasses;
		var columns = oSettings.aoColumns;
	
		if ( createHeader ) {
			row = $('<tr/>').appendTo( thead );
		}
	
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			column = columns[i];
			cell = $( column.nTh ).addClass( column.sClass );
	
			if ( createHeader ) {
				cell.appendTo( row );
			}
	
			// 1.11 move into sorting
			if ( oSettings.oFeatures.bSort ) {
				cell.addClass( column.sSortingClass );
	
				if ( column.bSortable !== false ) {
					cell
						.attr( 'tabindex', oSettings.iTabIndex )
						.attr( 'aria-controls', oSettings.sTableId );
	
					_fnSortAttachListener( oSettings, column.nTh, i );
				}
			}
	
			if ( column.sTitle != cell.html() ) {
				cell.html( column.sTitle );
			}
	
			_fnRenderer( oSettings, 'header' )(
				oSettings, cell, column, classes
			);
		}
	
		if ( createHeader ) {
			_fnDetectHeader( oSettings.aoHeader, thead );
		}
		
		/* Deal with the footer - add classes if required */
		$(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
		$(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );
	
		// Cache the footer cells. Note that we only take the cells from the first
		// row in the footer. If there is more than one row the user wants to
		// interact with, they need to use the table().foot() method. Note also this
		// allows cells to be used for multiple columns using colspan
		if ( tfoot !== null ) {
			var cells = oSettings.aoFooter[0];
	
			for ( i=0, ien=cells.length ; i<ien ; i++ ) {
				column = columns[i];
				column.nTf = cells[i].cell;
	
				if ( column.sClass ) {
					$(column.nTf).addClass( column.sClass );
				}
			}
		}
	}
	
	
	/**
	 * Draw the header (or footer) element based on the column visibility states. The
	 * methodology here is to use the layout array from _fnDetectHeader, modified for
	 * the instantaneous column visibility, to construct the new layout. The grid is
	 * traversed over cell at a time in a rows x columns grid fashion, although each
	 * cell insert can cover multiple elements in the grid - which is tracks using the
	 * aApplied array. Cell inserts in the grid will only occur where there isn't
	 * already a cell in that position.
	 *  @param {object} oSettings dataTables settings object
	 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	 *  @memberof DataTable#oApi
	 */
	function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
	{
		var i, iLen, j, jLen, k, kLen, n, nLocalTr;
		var aoLocal = [];
		var aApplied = [];
		var iColumns = oSettings.aoColumns.length;
		var iRowspan, iColspan;
	
		if ( ! aoSource )
		{
			return;
		}
	
		if (  bIncludeHidden === undefined )
		{
			bIncludeHidden = false;
		}
	
		/* Make a copy of the master layout array, but without the visible columns in it */
		for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
		{
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;
	
			/* Remove any columns which are currently hidden */
			for ( j=iColumns-1 ; j>=0 ; j-- )
			{
				if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
				{
					aoLocal[i].splice( j, 1 );
				}
			}
	
			/* Prep the applied array - it needs an element for each row */
			aApplied.push( [] );
		}
	
		for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
		{
			nLocalTr = aoLocal[i].nTr;
	
			/* All cells are going to be replaced, so empty out the row */
			if ( nLocalTr )
			{
				while( (n = nLocalTr.firstChild) )
				{
					nLocalTr.removeChild( n );
				}
			}
	
			for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
			{
				iRowspan = 1;
				iColspan = 1;
	
				/* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
				if ( aApplied[i][j] === undefined )
				{
					nLocalTr.appendChild( aoLocal[i][j].cell );
					aApplied[i][j] = 1;
	
					/* Expand the cell to cover as many rows as needed */
					while ( aoLocal[i+iRowspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
					{
						aApplied[i+iRowspan][j] = 1;
						iRowspan++;
					}
	
					/* Expand the cell to cover as many columns as needed */
					while ( aoLocal[i][j+iColspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
					{
						/* Must update the applied array over the rows for the columns */
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aApplied[i+k][j+iColspan] = 1;
						}
						iColspan++;
					}
	
					/* Do the actual expansion in the DOM */
					var headerCell = $(aoLocal[i][j].cell);
					if (iRowspan !== 1) {
						headerCell.attr('rowspan', iRowspan);
					}
					if (iColspan !== 1) {
						headerCell.attr('colspan', iColspan);
					}
				}
			}
		}
	}
	
	
	/**
	 * Insert the required TR nodes into the table for display
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnDraw( oSettings )
	{
		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
		var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
		if ( $.inArray( false, aPreDraw ) !== -1 )
		{
			_fnProcessingDisplay( oSettings, false );
			return;
		}
	
		var i, iLen, n;
		var anRows = [];
		var iRowCount = 0;
		var asStripeClasses = oSettings.asStripeClasses;
		var iStripes = asStripeClasses.length;
		var iOpenRows = oSettings.aoOpenRows.length;
		var oLang = oSettings.oLanguage;
		var iInitDisplayStart = oSettings.iInitDisplayStart;
		var bServerSide = _fnDataSource( oSettings ) == 'ssp';
		var aiDisplay = oSettings.aiDisplay;
	
		oSettings.bDrawing = true;
	
		/* Check and see if we have an initial draw position from state saving */
		if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
		{
			oSettings._iDisplayStart = bServerSide ?
				iInitDisplayStart :
				iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
					0 :
					iInitDisplayStart;
	
			oSettings.iInitDisplayStart = -1;
		}
	
		var iDisplayStart = oSettings._iDisplayStart;
		var iDisplayEnd = oSettings.fnDisplayEnd();
	
		/* Server-side processing draw intercept */
		if ( oSettings.bDeferLoading )
		{
			oSettings.bDeferLoading = false;
			oSettings.iDraw++;
			_fnProcessingDisplay( oSettings, false );
		}
		else if ( !bServerSide )
		{
			oSettings.iDraw++;
		}
		else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
		{
			return;
		}
	
		if ( aiDisplay.length !== 0 )
		{
			var iStart = bServerSide ? 0 : iDisplayStart;
			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
	
			for ( var j=iStart ; j<iEnd ; j++ )
			{
				var iDataIndex = aiDisplay[j];
				var aoData = oSettings.aoData[ iDataIndex ];
				if ( aoData.nTr === null )
				{
					_fnCreateTr( oSettings, iDataIndex );
				}
	
				var nRow = aoData.nTr;
	
				/* Remove the old striping classes and then add the new one */
				if ( iStripes !== 0 )
				{
					var sStripe = asStripeClasses[ iRowCount % iStripes ];
					if ( aoData._sRowStripe != sStripe )
					{
						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
						aoData._sRowStripe = sStripe;
					}
				}
	
				// Row callback functions - might want to manipulate the row
				// iRowCount and j are not currently documented. Are they at all
				// useful?
				_fnCallbackFire( oSettings, 'aoRowCallback', null,
					[nRow, aoData._aData, iRowCount, j] );
	
				anRows.push( nRow );
				iRowCount++;
			}
		}
		else
		{
			/* Table is empty - create a row with an empty message in it */
			var sZero = oLang.sZeroRecords;
			if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
			{
				sZero = oLang.sLoadingRecords;
			}
			else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
			{
				sZero = oLang.sEmptyTable;
			}
	
			anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
				.append( $('<td />', {
					'style': 'vertical-align: top;',
					'colSpan': _fnVisbleColumns( oSettings ),
					'class':   oSettings.oClasses.sRowEmpty
				} ).html( sZero ) )[0];
		}
	
		/* Header and footer callbacks */
		_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		var body = $(oSettings.nTBody);
	
		body.children().detach();
		body.append( $(anRows) );
	
		/* Call all required callback functions for the end of a draw */
		_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
	
		/* Draw is complete, sorting and filtering must be as well */
		oSettings.bSorted = false;
		oSettings.bFiltered = false;
		oSettings.bDrawing = false;
	}
	
	
	/**
	 * Redraw the table - taking account of the various features which are enabled
	 *  @param {object} oSettings dataTables settings object
	 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	 *    the paging is reset to the first page
	 *  @memberof DataTable#oApi
	 */
	function _fnReDraw( settings, holdPosition )
	{
		var
			features = settings.oFeatures,
			sort     = features.bSort,
			filter   = features.bFilter;
	
		if ( sort ) {
			_fnSort( settings );
		}
	
		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	
		if ( holdPosition !== true ) {
			settings._iDisplayStart = 0;
		}
	
		// Let any modules know about the draw hold position state (used by
		// scrolling internally)
		settings._drawHold = holdPosition;
	
		_fnDraw( settings );
	
		settings._drawHold = false;
	}
	
	
	/**
	 * Add the options to the page HTML for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAddOptionsHtml ( oSettings )
	{
		var classes = oSettings.oClasses;
		var table = $(oSettings.nTable);
		var holding = $('<div/>').insertBefore( table ); // Holding element for speed
		var features = oSettings.oFeatures;
	
		// All DataTables are wrapped in a div
		var insert = $('<div/>', {
			id:      oSettings.sTableId+'_wrapper',
			'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
		} );
	
		oSettings.nHolding = holding[0];
		oSettings.nTableWrapper = insert[0];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
	
		/* Loop over the user set positioning and place the elements as needed */
		var aDom = oSettings.sDom.split('');
		var featureNode, cOption, nNewNode, cNext, sAttr, j;
		for ( var i=0 ; i<aDom.length ; i++ )
		{
			featureNode = null;
			cOption = aDom[i];
	
			if ( cOption == '<' )
			{
				/* New container div */
				nNewNode = $('<div/>')[0];
	
				/* Check to see if we should append an id and/or a class name to the container */
				cNext = aDom[i+1];
				if ( cNext == "'" || cNext == '"' )
				{
					sAttr = "";
					j = 2;
					while ( aDom[i+j] != cNext )
					{
						sAttr += aDom[i+j];
						j++;
					}
	
					/* Replace jQuery UI constants @todo depreciated */
					if ( sAttr == "H" )
					{
						sAttr = classes.sJUIHeader;
					}
					else if ( sAttr == "F" )
					{
						sAttr = classes.sJUIFooter;
					}
	
					/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
					 * breaks the string into parts and applies them as needed
					 */
					if ( sAttr.indexOf('.') != -1 )
					{
						var aSplit = sAttr.split('.');
						nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
						nNewNode.className = aSplit[1];
					}
					else if ( sAttr.charAt(0) == "#" )
					{
						nNewNode.id = sAttr.substr(1, sAttr.length-1);
					}
					else
					{
						nNewNode.className = sAttr;
					}
	
					i += j; /* Move along the position array */
				}
	
				insert.append( nNewNode );
				insert = $(nNewNode);
			}
			else if ( cOption == '>' )
			{
				/* End container div */
				insert = insert.parent();
			}
			// @todo Move options into their own plugins?
			else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
			{
				/* Length */
				featureNode = _fnFeatureHtmlLength( oSettings );
			}
			else if ( cOption == 'f' && features.bFilter )
			{
				/* Filter */
				featureNode = _fnFeatureHtmlFilter( oSettings );
			}
			else if ( cOption == 'r' && features.bProcessing )
			{
				/* pRocessing */
				featureNode = _fnFeatureHtmlProcessing( oSettings );
			}
			else if ( cOption == 't' )
			{
				/* Table */
				featureNode = _fnFeatureHtmlTable( oSettings );
			}
			else if ( cOption ==  'i' && features.bInfo )
			{
				/* Info */
				featureNode = _fnFeatureHtmlInfo( oSettings );
			}
			else if ( cOption == 'p' && features.bPaginate )
			{
				/* Pagination */
				featureNode = _fnFeatureHtmlPaginate( oSettings );
			}
			else if ( DataTable.ext.feature.length !== 0 )
			{
				/* Plug-in features */
				var aoFeatures = DataTable.ext.feature;
				for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
				{
					if ( cOption == aoFeatures[k].cFeature )
					{
						featureNode = aoFeatures[k].fnInit( oSettings );
						break;
					}
				}
			}
	
			/* Add to the 2D features array */
			if ( featureNode )
			{
				var aanFeatures = oSettings.aanFeatures;
	
				if ( ! aanFeatures[cOption] )
				{
					aanFeatures[cOption] = [];
				}
	
				aanFeatures[cOption].push( featureNode );
				insert.append( featureNode );
			}
		}
	
		/* Built our DOM structure - replace the holding div with what we want */
		holding.replaceWith( insert );
	}
	
	
	/**
	 * Use the DOM source to create up an array of header cells. The idea here is to
	 * create a layout grid (array) of rows x columns, which contains a reference
	 * to the cell that that point in the grid (regardless of col/rowspan), such that
	 * any column / row could be removed and the new grid constructed
	 *  @param array {object} aLayout Array to store the calculated layout in
	 *  @param {node} nThead The header/footer element for the table
	 *  @memberof DataTable#oApi
	 */
	function _fnDetectHeader ( aLayout, nThead )
	{
		var nTrs = $(nThead).children('tr');
		var nTr, nCell;
		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		var bUnique;
		var fnShiftCol = function ( a, i, j ) {
			var k = a[i];
	                while ( k[j] ) {
				j++;
			}
			return j;
		};
	
		aLayout.splice( 0, aLayout.length );
	
		/* We know how many rows there are in the layout - so prep it */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			aLayout.push( [] );
		}
	
		/* Calculate a layout array */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			nTr = nTrs[i];
			iColumn = 0;
	
			/* For every cell in the row... */
			nCell = nTr.firstChild;
			while ( nCell ) {
				if ( nCell.nodeName.toUpperCase() == "TD" ||
				     nCell.nodeName.toUpperCase() == "TH" )
				{
					/* Get the col and rowspan attributes from the DOM and sanitise them */
					iColspan = nCell.getAttribute('colspan') * 1;
					iRowspan = nCell.getAttribute('rowspan') * 1;
					iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
					iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
	
					/* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
					iColShifted = fnShiftCol( aLayout, i, iColumn );
	
					/* Cache calculation for unique columns */
					bUnique = iColspan === 1 ? true : false;
	
					/* If there is col / rowspan, copy the information into the layout grid */
					for ( l=0 ; l<iColspan ; l++ )
					{
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aLayout[i+k][iColShifted+l] = {
								"cell": nCell,
								"unique": bUnique
							};
							aLayout[i+k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}
	
	
	/**
	 * Get an array of unique th elements, one for each column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nHeader automatically detect the layout from this node - optional
	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	 *  @returns array {node} aReturn list of unique th's
	 *  @memberof DataTable#oApi
	 */
	function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
	{
		var aReturn = [];
		if ( !aLayout )
		{
			aLayout = oSettings.aoHeader;
			if ( nHeader )
			{
				aLayout = [];
				_fnDetectHeader( aLayout, nHeader );
			}
		}
	
		for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
		{
			for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
			{
				if ( aLayout[i][j].unique &&
					 (!aReturn[j] || !oSettings.bSortCellsTop) )
				{
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}
	
		return aReturn;
	}
	
	
	
	/**
	 * Create an Ajax call based on the table's settings, taking into account that
	 * parameters can have multiple forms, and backwards compatibility.
	 *
	 * @param {object} oSettings dataTables settings object
	 * @param {array} data Data to send to the server, required by
	 *     DataTables - may be augmented by developer callbacks
	 * @param {function} fn Callback function to run when data is obtained
	 */
	function _fnBuildAjax( oSettings, data, fn )
	{
		// Compatibility with 1.9-, allow fnServerData and event to manipulate
		_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
	
		// Convert to object based for 1.10+ if using the old array scheme which can
		// come from server-side processing or serverParams
		if ( data && $.isArray(data) ) {
			var tmp = {};
			var rbracket = /(.*?)\[\]$/;
	
			$.each( data, function (key, val) {
				var match = val.name.match(rbracket);
	
				if ( match ) {
					// Support for arrays
					var name = match[0];
	
					if ( ! tmp[ name ] ) {
						tmp[ name ] = [];
					}
					tmp[ name ].push( val.value );
				}
				else {
					tmp[val.name] = val.value;
				}
			} );
			data = tmp;
		}
	
		var ajaxData;
		var ajax = oSettings.ajax;
		var instance = oSettings.oInstance;
	
		if ( $.isPlainObject( ajax ) && ajax.data )
		{
			ajaxData = ajax.data;
	
			var newData = $.isFunction( ajaxData ) ?
				ajaxData( data ) :  // fn can manipulate data or return an object
				ajaxData;           // object or array to merge
	
			// If the function returned an object, use that alone
			data = $.isFunction( ajaxData ) && newData ?
				newData :
				$.extend( true, data, newData );
	
			// Remove the data property as we've resolved it already and don't want
			// jQuery to do it again (it is restored at the end of the function)
			delete ajax.data;
		}
	
		var baseAjax = {
			"data": data,
			"success": function (json) {
				var error = json.error || json.sError;
				if ( error ) {
					oSettings.oApi._fnLog( oSettings, 0, error );
				}
	
				oSettings.json = json;
				_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json] );
				fn( json );
			},
			"dataType": "json",
			"cache": false,
			"type": oSettings.sServerMethod,
			"error": function (xhr, error, thrown) {
				var log = oSettings.oApi._fnLog;
	
				if ( error == "parsererror" ) {
					log( oSettings, 0, 'Invalid JSON response', 1 );
				}
				else if ( xhr.readyState === 4 ) {
					log( oSettings, 0, 'Ajax error', 7 );
				}
	
				_fnProcessingDisplay( oSettings, false );
			}
		};
	
		// Store the data submitted for the API
		oSettings.oAjaxData = data;
	
		// Allow plug-ins and external processes to modify the data
		_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
	
		if ( oSettings.fnServerData )
		{
			// DataTables 1.9- compatibility
			oSettings.fnServerData.call( instance,
				oSettings.sAjaxSource,
				$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
					return { name: key, value: val };
				} ),
				fn,
				oSettings
			);
		}
		else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
		{
			// DataTables 1.9- compatibility
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
				url: ajax || oSettings.sAjaxSource
			} ) );
		}
		else if ( $.isFunction( ajax ) )
		{
			// Is a function - let the caller define what needs to be done
			oSettings.jqXHR = ajax.call( instance, data, fn, oSettings );
		}
		else
		{
			// Object to extend the base settings
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
	
			// Restore for next time around
			ajax.data = ajaxData;
		}
	}
	
	
	/**
	 * Update the table using an Ajax call
	 *  @param {object} settings dataTables settings object
	 *  @returns {boolean} Block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdate( settings )
	{
		if ( settings.bAjaxDataGet ) {
			settings.iDraw++;
			_fnProcessingDisplay( settings, true );
	
			_fnBuildAjax(
				settings,
				_fnAjaxParameters( settings ),
				function(json) {
					_fnAjaxUpdateDraw( settings, json );
				}
			);
	
			return false;
		}
		return true;
	}
	
	
	/**
	 * Build up the parameters in an object needed for a server-side processing
	 * request. Note that this is basically done twice, is different ways - a modern
	 * method which is used by default in DataTables 1.10 which uses objects and
	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	 * option is set.
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {bool} block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxParameters( settings )
	{
		var
			columns = settings.aoColumns,
			columnCount = columns.length,
			features = settings.oFeatures,
			preSearch = settings.oPreviousSearch,
			preColSearch = settings.aoPreSearchCols,
			i, data = [], dataProp, column, columnSearch,
			sort = _fnSortFlatten( settings ),
			displayStart = settings._iDisplayStart,
			displayLength = features.bPaginate !== false ?
				settings._iDisplayLength :
				-1;
	
		var param = function ( name, value ) {
			data.push( { 'name': name, 'value': value } );
		};
	
		// DataTables 1.9- compatible method
		param( 'sEcho',          settings.iDraw );
		param( 'iColumns',       columnCount );
		param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
		param( 'iDisplayStart',  displayStart );
		param( 'iDisplayLength', displayLength );
	
		// DataTables 1.10+ method
		var d = {
			draw:    settings.iDraw,
			columns: [],
			order:   [],
			start:   displayStart,
			length:  displayLength,
			search:  {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};
	
		for ( i=0 ; i<columnCount ; i++ ) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
	
			d.columns.push( {
				data:       dataProp,
				name:       column.sName,
				searchable: column.bSearchable,
				orderable:  column.bSortable,
				search:     {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			} );
	
			param( "mDataProp_"+i, dataProp );
	
			if ( features.bFilter ) {
				param( 'sSearch_'+i,     columnSearch.sSearch );
				param( 'bRegex_'+i,      columnSearch.bRegex );
				param( 'bSearchable_'+i, column.bSearchable );
			}
	
			if ( features.bSort ) {
				param( 'bSortable_'+i, column.bSortable );
			}
		}
	
		if ( features.bFilter ) {
			param( 'sSearch', preSearch.sSearch );
			param( 'bRegex', preSearch.bRegex );
		}
	
		if ( features.bSort ) {
			$.each( sort, function ( i, val ) {
				d.order.push( { column: val.col, dir: val.dir } );
	
				param( 'iSortCol_'+i, val.col );
				param( 'sSortDir_'+i, val.dir );
			} );
	
			param( 'iSortingCols', sort.length );
		}
	
		// If the legacy.ajax parameter is null, then we automatically decide which
		// form to use, based on sAjaxSource
		var legacy = DataTable.ext.legacy.ajax;
		if ( legacy === null ) {
			return settings.sAjaxSource ? data : d;
		}
	
		// Otherwise, if legacy has been specified then we use that to decide on the
		// form
		return legacy ? data : d;
	}
	
	
	/**
	 * Data the data from the server (nuking the old) and redraw the table
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} json json data return from the server.
	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	 *  @param {array} json.aaData The data to display on this page
	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdateDraw ( settings, json )
	{
		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
		// Support both
		var compat = function ( old, modern ) {
			return json[old] !== undefined ? json[old] : json[modern];
		};
	
		var draw            = compat( 'sEcho',                'draw' );
		var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
		var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
	
		if ( draw ) {
			// Protect against out of sequence returns
			if ( draw*1 < settings.iDraw ) {
				return;
			}
			settings.iDraw = draw * 1;
		}
	
		_fnClearTable( settings );
		settings._iRecordsTotal   = parseInt(recordsTotal, 10);
		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
	
		var data = _fnAjaxDataSrc( settings, json );
		for ( var i=0, ien=data.length ; i<ien ; i++ ) {
			_fnAddData( settings, data[i] );
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();
	
		settings.bAjaxDataGet = false;
		_fnDraw( settings );
	
		if ( ! settings._bInitComplete ) {
			_fnInitComplete( settings, json );
		}
	
		settings.bAjaxDataGet = true;
		_fnProcessingDisplay( settings, false );
	}
	
	
	/**
	 * Get the data from the JSON data source to use for drawing a table. Using
	 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	 * source object, or from a processing function.
	 *  @param {object} oSettings dataTables settings object
	 *  @param  {object} json Data source object / array from the server
	 *  @return {array} Array of data to use
	 */
	function _fnAjaxDataSrc ( oSettings, json )
	{
		var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
			oSettings.ajax.dataSrc :
			oSettings.sAjaxDataProp; // Compatibility with 1.9-.
	
		// Compatibility with 1.9-. In order to read from aaData, check if the
		// default has been changed, if not, check for aaData
		if ( dataSrc === 'data' ) {
			return json.aaData || json[dataSrc];
		}
	
		return dataSrc !== "" ?
			_fnGetObjectDataFn( dataSrc )( json ) :
			json;
	}
	
	
	/**
	 * Generate the node required for filtering text
	 *  @returns {node} Filter control element
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlFilter ( settings )
	{
		var classes = settings.oClasses;
		var tableId = settings.sTableId;
		var language = settings.oLanguage;
		var previousSearch = settings.oPreviousSearch;
		var features = settings.aanFeatures;
		var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
	
		var str = language.sSearch;
		str = str.match(/_INPUT_/) ?
			str.replace('_INPUT_', input) :
			str+input;
	
		var filter = $('<div/>', {
				'id': ! features.f ? tableId+'_filter' : null,
				'class': classes.sFilter
			} )
			.append( $('<label/>' ).append( str ) );
	
		var searchFn = function() {
			/* Update all other filter input elements for the new display */
			var n = features.f;
			var val = !this.value ? "" : this.value; // mental IE8 fix :-(
	
			/* Now do the filter */
			if ( val != previousSearch.sSearch ) {
				_fnFilterComplete( settings, {
					"sSearch": val,
					"bRegex": previousSearch.bRegex,
					"bSmart": previousSearch.bSmart ,
					"bCaseInsensitive": previousSearch.bCaseInsensitive
				} );
	
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			}
		};
	
		var searchDelay = settings.searchDelay !== null ?
			settings.searchDelay :
			_fnDataSource( settings ) === 'ssp' ?
				400 :
				0;
	
		var jqFilter = $('input', filter)
			.val( previousSearch.sSearch )
			.attr( 'placeholder', language.sSearchPlaceholder )
			.bind(
				'keyup.DT search.DT input.DT paste.DT cut.DT',
				searchDelay ?
					_fnThrottle( searchFn, searchDelay ) :
					searchFn
			)
			.bind( 'keypress.DT', function(e) {
				/* Prevent form submission */
				if ( e.keyCode == 13 ) {
					return false;
				}
			} )
			.attr('aria-controls', tableId);
	
		// Update the input elements whenever the table is filtered
		$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
			if ( settings === s ) {
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame...
				try {
					if ( jqFilter[0] !== document.activeElement ) {
						jqFilter.val( previousSearch.sSearch );
					}
				}
				catch ( e ) {}
			}
		} );
	
		return filter[0];
	}
	
	
	/**
	 * Filter the table using both the global filter and column based filtering
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oSearch search information
	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterComplete ( oSettings, oInput, iForce )
	{
		var oPrevSearch = oSettings.oPreviousSearch;
		var aoPrevSearch = oSettings.aoPreSearchCols;
		var fnSaveFilter = function ( oFilter ) {
			/* Save the filtering values */
			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
		};
		var fnRegex = function ( o ) {
			// Backwards compatibility with the bEscapeRegex option
			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
		};
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo As per sort - can this be moved into an event handler?
		_fnColumnTypes( oSettings );
	
		/* In server-side processing all filtering is done by the server, so no point hanging around here */
		if ( _fnDataSource( oSettings ) != 'ssp' )
		{
			/* Global filter */
			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
			fnSaveFilter( oInput );
	
			/* Now do the individual column filter */
			for ( var i=0 ; i<aoPrevSearch.length ; i++ )
			{
				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
			}
	
			/* Custom filtering */
			_fnFilterCustom( oSettings );
		}
		else
		{
			fnSaveFilter( oInput );
		}
	
		/* Tell the draw function we have been filtering */
		oSettings.bFiltered = true;
		_fnCallbackFire( oSettings, null, 'search', [oSettings] );
	}
	
	
	/**
	 * Apply custom filtering functions
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCustom( settings )
	{
		var filters = DataTable.ext.search;
		var displayRows = settings.aiDisplay;
		var row, rowIdx;
	
		for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
			var rows = [];
	
			// Loop over each row and see if it should be included
			for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
				rowIdx = displayRows[ j ];
				row = settings.aoData[ rowIdx ];
	
				if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
					rows.push( rowIdx );
				}
			}
	
			// So the array reference doesn't break set the results into the
			// existing array
			displayRows.length = 0;
			displayRows.push.apply( displayRows, rows );
		}
	}
	
	
	/**
	 * Filter the table on a per-column basis
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sInput string to filter on
	 *  @param {int} iColumn column to filter
	 *  @param {bool} bRegex treat search string as a regular expression or not
	 *  @param {bool} bSmart use smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
	{
		if ( searchStr === '' ) {
			return;
		}
	
		var data;
		var display = settings.aiDisplay;
		var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
	
		for ( var i=display.length-1 ; i>=0 ; i-- ) {
			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
	
			if ( ! rpSearch.test( data ) ) {
				display.splice( i, 1 );
			}
		}
	}
	
	
	/**
	 * Filter the data table based on user input and draw the table
	 *  @param {object} settings dataTables settings object
	 *  @param {string} input string to filter on
	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	 *  @param {bool} regex treat as a regular expression or not
	 *  @param {bool} smart perform smart filtering or not
	 *  @param {bool} caseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
	{
		var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
		var prevSearch = settings.oPreviousSearch.sSearch;
		var displayMaster = settings.aiDisplayMaster;
		var display, invalidated, i;
	
		// Need to take account of custom filtering functions - always filter
		if ( DataTable.ext.search.length !== 0 ) {
			force = true;
		}
	
		// Check if any of the rows were invalidated
		invalidated = _fnFilterData( settings );
	
		// If the input is blank - we just want the full data set
		if ( input.length <= 0 ) {
			settings.aiDisplay = displayMaster.slice();
		}
		else {
			// New search - start from the master array
			if ( invalidated ||
				 force ||
				 prevSearch.length > input.length ||
				 input.indexOf(prevSearch) !== 0 ||
				 settings.bSorted // On resort, the display master needs to be
				                  // re-filtered since indexes will have changed
			) {
				settings.aiDisplay = displayMaster.slice();
			}
	
			// Search the display array
			display = settings.aiDisplay;
	
			for ( i=display.length-1 ; i>=0 ; i-- ) {
				if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
					display.splice( i, 1 );
				}
			}
		}
	}
	
	
	/**
	 * Build a regular expression object suitable for searching a table
	 *  @param {string} sSearch string to search for
	 *  @param {bool} bRegex treat as a regular expression or not
	 *  @param {bool} bSmart perform smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @returns {RegExp} constructed object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
	{
		search = regex ?
			search :
			_fnEscapeRegex( search );
		
		if ( smart ) {
			/* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 * 
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
			var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || '', function ( word ) {
				if ( word.charAt(0) === '"' ) {
					var m = word.match( /^"(.*)"$/ );
					word = m ? m[1] : word;
				}
	
				return word.replace('"', '');
			} );
	
			search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
		}
	
		return new RegExp( search, caseInsensitive ? 'i' : '' );
	}
	
	
	/**
	 * Escape a string such that it can be used in a regular expression
	 *  @param {string} sVal string to escape
	 *  @returns {string} escaped string
	 *  @memberof DataTable#oApi
	 */
	function _fnEscapeRegex ( sVal )
	{
		return sVal.replace( _re_escape_regex, '\\$1' );
	}
	
	
	
	var __filter_div = $('<div>')[0];
	var __filter_div_textContent = __filter_div.textContent !== undefined;
	
	// Update the filtering data for each row if needed (by invalidation or first run)
	function _fnFilterData ( settings )
	{
		var columns = settings.aoColumns;
		var column;
		var i, j, ien, jen, filterData, cellData, row;
		var fomatters = DataTable.ext.type.search;
		var wasInvalidated = false;
	
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aFilterData ) {
				filterData = [];
	
				for ( j=0, jen=columns.length ; j<jen ; j++ ) {
					column = columns[j];
	
					if ( column.bSearchable ) {
						cellData = _fnGetCellData( settings, i, j, 'filter' );
	
						if ( fomatters[ column.sType ] ) {
							cellData = fomatters[ column.sType ]( cellData );
						}
	
						// Search in DataTables 1.10 is string based. In 1.11 this
						// should be altered to also allow strict type checking.
						if ( cellData === null ) {
							cellData = '';
						}
	
						if ( typeof cellData !== 'string' && cellData.toString ) {
							cellData = cellData.toString();
						}
					}
					else {
						cellData = '';
					}
	
					// If it looks like there is an HTML entity in the string,
					// attempt to decode it so sorting works as expected. Note that
					// we could use a single line of jQuery to do this, but the DOM
					// method used here is much faster http://jsperf.com/html-decode
					if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
						__filter_div.innerHTML = cellData;
						cellData = __filter_div_textContent ?
							__filter_div.textContent :
							__filter_div.innerText;
					}
	
					if ( cellData.replace ) {
						cellData = cellData.replace(/[\r\n]/g, '');
					}
	
					filterData.push( cellData );
				}
	
				row._aFilterData = filterData;
				row._sFilterRow = filterData.join('  ');
				wasInvalidated = true;
			}
		}
	
		return wasInvalidated;
	}
	
	
	/**
	 * Convert from the internal Hungarian notation to camelCase for external
	 * interaction
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToCamel ( obj )
	{
		return {
			search:          obj.sSearch,
			smart:           obj.bSmart,
			regex:           obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}
	
	
	
	/**
	 * Convert from camelCase notation to the internal Hungarian. We could use the
	 * Hungarian convert function here, but this is cleaner
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToHung ( obj )
	{
		return {
			sSearch:          obj.search,
			bSmart:           obj.smart,
			bRegex:           obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}
	
	/**
	 * Generate the node required for the info display
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Information element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlInfo ( settings )
	{
		var
			tid = settings.sTableId,
			nodes = settings.aanFeatures.i,
			n = $('<div/>', {
				'class': settings.oClasses.sInfo,
				'id': ! nodes ? tid+'_info' : null
			} );
	
		if ( ! nodes ) {
			// Update display on each draw
			settings.aoDrawCallback.push( {
				"fn": _fnUpdateInfo,
				"sName": "information"
			} );
	
			n
				.attr( 'role', 'status' )
				.attr( 'aria-live', 'polite' );
	
			// Table is described by our info div
			$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
		}
	
		return n[0];
	}
	
	
	/**
	 * Update the information elements in the display
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnUpdateInfo ( settings )
	{
		/* Show information about the table */
		var nodes = settings.aanFeatures.i;
		if ( nodes.length === 0 ) {
			return;
		}
	
		var
			lang  = settings.oLanguage,
			start = settings._iDisplayStart+1,
			end   = settings.fnDisplayEnd(),
			max   = settings.fnRecordsTotal(),
			total = settings.fnRecordsDisplay(),
			out   = total ?
				lang.sInfo :
				lang.sInfoEmpty;
	
		if ( total !== max ) {
			/* Record set after filtering */
			out += ' ' + lang.sInfoFiltered;
		}
	
		// Convert the macros
		out += lang.sInfoPostFix;
		out = _fnInfoMacros( settings, out );
	
		var callback = lang.fnInfoCallback;
		if ( callback !== null ) {
			out = callback.call( settings.oInstance,
				settings, start, end, max, total, out
			);
		}
	
		$(nodes).html( out );
	}
	
	
	function _fnInfoMacros ( settings, str )
	{
		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
		// internally
		var
			formatter  = settings.fnFormatNumber,
			start      = settings._iDisplayStart+1,
			len        = settings._iDisplayLength,
			vis        = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return str.
			replace(/_START_/g, formatter.call( settings, start ) ).
			replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
			replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
			replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
			replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
			replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
	}
	
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnInitialise ( settings )
	{
		var i, iLen, iAjaxStart=settings.iInitDisplayStart;
		var columns = settings.aoColumns, column;
		var features = settings.oFeatures;
	
		/* Ensure that the table data is fully initialised */
		if ( ! settings.bInitialised ) {
			setTimeout( function(){ _fnInitialise( settings ); }, 200 );
			return;
		}
	
		/* Show the display HTML options */
		_fnAddOptionsHtml( settings );
	
		/* Build and draw the header / footer for the table */
		_fnBuildHead( settings );
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );
	
		/* Calculate sizes for columns */
		if ( features.bAutoWidth ) {
			_fnCalculateColumnWidths( settings );
		}
	
		for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
			column = columns[i];
	
			if ( column.sWidth ) {
				column.nTh.style.width = _fnStringToCss( column.sWidth );
			}
		}
	
		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw( settings );
	
		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		var dataSrc = _fnDataSource( settings );
		if ( dataSrc != 'ssp' ) {
			// if there is an ajax source load the data
			if ( dataSrc == 'ajax' ) {
				_fnBuildAjax( settings, [], function(json) {
					var aData = _fnAjaxDataSrc( settings, json );
	
					// Got the data - add it to the table
					for ( i=0 ; i<aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}
	
					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;
	
					_fnReDraw( settings );
	
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings, json );
				}, settings );
			}
			else {
				_fnProcessingDisplay( settings, false );
				_fnInitComplete( settings );
			}
		}
	}
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	 *    with client-side processing (optional)
	 *  @memberof DataTable#oApi
	 */
	function _fnInitComplete ( settings, json )
	{
		settings._bInitComplete = true;
	
		// On an Ajax load we now have data and therefore want to apply the column
		// sizing
		if ( json ) {
			_fnAdjustColumnSizing( settings );
		}
	
		_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
	}
	
	
	function _fnLengthChange ( settings, val )
	{
		var len = parseInt( val, 10 );
		settings._iDisplayLength = len;
	
		_fnLengthOverflow( settings );
	
		// Fire length change event
		_fnCallbackFire( settings, null, 'length', [settings, len] );
	}
	
	
	/**
	 * Generate the node required for user display length changing
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Display length feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlLength ( settings )
	{
		var
			classes  = settings.oClasses,
			tableId  = settings.sTableId,
			menu     = settings.aLengthMenu,
			d2       = $.isArray( menu[0] ),
			lengths  = d2 ? menu[0] : menu,
			language = d2 ? menu[1] : menu;
	
		var select = $('<select/>', {
			'name':          tableId+'_length',
			'aria-controls': tableId,
			'class':         classes.sLengthSelect
		} );
	
		for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
			select[0][ i ] = new Option( language[i], lengths[i] );
		}
	
		var div = $('<div><label/></div>').addClass( classes.sLength );
		if ( ! settings.aanFeatures.l ) {
			div[0].id = tableId+'_length';
		}
	
		div.children().append(
			settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
		);
	
		// Can't use `select` variable as user might provide their own and the
		// reference is broken by the use of outerHTML
		$('select', div)
			.val( settings._iDisplayLength )
			.bind( 'change.DT', function(e) {
				_fnLengthChange( settings, $(this).val() );
				_fnDraw( settings );
			} );
	
		// Update node value whenever anything changes the table's length
		$(settings.nTable).bind( 'length.dt.DT', function (e, s, len) {
			if ( settings === s ) {
				$('select', div).val( len );
			}
		} );
	
		return div[0];
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
	
	/**
	 * Generate the node required for default pagination
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Pagination feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlPaginate ( settings )
	{
		var
			type   = settings.sPaginationType,
			plugin = DataTable.ext.pager[ type ],
			modern = typeof plugin === 'function',
			redraw = function( settings ) {
				_fnDraw( settings );
			},
			node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
			features = settings.aanFeatures;
	
		if ( ! modern ) {
			plugin.fnInit( settings, node, redraw );
		}
	
		/* Add a draw callback for the pagination on first instance, to update the paging display */
		if ( ! features.p )
		{
			node.id = settings.sTableId+'_paginate';
	
			settings.aoDrawCallback.push( {
				"fn": function( settings ) {
					if ( modern ) {
						var
							start      = settings._iDisplayStart,
							len        = settings._iDisplayLength,
							visRecords = settings.fnRecordsDisplay(),
							all        = len === -1,
							page = all ? 0 : Math.ceil( start / len ),
							pages = all ? 1 : Math.ceil( visRecords / len ),
							buttons = plugin(page, pages),
							i, ien;
	
						for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
							_fnRenderer( settings, 'pageButton' )(
								settings, features.p[i], i, buttons, page, pages
							);
						}
					}
					else {
						plugin.fnUpdate( settings, redraw );
					}
				},
				"sName": "pagination"
			} );
		}
	
		return node;
	}
	
	
	/**
	 * Alter the display settings to change the page
	 *  @param {object} settings DataTables settings object
	 *  @param {string|int} action Paging action to take: "first", "previous",
	 *    "next" or "last" or page number to jump to (integer)
	 *  @param [bool] redraw Automatically draw the update or not
	 *  @returns {bool} true page has changed, false - no change
	 *  @memberof DataTable#oApi
	 */
	function _fnPageChange ( settings, action, redraw )
	{
		var
			start     = settings._iDisplayStart,
			len       = settings._iDisplayLength,
			records   = settings.fnRecordsDisplay();
	
		if ( records === 0 || len === -1 )
		{
			start = 0;
		}
		else if ( typeof action === "number" )
		{
			start = action * len;
	
			if ( start > records )
			{
				start = 0;
			}
		}
		else if ( action == "first" )
		{
			start = 0;
		}
		else if ( action == "previous" )
		{
			start = len >= 0 ?
				start - len :
				0;
	
			if ( start < 0 )
			{
			  start = 0;
			}
		}
		else if ( action == "next" )
		{
			if ( start + len < records )
			{
				start += len;
			}
		}
		else if ( action == "last" )
		{
			start = Math.floor( (records-1) / len) * len;
		}
		else
		{
			_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
		}
	
		var changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;
	
		if ( changed ) {
			_fnCallbackFire( settings, null, 'page', [settings] );
	
			if ( redraw ) {
				_fnDraw( settings );
			}
		}
	
		return changed;
	}
	
	
	
	/**
	 * Generate the node required for the processing node
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Processing element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlProcessing ( settings )
	{
		return $('<div/>', {
				'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
				'class': settings.oClasses.sProcessing
			} )
			.html( settings.oLanguage.sProcessing )
			.insertBefore( settings.nTable )[0];
	}
	
	
	/**
	 * Display or hide the processing indicator
	 *  @param {object} settings dataTables settings object
	 *  @param {bool} show Show the processing indicator (true) or not (false)
	 *  @memberof DataTable#oApi
	 */
	function _fnProcessingDisplay ( settings, show )
	{
		if ( settings.oFeatures.bProcessing ) {
			$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
		}
	
		_fnCallbackFire( settings, null, 'processing', [settings, show] );
	}
	
	/**
	 * Add any control elements for the table - specifically scrolling
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Node to add to the DOM
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlTable ( settings )
	{
		var table = $(settings.nTable);
	
		// Scrolling from here on in
		var scroll = settings.oScroll;
	
		if ( scroll.sX === '' && scroll.sY === '' ) {
			return settings.nTable;
		}
	
		var scrollX = scroll.sX;
		var scrollY = scroll.sY;
		var classes = settings.oClasses;
		var caption = table.children('caption');
		var captionSide = caption.length ? caption[0]._captionSide : null;
		var headerClone = $( table[0].cloneNode(false) );
		var footerClone = $( table[0].cloneNode(false) );
		var footer = table.children('tfoot');
		var _div = '<div/>';
		var size = function ( s ) {
			return !s ? null : _fnStringToCss( s );
		};
	
		// This is fairly messy, but with x scrolling enabled, if the table has a
		// width attribute, regardless of any width applied using the column width
		// options, the browser will shrink or grow the table as needed to fit into
		// that 100%. That would make the width options useless. So we remove it.
		// This is okay, under the assumption that width:100% is applied to the
		// table in CSS (it is in the default stylesheet) which will set the table
		// width as appropriate (the attribute and css behave differently...)
		if ( scroll.sX && table.attr('width') === '100%' ) {
			table.removeAttr('width');
		}
	
		if ( ! footer.length ) {
			footer = null;
		}
	
		/*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
		var scroller = $( _div, { 'class': classes.sScrollWrapper } )
			.append(
				$(_div, { 'class': classes.sScrollHead } )
					.css( {
						overflow: 'hidden',
						position: 'relative',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollHeadInner } )
							.css( {
								'box-sizing': 'content-box',
								width: scroll.sXInner || '100%'
							} )
							.append(
								headerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'top' ? caption : null )
									.append(
										table.children('thead')
									)
							)
					)
			)
			.append(
				$(_div, { 'class': classes.sScrollBody } )
					.css( {
						overflow: 'auto',
						height: size( scrollY ),
						width: size( scrollX )
					} )
					.append( table )
			);
	
		if ( footer ) {
			scroller.append(
				$(_div, { 'class': classes.sScrollFoot } )
					.css( {
						overflow: 'hidden',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollFootInner } )
							.append(
								footerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'bottom' ? caption : null )
									.append(
										table.children('tfoot')
									)
							)
					)
			);
		}
	
		var children = scroller.children();
		var scrollHead = children[0];
		var scrollBody = children[1];
		var scrollFoot = footer ? children[2] : null;
	
		// When the body is scrolled, then we also want to scroll the headers
		if ( scrollX ) {
			$(scrollBody).scroll( function (e) {
				var scrollLeft = this.scrollLeft;
	
				scrollHead.scrollLeft = scrollLeft;
	
				if ( footer ) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			} );
		}
	
		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;
	
		// On redraw - align columns
		settings.aoDrawCallback.push( {
			"fn": _fnScrollDraw,
			"sName": "scrolling"
		} );
	
		return scroller[0];
	}
	
	
	
	/**
	 * Update the header, footer and body tables for resizing - i.e. column
	 * alignment.
	 *
	 * Welcome to the most horrible function DataTables. The process that this
	 * function follows is basically:
	 *   1. Re-create the table inside the scrolling div
	 *   2. Take live measurements from the DOM
	 *   3. Apply the measurements to align the columns
	 *   4. Clean up
	 *
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnScrollDraw ( settings )
	{
		// Given that this is such a monster function, a lot of variables are use
		// to try and keep the minimised size as small as possible
		var
			scroll         = settings.oScroll,
			scrollX        = scroll.sX,
			scrollXInner   = scroll.sXInner,
			scrollY        = scroll.sY,
			barWidth       = scroll.iBarWidth,
			divHeader      = $(settings.nScrollHead),
			divHeaderStyle = divHeader[0].style,
			divHeaderInner = divHeader.children('div'),
			divHeaderInnerStyle = divHeaderInner[0].style,
			divHeaderTable = divHeaderInner.children('table'),
			divBodyEl      = settings.nScrollBody,
			divBody        = $(divBodyEl),
			divBodyStyle   = divBodyEl.style,
			divFooter      = $(settings.nScrollFoot),
			divFooterInner = divFooter.children('div'),
			divFooterTable = divFooterInner.children('table'),
			header         = $(settings.nTHead),
			table          = $(settings.nTable),
			tableEl        = table[0],
			tableStyle     = tableEl.style,
			footer         = settings.nTFoot ? $(settings.nTFoot) : null,
			browser        = settings.oBrowser,
			ie67           = browser.bScrollOversize,
			headerTrgEls, footerTrgEls,
			headerSrcEls, footerSrcEls,
			headerCopy, footerCopy,
			headerWidths=[], footerWidths=[],
			headerContent=[],
			idx, correction, sanityWidth,
			zeroOut = function(nSizer) {
				var style = nSizer.style;
				style.paddingTop = "0";
				style.paddingBottom = "0";
				style.borderTopWidth = "0";
				style.borderBottomWidth = "0";
				style.height = 0;
			};
	
		/*
		 * 1. Re-create the table inside the scrolling div
		 */
	
		// Remove the old minimised thead and tfoot elements in the inner table
		table.children('thead, tfoot').remove();
	
		// Clone the current header and footer elements and then place it into the inner table
		headerCopy = header.clone().prependTo( table );
		headerTrgEls = header.find('tr'); // original header is in its own table
		headerSrcEls = headerCopy.find('tr');
		headerCopy.find('th, td').removeAttr('tabindex');
	
		if ( footer ) {
			footerCopy = footer.clone().prependTo( table );
			footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
			footerSrcEls = footerCopy.find('tr');
		}
	
	
		/*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
	
		// Remove old sizing and apply the calculated column widths
		// Get the unique column headers in the newly created (cloned) header. We want to apply the
		// calculated sizes to this header
		if ( ! scrollX )
		{
			divBodyStyle.width = '100%';
			divHeader[0].style.width = '100%';
		}
	
		$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
			idx = _fnVisibleToColumnIndex( settings, i );
			el.style.width = settings.aoColumns[idx].sWidth;
		} );
	
		if ( footer ) {
			_fnApplyToChildren( function(n) {
				n.style.width = "";
			}, footerSrcEls );
		}
	
		// If scroll collapse is enabled, when we put the headers back into the body for sizing, we
		// will end up forcing the scrollbar to appear, making our measurements wrong for when we
		// then hide it (end of this function), so add the header height to the body scroller.
		if ( scroll.bCollapse && scrollY !== "" ) {
			divBodyStyle.height = (divBody[0].offsetHeight + header[0].offsetHeight)+"px";
		}
	
		// Size the table as a whole
		sanityWidth = table.outerWidth();
		if ( scrollX === "" ) {
			// No x scrolling
			tableStyle.width = "100%";
	
			// IE7 will make the width of the table when 100% include the scrollbar
			// - which is shouldn't. When there is a scrollbar we need to take this
			// into account.
			if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
			}
		}
		else
		{
			// x scrolling
			if ( scrollXInner !== "" ) {
				// x scroll inner has been given - use it
				tableStyle.width = _fnStringToCss(scrollXInner);
			}
			else if ( sanityWidth == divBody.width() && divBody.height() < table.height() ) {
				// There is y-scrolling - try to take account of the y scroll bar
				tableStyle.width = _fnStringToCss( sanityWidth-barWidth );
				if ( table.outerWidth() > sanityWidth-barWidth ) {
					// Not possible to take account of it
					tableStyle.width = _fnStringToCss( sanityWidth );
				}
			}
			else {
				// When all else fails
				tableStyle.width = _fnStringToCss( sanityWidth );
			}
		}
	
		// Recalculate the sanity width - now that we've applied the required width,
		// before it was a temporary variable. This is required because the column
		// width calculation is done before this table DOM is created.
		sanityWidth = table.outerWidth();
	
		// Hidden header should have zero height, so remove padding and borders. Then
		// set the width based on the real headers
	
		// Apply all styles in one pass
		_fnApplyToChildren( zeroOut, headerSrcEls );
	
		// Read all widths in next pass
		_fnApplyToChildren( function(nSizer) {
			headerContent.push( nSizer.innerHTML );
			headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
		}, headerSrcEls );
	
		// Apply all widths in final pass
		_fnApplyToChildren( function(nToSize, i) {
			nToSize.style.width = headerWidths[i];
		}, headerTrgEls );
	
		$(headerSrcEls).height(0);
	
		/* Same again with the footer if we have one */
		if ( footer )
		{
			_fnApplyToChildren( zeroOut, footerSrcEls );
	
			_fnApplyToChildren( function(nSizer) {
				footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, footerSrcEls );
	
			_fnApplyToChildren( function(nToSize, i) {
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls );
	
			$(footerSrcEls).height(0);
		}
	
	
		/*
		 * 3. Apply the measurements
		 */
	
		// "Hide" the header and footer that we used for the sizing. We need to keep
		// the content of the cell so that the width applied to the header and body
		// both match, but we want to hide it completely. We want to also fix their
		// width to what they currently are
		_fnApplyToChildren( function(nSizer, i) {
			nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+headerContent[i]+'</div>';
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls );
	
		if ( footer )
		{
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = "";
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls );
		}
	
		// Sanity check that the table is of a sensible width. If not then we are going to get
		// misalignment - try to prevent this by not allowing the table to shrink below its min width
		if ( table.outerWidth() < sanityWidth )
		{
			// The min width depends upon if we have a vertical scrollbar visible or not */
			correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")) ?
					sanityWidth+barWidth :
					sanityWidth;
	
			// IE6/7 are a law unto themselves...
			if ( ie67 && (divBodyEl.scrollHeight >
				divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( correction-barWidth );
			}
	
			// And give the user a warning that we've stopped the table getting too small
			if ( scrollX === "" || scrollXInner !== "" ) {
				_fnLog( settings, 1, 'Possible column misalignment', 6 );
			}
		}
		else
		{
			correction = '100%';
		}
	
		// Apply to the container elements
		divBodyStyle.width = _fnStringToCss( correction );
		divHeaderStyle.width = _fnStringToCss( correction );
	
		if ( footer ) {
			settings.nScrollFoot.style.width = _fnStringToCss( correction );
		}
	
	
		/*
		 * 4. Clean up
		 */
		if ( ! scrollY ) {
			/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don't want to do it in any other browsers.
			 */
			if ( ie67 ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
			}
		}
	
		if ( scrollY && scroll.bCollapse ) {
			divBodyStyle.height = _fnStringToCss( scrollY );
	
			var iExtra = (scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth) ?
				barWidth :
				0;
	
			if ( tableEl.offsetHeight < divBodyEl.offsetHeight ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+iExtra );
			}
		}
	
		/* Finally set the width's of the header and footer tables */
		var iOuterWidth = table.outerWidth();
		divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
	
		// Figure out if there are scrollbar present - if so then we need a the header and footer to
		// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
		var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
		var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
	
		if ( footer ) {
			divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
		}
	
		/* Adjust the position of the header in case we loose the y-scrollbar */
		divBody.scroll();
	
		// If sorting or filtering has occurred, jump the scrolling back to the top
		// only if we aren't holding the position
		if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
			divBodyEl.scrollTop = 0;
		}
	}
	
	
	
	/**
	 * Apply a given function to the display child nodes of an element array (typically
	 * TD children of TR rows
	 *  @param {function} fn Method to apply to the objects
	 *  @param array {nodes} an1 List of elements to look through for display children
	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyToChildren( fn, an1, an2 )
	{
		var index=0, i=0, iLen=an1.length;
		var nNode1, nNode2;
	
		while ( i < iLen ) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : null;
	
			while ( nNode1 ) {
				if ( nNode1.nodeType === 1 ) {
					if ( an2 ) {
						fn( nNode1, nNode2, index );
					}
					else {
						fn( nNode1, index );
					}
	
					index++;
				}
	
				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : null;
			}
	
			i++;
		}
	}
	
	
	
	var __re_html_remove = /<.*?>/g;
	
	
	/**
	 * Calculate the width of columns for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnCalculateColumnWidths ( oSettings )
	{
		var
			table = oSettings.nTable,
			columns = oSettings.aoColumns,
			scroll = oSettings.oScroll,
			scrollY = scroll.sY,
			scrollX = scroll.sX,
			scrollXInner = scroll.sXInner,
			columnCount = columns.length,
			visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
			headerCells = $('th', oSettings.nTHead),
			tableWidthAttr = table.getAttribute('width'),
			tableContainer = table.parentNode,
			userInputs = false,
			i, column, columnIdx, width, outerWidth;
	
		/* Convert any user input sizes into pixel sizes */
		for ( i=0 ; i<visibleColumns.length ; i++ ) {
			column = columns[ visibleColumns[i] ];
	
			if ( column.sWidth !== null ) {
				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
	
				userInputs = true;
			}
		}
	
		/* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
		if ( ! userInputs && ! scrollX && ! scrollY &&
		    columnCount == _fnVisbleColumns( oSettings ) &&
			columnCount == headerCells.length
		) {
			for ( i=0 ; i<columnCount ; i++ ) {
				columns[i].sWidth = _fnStringToCss( headerCells.eq(i).width() );
			}
		}
		else
		{
			// Otherwise construct a single row table with the widest node in the
			// data, assign any user defined widths, then insert it into the DOM and
			// allow the browser to do all the hard work of calculating table widths
			var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
				.empty()
				.css( 'visibility', 'hidden' )
				.removeAttr( 'id' )
				.append( $(oSettings.nTHead).clone( false ) )
				.append( $(oSettings.nTFoot).clone( false ) )
				.append( $('<tbody><tr/></tbody>') );
	
			// Remove any assigned widths from the footer (from scrolling)
			tmpTable.find('tfoot th, tfoot td').css('width', '');
	
			var tr = tmpTable.find( 'tbody tr' );
	
			// Apply custom sizing to the cloned header
			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
	
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
	
				headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
					_fnStringToCss( column.sWidthOrig ) :
					'';
			}
	
			// Find the widest cell for each column and put it into the table
			if ( oSettings.aoData.length ) {
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					columnIdx = visibleColumns[i];
					column = columns[ columnIdx ];
	
					$( _fnGetWidestNode( oSettings, columnIdx ) )
						.clone( false )
						.append( column.sContentPadding )
						.appendTo( tr );
				}
			}
	
			// Table has been built, attach to the document so we can work with it
			tmpTable.appendTo( tableContainer );
	
			// When scrolling (X or Y) we want to set the width of the table as 
			// appropriate. However, when not scrolling leave the table width as it
			// is. This results in slightly different, but I think correct behaviour
			if ( scrollX && scrollXInner ) {
				tmpTable.width( scrollXInner );
			}
			else if ( scrollX ) {
				tmpTable.css( 'width', 'auto' );
	
				if ( tmpTable.width() < tableContainer.offsetWidth ) {
					tmpTable.width( tableContainer.offsetWidth );
				}
			}
			else if ( scrollY ) {
				tmpTable.width( tableContainer.offsetWidth );
			}
			else if ( tableWidthAttr ) {
				tmpTable.width( tableWidthAttr );
			}
	
			// Take into account the y scrollbar
			_fnScrollingWidthAdjust( oSettings, tmpTable[0] );
	
			// Browsers need a bit of a hand when a width is assigned to any columns
			// when x-scrolling as they tend to collapse the table to the min-width,
			// even if we sent the column widths. So we need to keep track of what
			// the table width should be by summing the user given values, and the
			// automatic values
			if ( scrollX )
			{
				var total = 0;
	
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					column = columns[ visibleColumns[i] ];
					outerWidth = $(headerCells[i]).outerWidth();
	
					total += column.sWidthOrig === null ?
						outerWidth :
						parseInt( column.sWidth, 10 ) + outerWidth - $(headerCells[i]).width();
				}
	
				tmpTable.width( _fnStringToCss( total ) );
				table.style.width = _fnStringToCss( total );
			}
	
			// Get the width of each column in the constructed table
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
				width = $(headerCells[i]).width();
	
				if ( width ) {
					column.sWidth = _fnStringToCss( width );
				}
			}
	
			table.style.width = _fnStringToCss( tmpTable.css('width') );
	
			// Finished with the table - ditch it
			tmpTable.remove();
		}
	
		// If there is a width attr, we want to attach an event listener which
		// allows the table sizing to automatically adjust when the window is
		// resized. Use the width attr rather than CSS, since we can't know if the
		// CSS is a relative value or absolute - DOM read is always px.
		if ( tableWidthAttr ) {
			table.style.width = _fnStringToCss( tableWidthAttr );
		}
	
		if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
			$(window).bind('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
				_fnAdjustColumnSizing( oSettings );
			} ) );
	
			oSettings._reszEvt = true;
		}
	}
	
	
	/**
	 * Throttle the calls to a function. Arguments and context are maintained for
	 * the throttled function
	 *  @param {function} fn Function to be called
	 *  @param {int} [freq=200] call frequency in mS
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#oApi
	 */
	function _fnThrottle( fn, freq ) {
		var
			frequency = freq !== undefined ? freq : 200,
			last,
			timer;
	
		return function () {
			var
				that = this,
				now  = +new Date(),
				args = arguments;
	
			if ( last && now < last + frequency ) {
				clearTimeout( timer );
	
				timer = setTimeout( function () {
					last = undefined;
					fn.apply( that, args );
				}, frequency );
			}
			else if ( last ) {
				last = now;
				fn.apply( that, args );
			}
			else {
				last = now;
			}
		};
	}
	
	
	/**
	 * Convert a CSS unit width to pixels (e.g. 2em)
	 *  @param {string} width width to be converted
	 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
	function _fnConvertToWidth ( width, parent )
	{
		if ( ! width ) {
			return 0;
		}
	
		var n = $('<div/>')
			.css( 'width', _fnStringToCss( width ) )
			.appendTo( parent || document.body );
	
		var val = n[0].offsetWidth;
		n.remove();
	
		return val;
	}
	
	
	/**
	 * Adjust a table's width to take account of vertical scroll bar
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n table node
	 *  @memberof DataTable#oApi
	 */
	
	function _fnScrollingWidthAdjust ( settings, n )
	{
		var scroll = settings.oScroll;
	
		if ( scroll.sX || scroll.sY ) {
			// When y-scrolling only, we want to remove the width of the scroll bar
			// so the table + scroll bar will fit into the area available, otherwise
			// we fix the table at its current size with no adjustment
			var correction = ! scroll.sX ? scroll.iBarWidth : 0;
			n.style.width = _fnStringToCss( $(n).outerWidth() - correction );
		}
	}
	
	
	/**
	 * Get the widest node
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {node} widest table node
	 *  @memberof DataTable#oApi
	 */
	function _fnGetWidestNode( settings, colIdx )
	{
		var idx = _fnGetMaxLenString( settings, colIdx );
		if ( idx < 0 ) {
			return null;
		}
	
		var data = settings.aoData[ idx ];
		return ! data.nTr ? // Might not have been created when deferred rendering
			$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
			data.anCells[ colIdx ];
	}
	
	
	/**
	 * Get the maximum strlen for each data column
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {string} max string length for each column
	 *  @memberof DataTable#oApi
	 */
	function _fnGetMaxLenString( settings, colIdx )
	{
		var s, max=-1, maxIdx = -1;
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
			s = s.replace( __re_html_remove, '' );
	
			if ( s.length > max ) {
				max = s.length;
				maxIdx = i;
			}
		}
	
		return maxIdx;
	}
	
	
	/**
	 * Append a CSS unit (only if required) to a string
	 *  @param {string} value to css-ify
	 *  @returns {string} value with css unit
	 *  @memberof DataTable#oApi
	 */
	function _fnStringToCss( s )
	{
		if ( s === null ) {
			return '0px';
		}
	
		if ( typeof s == 'number' ) {
			return s < 0 ?
				'0px' :
				s+'px';
		}
	
		// Check it has a unit character already
		return s.match(/\d$/) ?
			s+'px' :
			s;
	}
	
	
	/**
	 * Get the width of a scroll bar in this browser being used
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
	function _fnScrollBarWidth ()
	{
		// On first run a static variable is set, since this is only needed once.
		// Subsequent runs will just use the previously calculated value
		if ( ! DataTable.__scrollbarWidth ) {
			var inner = $('<p/>').css( {
				width: '100%',
				height: 200,
				padding: 0
			} )[0];
	
			var outer = $('<div/>')
				.css( {
					position: 'absolute',
					top: 0,
					left: 0,
					width: 200,
					height: 150,
					padding: 0,
					overflow: 'hidden',
					visibility: 'hidden'
				} )
				.append( inner )
				.appendTo( 'body' );
	
			var w1 = inner.offsetWidth;
			outer.css( 'overflow', 'scroll' );
			var w2 = inner.offsetWidth;
	
			if ( w1 === w2 ) {
				w2 = outer[0].clientWidth;
			}
	
			outer.remove();
	
			DataTable.__scrollbarWidth = w1 - w2;
		}
	
		return DataTable.__scrollbarWidth;
	}
	
	
	
	function _fnSortFlatten ( settings )
	{
		var
			i, iLen, k, kLen,
			aSort = [],
			aiOrig = [],
			aoColumns = settings.aoColumns,
			aDataSort, iCol, sType, srcCol,
			fixed = settings.aaSortingFixed,
			fixedObj = $.isPlainObject( fixed ),
			nestedSort = [],
			add = function ( a ) {
				if ( a.length && ! $.isArray( a[0] ) ) {
					// 1D array
					nestedSort.push( a );
				}
				else {
					// 2D array
					nestedSort.push.apply( nestedSort, a );
				}
			};
	
		// Build the sort array, with pre-fix and post-fix options if they have been
		// specified
		if ( $.isArray( fixed ) ) {
			add( fixed );
		}
	
		if ( fixedObj && fixed.pre ) {
			add( fixed.pre );
		}
	
		add( settings.aaSorting );
	
		if (fixedObj && fixed.post ) {
			add( fixed.post );
		}
	
		for ( i=0 ; i<nestedSort.length ; i++ )
		{
			srcCol = nestedSort[i][0];
			aDataSort = aoColumns[ srcCol ].aDataSort;
	
			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';
	
				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
				}
	
				aSort.push( {
					src:       srcCol,
					col:       iCol,
					dir:       nestedSort[i][1],
					index:     nestedSort[i]._idx,
					type:      sType,
					formatter: DataTable.ext.type.order[ sType+"-pre" ]
				} );
			}
		}
	
		return aSort;
	}
	
	/**
	 * Change the order of the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 *  @todo This really needs split up!
	 */
	function _fnSort ( oSettings )
	{
		var
			i, ien, iLen, j, jLen, k, kLen,
			sDataType, nTh,
			aiOrig = [],
			oExtSort = DataTable.ext.type.order,
			aoData = oSettings.aoData,
			aoColumns = oSettings.aoColumns,
			aDataSort, data, iCol, sType, oSort,
			formatters = 0,
			sortCol,
			displayMaster = oSettings.aiDisplayMaster,
			aSort;
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo Can this be moved into a 'data-ready' handler which is called when
		//   data is going to be used in the table?
		_fnColumnTypes( oSettings );
	
		aSort = _fnSortFlatten( oSettings );
	
		for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
			sortCol = aSort[i];
	
			// Track if we can use the fast sort algorithm
			if ( sortCol.formatter ) {
				formatters++;
			}
	
			// Load the data needed for the sort, for each cell
			_fnSortData( oSettings, sortCol.col );
		}
	
		/* No sorting required if server-side or no sorting array */
		if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
		{
			// Create a value - key array of the current row positions such that we can use their
			// current position during the sort, if values match, in order to perform stable sorting
			for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
				aiOrig[ displayMaster[i] ] = i;
			}
	
			/* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
			 * follow on it's own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort['string-asc']('data11', 'data12');
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort['numeric-desc']('data21', 'data22');
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
			if ( formatters === aSort.length ) {
				// All sort types have formatting functions
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, test, sort,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						test = x<y ? -1 : x>y ? 1 : 0;
						if ( test !== 0 ) {
							return sort.dir === 'asc' ? test : -test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
			else {
				// Depreciated - remove in 1.11 (providing a plug-in option)
				// Not all sort types have formatting methods, so we have to call their sorting
				// methods.
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, l, test, sort, fn,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
						test = fn( x, y );
						if ( test !== 0 ) {
							return test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
		}
	
		/* Tell the draw function that we have sorted the data */
		oSettings.bSorted = true;
	}
	
	
	function _fnSortAria ( settings )
	{
		var label;
		var nextSort;
		var columns = settings.aoColumns;
		var aSort = _fnSortFlatten( settings );
		var oAria = settings.oLanguage.oAria;
	
		// ARIA attributes - need to loop all columns, to update all (removing old
		// attributes as needed)
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			var col = columns[i];
			var asSorting = col.asSorting;
			var sTitle = col.sTitle.replace( /<.*?>/g, "" );
			var th = col.nTh;
	
			// IE7 is throwing an error when setting these properties with jQuery's
			// attr() and removeAttr() methods...
			th.removeAttribute('aria-sort');
	
			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
			if ( col.bSortable ) {
				if ( aSort.length > 0 && aSort[0].col == i ) {
					th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
					nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
				}
				else {
					nextSort = asSorting[0];
				}
	
				label = sTitle + ( nextSort === "asc" ?
					oAria.sSortAscending :
					oAria.sSortDescending
				);
			}
			else {
				label = sTitle;
			}
	
			th.setAttribute('aria-label', label);
		}
	}
	
	
	/**
	 * Function to run on user sort request
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {boolean} [append=false] Append the requested sort to the existing
	 *    sort if true (i.e. multi-column sort)
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortListener ( settings, colIdx, append, callback )
	{
		var col = settings.aoColumns[ colIdx ];
		var sorting = settings.aaSorting;
		var asSorting = col.asSorting;
		var nextSortIdx;
		var next = function ( a, overflow ) {
			var idx = a._idx;
			if ( idx === undefined ) {
				idx = $.inArray( a[1], asSorting );
			}
	
			return idx+1 < asSorting.length ?
				idx+1 :
				overflow ?
					null :
					0;
		};
	
		// Convert to 2D array if needed
		if ( typeof sorting[0] === 'number' ) {
			sorting = settings.aaSorting = [ sorting ];
		}
	
		// If appending the sort then we are multi-column sorting
		if ( append && settings.oFeatures.bSortMulti ) {
			// Are we already doing some kind of sort on this column?
			var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
	
			if ( sortIdx !== -1 ) {
				// Yes, modify the sort
				nextSortIdx = next( sorting[sortIdx], true );
	
				if ( nextSortIdx === null ) {
					sorting.splice( sortIdx, 1 );
				}
				else {
					sorting[sortIdx][1] = asSorting[ nextSortIdx ];
					sorting[sortIdx]._idx = nextSortIdx;
				}
			}
			else {
				// No sort on this column yet
				sorting.push( [ colIdx, asSorting[0], 0 ] );
				sorting[sorting.length-1]._idx = 0;
			}
		}
		else if ( sorting.length && sorting[0][0] == colIdx ) {
			// Single column - already sorting on this column, modify the sort
			nextSortIdx = next( sorting[0] );
	
			sorting.length = 1;
			sorting[0][1] = asSorting[ nextSortIdx ];
			sorting[0]._idx = nextSortIdx;
		}
		else {
			// Single column - sort only on this column
			sorting.length = 0;
			sorting.push( [ colIdx, asSorting[0] ] );
			sorting[0]._idx = 0;
		}
	
		// Run the sort by calling a full redraw
		_fnReDraw( settings );
	
		// callback used for async user interaction
		if ( typeof callback == 'function' ) {
			callback( settings );
		}
	}
	
	
	/**
	 * Attach a sort handler (click) to a node
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
	{
		var col = settings.aoColumns[ colIdx ];
	
		_fnBindAction( attachTo, {}, function (e) {
			/* If the column is not sortable - don't to anything */
			if ( col.bSortable === false ) {
				return;
			}
	
			// If processing is enabled use a timeout to allow the processing
			// display to be shown - otherwise to it synchronously
			if ( settings.oFeatures.bProcessing ) {
				_fnProcessingDisplay( settings, true );
	
				setTimeout( function() {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
	
					// In server-side processing, the draw callback will remove the
					// processing display
					if ( _fnDataSource( settings ) !== 'ssp' ) {
						_fnProcessingDisplay( settings, false );
					}
				}, 0 );
			}
			else {
				_fnSortListener( settings, colIdx, e.shiftKey, callback );
			}
		} );
	}
	
	
	/**
	 * Set the sorting classes on table's body, Note: it is safe to call this function
	 * when bSort and bSortClasses are false
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSortingClasses( settings )
	{
		var oldSort = settings.aLastSort;
		var sortClass = settings.oClasses.sSortColumn;
		var sort = _fnSortFlatten( settings );
		var features = settings.oFeatures;
		var i, ien, colIdx;
	
		if ( features.bSort && features.bSortClasses ) {
			// Remove old sorting classes
			for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
				colIdx = oldSort[i].src;
	
				// Remove column sorting
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.removeClass( sortClass + (i<2 ? i+1 : 3) );
			}
	
			// Add new column sorting
			for ( i=0, ien=sort.length ; i<ien ; i++ ) {
				colIdx = sort[i].src;
	
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.addClass( sortClass + (i<2 ? i+1 : 3) );
			}
		}
	
		settings.aLastSort = sort;
	}
	
	
	// Get the data to sort a column, be it from cache, fresh (populating the
	// cache), or from a sort formatter
	function _fnSortData( settings, idx )
	{
		// Custom sorting function - provided by the sort data type
		var column = settings.aoColumns[ idx ];
		var customSort = DataTable.ext.order[ column.sSortDataType ];
		var customData;
	
		if ( customSort ) {
			customData = customSort.call( settings.oInstance, settings, idx,
				_fnColumnIndexToVisible( settings, idx )
			);
		}
	
		// Use / populate cache
		var row, cellData;
		var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aSortData ) {
				row._aSortData = [];
			}
	
			if ( ! row._aSortData[idx] || customSort ) {
				cellData = customSort ?
					customData[i] : // If there was a custom sort function, use data from there
					_fnGetCellData( settings, i, idx, 'sort' );
	
				row._aSortData[ idx ] = formatter ?
					formatter( cellData ) :
					cellData;
			}
		}
	}
	
	
	
	/**
	 * Save the state of a table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSaveState ( settings )
	{
		if ( !settings.oFeatures.bStateSave || settings.bDestroying )
		{
			return;
		}
	
		/* Store the interesting variables */
		var state = {
			time:    +new Date(),
			start:   settings._iDisplayStart,
			length:  settings._iDisplayLength,
			order:   $.extend( true, [], settings.aaSorting ),
			search:  _fnSearchToCamel( settings.oPreviousSearch ),
			columns: $.map( settings.aoColumns, function ( col, i ) {
				return {
					visible: col.bVisible,
					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
				};
			} )
		};
	
		_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
	
		settings.oSavedState = state;
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}
	
	
	/**
	 * Attempt to load a saved table state
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oInit DataTables init object so we can override settings
	 *  @memberof DataTable#oApi
	 */
	function _fnLoadState ( settings, oInit )
	{
		var i, ien;
		var columns = settings.aoColumns;
	
		if ( ! settings.oFeatures.bStateSave ) {
			return;
		}
	
		var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
		if ( ! state || ! state.time ) {
			return;
		}
	
		/* Allow custom and plug-in manipulation functions to alter the saved data set and
		 * cancelling of loading by returning false
		 */
		var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state] );
		if ( $.inArray( false, abStateLoad ) !== -1 ) {
			return;
		}
	
		/* Reject old data */
		var duration = settings.iStateDuration;
		if ( duration > 0 && state.time < +new Date() - (duration*1000) ) {
			return;
		}
	
		// Number of columns have changed - all bets are off, no restore of settings
		if ( columns.length !== state.columns.length ) {
			return;
		}
	
		// Store the saved state so it might be accessed at any time
		settings.oLoadedState = $.extend( true, {}, state );
	
		// Restore key features - todo - for 1.11 this needs to be done by
		// subscribed events
		settings._iDisplayStart    = state.start;
		settings.iInitDisplayStart = state.start;
		settings._iDisplayLength   = state.length;
		settings.aaSorting = [];
	
		// Order
		$.each( state.order, function ( i, col ) {
			settings.aaSorting.push( col[0] >= columns.length ?
				[ 0, col[1] ] :
				col
			);
		} );
	
		// Search
		$.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
	
		// Columns
		for ( i=0, ien=state.columns.length ; i<ien ; i++ ) {
			var col = state.columns[i];
	
			// Visibility
			columns[i].bVisible = col.visible;
	
			// Search
			$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
		}
	
		_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, state] );
	}
	
	
	/**
	 * Return the settings object for a particular table
	 *  @param {node} table table we are using as a dataTable
	 *  @returns {object} Settings object - or null if not found
	 *  @memberof DataTable#oApi
	 */
	function _fnSettingsFromNode ( table )
	{
		var settings = DataTable.settings;
		var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
	
		return idx !== -1 ?
			settings[ idx ] :
			null;
	}
	
	
	/**
	 * Log an error message
	 *  @param {object} settings dataTables settings object
	 *  @param {int} level log error messages, or display them to the user
	 *  @param {string} msg error message
	 *  @param {int} tn Technical note id to get more information about the error.
	 *  @memberof DataTable#oApi
	 */
	function _fnLog( settings, level, msg, tn )
	{
		msg = 'DataTables warning: '+
			(settings!==null ? 'table id='+settings.sTableId+' - ' : '')+msg;
	
		if ( tn ) {
			msg += '. For more information about this error, please see '+
			'http://datatables.net/tn/'+tn;
		}
	
		if ( ! level  ) {
			// Backwards compatibility pre 1.10
			var ext = DataTable.ext;
			var type = ext.sErrMode || ext.errMode;
	
			if ( type == 'alert' ) {
				alert( msg );
			}
			else {
				throw new Error(msg);
			}
		}
		else if ( window.console && console.log ) {
			console.log( msg );
		}
	}
	
	
	/**
	 * See if a property is defined on one object, if so assign it to the other object
	 *  @param {object} ret target object
	 *  @param {object} src source object
	 *  @param {string} name property
	 *  @param {string} [mappedName] name to map too - optional, name used if not given
	 *  @memberof DataTable#oApi
	 */
	function _fnMap( ret, src, name, mappedName )
	{
		if ( $.isArray( name ) ) {
			$.each( name, function (i, val) {
				if ( $.isArray( val ) ) {
					_fnMap( ret, src, val[0], val[1] );
				}
				else {
					_fnMap( ret, src, val );
				}
			} );
	
			return;
		}
	
		if ( mappedName === undefined ) {
			mappedName = name;
		}
	
		if ( src[name] !== undefined ) {
			ret[mappedName] = src[name];
		}
	}
	
	
	/**
	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	 * shallow copy arrays. The reason we need to do this, is that we don't want to
	 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	 * able to override them, but we do want to deep copy arrays.
	 *  @param {object} out Object to extend
	 *  @param {object} extender Object from which the properties will be applied to
	 *      out
	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	 *      independent copy with the exception of the `data` or `aaData` parameters
	 *      if they are present. This is so you can pass in a collection to
	 *      DataTables and have that used as your data source without breaking the
	 *      references
	 *  @returns {object} out Reference, just for convenience - out === the return.
	 *  @memberof DataTable#oApi
	 *  @todo This doesn't take account of arrays inside the deep copied objects.
	 */
	function _fnExtend( out, extender, breakRefs )
	{
		var val;
	
		for ( var prop in extender ) {
			if ( extender.hasOwnProperty(prop) ) {
				val = extender[prop];
	
				if ( $.isPlainObject( val ) ) {
					if ( ! $.isPlainObject( out[prop] ) ) {
						out[prop] = {};
					}
					$.extend( true, out[prop], val );
				}
				else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
					out[prop] = val.slice();
				}
				else {
					out[prop] = val;
				}
			}
		}
	
		return out;
	}
	
	
	/**
	 * Bind an event handers to allow a click or return key to activate the callback.
	 * This is good for accessibility since a return on the keyboard will have the
	 * same effect as a click, if the element has focus.
	 *  @param {element} n Element to bind the action to
	 *  @param {object} oData Data object to pass to the triggered function
	 *  @param {function} fn Callback function for when the event is triggered
	 *  @memberof DataTable#oApi
	 */
	function _fnBindAction( n, oData, fn )
	{
		$(n)
			.bind( 'click.DT', oData, function (e) {
					n.blur(); // Remove focus outline for mouse users
					fn(e);
				} )
			.bind( 'keypress.DT', oData, function (e){
					if ( e.which === 13 ) {
						e.preventDefault();
						fn(e);
					}
				} )
			.bind( 'selectstart.DT', function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
				} );
	}
	
	
	/**
	 * Register a callback function. Easily allows a callback function to be added to
	 * an array store of callback functions that can then all be called together.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	 *  @param {function} fn Function to be called back
	 *  @param {string} sName Identifying name for the callback (i.e. a label)
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackReg( oSettings, sStore, fn, sName )
	{
		if ( fn )
		{
			oSettings[sStore].push( {
				"fn": fn,
				"sName": sName
			} );
		}
	}
	
	
	/**
	 * Fire callback functions and trigger events. Note that the loop over the
	 * callback array store is done backwards! Further note that you do not want to
	 * fire off triggers in time sensitive applications (for example cell creation)
	 * as its slow.
	 *  @param {object} settings dataTables settings object
	 *  @param {string} callbackArr Name of the array storage for the callbacks in
	 *      oSettings
	 *  @param {string} event Name of the jQuery custom event to trigger. If null no
	 *      trigger is fired
	 *  @param {array} args Array of arguments to pass to the callback function /
	 *      trigger
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackFire( settings, callbackArr, e, args )
	{
		var ret = [];
	
		if ( callbackArr ) {
			ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
				return val.fn.apply( settings.oInstance, args );
			} );
		}
	
		if ( e !== null ) {
			$(settings.nTable).trigger( e+'.dt', args );
		}
	
		return ret;
	}
	
	
	function _fnLengthOverflow ( settings )
	{
		var
			start = settings._iDisplayStart,
			end = settings.fnDisplayEnd(),
			len = settings._iDisplayLength;
	
		/* If we have space to show extra rows (backing up from the end point - then do so */
		if ( start >= end )
		{
			start = end - len;
		}
	
		// Keep the start record on the current page
		start -= (start % len);
	
		if ( len === -1 || start < 0 )
		{
			start = 0;
		}
	
		settings._iDisplayStart = start;
	}
	
	
	function _fnRenderer( settings, type )
	{
		var renderer = settings.renderer;
		var host = DataTable.ext.renderer[type];
	
		if ( $.isPlainObject( renderer ) && renderer[type] ) {
			// Specific renderer for this type. If available use it, otherwise use
			// the default.
			return host[renderer[type]] || host._;
		}
		else if ( typeof renderer === 'string' ) {
			// Common renderer - if there is one available for this type use it,
			// otherwise use the default
			return host[renderer] || host._;
		}
	
		// Use the default
		return host._;
	}
	
	
	/**
	 * Detect the data source being used for the table. Used to simplify the code
	 * a little (ajax) and to make it compress a little smaller.
	 *
	 *  @param {object} settings dataTables settings object
	 *  @returns {string} Data source
	 *  @memberof DataTable#oApi
	 */
	function _fnDataSource ( settings )
	{
		if ( settings.oFeatures.bServerSide ) {
			return 'ssp';
		}
		else if ( settings.ajax || settings.sAjaxSource ) {
			return 'ajax';
		}
		return 'dom';
	}
	

	DataTable = function( options )
	{
		/**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
		this.$ = function ( sSelector, oOpts )
		{
			return this.api(true).$( sSelector, oOpts );
		};
		
		
		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
		 *    entry in the array.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"search": "applied"});
		 *
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the search" );
		 *    } );
		 */
		this._ = function ( sSelector, oOpts )
		{
			return this.api(true).rows( sSelector, oOpts ).data();
		};
		
		
		/**
		 * Create a DataTables Api instance, with the currently selected tables for
		 * the Api's context.
		 * @param {boolean} [traditional=false] Set the API instance's context to be
		 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
		 *   or if all tables captured in the jQuery object should be used.
		 * @return {DataTables.Api}
		 */
		this.api = function ( traditional )
		{
			return traditional ?
				new _Api(
					_fnSettingsFromNode( this[ _ext.iApiIndex ] )
				) :
				new _Api( this );
		};
		
		
		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} data The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mData</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
		 *    </ul>
		 *  @param {bool} [redraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
		 *    the table.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function( data, redraw )
		{
			var api = this.api( true );
		
			/* Check if we want to add multiple rows or not */
			var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
				api.rows.add( data ) :
				api.row.add( data );
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return rows.flatten().toArray();
		};
		
		
		/**
		 * This function will make DataTables recalculate the column sizes, based on the data
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
		 * through the sWidth parameter). This can be useful when the width of the table's
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *
		 *      $(window).bind('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			var api = this.api( true ).columns.adjust();
			var settings = api.settings()[0];
			var scroll = settings.oScroll;
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw( false );
			}
			else if ( scroll.sX !== "" || scroll.sY !== "" ) {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				_fnScrollDraw( settings );
			}
		};
		
		
		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function( bRedraw )
		{
			var api = this.api( true ).clear();
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
		};
		
		
		/**
		 * The exact opposite of 'opening' a row, this function will close any rows which
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnClose = function( nTr )
		{
			this.api( true ).row( nTr ).child.hide();
		};
		
		
		/**
		 * Remove a row for the table
		 *  @param {mixed} target The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [callBack] Callback function
		 *  @param {bool} [redraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function( target, callback, redraw )
		{
			var api = this.api( true );
			var rows = api.rows( target );
			var settings = rows.settings()[0];
			var data = settings.aoData[ rows[0][0] ];
		
			rows.remove();
		
			if ( callback ) {
				callback.call( this, settings, data );
			}
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return data;
		};
		
		
		/**
		 * Restore the table to it's original state in the DOM by removing all of DataTables
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [remove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function ( remove )
		{
			this.api( true ).destroy( remove );
		};
		
		
		/**
		 * Redraw the table
		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function( complete )
		{
			// Note that this isn't an exact match to the old call to _fnDraw - it takes
			// into account the new data, but can old position.
			this.api( true ).draw( ! complete );
		};
		
		
		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
		{
			var api = this.api( true );
		
			if ( iColumn === null || iColumn === undefined ) {
				api.search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
			else {
				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
		
			api.draw();
		};
		
		
		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the
		 * provided parameters.
		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [col] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function( src, col )
		{
			var api = this.api( true );
		
			if ( src !== undefined ) {
				var type = src.nodeName ? src.nodeName.toLowerCase() : '';
		
				return col !== undefined || type == 'td' || type == 'th' ?
					api.cell( src, col ).data() :
					api.row( src ).data() || null;
			}
		
			return api.data().toArray();
		};
		
		
		/**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will
		 * typically want to use the '$' API method in preference to this as it is more
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function( iRow )
		{
			var api = this.api( true );
		
			return iRow !== undefined ?
				api.row( iRow ).node() :
				api.rows().nodes().flatten().toArray();
		};
		
		
		/**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} node this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible),
		 *    column index (all)] is given.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnGetPosition = function( node )
		{
			var api = this.api( true );
			var nodeName = node.nodeName.toUpperCase();
		
			if ( nodeName == 'TR' ) {
				return api.row( node ).index();
			}
			else if ( nodeName == 'TD' || nodeName == 'TH' ) {
				var cell = api.cell( node ).index();
		
				return [
					cell.row,
					cell.columnVisible,
					cell.column
				];
			}
			return null;
		};
		
		
		/**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnIsOpen = function( nTr )
		{
			return this.api( true ).row( nTr ).child.isShown();
		};
		
		
		/**
		 * This function will place a new row directly after a row which is currently
		 * on display on the page, with the HTML contents that is passed into the
		 * function. This can be used, for example, to ask for confirmation that a
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnOpen = function( nTr, mHtml, sClass )
		{
			return this.api( true )
				.row( nTr )
				.child( mHtml, sClass )
				.show()
				.child()[0];
		};
		
		
		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API
		 * function. With this function you can have a DataTables table go to the next,
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
		this.fnPageChange = function ( mAction, bRedraw )
		{
			var api = this.api( true ).page( mAction );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw(false);
			}
		};
		
		
		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var api = this.api( true ).column( iCol ).visible( bShow );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.columns.adjust().draw();
			}
		};
		
		
		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function()
		{
			return _fnSettingsFromNode( this[_ext.iApiIndex] );
		};
		
		
		/**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
		this.fnSort = function( aaSort )
		{
			this.api( true ).order( aaSort ).draw();
		};
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			this.api( true ).order.listener( nNode, iColumn, fnCallback );
		};
		
		
		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update, give as null or undefined to
		 *    update a whole row.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
		 *    } );
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var api = this.api( true );
		
			if ( iColumn === undefined || iColumn === null ) {
				api.row( mRow ).data( mData );
			}
			else {
				api.cell( mRow, iColumn ).data( mData );
			}
		
			if ( bAction === undefined || bAction ) {
				api.columns.adjust();
			}
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
			return 0;
		};
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		this.fnVersionCheck = _ext.fnVersionCheck;
		

		var _that = this;
		var emptyInit = options === undefined;
		var len = this.length;

		if ( emptyInit ) {
			options = {};
		}

		this.oApi = this.internal = _ext.internal;

		// Extend with old style plug-in API methods
		for ( var fn in DataTable.ext.internal ) {
			if ( fn ) {
				this[fn] = _fnExternApiFunc(fn);
			}
		}

		this.each(function() {
			// For each initialisation we want to give it a clean initialisation
			// object that can be bashed around
			var o = {};
			var oInit = len > 1 ? // optimisation for single table case
				_fnExtend( o, options, true ) :
				options;

			/*global oInit,_that,emptyInit*/
			var i=0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute( 'id' );
			var bInitHandedOff = false;
			var defaults = DataTable.defaults;
			
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != 'table' )
			{
				_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
				return;
			}
			
			/* Backwards compatibility for the defaults */
			_fnCompatOpts( defaults );
			_fnCompatCols( defaults.column );
			
			/* Convert the camel-case defaults to Hungarian */
			_fnCamelToHungarian( defaults, defaults, true );
			_fnCamelToHungarian( defaults.column, defaults.column, true );
			
			/* Setting up the initialisation object */
			_fnCamelToHungarian( defaults, oInit );
			
			/* Check to see if we are re-initialising a table */
			var allSettings = DataTable.settings;
			for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
			{
				/* Base check on table node */
				if ( allSettings[i].nTable == this )
				{
					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
			
					if ( emptyInit || bRetrieve )
					{
						return allSettings[i].oInstance;
					}
					else if ( bDestroy )
					{
						allSettings[i].oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( allSettings[i], 0, 'Cannot reinitialise DataTable', 3 );
						return;
					}
				}
			
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( allSettings[i].sTableId == this.id )
				{
					allSettings.splice( i, 1 );
					break;
				}
			}
			
			/* Ensure the table has an ID - required for accessibility */
			if ( sId === null || sId === "" )
			{
				sId = "DataTables_Table_"+(DataTable.ext._unique++);
				this.id = sId;
			}
			
			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
				"nTable":        this,
				"oApi":          _that.internal,
				"oInit":         oInit,
				"sDestroyWidth": $(this)[0].style.width,
				"sInstance":     sId,
				"sTableId":      sId
			} );
			allSettings.push( oSettings );
			
			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length===1) ? _that : $(this).dataTable();
			
			// Backwards compatibility, before we apply all the defaults
			_fnCompatOpts( oInit );
			
			if ( oInit.oLanguage )
			{
				_fnLanguageCompat( oInit.oLanguage );
			}
			
			// If the length menu is given, but the init display length is not, use the length menu
			if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
			{
				oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
					oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
			}
			
			// Apply the defaults and init options to make a single init object will all
			// options defined from defaults and instance options.
			oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
			
			
			// Map the initialisation options onto the settings object
			_fnMap( oSettings.oFeatures, oInit, [
				"bPaginate",
				"bLengthChange",
				"bFilter",
				"bSort",
				"bSortMulti",
				"bInfo",
				"bProcessing",
				"bAutoWidth",
				"bSortClasses",
				"bServerSide",
				"bDeferRender"
			] );
			_fnMap( oSettings, oInit, [
				"asStripeClasses",
				"ajax",
				"fnServerData",
				"fnFormatNumber",
				"sServerMethod",
				"aaSorting",
				"aaSortingFixed",
				"aLengthMenu",
				"sPaginationType",
				"sAjaxSource",
				"sAjaxDataProp",
				"iStateDuration",
				"sDom",
				"bSortCellsTop",
				"iTabIndex",
				"fnStateLoadCallback",
				"fnStateSaveCallback",
				"renderer",
				"searchDelay",
				[ "iCookieDuration", "iStateDuration" ], // backwards compat
				[ "oSearch", "oPreviousSearch" ],
				[ "aoSearchCols", "aoPreSearchCols" ],
				[ "iDisplayLength", "_iDisplayLength" ],
				[ "bJQueryUI", "bJUI" ]
			] );
			_fnMap( oSettings.oScroll, oInit, [
				[ "sScrollX", "sX" ],
				[ "sScrollXInner", "sXInner" ],
				[ "sScrollY", "sY" ],
				[ "bScrollCollapse", "bCollapse" ]
			] );
			_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
			
			/* Callback functions which are array driven */
			_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
			_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
			_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
			_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
			_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
			
			var oClasses = oSettings.oClasses;
			
			// @todo Remove in 1.11
			if ( oInit.bJQueryUI )
			{
				/* Use the JUI classes object for display. You could clone the oStdClasses object if
				 * you want to have multiple tables with multiple independent classes
				 */
				$.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );
			
				if ( oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip" )
				{
					/* Set the DOM to use a layout suitable for jQuery UI's theming */
					oSettings.sDom = '<"H"lfr>t<"F"ip>';
				}
			
				if ( ! oSettings.renderer ) {
					oSettings.renderer = 'jqueryui';
				}
				else if ( $.isPlainObject( oSettings.renderer ) && ! oSettings.renderer.header ) {
					oSettings.renderer.header = 'jqueryui';
				}
			}
			else
			{
				$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
			}
			$(this).addClass( oClasses.sTable );
			
			/* Calculate the scroll bar width and cache it for use later on */
			if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
			{
				oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
			}
			if ( oSettings.oScroll.sX === true ) { // Easy initialisation of x-scrolling
				oSettings.oScroll.sX = '100%';
			}
			
			if ( oSettings.iInitDisplayStart === undefined )
			{
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			if ( oInit.iDeferLoading !== null )
			{
				oSettings.bDeferLoading = true;
				var tmp = $.isArray( oInit.iDeferLoading );
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}
			
			/* Language definitions */
			var oLanguage = oSettings.oLanguage;
			$.extend( true, oLanguage, oInit.oLanguage );
			
			if ( oLanguage.sUrl !== "" )
			{
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				$.ajax( {
					dataType: 'json',
					url: oLanguage.sUrl,
					success: function ( json ) {
						_fnLanguageCompat( json );
						_fnCamelToHungarian( defaults.oLanguage, json );
						$.extend( true, oLanguage, json );
						_fnInitialise( oSettings );
					},
					error: function () {
						// Error occurred loading language file, continue on as best we can
						_fnInitialise( oSettings );
					}
				} );
				bInitHandedOff = true;
			}
			
			/*
			 * Stripes
			 */
			if ( oInit.asStripeClasses === null )
			{
				oSettings.asStripeClasses =[
					oClasses.sStripeOdd,
					oClasses.sStripeEven
				];
			}
			
			/* Remove row stripe classes if they are already on the table row */
			var stripeClasses = oSettings.asStripeClasses;
			var rowOne = $('tbody tr:eq(0)', this);
			if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
				return rowOne.hasClass(el);
			} ) ) !== -1 ) {
				$('tbody tr', this).removeClass( stripeClasses.join(' ') );
				oSettings.asDestroyStripes = stripeClasses.slice();
			}
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if ( nThead.length !== 0 )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[0] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			
			/* If not given a column array, generate one with nulls */
			if ( oInit.aoColumns === null )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
			{
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Apply the column definitions */
			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			
			/* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
			if ( rowOne.length ) {
				var a = function ( cell, name ) {
					return cell.getAttribute( 'data-'+name ) ? name : null;
				};
			
				$.each( _fnGetRowElements( oSettings, rowOne[0] ).cells, function (i, cell) {
					var col = oSettings.aoColumns[i];
			
					if ( col.mData === i ) {
						var sort = a( cell, 'sort' ) || a( cell, 'order' );
						var filter = a( cell, 'filter' ) || a( cell, 'search' );
			
						if ( sort !== null || filter !== null ) {
							col.mData = {
								_:      i+'.display',
								sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
								type:   sort !== null   ? i+'.@data-'+sort   : undefined,
								filter: filter !== null ? i+'.@data-'+filter : undefined
							};
			
							_fnColumnOptions( oSettings, i );
						}
					}
				} );
			}
			
			var features = oSettings.oFeatures;
			
			/* Must be done after everything which can be overridden by the state saving! */
			if ( oInit.bStateSave )
			{
				features.bStateSave = true;
				_fnLoadState( oSettings, oInit );
				_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
			}
			
			
			/*
			 * Sorting
			 * @todo For modularisation (1.11) this needs to do into a sort start up handler
			 */
			
			// If aaSorting is not defined, then we use the first indicator in asSorting
			// in case that has been altered, so the default sort reflects that option
			if ( oInit.aaSorting === undefined )
			{
				var sorting = oSettings.aaSorting;
				for ( i=0, iLen=sorting.length ; i<iLen ; i++ )
				{
					sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
				}
			}
			
			/* Do a first pass on the sorting classes (allows any size changes to be taken into
			 * account, and also will apply sorting disabled classes if disabled
			 */
			_fnSortingClasses( oSettings );
			
			if ( features.bSort )
			{
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted ) {
						var aSort = _fnSortFlatten( oSettings );
						var sortedColumns = {};
			
						$.each( aSort, function (i, val) {
							sortedColumns[ val.src ] = val.dir;
						} );
			
						_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
						_fnSortAria( oSettings );
					}
				} );
			}
			
			_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
				if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
					_fnSortingClasses( oSettings );
				}
			}, 'sc' );
			
			
			/*
			 * Final init
			 * Cache the header, body and footer as required, creating them if needed
			 */
			
			/* Browser support detection */
			_fnBrowserDetect( oSettings );
			
			// Work around for Webkit bug 83867 - store the caption-side before removing from doc
			var captions = $(this).children('caption').each( function () {
				this._captionSide = $(this).css('caption-side');
			} );
			
			var thead = $(this).children('thead');
			if ( thead.length === 0 )
			{
				thead = $('<thead/>').appendTo(this);
			}
			oSettings.nTHead = thead[0];
			
			var tbody = $(this).children('tbody');
			if ( tbody.length === 0 )
			{
				tbody = $('<tbody/>').appendTo(this);
			}
			oSettings.nTBody = tbody[0];
			
			var tfoot = $(this).children('tfoot');
			if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
			{
				// If we are a scrolling table, and no footer has been given, then we need to create
				// a tfoot element for the caption element to be appended to
				tfoot = $('<tfoot/>').appendTo(this);
			}
			
			if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
				$(this).addClass( oClasses.sNoFooter );
			}
			else if ( tfoot.length > 0 ) {
				oSettings.nTFoot = tfoot[0];
				_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
			}
			
			/* Check if there is data passing into the constructor */
			if ( oInit.aaData )
			{
				for ( i=0 ; i<oInit.aaData.length ; i++ )
				{
					_fnAddData( oSettings, oInit.aaData[ i ] );
				}
			}
			else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' )
			{
				/* Grab the data from the page - only do this when deferred loading or no Ajax
				 * source since there is no point in reading the DOM data if we are then going
				 * to replace it with Ajax data
				 */
				_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
			}
			
			/* Copy the data index array */
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			/* Initialisation complete - table can be drawn */
			oSettings.bInitialised = true;
			
			/* Check if we need to initialise the table (it might not have been handed off to the
			 * language processor)
			 */
			if ( bInitHandedOff === false )
			{
				_fnInitialise( oSettings );
			}
		} );
		_that = null;
		return this;
	};

	
	
	/**
	 * Computed structure of the DataTables API, defined by the options passed to
	 * `DataTable.Api.register()` when building the API.
	 *
	 * The structure is built in order to speed creation and extension of the Api
	 * objects since the extensions are effectively pre-parsed.
	 *
	 * The array is an array of objects with the following structure, where this
	 * base array represents the Api prototype base:
	 *
	 *     [
	 *       {
	 *         name:      'data'                -- string   - Property name
	 *         val:       function () {},       -- function - Api method (or undefined if just an object
	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	 *       },
	 *       {
	 *         name:     'row'
	 *         val:       {},
	 *         methodExt: [ ... ],
	 *         propExt:   [
	 *           {
	 *             name:      'data'
	 *             val:       function () {},
	 *             methodExt: [ ... ],
	 *             propExt:   [ ... ]
	 *           },
	 *           ...
	 *         ]
	 *       }
	 *     ]
	 *
	 * @type {Array}
	 * @ignore
	 */
	var __apiStruct = [];
	
	
	/**
	 * `Array.prototype` reference.
	 *
	 * @type object
	 * @ignore
	 */
	var __arrayProto = Array.prototype;
	
	
	/**
	 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	 * take several different forms for ease of use.
	 *
	 * Each of the input parameter types will be converted to a DataTables settings
	 * object where possible.
	 *
	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	 *   of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 *   * `DataTables.Api` - API instance
	 * @return {array|null} Matching DataTables settings objects. `null` or
	 *   `undefined` is returned if no matching DataTable is found.
	 * @ignore
	 */
	var _toSettings = function ( mixed )
	{
		var idx, jq;
		var settings = DataTable.settings;
		var tables = $.map( settings, function (el, i) {
			return el.nTable;
		} );
	
		if ( ! mixed ) {
			return [];
		}
		else if ( mixed.nTable && mixed.oApi ) {
			// DataTables settings object
			return [ mixed ];
		}
		else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
			// Table node
			idx = $.inArray( mixed, tables );
			return idx !== -1 ? [ settings[idx] ] : null;
		}
		else if ( mixed && typeof mixed.settings === 'function' ) {
			return mixed.settings().toArray();
		}
		else if ( typeof mixed === 'string' ) {
			// jQuery selector
			jq = $(mixed);
		}
		else if ( mixed instanceof $ ) {
			// jQuery object (also DataTables instance)
			jq = mixed;
		}
	
		if ( jq ) {
			return jq.map( function(i) {
				idx = $.inArray( this, tables );
				return idx !== -1 ? settings[idx] : null;
			} ).toArray();
		}
	};
	
	
	/**
	 * DataTables API class - used to control and interface with  one or more
	 * DataTables enhanced tables.
	 *
	 * The API class is heavily based on jQuery, presenting a chainable interface
	 * that you can use to interact with tables. Each instance of the API class has
	 * a "context" - i.e. the tables that it will operate on. This could be a single
	 * table, all tables on a page or a sub-set thereof.
	 *
	 * Additionally the API is designed to allow you to easily work with the data in
	 * the tables, retrieving and manipulating it as required. This is done by
	 * presenting the API class as an array like interface. The contents of the
	 * array depend upon the actions requested by each method (for example
	 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	 * return an array of objects or arrays depending upon your table's
	 * configuration). The API object has a number of array like methods (`push`,
	 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	 * `unique` etc) to assist your working with the data held in a table.
	 *
	 * Most methods (those which return an Api instance) are chainable, which means
	 * the return from a method call also has all of the methods available that the
	 * top level object had. For example, these two calls are equivalent:
	 *
	 *     // Not chained
	 *     api.row.add( {...} );
	 *     api.draw();
	 *
	 *     // Chained
	 *     api.row.add( {...} ).draw();
	 *
	 * @class DataTable.Api
	 * @param {array|object|string|jQuery} context DataTable identifier. This is
	 *   used to define which DataTables enhanced tables this API will operate on.
	 *   Can be one of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 * @param {array} [data] Data to initialise the Api instance with.
	 *
	 * @example
	 *   // Direct initialisation during DataTables construction
	 *   var api = $('#example').DataTable();
	 *
	 * @example
	 *   // Initialisation using a DataTables jQuery object
	 *   var api = $('#example').dataTable().api();
	 *
	 * @example
	 *   // Initialisation as a constructor
	 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	 */
	_Api = function ( context, data )
	{
		if ( ! this instanceof _Api ) {
			throw 'DT API must be constructed as a new object';
			// or should it do the 'new' for the caller?
			// return new _Api.apply( this, arguments );
		}
	
		var settings = [];
		var ctxSettings = function ( o ) {
			var a = _toSettings( o );
			if ( a ) {
				settings.push.apply( settings, a );
			}
		};
	
		if ( $.isArray( context ) ) {
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				ctxSettings( context[i] );
			}
		}
		else {
			ctxSettings( context );
		}
	
		// Remove duplicates
		this.context = _unique( settings );
	
		// Initial data
		if ( data ) {
			this.push.apply( this, data.toArray ? data.toArray() : data );
		}
	
		// selector
		this.selector = {
			rows: null,
			cols: null,
			opts: null
		};
	
		_Api.extend( this, this, __apiStruct );
	};
	
	DataTable.Api = _Api;
	
	_Api.prototype = /** @lends DataTables.Api */{
		/**
		 * Return a new Api instance, comprised of the data held in the current
		 * instance, join with the other array(s) and/or value(s).
		 *
		 * An alias for `Array.prototype.concat`.
		 *
		 * @type method
		 * @param {*} value1 Arrays and/or values to concatenate.
		 * @param {*} [...] Additional arrays and/or values to concatenate.
		 * @returns {DataTables.Api} New API instance, comprising of the combined
		 *   array.
		 */
		concat:  __arrayProto.concat,
	
	
		context: [], // array of table settings objects
	
	
		each: function ( fn )
		{
			for ( var i=0, ien=this.length ; i<ien; i++ ) {
				fn.call( this, this[i], i, this );
			}
	
			return this;
		},
	
	
		eq: function ( idx )
		{
			var ctx = this.context;
	
			return ctx.length > idx ?
				new _Api( ctx[idx], this[idx] ) :
				null;
		},
	
	
		filter: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.filter ) {
				a = __arrayProto.filter.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					if ( fn.call( this, this[i], i, this ) ) {
						a.push( this[i] );
					}
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		flatten: function ()
		{
			var a = [];
			return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
		},
	
	
		join:    __arrayProto.join,
	
	
		indexOf: __arrayProto.indexOf || function (obj, start)
		{
			for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
				if ( this[i] === obj ) {
					return i;
				}
			}
			return -1;
		},
	
		// Note that `alwaysNew` is internal - use iteratorNew externally
		iterator: function ( flatten, type, fn, alwaysNew ) {
			var
				a = [], ret,
				i, ien, j, jen,
				context = this.context,
				rows, items, item,
				selector = this.selector;
	
			// Argument shifting
			if ( typeof flatten === 'string' ) {
				alwaysNew = fn;
				fn = type;
				type = flatten;
				flatten = false;
			}
	
			for ( i=0, ien=context.length ; i<ien ; i++ ) {
				var apiInst = new _Api( context[i] );
	
				if ( type === 'table' ) {
					ret = fn.call( apiInst, context[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'columns' || type === 'rows' ) {
					// this has same length as context - one entry for each table
					ret = fn.call( apiInst, context[i], this[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
					// columns and rows share the same structure.
					// 'this' is an array of column indexes for each context
					items = this[i];
	
					if ( type === 'column-rows' ) {
						rows = _selector_row_indexes( context[i], selector.opts );
					}
	
					for ( j=0, jen=items.length ; j<jen ; j++ ) {
						item = items[j];
	
						if ( type === 'cell' ) {
							ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
						}
						else {
							ret = fn.call( apiInst, context[i], item, i, j, rows );
						}
	
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
				}
			}
	
			if ( a.length || alwaysNew ) {
				var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
				var apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				return api;
			}
			return this;
		},
	
	
		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
		{
			// Bit cheeky...
			return this.indexOf.apply( this.toArray.reverse(), arguments );
		},
	
	
		length:  0,
	
	
		map: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.map ) {
				a = __arrayProto.map.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					a.push( fn.call( this, this[i], i ) );
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		pluck: function ( prop )
		{
			return this.map( function ( el ) {
				return el[ prop ];
			} );
		},
	
		pop:     __arrayProto.pop,
	
	
		push:    __arrayProto.push,
	
	
		// Does not return an API instance
		reduce: __arrayProto.reduce || function ( fn, init )
		{
			return _fnReduce( this, fn, init, 0, this.length, 1 );
		},
	
	
		reduceRight: __arrayProto.reduceRight || function ( fn, init )
		{
			return _fnReduce( this, fn, init, this.length-1, -1, -1 );
		},
	
	
		reverse: __arrayProto.reverse,
	
	
		// Object with rows, columns and opts
		selector: null,
	
	
		shift:   __arrayProto.shift,
	
	
		sort:    __arrayProto.sort, // ? name - order?
	
	
		splice:  __arrayProto.splice,
	
	
		toArray: function ()
		{
			return __arrayProto.slice.call( this );
		},
	
	
		to$: function ()
		{
			return $( this );
		},
	
	
		toJQuery: function ()
		{
			return $( this );
		},
	
	
		unique: function ()
		{
			return new _Api( this.context, _unique(this) );
		},
	
	
		unshift: __arrayProto.unshift
	};
	
	
	_Api.extend = function ( scope, obj, ext )
	{
		// Only extend API instances and static properties of the API
		if ( ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
			return;
		}
	
		var
			i, ien,
			j, jen,
			struct, inner,
			methodScoping = function ( scope, fn, struc ) {
				return function () {
					var ret = fn.apply( scope, arguments );
	
					// Method extension
					_Api.extend( ret, ret, struc.methodExt );
					return ret;
				};
			};
	
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			struct = ext[i];
	
			// Value
			obj[ struct.name ] = typeof struct.val === 'function' ?
				methodScoping( scope, struct.val, struct ) :
				$.isPlainObject( struct.val ) ?
					{} :
					struct.val;
	
			obj[ struct.name ].__dt_wrapper = true;
	
			// Property extension
			_Api.extend( scope, obj[ struct.name ], struct.propExt );
		}
	};
	
	
	// @todo - Is there need for an augment function?
	// _Api.augment = function ( inst, name )
	// {
	// 	// Find src object in the structure from the name
	// 	var parts = name.split('.');
	
	// 	_Api.extend( inst, obj );
	// };
	
	
	//     [
	//       {
	//         name:      'data'                -- string   - Property name
	//         val:       function () {},       -- function - Api method (or undefined if just an object
	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	//       },
	//       {
	//         name:     'row'
	//         val:       {},
	//         methodExt: [ ... ],
	//         propExt:   [
	//           {
	//             name:      'data'
	//             val:       function () {},
	//             methodExt: [ ... ],
	//             propExt:   [ ... ]
	//           },
	//           ...
	//         ]
	//       }
	//     ]
	
	_Api.register = _api_register = function ( name, val )
	{
		if ( $.isArray( name ) ) {
			for ( var j=0, jen=name.length ; j<jen ; j++ ) {
				_Api.register( name[j], val );
			}
			return;
		}
	
		var
			i, ien,
			heir = name.split('.'),
			struct = __apiStruct,
			key, method;
	
		var find = function ( src, name ) {
			for ( var i=0, ien=src.length ; i<ien ; i++ ) {
				if ( src[i].name === name ) {
					return src[i];
				}
			}
			return null;
		};
	
		for ( i=0, ien=heir.length ; i<ien ; i++ ) {
			method = heir[i].indexOf('()') !== -1;
			key = method ?
				heir[i].replace('()', '') :
				heir[i];
	
			var src = find( struct, key );
			if ( ! src ) {
				src = {
					name:      key,
					val:       {},
					methodExt: [],
					propExt:   []
				};
				struct.push( src );
			}
	
			if ( i === ien-1 ) {
				src.val = val;
			}
			else {
				struct = method ?
					src.methodExt :
					src.propExt;
			}
		}
	};
	
	
	_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
		_Api.register( pluralName, val );
	
		_Api.register( singularName, function () {
			var ret = val.apply( this, arguments );
	
			if ( ret === this ) {
				// Returned item is the API instance that was passed in, return it
				return this;
			}
			else if ( ret instanceof _Api ) {
				// New API instance returned, want the value from the first item
				// in the returned array for the singular result.
				return ret.length ?
					$.isArray( ret[0] ) ?
						new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
						ret[0] :
					undefined;
			}
	
			// Non-API return - just fire it back
			return ret;
		} );
	};
	
	
	/**
	 * Selector for HTML tables. Apply the given selector to the give array of
	 * DataTables settings objects.
	 *
	 * @param {string|integer} [selector] jQuery selector string or integer
	 * @param  {array} Array of DataTables settings objects to be filtered
	 * @return {array}
	 * @ignore
	 */
	var __table_selector = function ( selector, a )
	{
		// Integer is used to pick out a table by index
		if ( typeof selector === 'number' ) {
			return [ a[ selector ] ];
		}
	
		// Perform a jQuery selector on the table nodes
		var nodes = $.map( a, function (el, i) {
			return el.nTable;
		} );
	
		return $(nodes)
			.filter( selector )
			.map( function (i) {
				// Need to translate back from the table node to the settings
				var idx = $.inArray( this, nodes );
				return a[ idx ];
			} )
			.toArray();
	};
	
	
	
	/**
	 * Context selector for the API's context (i.e. the tables the API instance
	 * refers to.
	 *
	 * @name    DataTable.Api#tables
	 * @param {string|integer} [selector] Selector to pick which tables the iterator
	 *   should operate on. If not given, all tables in the current context are
	 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	 *   select multiple tables or as an integer to select a single table.
	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	 */
	_api_register( 'tables()', function ( selector ) {
		// A new instance is created if there was a selector specified
		return selector ?
			new _Api( __table_selector( selector, this.context ) ) :
			this;
	} );
	
	
	_api_register( 'table()', function ( selector ) {
		var tables = this.tables( selector );
		var ctx = tables.context;
	
		// Truncate to the first matched table
		return ctx.length ?
			new _Api( ctx[0] ) :
			tables;
	} );
	
	
	_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTable;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().body()', 'table().body()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTBody;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().header()', 'table().header()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTHead;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTFoot;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTableWrapper;
		}, 1 );
	} );
	
	
	
	/**
	 * Redraw the tables in the current context.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'draw()', function ( resetPaging ) {
		return this.iterator( 'table', function ( settings ) {
			_fnReDraw( settings, resetPaging===false );
		} );
	} );
	
	
	
	/**
	 * Get the current page index.
	 *
	 * @return {integer} Current page index (zero based)
	 *//**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * `integer` - The page index to jump to
	 *  * `string` - An action to take:
	 *    * `first` - Jump to first page.
	 *    * `next` - Jump to the next page
	 *    * `previous` - Jump to previous page
	 *    * `last` - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page()', function ( action ) {
		if ( action === undefined ) {
			return this.page.info().page; // not an expensive call
		}
	
		// else, have an action to take on all tables
		return this.iterator( 'table', function ( settings ) {
			_fnPageChange( settings, action );
		} );
	} );
	
	
	/**
	 * Paging information for the first table in the current context.
	 *
	 * If you require paging information for another table, use the `table()` method
	 * with a suitable selector.
	 *
	 * @return {object} Object with the following properties set:
	 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	 *  * `pages` - Total number of pages
	 *  * `start` - Display index for the first record shown on the current page
	 *  * `end` - Display index for the last record shown on the current page
	 *  * `length` - Display length (number of records). Note that generally `start
	 *    + length = end`, but this is not always true, for example if there are
	 *    only 2 records to show on the final page, with a length of 10.
	 *  * `recordsTotal` - Full data set length
	 *  * `recordsDisplay` - Data set length once the current filtering criterion
	 *    are applied.
	 */
	_api_register( 'page.info()', function ( action ) {
		if ( this.context.length === 0 ) {
			return undefined;
		}
	
		var
			settings   = this.context[0],
			start      = settings._iDisplayStart,
			len        = settings._iDisplayLength,
			visRecords = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return {
			"page":           all ? 0 : Math.floor( start / len ),
			"pages":          all ? 1 : Math.ceil( visRecords / len ),
			"start":          start,
			"end":            settings.fnDisplayEnd(),
			"length":         len,
			"recordsTotal":   settings.fnRecordsTotal(),
			"recordsDisplay": visRecords
		};
	} );
	
	
	/**
	 * Get the current page length.
	 *
	 * @return {integer} Current page length. Note `-1` indicates that all records
	 *   are to be shown.
	 *//**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use `-1` to show all records.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page.len()', function ( len ) {
		// Note that we can't call this function 'length()' because `length`
		// is a Javascript property of functions which defines how many arguments
		// the function expects.
		if ( len === undefined ) {
			return this.context.length !== 0 ?
				this.context[0]._iDisplayLength :
				undefined;
		}
	
		// else, set the page length
		return this.iterator( 'table', function ( settings ) {
			_fnLengthChange( settings, len );
		} );
	} );
	
	
	
	var __reload = function ( settings, holdPosition, callback ) {
		if ( _fnDataSource( settings ) == 'ssp' ) {
			_fnReDraw( settings, holdPosition );
		}
		else {
			// Trigger xhr
			_fnProcessingDisplay( settings, true );
	
			_fnBuildAjax( settings, [], function( json ) {
				_fnClearTable( settings );
	
				var data = _fnAjaxDataSrc( settings, json );
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					_fnAddData( settings, data[i] );
				}
	
				_fnReDraw( settings, holdPosition );
				_fnProcessingDisplay( settings, false );
			} );
		}
	
		// Use the draw event to trigger a callback, regardless of if it is an async
		// or sync draw
		if ( callback ) {
			var api = new _Api( settings );
	
			api.one( 'draw', function () {
				callback( api.ajax.json() );
			} );
		}
	};
	
	
	/**
	 * Get the JSON response from the last Ajax request that DataTables made to the
	 * server. Note that this returns the JSON from the first table in the current
	 * context.
	 *
	 * @return {object} JSON received from the server.
	 */
	_api_register( 'ajax.json()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].json;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Get the data submitted in the last Ajax request
	 */
	_api_register( 'ajax.params()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].oAjaxData;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Reload tables from the Ajax data source. Note that this function will
	 * automatically re-draw the table when the remote data has been loaded.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
		return this.iterator( 'table', function (settings) {
			__reload( settings, resetPaging===false, callback );
		} );
	} );
	
	
	/**
	 * Get the current Ajax URL. Note that this returns the URL from the first
	 * table in the current context.
	 *
	 * @return {string} Current Ajax source URL
	 *//**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url()', function ( url ) {
		var ctx = this.context;
	
		if ( url === undefined ) {
			// get
			if ( ctx.length === 0 ) {
				return undefined;
			}
			ctx = ctx[0];
	
			return ctx.ajax ?
				$.isPlainObject( ctx.ajax ) ?
					ctx.ajax.url :
					ctx.ajax :
				ctx.sAjaxSource;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( $.isPlainObject( settings.ajax ) ) {
				settings.ajax.url = url;
			}
			else {
				settings.ajax = url;
			}
			// No need to consider sAjaxSource here since DataTables gives priority
			// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
			// value of `sAjaxSource` redundant.
		} );
	} );
	
	
	/**
	 * Load data from the newly set Ajax URL. Note that this method is only
	 * available when `ajax.url()` is used to set a URL. Additionally, this method
	 * has the same effect as calling `ajax.reload()` but is provided for
	 * convenience when setting a new URL. Like `ajax.reload()` it will
	 * automatically redraw the table once the remote data has been loaded.
	 *
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
		// Same as a reload, but makes sense to present it for easy access after a
		// url change
		return this.iterator( 'table', function ( ctx ) {
			__reload( ctx, resetPaging===false, callback );
		} );
	} );
	
	
	
	
	var _selector_run = function ( selector, select )
	{
		var
			out = [], res,
			a, i, ien, j, jen,
			selectorType = typeof selector;
	
		// Can't just check for isArray here, as an API or jQuery instance might be
		// given with their array like look
		if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
			selector = [ selector ];
		}
	
		for ( i=0, ien=selector.length ; i<ien ; i++ ) {
			a = selector[i] && selector[i].split ?
				selector[i].split(',') :
				[ selector[i] ];
	
			for ( j=0, jen=a.length ; j<jen ; j++ ) {
				res = select( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );
	
				if ( res && res.length ) {
					out.push.apply( out, res );
				}
			}
		}
	
		return out;
	};
	
	
	var _selector_opts = function ( opts )
	{
		if ( ! opts ) {
			opts = {};
		}
	
		// Backwards compatibility for 1.9- which used the terminology filter rather
		// than search
		if ( opts.filter && ! opts.search ) {
			opts.search = opts.filter;
		}
	
		return {
			search: opts.search || 'none',
			order:  opts.order  || 'current',
			page:   opts.page   || 'all'
		};
	};
	
	
	var _selector_first = function ( inst )
	{
		// Reduce the API instance to the first item found
		for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
			if ( inst[i].length > 0 ) {
				// Assign the first element to the first item in the instance
				// and truncate the instance and context
				inst[0] = inst[i];
				inst.length = 1;
				inst.context = [ inst.context[i] ];
	
				return inst;
			}
		}
	
		// Not found - return an empty instance
		inst.length = 0;
		return inst;
	};
	
	
	var _selector_row_indexes = function ( settings, opts )
	{
		var
			i, ien, tmp, a=[],
			displayFiltered = settings.aiDisplay,
			displayMaster = settings.aiDisplayMaster;
	
		var
			search = opts.search,  // none, applied, removed
			order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
			page   = opts.page;    // all, current
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			// In server-side processing mode, most options are irrelevant since
			// rows not shown don't exist and the index order is the applied order
			// Removed is a special case - for consistency just return an empty
			// array
			return search === 'removed' ?
				[] :
				_range( 0, displayMaster.length );
		}
		else if ( page == 'current' ) {
			// Current page implies that order=current and fitler=applied, since it is
			// fairly senseless otherwise, regardless of what order and search actually
			// are
			for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
				a.push( displayFiltered[i] );
			}
		}
		else if ( order == 'current' || order == 'applied' ) {
			a = search == 'none' ?
				displayMaster.slice() :                      // no search
				search == 'applied' ?
					displayFiltered.slice() :                // applied search
					$.map( displayMaster, function (el, i) { // removed search
						return $.inArray( el, displayFiltered ) === -1 ? el : null;
					} );
		}
		else if ( order == 'index' || order == 'original' ) {
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				if ( search == 'none' ) {
					a.push( i );
				}
				else { // applied | removed
					tmp = $.inArray( i, displayFiltered );
	
					if ((tmp === -1 && search == 'removed') ||
						(tmp >= 0   && search == 'applied') )
					{
						a.push( i );
					}
				}
			}
		}
	
		return a;
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
	
	
	var __row_selector = function ( settings, selector, opts )
	{
		return _selector_run( selector, function ( sel ) {
			var selInt = _intVal( sel );
			var i, ien;
	
			// Short cut - selector is a number and no options provided (default is
			// all records, so no need to check if the index is in there, since it
			// must be - dev error if the index doesn't exist).
			if ( selInt !== null && ! opts ) {
				return [ selInt ];
			}
	
			var rows = _selector_row_indexes( settings, opts );
	
			if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
				// Selector - integer
				return [ selInt ];
			}
			else if ( ! sel ) {
				// Selector - none
				return rows;
			}
	
			// Selector - function
			if ( typeof sel === 'function' ) {
				return $.map( rows, function (idx) {
					var row = settings.aoData[ idx ];
					return sel( idx, row._aData, row.nTr ) ? idx : null;
				} );
			}
	
			// Get nodes in the order from the `rows` array with null values removed
			var nodes = _removeEmpty(
				_pluck_order( settings.aoData, rows, 'nTr' )
			);
	
			// Selector - node
			if ( sel.nodeName ) {
				if ( $.inArray( sel, nodes ) !== -1 ) {
					return [ sel._DT_RowIndex ]; // sel is a TR node that is in the table
					                             // and DataTables adds a prop for fast lookup
				}
			}
	
			// Selector - jQuery selector string, array of nodes or jQuery object/
			// As jQuery's .filter() allows jQuery objects to be passed in filter,
			// it also allows arrays, so this will cope with all three options
			return $(nodes)
				.filter( sel )
				.map( function () {
					return this._DT_RowIndex;
				} )
				.toArray();
		} );
	};
	
	
	/**
	 *
	 */
	_api_register( 'rows()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __row_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in __row_selector?
		inst.selector.rows = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	
	_api_register( 'rows().nodes()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return settings.aoData[ row ].nTr || undefined;
		}, 1 );
	} );
	
	_api_register( 'rows().data()', function () {
		return this.iterator( true, 'rows', function ( settings, rows ) {
			return _pluck_order( settings.aoData, rows, '_aData' );
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
		return this.iterator( 'row', function ( settings, row ) {
			var r = settings.aoData[ row ];
			return type === 'search' ? r._aFilterData : r._aSortData;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
		return this.iterator( 'row', function ( settings, row ) {
			_fnInvalidate( settings, row, src );
		} );
	} );
	
	_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return row;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
		var that = this;
	
		return this.iterator( 'row', function ( settings, row, thatIdx ) {
			var data = settings.aoData;
	
			data.splice( row, 1 );
	
			// Update the _DT_RowIndex parameter on all rows in the table
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				if ( data[i].nTr !== null ) {
					data[i].nTr._DT_RowIndex = i;
				}
			}
	
			// Remove the target row from the search array
			var displayIndex = $.inArray( row, settings.aiDisplay );
	
			// Delete from the display arrays
			_fnDeleteIndex( settings.aiDisplayMaster, row );
			_fnDeleteIndex( settings.aiDisplay, row );
			_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
	
			// Check for an 'overflow' they case for displaying the table
			_fnLengthOverflow( settings );
		} );
	} );
	
	
	_api_register( 'rows.add()', function ( rows ) {
		var newRows = this.iterator( 'table', function ( settings ) {
				var row, i, ien;
				var out = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
						out.push( _fnAddTr( settings, row )[0] );
					}
					else {
						out.push( _fnAddData( settings, row ) );
					}
				}
	
				return out;
			}, 1 );
	
		// Return an Api.rows() extended instance, so rows().nodes() etc can be used
		var modRows = this.rows( -1 );
		modRows.pop();
		modRows.push.apply( modRows, newRows.toArray() );
	
		return modRows;
	} );
	
	
	
	
	
	/**
	 *
	 */
	_api_register( 'row()', function ( selector, opts ) {
		return _selector_first( this.rows( selector, opts ) );
	} );
	
	
	_api_register( 'row().data()', function ( data ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// Get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._aData :
				undefined;
		}
	
		// Set
		ctx[0].aoData[ this[0] ]._aData = data;
	
		// Automatically invalidate
		_fnInvalidate( ctx[0], this[0], 'data' );
	
		return this;
	} );
	
	
	_api_register( 'row().node()', function () {
		var ctx = this.context;
	
		return ctx.length && this.length ?
			ctx[0].aoData[ this[0] ].nTr || null :
			null;
	} );
	
	
	_api_register( 'row.add()', function ( row ) {
		// Allow a jQuery object to be passed in - only a single row is added from
		// it though - the first element in the set
		if ( row instanceof $ && row.length ) {
			row = row[0];
		}
	
		var rows = this.iterator( 'table', function ( settings ) {
			if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
				return _fnAddTr( settings, row )[0];
			}
			return _fnAddData( settings, row );
		} );
	
		// Return an Api.rows() extended instance, with the newly added row selected
		return this.row( rows[0] );
	} );
	
	
	
	var __details_add = function ( ctx, row, data, klass )
	{
		// Convert to array of TR elements
		var rows = [];
		var addRow = function ( r, k ) {
			// If we get a TR element, then just add it directly - up to the dev
			// to add the correct number of columns etc
			if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
				rows.push( r );
			}
			else {
				// Otherwise create a row with a wrapper
				var created = $('<tr><td/></tr>').addClass( k );
				$('td', created)
					.addClass( k )
					.html( r )
					[0].colSpan = _fnVisbleColumns( ctx );
	
				rows.push( created[0] );
			}
		};
	
		if ( $.isArray( data ) || data instanceof $ ) {
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				addRow( data[i], klass );
			}
		}
		else {
			addRow( data, klass );
		}
	
		if ( row._details ) {
			row._details.remove();
		}
	
		row._details = $(rows);
	
		// If the children were already shown, that state should be retained
		if ( row._detailsShow ) {
			row._details.insertAfter( row.nTr );
		}
	};
	
	
	var __details_remove = function ( api, idx )
	{
		var ctx = api.context;
	
		if ( ctx.length ) {
			var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
	
			if ( row._details ) {
				row._details.remove();
	
				row._detailsShow = undefined;
				row._details = undefined;
			}
		}
	};
	
	
	var __details_display = function ( api, show ) {
		var ctx = api.context;
	
		if ( ctx.length && api.length ) {
			var row = ctx[0].aoData[ api[0] ];
	
			if ( row._details ) {
				row._detailsShow = show;
	
				if ( show ) {
					row._details.insertAfter( row.nTr );
				}
				else {
					row._details.detach();
				}
	
				__details_events( ctx[0] );
			}
		}
	};
	
	
	var __details_events = function ( settings )
	{
		var api = new _Api( settings );
		var namespace = '.dt.DT_details';
		var drawEvent = 'draw'+namespace;
		var colvisEvent = 'column-visibility'+namespace;
		var destroyEvent = 'destroy'+namespace;
		var data = settings.aoData;
	
		api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
	
		if ( _pluck( data, '_details' ).length > 0 ) {
			// On each draw, insert the required elements into the document
			api.on( drawEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				api.rows( {page:'current'} ).eq(0).each( function (idx) {
					// Internal data grab
					var row = data[ idx ];
	
					if ( row._detailsShow ) {
						row._details.insertAfter( row.nTr );
					}
				} );
			} );
	
			// Column visibility change - update the colspan
			api.on( colvisEvent, function ( e, ctx, idx, vis ) {
				if ( settings !== ctx ) {
					return;
				}
	
				// Update the colspan for the details rows (note, only if it already has
				// a colspan)
				var row, visible = _fnVisbleColumns( ctx );
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					row = data[i];
	
					if ( row._details ) {
						row._details.children('td[colspan]').attr('colspan', visible );
					}
				}
			} );
	
			// Table destroyed - nuke any child rows
			api.on( destroyEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					if ( data[i]._details ) {
						__details_remove( api, i );
					}
				}
			} );
		}
	};
	
	// Strings for the method names to help minification
	var _emp = '';
	var _child_obj = _emp+'row().child';
	var _child_mth = _child_obj+'()';
	
	// data can be:
	//  tr
	//  string
	//  jQuery or array of any of the above
	_api_register( _child_mth, function ( data, klass ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._details :
				undefined;
		}
		else if ( data === true ) {
			// show
			this.child.show();
		}
		else if ( data === false ) {
			// remove
			__details_remove( this );
		}
		else if ( ctx.length && this.length ) {
			// set
			__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
		}
	
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.show()',
		_child_mth+'.show()' // only when `child()` was called with parameters (without
	], function ( show ) {   // it returns an object and this method is not executed)
		__details_display( this, true );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.hide()',
		_child_mth+'.hide()' // only when `child()` was called with parameters (without
	], function () {         // it returns an object and this method is not executed)
		__details_display( this, false );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.remove()',
		_child_mth+'.remove()' // only when `child()` was called with parameters (without
	], function () {           // it returns an object and this method is not executed)
		__details_remove( this );
		return this;
	} );
	
	
	_api_register( _child_obj+'.isShown()', function () {
		var ctx = this.context;
	
		if ( ctx.length && this.length ) {
			// _detailsShown as false or undefined will fall through to return false
			return ctx[0].aoData[ this[0] ]._detailsShow || false;
		}
		return false;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (>=0 count from left, <0 count from right)
	 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	 * "{string}:name"     - column name
	 * "{string}"          - jQuery selector on column header nodes
	 *
	 */
	
	// can be an array of these items, comma separated list, or an array of comma
	// separated lists
	
	var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
	
	
	// r1 and r2 are redundant - but it means that the parameters match for the
	// iterator callback in columns().data()
	var __columnData = function ( settings, column, r1, r2, rows ) {
		var a = [];
		for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
			a.push( _fnGetCellData( settings, rows[row], column ) );
		}
		return a;
	};
	
	
	var __column_selector = function ( settings, selector, opts )
	{
		var
			columns = settings.aoColumns,
			names = _pluck( columns, 'sName' ),
			nodes = _pluck( columns, 'nTh' );
	
		return _selector_run( selector, function ( s ) {
			var selInt = _intVal( s );
	
			// Selector - all
			if ( s === '' ) {
				return _range( columns.length );
			}
			
			// Selector - index
			if ( selInt !== null ) {
				return [ selInt >= 0 ?
					selInt : // Count from left
					columns.length + selInt // Count from right (+ because its a negative value)
				];
			}
			
			// Selector = function
			if ( typeof s === 'function' ) {
				var rows = _selector_row_indexes( settings, opts );
	
				return $.map( columns, function (col, idx) {
					return s(
							idx,
							__columnData( settings, idx, 0, 0, rows ),
							nodes[ idx ]
						) ? idx : null;
				} );
			}
	
			// jQuery or string selector
			var match = typeof s === 'string' ?
				s.match( __re_column_selector ) :
				'';
	
			if ( match ) {
				switch( match[2] ) {
					case 'visIdx':
					case 'visible':
						var idx = parseInt( match[1], 10 );
						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = $.map( columns, function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
	
					case 'name':
						// match by name. `names` is column index complete and in order
						return $.map( names, function (name, i) {
							return name === match[1] ? i : null;
						} );
				}
			}
			else {
				// jQuery selector on the TH elements for the columns
				return $( nodes )
					.filter( s )
					.map( function () {
						return $.inArray( this, nodes ); // `nodes` is column index complete and in order
					} )
					.toArray();
			}
		} );
	};
	
	
	var __setColumnVis = function ( settings, column, vis, recalc ) {
		var
			cols = settings.aoColumns,
			col  = cols[ column ],
			data = settings.aoData,
			row, cells, i, ien, tr;
	
		// Get
		if ( vis === undefined ) {
			return col.bVisible;
		}
	
		// Set
		// No change
		if ( col.bVisible === vis ) {
			return;
		}
	
		if ( vis ) {
			// Insert column
			// Need to decide if we should use appendChild or insertBefore
			var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
	
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				tr = data[i].nTr;
				cells = data[i].anCells;
	
				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
		else {
			// Remove column
			$( _pluck( settings.aoData, 'anCells', column ) ).detach();
		}
	
		// Common actions
		col.bVisible = vis;
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		if ( recalc === undefined || recalc ) {
			// Automatically adjust column sizing
			_fnAdjustColumnSizing( settings );
	
			// Realign columns for scrolling
			if ( settings.oScroll.sX || settings.oScroll.sY ) {
				_fnScrollDraw( settings );
			}
		}
	
		_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis] );
	
		_fnSaveState( settings );
	};
	
	
	/**
	 *
	 */
	_api_register( 'columns()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __column_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in _row_selector?
		inst.selector.cols = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	
	/**
	 *
	 */
	_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTh;
		}, 1 );
	} );
	
	
	/**
	 *
	 */
	_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTf;
		}, 1 );
	} );
	
	
	/**
	 *
	 */
	_api_registerPlural( 'columns().data()', 'column().data()', function () {
		return this.iterator( 'column-rows', __columnData, 1 );
	} );
	
	
	_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].mData;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows,
				type === 'search' ? '_aFilterData' : '_aSortData', column
			);
		}, 1 );
	} );
	
	
	_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
		}, 1 );
	} );
	
	
	
	_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
		return this.iterator( 'column', function ( settings, column ) {
			if ( vis === undefined ) {
				return settings.aoColumns[ column ].bVisible;
			} // else
			__setColumnVis( settings, column, vis, calc );
		} );
	} );
	
	
	
	_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
		return this.iterator( 'column', function ( settings, column ) {
			return type === 'visible' ?
				_fnColumnIndexToVisible( settings, column ) :
				column;
		}, 1 );
	} );
	
	
	// _api_register( 'columns().show()', function () {
	// 	var selector = this.selector;
	// 	return this.columns( selector.cols, selector.opts ).visible( true );
	// } );
	
	
	// _api_register( 'columns().hide()', function () {
	// 	var selector = this.selector;
	// 	return this.columns( selector.cols, selector.opts ).visible( false );
	// } );
	
	
	
	_api_register( 'columns.adjust()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnAdjustColumnSizing( settings );
		}, 1 );
	} );
	
	
	// Convert from one column index type, to another type
	_api_register( 'column.index()', function ( type, idx ) {
		if ( this.context.length !== 0 ) {
			var ctx = this.context[0];
	
			if ( type === 'fromVisible' || type === 'toData' ) {
				return _fnVisibleToColumnIndex( ctx, idx );
			}
			else if ( type === 'fromData' || type === 'toVisible' ) {
				return _fnColumnIndexToVisible( ctx, idx );
			}
		}
	} );
	
	
	_api_register( 'column()', function ( selector, opts ) {
		return _selector_first( this.columns( selector, opts ) );
	} );
	
	
	
	
	var __cell_selector = function ( settings, selector, opts )
	{
		var data = settings.aoData;
		var rows = _selector_row_indexes( settings, opts );
		var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
		var allCells = $( [].concat.apply([], cells) );
		var row;
		var columns = settings.aoColumns.length;
		var a, i, ien, j, o, host;
	
		return _selector_run( selector, function ( s ) {
			var fnSelector = typeof s === 'function';
	
			if ( s === null || s === undefined || fnSelector ) {
				// All cells and function selectors
				a = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					for ( j=0 ; j<columns ; j++ ) {
						o = {
							row: row,
							column: j
						};
	
						if ( fnSelector ) {
							// Selector - function
							host = settings.aoData[ row ];
	
							if ( s( o, _fnGetCellData(settings, row, j), host.anCells[j] ) ) {
								a.push( o );
							}
						}
						else {
							// Selector - all
							a.push( o );
						}
					}
				}
	
				return a;
			}
			
			// Selector - index
			if ( $.isPlainObject( s ) ) {
				return [s];
			}
	
			// Selector - jQuery filtered cells
			return allCells
				.filter( s )
				.map( function (i, el) {
					row = el.parentNode._DT_RowIndex;
	
					return {
						row: row,
						column: $.inArray( el, data[ row ].anCells )
					};
				} )
				.toArray();
		} );
	};
	
	
	
	
	_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
		// Argument shifting
		if ( $.isPlainObject( rowSelector ) ) {
			// Indexes
			if ( typeof rowSelector.row !== undefined ) {
				opts = columnSelector;
				columnSelector = null;
			}
			else {
				opts = rowSelector;
				rowSelector = null;
			}
		}
		if ( $.isPlainObject( columnSelector ) ) {
			opts = columnSelector;
			columnSelector = null;
		}
	
		// Cell selector
		if ( columnSelector === null || columnSelector === undefined ) {
			return this.iterator( 'table', function ( settings ) {
				return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
			} );
		}
	
		// Row + column selector
		var columns = this.columns( columnSelector, opts );
		var rows = this.rows( rowSelector, opts );
		var a, i, ien, j, jen;
	
		var cells = this.iterator( 'table', function ( settings, idx ) {
			a = [];
	
			for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
				for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
					a.push( {
						row:    rows[idx][i],
						column: columns[idx][j]
					} );
				}
			}
	
			return a;
		}, 1 );
	
		$.extend( cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		} );
	
		return cells;
	} );
	
	
	_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			var cells = settings.aoData[ row ].anCells;
			return cells ?
				cells[ column ] :
				undefined;
		}, 1 );
	} );
	
	
	_api_register( 'cells().data()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
		type = type === 'search' ? '_aFilterData' : '_aSortData';
	
		return this.iterator( 'cell', function ( settings, row, column ) {
			return settings.aoData[ row ][ type ][ column ];
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column, type );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible( settings, column )
			};
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			_fnInvalidate( settings, row, src, column );
		} );
	} );
	
	
	
	_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
		return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
	} );
	
	
	_api_register( 'cell().data()', function ( data ) {
		var ctx = this.context;
		var cell = this[0];
	
		if ( data === undefined ) {
			// Get
			return ctx.length && cell.length ?
				_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
				undefined;
		}
	
		// Set
		_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
		_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
	
		return this;
	} );
	
	
	
	/**
	 * Get current ordering (sorting) that has been applied to the table.
	 *
	 * @returns {array} 2D array containing the sorting information for the first
	 *   table in the current context. Each element in the parent array represents
	 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	 *   the column index that the sorting condition applies to, the second is the
	 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	 *   index of the sorting order from the `column.sorting` initialisation array.
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order()', function ( order, dir ) {
		var ctx = this.context;
	
		if ( order === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].aaSorting :
				undefined;
		}
	
		// set
		if ( typeof order === 'number' ) {
			// Simple column / direction passed in
			order = [ [ order, dir ] ];
		}
		else if ( ! $.isArray( order[0] ) ) {
			// Arguments passed in (list of 1D arrays)
			order = Array.prototype.slice.call( arguments );
		}
		// otherwise a 2D array was passed in
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSorting = order.slice();
		} );
	} );
	
	
	/**
	 * Attach a sort listener to an element for a given column
	 *
	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	 *   listener to. This can take the form of a single DOM node, a jQuery
	 *   collection of nodes or a jQuery selector which will identify the node(s).
	 * @param {integer} column the column that a click on this node will sort on
	 * @param {function} [callback] callback function when sort is run
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order.listener()', function ( node, column, callback ) {
		return this.iterator( 'table', function ( settings ) {
			_fnSortAttachListener( settings, node, column, callback );
		} );
	} );
	
	
	// Order by the selected column(s)
	_api_register( [
		'columns().order()',
		'column().order()'
	], function ( dir ) {
		var that = this;
	
		return this.iterator( 'table', function ( settings, i ) {
			var sort = [];
	
			$.each( that[i], function (j, col) {
				sort.push( [ col, dir ] );
			} );
	
			settings.aaSorting = sort;
		} );
	} );
	
	
	
	_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
		var ctx = this.context;
	
		if ( input === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].oPreviousSearch.sSearch :
				undefined;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}
	
			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
				"sSearch": input+"",
				"bRegex":  regex === null ? false : regex,
				"bSmart":  smart === null ? true  : smart,
				"bCaseInsensitive": caseInsen === null ? true : caseInsen
			} ), 1 );
		} );
	} );
	
	
	_api_registerPlural(
		'columns().search()',
		'column().search()',
		function ( input, regex, smart, caseInsen ) {
			return this.iterator( 'column', function ( settings, column ) {
				var preSearch = settings.aoPreSearchCols;
	
				if ( input === undefined ) {
					// get
					return preSearch[ column ].sSearch;
				}
	
				// set
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
	
				$.extend( preSearch[ column ], {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} );
	
				_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
			} );
		}
	);
	
	/*
	 * State API methods
	 */
	
	_api_register( 'state()', function () {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	} );
	
	
	_api_register( 'state.clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			// Save an empty object
			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
		} );
	} );
	
	
	_api_register( 'state.loaded()', function () {
		return this.context.length ?
			this.context[0].oLoadedState :
			null;
	} );
	
	
	_api_register( 'state.save()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnSaveState( settings );
		} );
	} );
	
	
	
	/**
	 * Provide a common method for plug-ins to check the version of DataTables being
	 * used, in order to ensure compatibility.
	 *
	 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	 *    Note that the formats "X" and "X.Y" are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to
	 *    the required version, or false if this version of DataTales is not
	 *    suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	 */
	DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
	{
		var aThis = DataTable.version.split('.');
		var aThat = version.split('.');
		var iThis, iThat;
	
		for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
			iThis = parseInt( aThis[i], 10 ) || 0;
			iThat = parseInt( aThat[i], 10 ) || 0;
	
			// Parts are the same, keep comparing
			if (iThis === iThat) {
				continue;
			}
	
			// Parts are different, return immediately
			return iThis > iThat;
		}
	
		return true;
	};
	
	
	/**
	 * Check if a `<table>` node is a DataTable table already or not.
	 *
	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	 *      selector for the table to test. Note that if more than more than one
	 *      table is passed on, only the first will be checked
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	 *      $('#example').dataTable();
	 *    }
	 */
	DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
	{
		var t = $(table).get(0);
		var is = false;
	
		$.each( DataTable.settings, function (i, o) {
			if ( o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t ) {
				is = true;
			}
		} );
	
		return is;
	};
	
	
	/**
	 * Get all DataTable tables that have been initialised - optionally you can
	 * select to get only currently visible tables.
	 *
	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	 *    or visible tables only.
	 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	 *    DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    $.each( $.fn.dataTable.tables(true), function () {
	 *      $(table).DataTable().columns.adjust();
	 *    } );
	 */
	DataTable.tables = DataTable.fnTables = function ( visible )
	{
		return $.map( DataTable.settings, function (o) {
			if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
				return o.nTable;
			}
		} );
	};
	
	
	/**
	 * DataTables utility methods
	 * 
	 * This namespace provides helper methods that DataTables uses internally to
	 * create a DataTable, but which are not exclusively used only for DataTables.
	 * These methods can be used by extension authors to save the duplication of
	 * code.
	 *
	 *  @namespace
	 */
	DataTable.util = {
		/**
		 * Throttle the calls to a function. Arguments and context are maintained
		 * for the throttled function.
		 *
		 * @param {function} fn Function to be called
		 * @param {integer} freq Call frequency in mS
		 * @return {function} Wrapped function
		 */
		throttle: _fnThrottle,
	
	
		/**
		 * Escape a string such that it can be used in a regular expression
		 *
		 *  @param {string} sVal string to escape
		 *  @returns {string} escaped string
		 */
		escapeRegex: _fnEscapeRegex
	};
	
	
	/**
	 * Convert from camel case parameters to Hungarian notation. This is made public
	 * for the extensions to provide the same ability as DataTables core to accept
	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	 * parameters.
	 *
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 */
	DataTable.camelToHungarian = _fnCamelToHungarian;
	
	
	
	/**
	 *
	 */
	_api_register( '$()', function ( selector, opts ) {
		var
			rows   = this.rows( opts ).nodes(), // Get all rows
			jqRows = $(rows);
	
		return $( [].concat(
			jqRows.filter( selector ).toArray(),
			jqRows.find( selector ).toArray()
		) );
	} );
	
	
	// jQuery functions to operate on the tables
	$.each( [ 'on', 'one', 'off' ], function (i, key) {
		_api_register( key+'()', function ( /* event, handler */ ) {
			var args = Array.prototype.slice.call(arguments);
	
			// Add the `dt` namespace automatically if it isn't already present
			if ( ! args[0].match(/\.dt\b/) ) {
				args[0] += '.dt';
			}
	
			var inst = $( this.tables().nodes() );
			inst[key].apply( inst, args );
			return this;
		} );
	} );
	
	
	_api_register( 'clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnClearTable( settings );
		} );
	} );
	
	
	_api_register( 'settings()', function () {
		return new _Api( this.context, this.context );
	} );
	
	
	_api_register( 'data()', function () {
		return this.iterator( 'table', function ( settings ) {
			return _pluck( settings.aoData, '_aData' );
		} ).flatten();
	} );
	
	
	_api_register( 'destroy()', function ( remove ) {
		remove = remove || false;
	
		return this.iterator( 'table', function ( settings ) {
			var orig      = settings.nTableWrapper.parentNode;
			var classes   = settings.oClasses;
			var table     = settings.nTable;
			var tbody     = settings.nTBody;
			var thead     = settings.nTHead;
			var tfoot     = settings.nTFoot;
			var jqTable   = $(table);
			var jqTbody   = $(tbody);
			var jqWrapper = $(settings.nTableWrapper);
			var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
			var i, ien;
	
			// Flag to note that the table is currently being destroyed - no action
			// should be taken
			settings.bDestroying = true;
	
			// Fire off the destroy callbacks for plug-ins etc
			_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
	
			// If not being removed from the document, make all columns visible
			if ( ! remove ) {
				new _Api( settings ).columns().visible( true );
			}
	
			// Blitz all `DT` namespaced events (these are internal events, the
			// lowercase, `dt` events are user subscribed and they are responsible
			// for removing them
			jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
			$(window).unbind('.DT-'+settings.sInstance);
	
			// When scrolling we had to break the table up - restore it
			if ( table != thead.parentNode ) {
				jqTable.children('thead').detach();
				jqTable.append( thead );
			}
	
			if ( tfoot && table != tfoot.parentNode ) {
				jqTable.children('tfoot').detach();
				jqTable.append( tfoot );
			}
	
			// Remove the DataTables generated nodes, events and classes
			jqTable.detach();
			jqWrapper.detach();
	
			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses( settings );
	
			$( rows ).removeClass( settings.asStripeClasses.join(' ') );
	
			$('th, td', thead).removeClass( classes.sSortable+' '+
				classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
			);
	
			if ( settings.bJUI ) {
				$('th span.'+classes.sSortIcon+ ', td span.'+classes.sSortIcon, thead).detach();
				$('th, td', thead).each( function () {
					var wrapper = $('div.'+classes.sSortJUIWrapper, this);
					$(this).append( wrapper.contents() );
					wrapper.detach();
				} );
			}
	
			if ( ! remove && orig ) {
				// insertBefore acts like appendChild if !arg[1]
				orig.insertBefore( table, settings.nTableReinsertBefore );
			}
	
			// Add the TR elements back into the table in their original order
			jqTbody.children().detach();
			jqTbody.append( rows );
	
			// Restore the width of the original table - was read from the style property,
			// so we can restore directly to that
			jqTable
				.css( 'width', settings.sDestroyWidth )
				.removeClass( classes.sTable );
	
			// If the were originally stripe classes - then we add them back here.
			// Note this is not fool proof (for example if not all rows had stripe
			// classes - but it's a good effort without getting carried away
			ien = settings.asDestroyStripes.length;
	
			if ( ien ) {
				jqTbody.children().each( function (i) {
					$(this).addClass( settings.asDestroyStripes[i % ien] );
				} );
			}
	
			/* Remove the settings object from the settings array */
			var idx = $.inArray( settings, DataTable.settings );
			if ( idx !== -1 ) {
				DataTable.settings.splice( idx, 1 );
			}
		} );
	} );
	

	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	 * only for non-release builds. See http://semver.org/ for more information.
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = "1.10.4";

	/**
	 * Private data store, containing all of the settings objects that are
	 * created for the tables on a given page.
	 *
	 * Note that the `DataTable.settings` object is aliased to
	 * `jQuery.fn.dataTableExt` through which it may be accessed and
	 * manipulated, or `jQuery.fn.dataTable.settings`.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];

	/**
	 * Object models container, for the various models that DataTables has
	 * available to it. These models define the objects that are used to hold
	 * the active state and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		"bCaseInsensitive": true,
	
		/**
		 * Applied search term
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sSearch": "",
	
		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		"bRegex": false,
	
		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		"bSmart": true
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		"nTr": null,
	
		/**
		 * Array of TD elements for each row. This is null until the row has been
		 * created.
		 *  @type array nodes
		 *  @default []
		 */
		"anCells": null,
	
		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mData options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		"_aData": [],
	
		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aSortData": null,
	
		/**
		 * Per cell filtering data cache. As per the sort data cache, used to
		 * increase the performance of the filtering in DataTables
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aFilterData": null,
	
		/**
		 * Filtering data cache. This is the same as the cell filtering cache, but
		 * in this case a string rather than an array. This is easily computed with
		 * a join on `_aFilterData`, but is provided as a cache so the join isn't
		 * needed on every search (memory traded for performance)
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_sFilterRow": null,
	
		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @private
		 */
		"_sRowStripe": "",
	
		/**
		 * Denote if the original data source was from the DOM, or the data source
		 * object. This is used for invalidating data, so DataTables can
		 * automatically read data from the original source, unless uninstructed
		 * otherwise.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"src": null
	};
	
	
	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 *
	 * Note that this object is related to {@link DataTable.defaults.column}
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * Column index. This could be worked out on-the-fly with $.inArray, but it
		 * is faster to just hold it as a variable
		 *  @type integer
		 *  @default null
		 */
		"idx": null,
	
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn't need to be the case).
		 *  @type array
		 */
		"aDataSort": null,
	
		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		"asSorting": null,
	
		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		"bSearchable": null,
	
		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		"bSortable": null,
	
		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		"bVisible": null,
	
		/**
		 * Store for manual type assignment using the `column.type` option. This
		 * is held in store so we can manipulate the column's `sType` property.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"_sManualType": null,
	
		/**
		 * Flag to indicate if HTML5 data attributes should be used as the data
		 * source for filtering or sorting. True is either are.
		 *  @type boolean
		 *  @default false
		 *  @private
		 */
		"_bAttrSrc": false,
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		"fnCreatedCell": null,
	
		/**
		 * Function to get data from a cell in a column. You should <b>never</b>
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mData to function as
		 * required. This function is automatically assigned by the column
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get -
		 *    'display', 'type' 'filter' 'sort'
		 *  @returns {*} The data for the cell from the given row's data
		 *  @default null
		 */
		"fnGetData": null,
	
		/**
		 * Function to set data for a cell in the column. You should <b>never</b>
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mData to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		"fnSetData": null,
	
		/**
		 * Property to read the value for the cells in the column from the data
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mData": null,
	
		/**
		 * Partner property to mData which is used (only when defined) to get
		 * the data - i.e. it is basically the same as mData, but without the
		 * 'set' option, and also the data fed to it is the result from mData.
		 * This is the rendering method to match the data method of mData.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mRender": null,
	
		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		"nTh": null,
	
		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used
		 * in DataTables as such, but can be used for plug-ins to reference the
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		"nTf": null,
	
		/**
		 * The class to apply to all TD elements in the table's TBODY for the column
		 *  @type string
		 *  @default null
		 */
		"sClass": null,
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		"sContentPadding": null,
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		"sDefaultContent": null,
	
		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		"sName": null,
	
		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		"sSortDataType": 'std',
	
		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		"sSortingClass": null,
	
		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		"sSortingClassJUI": null,
	
		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		"sTitle": null,
	
		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		"sType": null,
	
		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		"sWidth": null,
	
		/**
		 * Width of the column when it was first "encountered"
		 *  @type string
		 *  @default null
		 */
		"sWidthOrig": null
	};
	
	
	/*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would at around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit.
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
	
	/**
	 * Initialisation options that can be given to DataTables at initialisation
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.data
		 *
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine" },
		 *          { "title": "Browser" },
		 *          { "title": "Platform" },
		 *          { "title": "Version" },
		 *          { "title": "Grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using an array of objects as a data source (`data`)
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine",   "data": "engine" },
		 *          { "title": "Browser",  "data": "browser" },
		 *          { "title": "Platform", "data": "platform" },
		 *          { "title": "Version",  "data": "version" },
		 *          { "title": "Grade",    "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"aaData": null,
	
	
		/**
		 * If ordering is enabled, then DataTables will perform a first pass sort on
		 * initialisation. You can define which column(s) the sort is performed
		 * upon, and the sorting direction, with this variable. The `sorting` array
		 * should contain an array for each column to be sorted initially containing
		 * the column's index and a direction string ('asc' or 'desc').
		 *  @type array
		 *  @default [[0,'asc']]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.order
		 *
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
		 *
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": []
		 *      } );
		 *    } );
		 */
		"aaSorting": [[0,'asc']],
	
	
		/**
		 * This parameter is basically identical to the `sorting` parameter, but
		 * cannot be overridden by user interaction with the table. What this means
		 * is that you could have a column (visible or hidden) which the sorting
		 * will always be forced on first - any sorting after that (from the user)
		 * will then be performed as required. This can be useful for grouping rows
		 * together.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.orderFixed
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderFixed": [[0,'asc']]
		 *      } );
		 *    } )
		 */
		"aaSortingFixed": [],
	
	
		/**
		 * DataTables can be instructed to load data to display in the table from a
		 * Ajax source. This option defines how that Ajax call is made and where to.
		 *
		 * The `ajax` property has three different modes of operation, depending on
		 * how it is defined. These are:
		 *
		 * * `string` - Set the URL from where the data should be loaded from.
		 * * `object` - Define properties for `jQuery.ajax`.
		 * * `function` - Custom data get function
		 *
		 * `string`
		 * --------
		 *
		 * As a string, the `ajax` property simply defines the URL from which
		 * DataTables will load data.
		 *
		 * `object`
		 * --------
		 *
		 * As an object, the parameters in the object are passed to
		 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
		 * of the Ajax request. DataTables has a number of default parameters which
		 * you can override using this option. Please refer to the jQuery
		 * documentation for a full description of the options available, although
		 * the following parameters provide additional options in DataTables or
		 * require special consideration:
		 *
		 * * `data` - As with jQuery, `data` can be provided as an object, but it
		 *   can also be used as a function to manipulate the data DataTables sends
		 *   to the server. The function takes a single parameter, an object of
		 *   parameters with the values that DataTables has readied for sending. An
		 *   object may be returned which will be merged into the DataTables
		 *   defaults, or you can add the items to the object that was passed in and
		 *   not return anything from the function. This supersedes `fnServerParams`
		 *   from DataTables 1.9-.
		 *
		 * * `dataSrc` - By default DataTables will look for the property `data` (or
		 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
		 *   from an Ajax source or for server-side processing - this parameter
		 *   allows that property to be changed. You can use Javascript dotted
		 *   object notation to get a data source for multiple levels of nesting, or
		 *   it my be used as a function. As a function it takes a single parameter,
		 *   the JSON returned from the server, which can be manipulated as
		 *   required, with the returned value being that used by DataTables as the
		 *   data source for the table. This supersedes `sAjaxDataProp` from
		 *   DataTables 1.9-.
		 *
		 * * `success` - Should not be overridden it is used internally in
		 *   DataTables. To manipulate / transform the data returned by the server
		 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
		 *
		 * `function`
		 * ----------
		 *
		 * As a function, making the Ajax call is left up to yourself allowing
		 * complete control of the Ajax request. Indeed, if desired, a method other
		 * than Ajax could be used to obtain the required data, such as Web storage
		 * or an AIR database.
		 *
		 * The function is given four parameters and no return is required. The
		 * parameters are:
		 *
		 * 1. _object_ - Data to send to the server
		 * 2. _function_ - Callback function that must be executed when the required
		 *    data has been obtained. That data should be passed into the callback
		 *    as the only parameter
		 * 3. _object_ - DataTables settings object for the table
		 *
		 * Note that this supersedes `fnServerData` from DataTables 1.9-.
		 *
		 *  @type string|object|function
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.ajax
		 *  @since 1.10.0
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax.
		 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
		 *   $('#example').dataTable( {
		 *     "ajax": "data.json"
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
		 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": "tableData"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
		 *   // from a plain array rather than an array in an object
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": ""
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Manipulate the data returned from the server - add a link to data
		 *   // (note this can, should, be done using `render` for the column - this
		 *   // is just a simple example of how the data can be manipulated).
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": function ( json ) {
		 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
		 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
		 *         }
		 *         return json;
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Add data to the request
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "data": function ( d ) {
		 *         return {
		 *           "extra_search": $('#extra').val()
		 *         };
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Send request as POST
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "type": "POST"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get the data from localStorage (could interface with a form for
		 *   // adding, editing and removing rows).
		 *   $('#example').dataTable( {
		 *     "ajax": function (data, callback, settings) {
		 *       callback(
		 *         JSON.parse( localStorage.getItem('dataTablesData') )
		 *       );
		 *     }
		 *   } );
		 */
		"ajax": null,
	
	
		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be
		 * either a 1D array of options which will be used for both the displayed
		 * option and the value, or a 2D array which will use the array in the first
		 * position as the value, and the array in the second position as the
		 * displayed options (useful for language strings such as 'All').
		 *
		 * Note that the `pageLength` property will be automatically set to the
		 * first value given in this array, unless `pageLength` is also provided.
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.lengthMenu
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
		 */
		"aLengthMenu": [ 10, 25, 50, 100 ],
	
	
		/**
		 * The `columns` option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see
		 * {@link DataTable.defaults.column}. Note that if you use `columns` to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don't which
		 * to specify any options).
		 *  @member
		 *
		 *  @name DataTable.defaults.column
		 */
		"aoColumns": null,
	
		/**
		 * Very similar to `columns`, `columnDefs` allows you to target a specific
		 * column, multiple columns, or all columns, using the `targets` property of
		 * each object in the array. This allows great flexibility when creating
		 * tables, as the `columnDefs` arrays can be of any length, targeting the
		 * columns you specifically want. `columnDefs` may use any of the column
		 * options available: {@link DataTable.defaults.column}, but it _must_
		 * have `targets` defined in each object in the array. Values in the `targets`
		 * array may be:
		 *   <ul>
		 *     <li>a string - class name will be matched on the TH for the column</li>
		 *     <li>0 or a positive integer - column index counting from the left</li>
		 *     <li>a negative integer - column index counting from the right</li>
		 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
		 *   </ul>
		 *  @member
		 *
		 *  @name DataTable.defaults.columnDefs
		 */
		"aoColumnDefs": null,
	
	
		/**
		 * Basically the same as `search`, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size
		 * as the number of columns, and each element be an object with the parameters
		 * `search` and `escapeRegex` (the latter is optional). 'null' is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.searchCols
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchCols": [
		 *          null,
		 *          { "search": "My filter" },
		 *          null,
		 *          { "search": "^[0-9]", "escapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
		 */
		"aoSearchCols": [],
	
	
		/**
		 * An array of CSS classes that should be applied to displayed rows. This
		 * array may be of any length, and DataTables will apply each class
		 * sequentially, looping when required.
		 *  @type array
		 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
		 *    options</i>
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.stripeClasses
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
		 */
		"asStripeClasses": null,
	
	
		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using `columns`.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.autoWidth
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "autoWidth": false
		 *      } );
		 *    } );
		 */
		"bAutoWidth": true,
	
	
		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.deferRender
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajax": "sources/arrays.txt",
		 *        "deferRender": true
		 *      } );
		 *    } );
		 */
		"bDeferRender": false,
	
	
		/**
		 * Replace a DataTable which matches the given selector and replace it with
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.destroy
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "srollY": "200px",
		 *        "paginate": false
		 *      } );
		 *
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "filter": false,
		 *        "destroy": true
		 *      } );
		 *    } );
		 */
		"bDestroy": false,
	
	
		/**
		 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain 'true' - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * {@link DataTable.defaults.dom}.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.searching
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "searching": false
		 *      } );
		 *    } );
		 */
		"bFilter": true,
	
	
		/**
		 * Enable or disable the table information display. This shows information
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.info
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "info": false
		 *      } );
		 *    } );
		 */
		"bInfo": true,
	
	
		/**
		 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
		 * slightly different and additional mark-up from what DataTables has
		 * traditionally used).
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.jQueryUI
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "jQueryUI": true
		 *      } );
		 *    } );
		 */
		"bJQueryUI": false,
	
	
		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.lengthChange
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "lengthChange": false
		 *      } );
		 *    } );
		 */
		"bLengthChange": true,
	
	
		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.paging
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "paging": false
		 *      } );
		 *    } );
		 */
		"bPaginate": true,
	
	
		/**
		 * Enable or disable the display of a 'processing' indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.processing
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "processing": true
		 *      } );
		 *    } );
		 */
		"bProcessing": false,
	
	
		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). `destroy` can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.retrieve
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *
		 *    function initTable ()
		 *    {
		 *      return $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false,
		 *        "retrieve": true
		 *      } );
		 *    }
		 *
		 *    function tableActions ()
		 *    {
		 *      var table = initTable();
		 *      // perform API operations with oTable
		 *    }
		 */
		"bRetrieve": false,
	
	
		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table's viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left "floating" further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table's viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollCollapse
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200",
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"bScrollCollapse": false,
	
	
		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * `ajax` parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverSide
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "xhr.php"
		 *      } );
		 *    } );
		 */
		"bServerSide": false,
	
	
		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the `sortable` option for each column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.ordering
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "ordering": false
		 *      } );
		 *    } );
		 */
		"bSort": true,
	
	
		/**
		 * Enable or display DataTables' ability to sort multiple columns at the
		 * same time (activated by shift-click by the user).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderMulti
		 *
		 *  @example
		 *    // Disable multiple column sorting ability
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderMulti": false
		 *      } );
		 *    } );
		 */
		"bSortMulti": true,
	
	
		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderCellsTop
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderCellsTop": true
		 *      } );
		 *    } );
		 */
		"bSortCellsTop": false,
	
	
		/**
		 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
		 * `sorting\_3` to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.orderClasses
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderClasses": false
		 *      } );
		 *    } );
		 */
		"bSortClasses": true,
	
	
		/**
		 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
		 * used to save table display information such as pagination information,
		 * display length, filtering and sorting. As such when the end user reloads
		 * the page the display display will match what thy had previously set up.
		 *
		 * Due to the use of `localStorage` the default state saving is not supported
		 * in IE6 or 7. If state saving is required in those browsers, use
		 * `stateSaveCallback` to provide a storage solution such as cookies.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.stateSave
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "stateSave": true
		 *      } );
		 *    } );
		 */
		"bStateSave": false,
	
	
		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} dataIndex The index of this row in the internal aoData array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.createdRow
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "createdRow": function( row, data, dataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" )
		 *          {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCreatedRow": null,
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.drawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "drawCallback": function( settings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnDrawCallback": null,
	
	
		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every 'draw' event.
		 *  @type function
		 *  @param {node} foot "TR" element for the footer
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.footerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "footerCallback": function( tfoot, data, start, end, display ) {
		 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
		 *        }
		 *      } );
		 *    } )
		 */
		"fnFooterCallback": null,
	
	
		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
		 * to have a comma separator for the 'thousands' units (e.g. 1 million is
		 * rendered as "1,000,000") to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} toFormat number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.formatNumber
		 *
		 *  @example
		 *    // Format a number using a single quote for the separator (note that
		 *    // this can also be done with the language.thousands option)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "formatNumber": function ( toFormat ) {
		 *          return toFormat.toString().replace(
		 *            /\B(?=(\d{3})+(?!\d))/g, "'"
		 *          );
		 *        };
		 *      } );
		 *    } );
		 */
		"fnFormatNumber": function ( toFormat ) {
			return toFormat.toString().replace(
				/\B(?=(\d{3})+(?!\d))/g,
				this.oLanguage.sThousands
			);
		},
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} head "TR" element for the header
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.headerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fheaderCallback": function( head, data, start, end, display ) {
		 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
		 *        }
		 *      } );
		 *    } )
		 */
		"fnHeaderCallback": null,
	
	
		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} start Starting position in data for the draw
		 *  @param {int} end End position in data for the draw
		 *  @param {int} max Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} total Total number of rows in the data set, after filtering
		 *  @param {string} pre The string that DataTables has formatted using it's
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.infoCallback
		 *
		 *  @example
		 *    $('#example').dataTable( {
		 *      "infoCallback": function( settings, start, end, max, total, pre ) {
		 *        return start +" to "+ end;
		 *      }
		 *    } );
		 */
		"fnInfoCallback": null,
	
	
		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.initComplete
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "initComplete": function(settings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
		 */
		"fnInitComplete": null,
	
	
		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.preDrawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "preDrawCallback": function( settings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnPreDrawCallback": null,
	
	
		/**
		 * This function allows you to 'post process' each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} displayIndex The display index for the current table draw
		 *  @param {int} displayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.rowCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" ) {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnRowCallback": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * This parameter allows you to override the default function which obtains
		 * the data from the server so something more suitable for your application.
		 * For example you could use POST data, or pull information from a Gears or
		 * AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} source HTTP source to obtain the data from (`ajax`)
		 *  @param {array} data A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} callback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverData
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerData": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 *  It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} data Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the data array passed in,
		 *    as this is passed by reference.
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverParams
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerParams": null,
	
	
		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @return {object} The DataTables state object to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadCallback": function (settings) {
		 *          var o;
		 *
		 *          // Send an Ajax request to the server to get the data. Note that
		 *          // this is a synchronous request.
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "async": false,
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              o = json;
		 *            }
		 *          } );
		 *
		 *          return o;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadCallback": function ( settings ) {
			try {
				return JSON.parse(
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname
					)
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for
		 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
		 * a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that is to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadParams": null,
	
	
		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that was loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoaded
		 *
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoaded": function (settings, data) {
		 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoaded": null,
	
	
		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored By default DataTables will use `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveCallback": function (settings, data) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": data,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveCallback": function ( settings, data ) {
			try {
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname,
					JSON.stringify( data )
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the state to be saved. Called when the table
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or
		 * other state properties or modification. Note that for plug-in authors, you should
		 * use the `stateSaveParams` event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveParams": null,
	
	
		/**
		 * Duration for which the saved state information is considered valid. After this period
		 * has elapsed the state will be returned to the default.
		 * Value is given in seconds.
		 *  @type int
		 *  @default 7200 <i>(2 hours)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.stateDuration
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
		 */
		"iStateDuration": 7200,
	
	
		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly). In the case
		 * where a filtering is applied to the table on initial load, this can be
		 * indicated by giving the parameter as an array, where the first element is
		 * the number of records available after filtering and the second element is the
		 * number of records without filtering (allowing the table information element
		 * to be shown correctly).
		 *  @type int | array
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.deferLoading
		 *
		 *  @example
		 *    // 57 records available in the table, no filtering applied
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": 57
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": [ 57, 100 ],
		 *        "search": {
		 *          "search": "my_filter"
		 *        }
		 *      } );
		 *    } );
		 */
		"iDeferLoading": null,
	
	
		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (`lengthChange`) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pageLength
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pageLength": 50
		 *      } );
		 *    } )
		 */
		"iDisplayLength": 10,
	
	
		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be "20".
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.displayStart
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "displayStart": 20
		 *      } );
		 *    } )
		 */
		"iDisplayStart": 0,
	
	
		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a `tabindex` attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.tabIndex
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "tabIndex": 1
		 *      } );
		 *    } );
		 */
		"iTabIndex": 0,
	
	
		/**
		 * Classes that DataTables assigns to the various components and features
		 * that it adds to the HTML table. This allows classes to be configured
		 * during initialisation in addition to through the static
		 * {@link DataTable.ext.oStdClasses} object).
		 *  @namespace
		 *  @name DataTable.defaults.classes
		 */
		"oClasses": {},
	
	
		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 *  @name DataTable.defaults.language
		 */
		"oLanguage": {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 *  @name DataTable.defaults.language.aria
			 */
			"oAria": {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortAscending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortAscending": ": activate to sort column ascending",
	
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortDescending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortDescending": ": activate to sort column descending"
			},
	
			/**
			 * Pagination string used by DataTables for the built-in pagination
			 * control types.
			 *  @namespace
			 *  @name DataTable.defaults.language.paginate
			 */
			"oPaginate": {
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.first
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "first": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sFirst": "First",
	
	
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.last
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "last": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sLast": "Last",
	
	
				/**
				 * Text to use for the 'next' pagination button (to take the user to the
				 * next page).
				 *  @type string
				 *  @default Next
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.next
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "next": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sNext": "Next",
	
	
				/**
				 * Text to use for the 'previous' pagination button (to take the user to
				 * the previous page).
				 *  @type string
				 *  @default Previous
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.previous
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "previous": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sPrevious": "Previous"
			},
	
			/**
			 * This string is shown in preference to `zeroRecords` when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of `zeroRecords` will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.emptyTable
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "emptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sEmptyTable": "No data available in table",
	
	
			/**
			 * This string gives information to the end user about the information
			 * that is current on display on the page. The following tokens can be
			 * used in the string and will be dynamically replaced as the table
			 * display updates. This tokens can be placed anywhere in the string, or
			 * removed as needed by the language requires:
			 *
			 * * `\_START\_` - Display index of the first record on the current page
			 * * `\_END\_` - Display index of the last record on the current page
			 * * `\_TOTAL\_` - Number of records in the table after filtering
			 * * `\_MAX\_` - Number of records in the table without filtering
			 * * `\_PAGE\_` - Current page number
			 * * `\_PAGES\_` - Total number of pages of data in the table
			 *
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.info
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "info": "Showing page _PAGE_ of _PAGES_"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
	
	
			/**
			 * Display information string for when the table is empty. Typically the
			 * format of this string should match `info`.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoEmpty
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",
	
	
			/**
			 * When a user filters the information in a table, this string is appended
			 * to the information (`info`) to give an idea of how strong the filtering
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoFiltered
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",
	
	
			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoPostFix
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoPostFix": "",
	
	
			/**
			 * This decimal place operator is a little different from the other
			 * language options since DataTables doesn't output floating point
			 * numbers, so it won't ever use this for display of a number. Rather,
			 * what this parameter does is modify the sort methods of the table so
			 * that numbers which are in a format which has a character other than
			 * a period (`.`) as a decimal place will be sorted numerically.
			 *
			 * Note that numbers with different decimal places cannot be shown in
			 * the same table and still be sortable, the table must be consistent.
			 * However, multiple different tables on the page can use different
			 * decimal place characters.
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.decimal
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "decimal": ","
			 *          "thousands": "."
			 *        }
			 *      } );
			 *    } );
			 */
			"sDecimal": "",
	
	
			/**
			 * DataTables has a build in number formatter (`formatNumber`) which is
			 * used to format large numbers that are used in the table information.
			 * By default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.thousands
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "thousands": "'"
			 *        }
			 *      } );
			 *    } );
			 */
			"sThousands": ",",
	
	
			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The '_MENU_' variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.lengthMenu
			 *
			 *  @example
			 *    // Language change only
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Language and options change
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
			 */
			"sLengthMenu": "Show _MENU_ entries",
	
	
			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.loadingRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "loadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
			 */
			"sLoadingRecords": "Loading...",
	
	
			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *  @default Processing...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.processing
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "processing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
			 */
			"sProcessing": "Processing...",
	
	
			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable "_INPUT_", if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If "_INPUT_" is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.search
			 *
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Filter records:"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sSearch": "Search:",
	
	
			/**
			 * Assign a `placeholder` attribute to the search `input` element
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.searchPlaceholder
			 */
			"sSearchPlaceholder": "",
	
	
			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default <i>Empty string - i.e. disabled</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.url
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
			 */
			"sUrl": "",
	
	
			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. `emptyTable` is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.zeroRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "zeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
			 */
			"sZeroRecords": "No matching records found"
		},
	
	
		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the `search` parameter must be
		 * defined, but all other parameters are optional. When `regex` is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When `smart`
		 * DataTables will use it's smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.search
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "search": {"search": "Initial search"}
		 *      } );
		 *    } )
		 */
		"oSearch": $.extend( {}, DataTable.models.oSearch ),
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * By default DataTables will look for the property `data` (or `aaData` for
		 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
		 * source or for server-side processing - this parameter allows that
		 * property to be changed. You can use Javascript dotted object notation to
		 * get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default data
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxDataProp
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxDataProp": "data",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * You can instruct DataTables to load data from an external
		 * source using this parameter (use aData if you want to pass data in you
		 * already have). Simply provide a url a JSON object can be obtained from.
		 *  @type string
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxSource
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxSource": null,
	
	
		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   <ul>
		 *     <li>The following options are allowed:
		 *       <ul>
		 *         <li>'l' - Length changing</li>
		 *         <li>'f' - Filtering input</li>
		 *         <li>'t' - The table!</li>
		 *         <li>'i' - Information</li>
		 *         <li>'p' - Pagination</li>
		 *         <li>'r' - pRocessing</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following constants are allowed:
		 *       <ul>
		 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
		 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following syntax is expected:
		 *       <ul>
		 *         <li>'&lt;' and '&gt;' - div elements</li>
		 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
		 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
		 *       </ul>
		 *     </li>
		 *     <li>Examples:
		 *       <ul>
		 *         <li>'&lt;"wrapper"flipt&gt;'</li>
		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
		 *       </ul>
		 *     </li>
		 *   </ul>
		 *  @type string
		 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
		 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.dom
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
		 */
		"sDom": "lfrtip",
	
	
		/**
		 * Search delay option. This will throttle full table searches that use the
		 * DataTables provided search input element (it does not effect calls to
		 * `dt-api search()`, providing a delay before the search is made.
		 *  @type integer
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.searchDelay
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchDelay": 200
		 *      } );
		 *    } )
		 */
		"searchDelay": null,
	
	
		/**
		 * DataTables features four different built-in options for the buttons to
		 * display for pagination control:
		 *
		 * * `simple` - 'Previous' and 'Next' buttons only
		 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
		 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
		 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
		 *   page numbers
		 *  
		 * Further methods can be added using {@link DataTable.ext.oPagination}.
		 *  @type string
		 *  @default simple_numbers
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pagingType
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pagingType": "full_numbers"
		 *      } );
		 *    } )
		 */
		"sPaginationType": "simple_numbers",
	
	
		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a
		 * certain layout, or you have a large number of columns in the table, you
		 * can enable x-scrolling to show the table in a viewport, which can be
		 * scrolled. This property can be `true` which will allow the table to
		 * scroll horizontally when needed, or any CSS unit, or a number (in which
		 * case it will be treated as a pixel measurement). Setting as simply `true`
		 * is recommended.
		 *  @type boolean|string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollX
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": true,
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"sScrollX": "",
	
	
		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * "over-sizing" the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollXInner
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": "100%",
		 *        "scrollXInner": "110%"
		 *      } );
		 *    } );
		 */
		"sScrollXInner": "",
	
	
		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, and enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can be any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollY
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false
		 *      } );
		 *    } );
		 */
		"sScrollY": "",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverMethod
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sServerMethod": "GET",
	
	
		/**
		 * DataTables makes use of renderers when displaying HTML elements for
		 * a table. These renderers can be added or modified by plug-ins to
		 * generate suitable mark-up for a site. For example the Bootstrap
		 * integration plug-in for DataTables uses a paging button renderer to
		 * display pagination buttons in the mark-up required by Bootstrap.
		 *
		 * For further information about the renderers available see
		 * DataTable.ext.renderer
		 *  @type string|object
		 *  @default null
		 *
		 *  @name DataTable.defaults.renderer
		 *
		 */
		"renderer": null
	};
	
	_fnHungarianMap( DataTable.defaults );
	
	
	
	/*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
	
	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.column = {
		/**
		 * Define which column(s) an order will occur on for this column. This
		 * allows a column's ordering to take multiple columns into account when
		 * doing a sort or use the data from a different column. For example first
		 * name / last name columns make sense to do a multi-column sort over the
		 * two columns.
		 *  @type array|int
		 *  @default null <i>Takes the value of the column index automatically</i>
		 *
		 *  @name DataTable.defaults.column.orderData
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
		 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
		 *          { "orderData": 2, "targets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderData": [ 0, 1 ] },
		 *          { "orderData": [ 1, 0 ] },
		 *          { "orderData": 2 },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"aDataSort": null,
		"iDataSort": -1,
	
	
		/**
		 * You can control the default ordering direction, and even alter the
		 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
		 * using this parameter.
		 *  @type array
		 *  @default [ 'asc', 'desc' ]
		 *
		 *  @name DataTable.defaults.column.orderSequence
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
		 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          { "orderSequence": [ "asc" ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ] },
		 *          { "orderSequence": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"asSorting": [ 'asc', 'desc' ],
	
	
		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.searchable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "searchable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "searchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSearchable": true,
	
	
		/**
		 * Enable or disable ordering on this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.orderable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSortable": true,
	
	
		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.visible
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "visible": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "visible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bVisible": true,
	
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} td The TD node that has been created
		 *  @param {*} cellData The Data for the cell
		 *  @param {array|object} rowData The data for the whole row
		 *  @param {int} row The row index for the aoData data store
		 *  @param {int} col The column index for aoColumns
		 *
		 *  @name DataTable.defaults.column.createdCell
		 *  @dtopt Columns
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [3],
		 *          "createdCell": function (td, cellData, rowData, row, col) {
		 *            if ( cellData == "1.7" ) {
		 *              $(td).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		"fnCreatedCell": null,
	
	
		/**
		 * This parameter has been replaced by `data` in DataTables to ensure naming
		 * consistency. `dataProp` can still be used, as there is backwards
		 * compatibility in DataTables for this option, but it is strongly
		 * recommended that you use `data` in preference to `dataProp`.
		 *  @name DataTable.defaults.column.dataProp
		 */
	
	
		/**
		 * This property can be used to read data from any data source property,
		 * including deeply nested objects / properties. `data` can be given in a
		 * number of different ways which effect its behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object. Note that
		 *      function notation is recommended for use in `render` rather than
		 *      `data` as it is much simpler to use as a renderer.
		 * * `null` - use the original data source for the row rather than plucking
		 *   data directly from it. This action has effects on two other
		 *   initialisation options:
		 *    * `defaultContent` - When null is given as the `data` option and
		 *      `defaultContent` is specified for the column, the value defined by
		 *      `defaultContent` will be used for the cell.
		 *    * `render` - When null is used for the `data` option and the `render`
		 *      option is specified for the column, the whole data source for the
		 *      row is used for the renderer.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * `{array|object}` The data source for the row
		 *      * `{string}` The type call data requested - this will be 'set' when
		 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
		 *        when gathering data. Note that when `undefined` is given for the
		 *        type DataTables expects to get the raw data for the object back<
		 *      * `{*}` Data to set when the second parameter is 'set'.
		 *    * Return:
		 *      * The return value from the function is not required when 'set' is
		 *        the type of call, but otherwise the return is what will be used
		 *        for the data requested.
		 *
		 * Note that `data` is a getter and setter option. If you just require
		 * formatting of data for output, you will likely want to use `render` which
		 * is simply a getter and thus simpler to use.
		 *
		 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
		 * name change reflects the flexibility of this property and is consistent
		 * with the naming of mRender. If 'mDataProp' is given, then it will still
		 * be used by DataTables, as it automatically maps the old name to the new
		 * if required.
		 *
		 *  @type string|int|function|null
		 *  @default null <i>Use automatically calculated column index</i>
		 *
		 *  @name DataTable.defaults.column.data
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Read table data from objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {value},
		 *    //      "version": {value},
		 *    //      "grade": {value}
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/objects.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform" },
		 *          { "data": "version" },
		 *          { "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Read information from deeply nested objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {
		 *    //         "inner": {value}
		 *    //      },
		 *    //      "details": [
		 *    //         {value}, {value}
		 *    //      ]
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform.inner" },
		 *          { "data": "platform.details.0" },
		 *          { "data": "platform.details.1" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `data` as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using default content
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null,
		 *          "defaultContent": "Click to edit"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using array notation - outputting a list from an array
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "name[, ]"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 */
		"mData": null,
	
	
		/**
		 * This property is the rendering partner to `data` and it is suggested that
		 * when you want to manipulate data for display (including filtering,
		 * sorting etc) without altering the underlying data for the table, use this
		 * property. `render` can be considered to be the the read only companion to
		 * `data` which is read / write (then as such more complex). Like `data`
		 * this option can be given in a number of different ways to effect its
		 * behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object.
		 * * `object` - use different data for the different data types requested by
		 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
		 *   of the object is the data type the property refers to and the value can
		 *   defined using an integer, string or function using the same rules as
		 *   `render` normally does. Note that an `_` option _must_ be specified.
		 *   This is the default value to use if you haven't specified a value for
		 *   the data type requested by DataTables.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * {array|object} The data source for the row (based on `data`)
		 *      * {string} The type call data requested - this will be 'filter',
		 *        'display', 'type' or 'sort'.
		 *      * {array|object} The full data source for the row (not based on
		 *        `data`)
		 *    * Return:
		 *      * The return value from the function is what will be used for the
		 *        data requested.
		 *
		 *  @type string|int|function|object|null
		 *  @default null Use the data source value.
		 *
		 *  @name DataTable.defaults.column.render
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Create a comma separated list from an array of objects
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          {
		 *            "data": "platform",
		 *            "render": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Execute a function to obtain data
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": "browserName()"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // As an object, extracting different data for the different types
		 *    // This would be used with a data source such as:
		 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
		 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
		 *    // (which has both forms) is used for filtering for if a user inputs either format, while
		 *    // the formatted phone number is the one that is shown in the table.
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": {
		 *            "_": "phone",
		 *            "filter": "phone_filter",
		 *            "display": "phone_display"
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Use as a function to create a link from the data source
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "download_link",
		 *          "render": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 */
		"mRender": null,
	
	
		/**
		 * Change the cell type created for the column - either TD cells or TH cells. This
		 * can be useful as TH cells have semantic meaning in the table body, allowing them
		 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
		 *  @type string
		 *  @default td
		 *
		 *  @name DataTable.defaults.column.cellType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Make the first column use TH cells
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "cellType": "th"
		 *        } ]
		 *      } );
		 *    } );
		 */
		"sCellType": "td",
	
	
		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.class
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "class": "my_class", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "class": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sClass": "",
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn't need this!
		 *  @type string
		 *  @default <i>Empty string<i>
		 *
		 *  @name DataTable.defaults.column.contentPadding
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "contentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sContentPadding": "",
	
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because `data`
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *
		 *  @name DataTable.defaults.column.defaultContent
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit",
		 *            "targets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sDefaultContent": null,
	
	
		/**
		 * This parameter is only used in DataTables' server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.name
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "name": "engine", "targets": [ 0 ] },
		 *          { "name": "browser", "targets": [ 1 ] },
		 *          { "name": "platform", "targets": [ 2 ] },
		 *          { "name": "version", "targets": [ 3 ] },
		 *          { "name": "grade", "targets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "name": "engine" },
		 *          { "name": "browser" },
		 *          { "name": "platform" },
		 *          { "name": "version" },
		 *          { "name": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sName": "",
	
	
		/**
		 * Defines a data source type for the ordering which can be used to read
		 * real-time information from the table (updating the internally cached
		 * version) prior to ordering. This allows ordering to occur on user
		 * editable elements such as form inputs.
		 *  @type string
		 *  @default std
		 *
		 *  @name DataTable.defaults.column.orderDataType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
		 *          { "type": "numeric", "targets": [ 3 ] },
		 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
		 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          { "orderDataType": "dom-text" },
		 *          { "orderDataType": "dom-text", "type": "numeric" },
		 *          { "orderDataType": "dom-select" },
		 *          { "orderDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sSortDataType": "std",
	
	
		/**
		 * The title of this column.
		 *  @type string
		 *  @default null <i>Derived from the 'TH' value for this column in the
		 *    original HTML table.</i>
		 *
		 *  @name DataTable.defaults.column.title
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "title": "My column title", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "title": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sTitle": null,
	
	
		/**
		 * The type allows you to specify how the data for this column will be
		 * ordered. Four types (string, numeric, date and html (which will strip
		 * HTML tags before ordering)) are currently available. Note that only date
		 * formats understood by Javascript's Date() object will be accepted as type
		 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
		 * 'numeric', 'date' or 'html' (by default). Further types can be adding
		 * through plug-ins.
		 *  @type string
		 *  @default null <i>Auto-detected from raw data</i>
		 *
		 *  @name DataTable.defaults.column.type
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "type": "html", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "type": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sType": null,
	
	
		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null <i>Automatic</i>
		 *
		 *  @name DataTable.defaults.column.width
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "width": "20%", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "width": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sWidth": null
	};
	
	_fnHungarianMap( DataTable.defaults.column );
	
	
	
	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 *
	 * Note that this object is related to {@link DataTable.defaults} but this
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		"oFeatures": {
	
			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoWidth": null,
	
			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all fro DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bDeferRender": null,
	
			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the 'f' option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bFilter": null,
	
			/**
			 * Table information element (the 'Showing x of y records' div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfo": null,
	
			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bLengthChange": null,
	
			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bPaginate": null,
	
			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bProcessing": null,
	
			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bServerSide": null,
	
			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSort": null,
	
			/**
			 * Multi-column sorting
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortMulti": null,
	
			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortClasses": null,
	
			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bStateSave": null
		},
	
	
		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		"oScroll": {
			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bCollapse": null,
	
			/**
			 * Width of the scrollbar for the web-browser's platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			"iBarWidth": 0,
	
			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sX": null,
	
			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			"sXInner": null,
	
			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sY": null
		},
	
		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		"oLanguage": {
			/**
			 * Information callback function. See
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default null
			 */
			"fnInfoCallback": null
		},
	
		/**
		 * Browser support parameters
		 *  @namespace
		 */
		"oBrowser": {
			/**
			 * Indicate if the browser incorrectly calculates width:100% inside a
			 * scrolling element (IE6/7)
			 *  @type boolean
			 *  @default false
			 */
			"bScrollOversize": false,
	
			/**
			 * Determine if the vertical scrollbar is on the right or left of the
			 * scrolling container - needed for rtl language layout, although not
			 * all browsers move the scrollbar (Safari).
			 *  @type boolean
			 *  @default false
			 */
			"bScrollbarLeft": false
		},
	
	
		"ajax": null,
	
	
		/**
		 * Array referencing the nodes which are used for the features. The
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   <ul>
		 *     <li>'l' - Length changing</li>
		 *     <li>'f' - Filtering input</li>
		 *     <li>'t' - The table!</li>
		 *     <li>'i' - Information</li>
		 *     <li>'p' - Pagination</li>
		 *     <li>'r' - pRocessing</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aanFeatures": [],
	
		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		"aoData": [],
	
		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		"aiDisplay": [],
	
		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		"aiDisplayMaster": [],
	
		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		"aoColumns": [],
	
		/**
		 * Store information about the table's header
		 *  @type array
		 *  @default []
		 */
		"aoHeader": [],
	
		/**
		 * Store information about the table's footer
		 *  @type array
		 *  @default []
		 */
		"aoFooter": [],
	
		/**
		 * Store the applied global search information in case we want to force a
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		"oPreviousSearch": {},
	
		/**
		 * Store the applied search for each column - see
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		"aoPreSearchCols": [],
	
		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * <ul>
		 *   <li>Index 0 - column number</li>
		 *   <li>Index 1 - current sorting direction</li>
		 * </ul>
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		"aaSorting": null,
	
		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aaSortingFixed": [],
	
		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"asStripeClasses": null,
	
		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		"asDestroyStripes": [],
	
		/**
		 * If restoring a table - we should restore its width
		 *  @type int
		 *  @default 0
		 */
		"sDestroyWidth": 0,
	
		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		"aoRowCallback": [],
	
		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoHeaderCallback": [],
	
		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoFooterCallback": [],
	
		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		"aoDrawCallback": [],
	
		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		"aoRowCreatedCallback": [],
	
		/**
		 * Callback functions for just before the table is redrawn. A return of
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		"aoPreDrawCallback": [],
	
		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		"aoInitComplete": [],
	
	
		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		"aoStateSaveParams": [],
	
		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		"aoStateLoadParams": [],
	
		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		"aoStateLoaded": [],
	
		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sTableId": "",
	
		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		"nTable": null,
	
		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		"nTHead": null,
	
		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		"nTFoot": null,
	
		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		"nTBody": null,
	
		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		"nTableWrapper": null,
	
		/**
		 * Indicate if when using server-side processing the loading of data
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		"bDeferLoading": false,
	
		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		"bInitialised": false,
	
		/**
		 * Information about open rows. Each object in the array has the parameters
		 * 'nTr' and 'nParent'
		 *  @type array
		 *  @default []
		 */
		"aoOpenRows": [],
	
		/**
		 * Dictate the positioning of DataTables' control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sDom": null,
	
		/**
		 * Search delay (in mS)
		 *  @type integer
		 *  @default null
		 */
		"searchDelay": null,
	
		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default two_button
		 */
		"sPaginationType": "two_button",
	
		/**
		 * The state duration (for `stateSave`) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		"iStateDuration": 0,
	
		/**
		 * Array of callback functions for state saving. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object
		 *       (i.e. '"param": [ 0, 1, 2]')</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateSave": [],
	
		/**
		 * Array of callback functions for state loading. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the object stored. May return false to cancel state loading</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateLoad": [],
	
		/**
		 * State that was saved. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oSavedState": null,
	
		/**
		 * State that was loaded. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oLoadedState": null,
	
		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sAjaxSource": null,
	
		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sAjaxDataProp": null,
	
		/**
		 * Note if draw should be blocked while getting data
		 *  @type boolean
		 *  @default true
		 */
		"bAjaxDataGet": true,
	
		/**
		 * The last jQuery XHR object that was used for server-side data gathering.
		 * This can be used for working with the XHR information in one of the
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		"jqXHR": null,
	
		/**
		 * JSON returned from the server in the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"json": undefined,
	
		/**
		 * Data submitted as part of the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"oAjaxData": undefined,
	
		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnServerData": null,
	
		/**
		 * Functions which are called prior to sending an Ajax request so extra
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		"aoServerParams": [],
	
		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sServerMethod": null,
	
		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnFormatNumber": null,
	
		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aLengthMenu": null,
	
		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		"iDraw": 0,
	
		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		"bDrawing": false,
	
		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		"iDrawError": -1,
	
		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		"_iDisplayLength": 10,
	
		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		"_iDisplayStart": 0,
	
		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		"_iRecordsTotal": 0,
	
		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		"_iRecordsDisplay": 0,
	
		/**
		 * Flag to indicate if jQuery UI marking and classes should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bJUI": null,
	
		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		"oClasses": {},
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bFiltered": false,
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bSorted": false,
	
		/**
		 * Indicate that if multiple rows are in the header and there is more than
		 * one unique cell per column, if the top one (true) or bottom one (false)
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bSortCellsTop": null,
	
		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		"oInit": null,
	
		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		"aoDestroyCallback": [],
	
	
		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		"fnRecordsTotal": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsTotal * 1 :
				this.aiDisplayMaster.length;
		},
	
		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		"fnRecordsDisplay": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsDisplay * 1 :
				this.aiDisplay.length;
		},
	
		/**
		 * Get the display end point - aiDisplay index
		 *  @type function
		 */
		"fnDisplayEnd": function ()
		{
			var
				len      = this._iDisplayLength,
				start    = this._iDisplayStart,
				calc     = start + len,
				records  = this.aiDisplay.length,
				features = this.oFeatures,
				paginate = features.bPaginate;
	
			if ( features.bServerSide ) {
				return paginate === false || len === -1 ?
					start + records :
					Math.min( start+len, this._iRecordsDisplay );
			}
			else {
				return ! paginate || calc>records || len===-1 ?
					records :
					calc;
			}
		},
	
		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		"oInstance": null,
	
		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		"sInstance": null,
	
		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		"iTabIndex": 0,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollHead": null,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollFoot": null,
	
		/**
		 * Last applied sort
		 *  @type array
		 *  @default []
		 */
		"aLastSort": [],
	
		/**
		 * Stored plug-in instances
		 *  @type object
		 *  @default {}
		 */
		"oPlugins": {}
	};

	/**
	 * Extension object for DataTables that is used to provide all extension
	 * options.
	 *
	 * Note that the `DataTable.ext` object is available through
	 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	
	
	/**
	 * DataTables extensions
	 * 
	 * This namespace acts as a collection area for plug-ins that can be used to
	 * extend DataTables capabilities. Indeed many of the build in methods
	 * use this method to provide their own capabilities (sorting methods for
	 * example).
	 *
	 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	 * reasons
	 *
	 *  @namespace
	 */
	DataTable.ext = _ext = {
		/**
		 * Element class names
		 *
		 *  @type object
		 *  @default {}
		 */
		classes: {},
	
	
		/**
		 * Error reporting.
		 * 
		 * How should DataTables report an error. Can take the value 'alert' or
		 * 'throw'
		 *
		 *  @type string
		 *  @default alert
		 */
		errMode: "alert",
	
	
		/**
		 * Feature plug-ins.
		 * 
		 * This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are then available for
		 * use through the `dom` initialisation option.
		 * 
		 * Each feature plug-in is described by an object which must have the
		 * following properties:
		 * 
		 * * `fnInit` - function that is used to initialise the plug-in,
		 * * `cFeature` - a character so the feature can be enabled by the `dom`
		 *   instillation option. This is case sensitive.
		 *
		 * The `fnInit` function has the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 *
		 * And the following return is expected:
		 * 
		 * * {node|null} The element which contains your feature. Note that the
		 *   return may also be void if your plug-in does not require to inject any
		 *   DOM elements into DataTables control (`dom`) - for example this might
		 *   be useful when developing a plug-in which allows table control via
		 *   keyboard entry
		 *
		 *  @type array
		 *
		 *  @example
		 *    $.fn.dataTable.ext.features.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T"
		 *    } );
		 */
		feature: [],
	
	
		/**
		 * Row searching.
		 * 
		 * This method of searching is complimentary to the default type based
		 * searching, and a lot more comprehensive as it allows you complete control
		 * over the searching logic. Each element in this array is a function
		 * (parameters described below) that is called for every row in the table,
		 * and your logic decides if it should be included in the searching data set
		 * or not.
		 *
		 * Searching functions have the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{array|object}` Data for the row to be processed (same as the
		 *    original format that was passed in as the data source, or an array
		 *    from a DOM data source
		 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
		 *    can be useful to retrieve the `TR` element if you need DOM interaction.
		 *
		 * And the following return is expected:
		 *
		 * * {boolean} Include the row in the searched result set (true) or not
		 *   (false)
		 *
		 * Note that as with the main search ability in DataTables, technically this
		 * is "filtering", since it is subtractive. However, for consistency in
		 * naming we call it searching here.
		 *
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom search being applied to the
		 *    // fourth column (i.e. the data[3] index) based on two input values
		 *    // from the end-user, matching the data in a certain range.
		 *    $.fn.dataTable.ext.search.push(
		 *      function( settings, data, dataIndex ) {
		 *        var min = document.getElementById('min').value * 1;
		 *        var max = document.getElementById('max').value * 1;
		 *        var version = data[3] == "-" ? 0 : data[3]*1;
		 *
		 *        if ( min == "" && max == "" ) {
		 *          return true;
		 *        }
		 *        else if ( min == "" && version < max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && "" == max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && version < max ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		search: [],
	
	
		/**
		 * Internal functions, exposed for used in plug-ins.
		 * 
		 * Please note that you should not need to use the internal methods for
		 * anything other than a plug-in (and even then, try to avoid if possible).
		 * The internal function may change between releases.
		 *
		 *  @type object
		 *  @default {}
		 */
		internal: {},
	
	
		/**
		 * Legacy configuration options. Enable and disable legacy options that
		 * are available in DataTables.
		 *
		 *  @type object
		 */
		legacy: {
			/**
			 * Enable / disable DataTables 1.9 compatible server-side processing
			 * requests
			 *
			 *  @type boolean
			 *  @default null
			 */
			ajax: null
		},
	
	
		/**
		 * Pagination plug-in methods.
		 * 
		 * Each entry in this object is a function and defines which buttons should
		 * be shown by the pagination rendering method that is used for the table:
		 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
		 * buttons are displayed in the document, while the functions here tell it
		 * what buttons to display. This is done by returning an array of button
		 * descriptions (what each button will do).
		 *
		 * Pagination types (the four built in options and any additional plug-in
		 * options defined here) can be used through the `paginationType`
		 * initialisation parameter.
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{int} page` The current page index
		 * 2. `{int} pages` The number of pages in the table
		 *
		 * Each function is expected to return an array where each element of the
		 * array can be one of:
		 *
		 * * `first` - Jump to first page when activated
		 * * `last` - Jump to last page when activated
		 * * `previous` - Show previous page when activated
		 * * `next` - Show next page when activated
		 * * `{int}` - Show page of the index given
		 * * `{array}` - A nested array containing the above elements to add a
		 *   containing 'DIV' element (might be useful for styling).
		 *
		 * Note that DataTables v1.9- used this object slightly differently whereby
		 * an object with two functions would be defined for each plug-in. That
		 * ability is still supported by DataTables 1.10+ to provide backwards
		 * compatibility, but this option of use is now decremented and no longer
		 * documented in DataTables 1.10+.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Show previous, next and current page buttons only
		 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
		 *      return [ 'previous', page, 'next' ];
		 *    };
		 */
		pager: {},
	
	
		renderer: {
			pageButton: {},
			header: {}
		},
	
	
		/**
		 * Ordering plug-ins - custom data source
		 * 
		 * The extension options for ordering of data available here is complimentary
		 * to the default type based ordering that DataTables typically uses. It
		 * allows much greater control over the the data that is being used to
		 * order a column, but is necessarily therefore more complex.
		 * 
		 * This type of ordering is useful if you want to do ordering based on data
		 * live from the DOM (for example the contents of an 'input' element) rather
		 * than just the static string that DataTables knows of.
		 * 
		 * The way these plug-ins work is that you create an array of the values you
		 * wish to be ordering for the column in question and then return that
		 * array. The data in the array much be in the index order of the rows in
		 * the table (not the currently ordering order!). Which order data gathering
		 * function is run here depends on the `dt-init columns.orderDataType`
		 * parameter that is used for the column (if any).
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{int}` Target column index
		 *
		 * Each function is expected to return an array:
		 *
		 * * `{array}` Data for the column to be ordering upon
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Ordering using `input` node values
		 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
		 *    {
		 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
		 *        return $('input', td).val();
		 *      } );
		 *    }
		 */
		order: {},
	
	
		/**
		 * Type based plug-ins.
		 *
		 * Each column in DataTables has a type assigned to it, either by automatic
		 * detection or by direct assignment using the `type` option for the column.
		 * The type of a column will effect how it is ordering and search (plug-ins
		 * can also make use of the column type if required).
		 *
		 * @namespace
		 */
		type: {
			/**
			 * Type detection functions.
			 *
			 * The functions defined in this object are used to automatically detect
			 * a column's type, making initialisation of DataTables super easy, even
			 * when complex data is in the table.
			 *
			 * The functions defined take two parameters:
			 *
		     *  1. `{*}` Data from the column cell to be analysed
		     *  2. `{settings}` DataTables settings object. This can be used to
		     *     perform context specific type detection - for example detection
		     *     based on language settings such as using a comma for a decimal
		     *     place. Generally speaking the options from the settings will not
		     *     be required
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Data type detected, or null if unknown (and thus
			 *   pass it on to the other type detection functions.
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Currency type detection plug-in:
			 *    $.fn.dataTable.ext.type.detect.push(
			 *      function ( data, settings ) {
			 *        // Check the numeric part
			 *        if ( ! $.isNumeric( data.substring(1) ) ) {
			 *          return null;
			 *        }
			 *
			 *        // Check prefixed by currency
			 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
			 *          return 'currency';
			 *        }
			 *        return null;
			 *      }
			 *    );
			 */
			detect: [],
	
	
			/**
			 * Type based search formatting.
			 *
			 * The type based searching functions can be used to pre-format the
			 * data to be search on. For example, it can be used to strip HTML
			 * tags or to de-format telephone numbers for numeric only searching.
			 *
			 * Note that is a search is not defined for a column of a given type,
			 * no search formatting will be performed.
			 * 
			 * Pre-processing of searching data plug-ins - When you assign the sType
			 * for a column (or have it automatically detected for you by DataTables
			 * or a type detection plug-in), you will typically be using this for
			 * custom sorting, but it can also be used to provide custom searching
			 * by allowing you to pre-processing the data and returning the data in
			 * the format that should be searched upon. This is done by adding
			 * functions this object with a parameter name which matches the sType
			 * for that target column. This is the corollary of <i>afnSortData</i>
			 * for searching data.
			 *
			 * The functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for searching
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Formatted string that will be used for the searching.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
			 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
			 *    }
			 */
			search: {},
	
	
			/**
			 * Type based ordering.
			 *
			 * The column type tells DataTables what ordering to apply to the table
			 * when a column is sorted upon. The order for each type that is defined,
			 * is defined by the functions available in this object.
			 *
			 * Each ordering option can be described by three properties added to
			 * this object:
			 *
			 * * `{type}-pre` - Pre-formatting function
			 * * `{type}-asc` - Ascending order function
			 * * `{type}-desc` - Descending order function
			 *
			 * All three can be used together, only `{type}-pre` or only
			 * `{type}-asc` and `{type}-desc` together. It is generally recommended
			 * that only `{type}-pre` is used, as this provides the optimal
			 * implementation in terms of speed, although the others are provided
			 * for compatibility with existing Javascript sort functions.
			 *
			 * `{type}-pre`: Functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for ordering
			 *
			 * And return:
			 *
			 * * `{*}` Data to be sorted upon
			 *
			 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
			 * functions, taking two parameters:
			 *
		     *  1. `{*}` Data to compare to the second parameter
		     *  2. `{*}` Data to compare to the first parameter
			 *
			 * And returning:
			 *
			 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
			 *   than the second parameter, ===0 if the two parameters are equal and
			 *   >0 if the first parameter should be sorted height than the second
			 *   parameter.
			 * 
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Numeric ordering of formatted numbers with a pre-formatter
			 *    $.extend( $.fn.dataTable.ext.type.order, {
			 *      "string-pre": function(x) {
			 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
			 *        return parseFloat( a );
			 *      }
			 *    } );
			 *
			 *  @example
			 *    // Case-sensitive string ordering, with no pre-formatting method
			 *    $.extend( $.fn.dataTable.ext.order, {
			 *      "string-case-asc": function(x,y) {
			 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			 *      },
			 *      "string-case-desc": function(x,y) {
			 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			 *      }
			 *    } );
			 */
			order: {}
		},
	
		/**
		 * Unique DataTables instance counter
		 *
		 * @type int
		 * @private
		 */
		_unique: 0,
	
	
		//
		// Depreciated
		// The following properties are retained for backwards compatiblity only.
		// The should not be used in new projects and will be removed in a future
		// version
		//
	
		/**
		 * Version check function.
		 *  @type function
		 *  @depreciated Since 1.10
		 */
		fnVersionCheck: DataTable.fnVersionCheck,
	
	
		/**
		 * Index for what 'this' index API functions should use
		 *  @type int
		 *  @deprecated Since v1.10
		 */
		iApiIndex: 0,
	
	
		/**
		 * jQuery UI class container
		 *  @type object
		 *  @deprecated Since v1.10
		 */
		oJUIClasses: {},
	
	
		/**
		 * Software version
		 *  @type string
		 *  @deprecated Since v1.10
		 */
		sVersion: DataTable.version
	};
	
	
	//
	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	//
	$.extend( _ext, {
		afnFiltering: _ext.search,
		aTypes:       _ext.type.detect,
		ofnSearch:    _ext.type.search,
		oSort:        _ext.type.order,
		afnSortData:  _ext.order,
		aoFeatures:   _ext.feature,
		oApi:         _ext.internal,
		oStdClasses:  _ext.classes,
		oPagination:  _ext.pager
	} );
	
	
	$.extend( DataTable.ext.classes, {
		"sTable": "dataTable",
		"sNoFooter": "no-footer",
	
		/* Paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "current",
		"sPageButtonDisabled": "disabled",
	
		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",
	
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
	
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
	
		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_asc_disabled",
		"sSortableDesc": "sorting_desc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
	
		/* Filtering */
		"sFilterInput": "",
	
		/* Page length */
		"sLengthSelect": "",
	
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",
	
		/* Misc */
		"sHeaderTH": "",
		"sFooterTH": "",
	
		// Deprecated
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",
		"sJUIHeader": "",
		"sJUIFooter": ""
	} );
	
	
	(function() {
	
	// Reused strings for better compression. Closure compiler appears to have a
	// weird edge case where it is trying to expand strings rather than use the
	// variable version. This results in about 200 bytes being added, for very
	// little preference benefit since it this run on script load only.
	var _empty = '';
	_empty = '';
	
	var _stateDefault = _empty + 'ui-state-default';
	var _sortIcon     = _empty + 'css_right ui-icon ui-icon-';
	var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';
	
	$.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {
		/* Full numbers paging buttons */
		"sPageButton":         "fg-button ui-button "+_stateDefault,
		"sPageButtonActive":   "ui-state-disabled",
		"sPageButtonDisabled": "ui-state-disabled",
	
		/* Features */
		"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
			"ui-buttonset-multi paging_", /* Note that the type is postfixed */
	
		/* Sorting */
		"sSortAsc":            _stateDefault+" sorting_asc",
		"sSortDesc":           _stateDefault+" sorting_desc",
		"sSortable":           _stateDefault+" sorting",
		"sSortableAsc":        _stateDefault+" sorting_asc_disabled",
		"sSortableDesc":       _stateDefault+" sorting_desc_disabled",
		"sSortableNone":       _stateDefault+" sorting_disabled",
		"sSortJUIAsc":         _sortIcon+"triangle-1-n",
		"sSortJUIDesc":        _sortIcon+"triangle-1-s",
		"sSortJUI":            _sortIcon+"carat-2-n-s",
		"sSortJUIAscAllowed":  _sortIcon+"carat-1-n",
		"sSortJUIDescAllowed": _sortIcon+"carat-1-s",
		"sSortJUIWrapper":     "DataTables_sort_wrapper",
		"sSortIcon":           "DataTables_sort_icon",
	
		/* Scrolling */
		"sScrollHead": "dataTables_scrollHead "+_stateDefault,
		"sScrollFoot": "dataTables_scrollFoot "+_stateDefault,
	
		/* Misc */
		"sHeaderTH":  _stateDefault,
		"sFooterTH":  _stateDefault,
		"sJUIHeader": _headerFooter+" ui-corner-tl ui-corner-tr",
		"sJUIFooter": _headerFooter+" ui-corner-bl ui-corner-br"
	} );
	
	}());
	
	
	
	var extPagination = DataTable.ext.pager;
	
	function _numbers ( page, pages ) {
		var
			numbers = [],
			buttons = extPagination.numbers_length,
			half = Math.floor( buttons / 2 ),
			i = 1;
	
		if ( pages <= buttons ) {
			numbers = _range( 0, pages );
		}
		else if ( page <= half ) {
			numbers = _range( 0, buttons-2 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
		}
		else if ( page >= pages - 1 - half ) {
			numbers = _range( pages-(buttons-2), pages );
			numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
			numbers.splice( 0, 0, 0 );
		}
		else {
			numbers = _range( page-1, page+2 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
			numbers.splice( 0, 0, 'ellipsis' );
			numbers.splice( 0, 0, 0 );
		}
	
		numbers.DT_el = 'span';
		return numbers;
	}
	
	
	$.extend( extPagination, {
		simple: function ( page, pages ) {
			return [ 'previous', 'next' ];
		},
	
		full: function ( page, pages ) {
			return [  'first', 'previous', 'next', 'last' ];
		},
	
		simple_numbers: function ( page, pages ) {
			return [ 'previous', _numbers(page, pages), 'next' ];
		},
	
		full_numbers: function ( page, pages ) {
			return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
		},
	
		// For testing and plug-ins to use
		_numbers: _numbers,
		numbers_length: 7
	} );
	
	
	$.extend( true, DataTable.ext.renderer, {
		pageButton: {
			_: function ( settings, host, idx, buttons, page, pages ) {
				var classes = settings.oClasses;
				var lang = settings.oLanguage.oPaginate;
				var btnDisplay, btnClass, counter=0;
	
				var attach = function( container, buttons ) {
					var i, ien, node, button;
					var clickHandler = function ( e ) {
						_fnPageChange( settings, e.data.action, true );
					};
	
					for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
						button = buttons[i];
	
						if ( $.isArray( button ) ) {
							var inner = $( '<'+(button.DT_el || 'div')+'/>' )
								.appendTo( container );
							attach( inner, button );
						}
						else {
							btnDisplay = '';
							btnClass = '';
	
							switch ( button ) {
								case 'ellipsis':
									container.append('<span>&hellip;</span>');
									break;
	
								case 'first':
									btnDisplay = lang.sFirst;
									btnClass = button + (page > 0 ?
										'' : ' '+classes.sPageButtonDisabled);
									break;
	
								case 'previous':
									btnDisplay = lang.sPrevious;
									btnClass = button + (page > 0 ?
										'' : ' '+classes.sPageButtonDisabled);
									break;
	
								case 'next':
									btnDisplay = lang.sNext;
									btnClass = button + (page < pages-1 ?
										'' : ' '+classes.sPageButtonDisabled);
									break;
	
								case 'last':
									btnDisplay = lang.sLast;
									btnClass = button + (page < pages-1 ?
										'' : ' '+classes.sPageButtonDisabled);
									break;
	
								default:
									btnDisplay = button + 1;
									btnClass = page === button ?
										classes.sPageButtonActive : '';
									break;
							}
	
							if ( btnDisplay ) {
								node = $('<a>', {
										'class': classes.sPageButton+' '+btnClass,
										'aria-controls': settings.sTableId,
										'data-dt-idx': counter,
										'tabindex': settings.iTabIndex,
										'id': idx === 0 && typeof button === 'string' ?
											settings.sTableId +'_'+ button :
											null
									} )
									.html( btnDisplay )
									.appendTo( container );
	
								_fnBindAction(
									node, {action: button}, clickHandler
								);
	
								counter++;
							}
						}
					}
				};
	
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame. Try / catch the error. Not good for
				// accessibility, but neither are frames.
				try {
					// Because this approach is destroying and recreating the paging
					// elements, focus is lost on the select button which is bad for
					// accessibility. So we want to restore focus once the draw has
					// completed
					var activeEl = $(document.activeElement).data('dt-idx');
	
					attach( $(host).empty(), buttons );
	
					if ( activeEl !== null ) {
						$(host).find( '[data-dt-idx='+activeEl+']' ).focus();
					}
				}
				catch (e) {}
			}
		}
	} );
	
	
	
	// Built in type detection. See model.ext.aTypes for information about
	// what is required from this methods.
	$.extend( DataTable.ext.type.detect, [
		// Plain numbers - first since V8 detects some plain numbers as dates
		// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal ) ? 'num'+decimal : null;
		},
	
		// Dates (only those recognised by the browser's Date.parse)
		function ( d, settings )
		{
			// V8 will remove any unknown characters at the start and end of the
			// expression, leading to false matches such as `$245.12` or `10%` being
			// a valid date. See forum thread 18941 for detail.
			if ( d && !(d instanceof Date) && ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
		},
	
		// Formatted numbers
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
		},
	
		// HTML numeric
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
		},
	
		// HTML numeric, formatted
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
		},
	
		// HTML (this is strict checking - there must be html)
		function ( d, settings )
		{
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
				'html' : null;
		}
	] );
	
	
	
	// Filter formatting functions. See model.ext.ofnSearch for information about
	// what is required from these methods.
	// 
	// Note that additional search methods are added for the html numbers and
	// html formatted numbers by `_addNumericSort()` when we know what the decimal
	// place is
	
	
	$.extend( DataTable.ext.type.search, {
		html: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data
						.replace( _re_new_lines, " " )
						.replace( _re_html, "" ) :
					'';
		},
	
		string: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data.replace( _re_new_lines, " " ) :
					data;
		}
	} );
	
	
	
	var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
		if ( d !== 0 && (!d || d === '-') ) {
			return -Infinity;
		}
	
		// If a decimal place other than `.` is used, it needs to be given to the
		// function so we can detect it and replace with a `.` which is the only
		// decimal place Javascript recognises - it is not locale aware.
		if ( decimalPlace ) {
			d = _numToDecimal( d, decimalPlace );
		}
	
		if ( d.replace ) {
			if ( re1 ) {
				d = d.replace( re1, '' );
			}
	
			if ( re2 ) {
				d = d.replace( re2, '' );
			}
		}
	
		return d * 1;
	};
	
	
	// Add the numeric 'deformatting' functions for sorting and search. This is done
	// in a function to provide an easy ability for the language options to add
	// additional methods if a non-period decimal place is used.
	function _addNumericSort ( decimalPlace ) {
		$.each(
			{
				// Plain numbers
				"num": function ( d ) {
					return __numericReplace( d, decimalPlace );
				},
	
				// Formatted numbers
				"num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_formatted_numeric );
				},
	
				// HTML numeric
				"html-num": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html );
				},
	
				// HTML numeric, formatted
				"html-num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
				}
			},
			function ( key, fn ) {
				// Add the ordering method
				_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
	
				// For HTML types add a search formatter that will strip the HTML
				if ( key.match(/^html\-/) ) {
					_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
				}
			}
		);
	}
	
	
	// Default sort methods
	$.extend( _ext.type.order, {
		// Dates
		"date-pre": function ( d ) {
			return Date.parse( d ) || 0;
		},
	
		// html
		"html-pre": function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					a.replace( /<.*?>/g, "" ).toLowerCase() :
					a+'';
		},
	
		// string
		"string-pre": function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		},
	
		// string-asc and -desc are retained only for compatibility with the old
		// sort methods
		"string-asc": function ( x, y ) {
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
	
		"string-desc": function ( x, y ) {
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		}
	} );
	
	
	// Numeric sorting types - order doesn't matter here
	_addNumericSort( '' );
	
	
	$.extend( true, DataTable.ext.renderer, {
		header: {
			_: function ( settings, cell, column, classes ) {
				// No additional mark-up required
				// Attach a sort listener to update on sort - note that using the
				// `DT` namespace will allow the event to be removed automatically
				// on destroy, while the `dt` namespaced event is the one we are
				// listening for
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) { // need to check this this is the host
						return;               // table, not a nested one
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass(
							column.sSortingClass +' '+
							classes.sSortAsc +' '+
							classes.sSortDesc
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
				} );
			},
	
			jqueryui: function ( settings, cell, column, classes ) {
				$('<div/>')
					.addClass( classes.sSortJUIWrapper )
					.append( cell.contents() )
					.append( $('<span/>')
						.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
					)
					.appendTo( cell );
	
				// Attach a sort listener to update on sort
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) {
						return;
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
	
					cell
						.find( 'span.'+classes.sSortIcon )
						.removeClass(
							classes.sSortJUIAsc +" "+
							classes.sSortJUIDesc +" "+
							classes.sSortJUI +" "+
							classes.sSortJUIAscAllowed +" "+
							classes.sSortJUIDescAllowed
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortJUIDesc :
								column.sSortingClassJUI
						);
				} );
			}
		}
	} );
	
	/*
	 * Public helper functions. These aren't used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
	
	/**
	 * Helpers for `columns.render`.
	 *
	 * The options defined here can be used with the `columns.render` initialisation
	 * option to provide a display renderer. The following functions are defined:
	 *
	 * * `number` - Will format numeric data (defined by `columns.data`) for
	 *   display, retaining the original unformatted data for sorting and filtering.
	 *   It takes 4 parameters:
	 *   * `string` - Thousands grouping separator
	 *   * `string` - Decimal point indicator
	 *   * `integer` - Number of decimal points to show
	 *   * `string` (optional) - Prefix.
	 *
	 * @example
	 *   // Column definition using the number renderer
	 *   {
	 *     data: "salary",
	 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	 *   }
	 *
	 * @namespace
	 */
	DataTable.render = {
		number: function ( thousands, decimal, precision, prefix ) {
			return {
				display: function ( d ) {
					var negative = d < 0 ? '-' : '';
					d = Math.abs( parseFloat( d ) );
	
					var intPart = parseInt( d, 10 );
					var floatPart = precision ?
						decimal+(d - intPart).toFixed( precision ).substring( 2 ):
						'';
	
					return negative + (prefix||'') +
						intPart.toString().replace(
							/\B(?=(\d{3})+(?!\d))/g, thousands
						) +
						floatPart;
				}
			};
		}
	};
	
	
	/*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
	
	
	/**
	 * Create a wrapper function for exporting an internal functions to an external API.
	 *  @param {string} fn API function name
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#internal
	 */
	function _fnExternApiFunc (fn)
	{
		return function() {
			var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
				Array.prototype.slice.call(arguments)
			);
			return DataTable.ext.internal[fn].apply( this, args );
		};
	}
	
	
	/**
	 * Reference to internal functions for use by plug-in developers. Note that
	 * these methods are references to internal functions and are considered to be
	 * private. If you use these methods, be aware that they are liable to change
	 * between versions.
	 *  @namespace
	 */
	$.extend( DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidate: _fnInvalidate,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnScrollBarWidth: _fnScrollBarWidth,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
		                                // in 1.10, so this dead-end function is
		                                // added to prevent errors
	} );
	

	// jQuery access
	$.fn.dataTable = DataTable;

	// Legacy aliases
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;

	// With a capital `D` we return a DataTables API instance rather than a
	// jQuery object
	$.fn.DataTable = function ( opts ) {
		return $(this).dataTable( opts ).api();
	};

	// All properties that are available to $.fn.dataTable should also be
	// available on $.fn.DataTable
	$.each( DataTable, function ( prop, val ) {
		$.fn.DataTable[ prop ] = val;
	} );


	// Information about events fired by DataTables - for documentation.
	/**
	 * Draw event, fired whenever the table is redrawn on the page, at the same
	 * point as fnDrawCallback. This may be useful for binding events or
	 * performing calculations when the table is altered at all.
	 *  @name DataTable#draw.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Search event, fired when the searching applied to the table (using the
	 * built-in global search, or column filters) is altered.
	 *  @name DataTable#search.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page change event, fired when the paging of the table is altered.
	 *  @name DataTable#page.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Order event, fired when the ordering applied to the table is altered.
	 *  @name DataTable#order.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * DataTables initialisation complete event, fired when the table is fully
	 * drawn, including Ajax data loaded, if Ajax data is required.
	 *  @name DataTable#init.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The JSON object request from the server - only
	 *    present if client-side Ajax sourced data is used</li></ol>
	 */

	/**
	 * State save event, fired when the table has changed state a new state save
	 * is required. This event allows modification of the state saving object
	 * prior to actually doing the save, including addition or other state
	 * properties (for plug-ins) or modification of a DataTables core property.
	 *  @name DataTable#stateSaveParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The state information to be saved
	 */

	/**
	 * State load event, fired when the table is loading state from the stored
	 * data, but prior to the settings object being modified by the saved state
	 * - allowing modification of the saved state is required or loading of
	 * state for a plug-in.
	 *  @name DataTable#stateLoadParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * State loaded event, fired when state has been loaded from stored data and
	 * the settings object has been modified by the loaded data.
	 *  @name DataTable#stateLoaded.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * Processing event, fired when DataTables is doing some kind of processing
	 * (be it, order, searcg or anything else). It can be used to indicate to
	 * the end user that there is something happening, or that something has
	 * finished.
	 *  @name DataTable#processing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	 */

	/**
	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
	 * request to made to the server for new data. This event is called before
	 * DataTables processed the returned data, so it can also be used to pre-
	 * process the data returned from the server, if needed.
	 *
	 * Note that this trigger is called in `fnServerData`, if you override
	 * `fnServerData` and which to use this event, you need to trigger it in you
	 * success function.
	 *  @name DataTable#xhr.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {object} json JSON returned from the server
	 *
	 *  @example
	 *     // Use a custom property returned from the server in another DOM element
	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	 *       $('#status').html( json.status );
	 *     } );
	 *
	 *  @example
	 *     // Pre-process the data returned from the server
	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
	 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
	 *       }
	 *       // Note no return - manipulate the data directly in the JSON object.
	 *     } );
	 */

	/**
	 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
	 * or passing the bDestroy:true parameter in the initialisation object. This
	 * can be used to remove bound events, added DOM nodes, etc.
	 *  @name DataTable#destroy.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page length change event, fired when number of records to show on each
	 * page (the length) is changed.
	 *  @name DataTable#length.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {integer} len New length
	 */

	/**
	 * Column sizing has changed.
	 *  @name DataTable#column-sizing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Column visibility has changed.
	 *  @name DataTable#column-visibility.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {int} column Column index
	 *  @param {bool} vis `false` if column now hidden, or `true` if visible
	 */

	return $.fn.dataTable;
}));

}(window, document));

	return jQuery.fn.dataTable;

});

/*! DataTables Bootstrap 3 integration
 * 2011-2014 SpryMedia Ltd - datatables.net/license
 */
csui.define('csui/lib/jquery.dataTables.bootstrap/js/dataTables.bootstrap',[
        'csui/lib/jquery',
        'csui/lib/jquery.dataTables/js/jquery.dataTables',
        'csui/lib/binf/js/binf'
    ],
    function (jQuery, DataTable) {

        /**
         * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and
         * DataTables 1.10 or newer.
         *
         * This file sets the defaults and adds options to DataTables to style its
         * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
         * for further information.
         */
        (/** @lends <global> */function (window, document, undefined) {

            (function (factory) {
                "use strict";

                /*
                 if ( typeof csui.define === 'function' && csui.define.amd ) {
                 // Define as an AMD module if possible
                 define( 'datatables', ['jquery'], factory );
                 }
                 else if ( typeof exports === 'object' ) {
                 // Node/CommonJS
                 factory( require( 'jquery' ) );
                 }
                 else */
                if (jQuery && DataTable.defaults.renderer != 'bootstrap') {
                    // Prevent multiple instantiations if the script is loaded twice
                    factory(jQuery, DataTable);
                }
            }
            (/** @lends <global> */function ($, DataTable) {
                "use strict";

                /* Set the defaults for DataTables initialisation */
                $.extend(true, DataTable.defaults, {
                    dom: "<'binf-row'<'binf-col-sm-6'l><'binf-col-sm-6'f>>" +
                    "<'binf-row'<'binf-col-sm-12'tr>>" +
                    "<'binf-row'<'binf-col-sm-6'i><'binf-col-sm-6'p>>",
                    renderer: 'bootstrap'
                });


                /* Default class modification */
                $.extend(DataTable.ext.classes, {
                    sWrapper: "dataTables_wrapper binf-form-inline dt-bootstrap",
                    sFilterInput: "binf-form-control binf-input-sm",
                    sLengthSelect: "binf-form-control binf-input-sm"
                });


                /* Bootstrap paging button renderer */
                DataTable.ext.renderer.pageButton.bootstrap = function (settings, host, idx, buttons, page, pages) {
                    var api = new DataTable.Api(settings);
                    var classes = settings.oClasses;
                    var lang = settings.oLanguage.oPaginate;
                    var btnDisplay, btnClass;

                    var attach = function (container, buttons) {
                        var i, ien, node, button;
                        var clickHandler = function (e) {
                            e.preventDefault();
                            if (!$(e.currentTarget).hasClass('binf-disabled')) {
                                api.page(e.data.action).draw(false);
                            }
                        };

                        for (i = 0, ien = buttons.length; i < ien; i++) {
                            button = buttons[i];

                            if ($.isArray(button)) {
                                attach(container, button);
                            }
                            else {
                                btnDisplay = '';
                                btnClass = '';

                                switch (button) {
                                    case 'ellipsis':
                                        btnDisplay = '&hellip;';
                                        btnClass = ' binf-disabled';
                                        break;

                                    case 'first':
                                        btnDisplay = lang.sFirst;
                                        btnClass = button + (page > 0 ?
                                            '' : ' binf-disabled');
                                        break;

                                    case 'previous':
                                        btnDisplay = lang.sPrevious;
                                        btnClass = button + (page > 0 ?
                                            '' : ' binf-disabled');
                                        break;

                                    case 'next':
                                        btnDisplay = lang.sNext;
                                        btnClass = button + (page < pages - 1 ?
                                            '' : ' binf-disabled');
                                        break;

                                    case 'last':
                                        btnDisplay = lang.sLast;
                                        btnClass = button + (page < pages - 1 ?
                                            '' : ' binf-disabled');
                                        break;

                                    default:
                                        btnDisplay = button + 1;
                                        btnClass = page === button ?
                                            ' binf-active' : '';
                                        break;
                                }

                                if (btnDisplay) {
                                    node = $('<li>', {
                                        'class': classes.sPageButton + ' ' + btnClass,
                                        'aria-controls': settings.sTableId,
                                        'tabindex': settings.iTabIndex,
                                        'id': idx === 0 && typeof button === 'string' ?
                                        settings.sTableId + '_' + button :
                                            null
                                    })
                                        .append($('<a>', {
                                            'href': '#'
                                        })
                                            .html(btnDisplay)
                                    )
                                        .appendTo(container);

                                    settings.oApi._fnBindAction(
                                        node, {action: button}, clickHandler
                                    );
                                }
                            }
                        }
                    };

                    attach(
                        $(host).empty().html('<ul class="binf-pagination"/>').children('ul'),
                        buttons
                    );
                };


                /*
                 * TableTools Bootstrap compatibility
                 * Required TableTools 2.1+
                 */
                if (DataTable.TableTools) {
                    // Set the classes that TableTools uses to something suitable for Bootstrap
                    $.extend(true, DataTable.TableTools.classes, {
                        "container": "DTTT binf-btn-group",
                        "buttons": {
                            "normal": "binf-btn binf-btn-default",
                            "disabled": "binf-disabled"
                        },
                        "collection": {
                            "container": "DTTT_dropdown binf-dropdown-menu",
                            "buttons": {
                                "normal": "",
                                "disabled": "disabled"
                            }
                        },
                        "print": {
                            "info": "DTTT_print_info"
                        },
                        "select": {
                            "row": "binf-active"
                        }
                    });

                    // Have the collection use a bootstrap compatible drop down
                    $.extend(true, DataTable.TableTools.DEFAULTS.oTags, {
                        "collection": {
                            "container": "ul",
                            "button": "li",
                            "liner": "a"
                        }
                    });
                }

                return $.fn.dataTable;
            }));


// Define as an AMD module if possible
            /*
             if (typeof csui.define === 'function' && csui.define.amd) {
             define(['jquery', 'datatables'], factory);
             }
             else if (typeof exports === 'object') {
             // Node/CommonJS
             factory(require('jquery'), require('datatables'));
             }
             else if (jQuery) {
             // Otherwise simply initialise as normal, stopping multiple evaluation
             factory(jQuery, jQuery.fn.dataTable);
             }

             */
        }(window, document));

        return jQuery.fn.dataTable;

    });

/*! TableTools 2.2.3
 * 2009-2014 SpryMedia Ltd - datatables.net/license
 *
 * ZeroClipboard 1.0.4
 * Author: Joseph Huckaby - MIT licensed
 */
csui.define('csui/lib/jquery.dataTables.tableTools/js/dataTables.tableTools',['csui/lib/jquery', 'csui/lib/jquery.dataTables/js/jquery.dataTables'], function(jQuery) {

/**
 * @summary     TableTools
 * @description Tools and buttons for DataTables
 * @version     2.2.3
 * @file        dataTables.tableTools.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2009-2014 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */


/* Global scope for TableTools for backwards compatibility.
 * Will be removed in 2.3
 */
var TableTools;

(function(window, document, undefined) {


var factory = function( $, DataTable ) {



//include ZeroClipboard.js
/* ZeroClipboard 1.0.4
 * Author: Joseph Huckaby
 */

var ZeroClipboard_TableTools = {

	version: "1.0.4-TableTools2",
	clients: {}, // registered upload clients on page, indexed by id
	moviePath: '', // URL to movie
	nextId: 1, // ID of next movie

	$: function(thingy) {
		// simple DOM lookup utility function
		if (typeof(thingy) == 'string') {
			thingy = document.getElementById(thingy);
		}
		if (!thingy.addClass) {
			// extend element with a few useful methods
			thingy.hide = function() { this.style.display = 'none'; };
			thingy.show = function() { this.style.display = ''; };
			thingy.addClass = function(name) { this.removeClass(name); this.className += ' ' + name; };
			thingy.removeClass = function(name) {
				this.className = this.className.replace( new RegExp("\\s*" + name + "\\s*"), " ").replace(/^\s+/, '').replace(/\s+$/, '');
			};
			thingy.hasClass = function(name) {
				return !!this.className.match( new RegExp("\\s*" + name + "\\s*") );
			};
		}
		return thingy;
	},

	setMoviePath: function(path) {
		// set path to ZeroClipboard.swf
		this.moviePath = path;
	},

	dispatch: function(id, eventName, args) {
		// receive event from flash movie, send to client
		var client = this.clients[id];
		if (client) {
			client.receiveEvent(eventName, args);
		}
	},

	register: function(id, client) {
		// register new client to receive events
		this.clients[id] = client;
	},

	getDOMObjectPosition: function(obj) {
		// get absolute coordinates for dom element
		var info = {
			left: 0,
			top: 0,
			width: obj.width ? obj.width : obj.offsetWidth,
			height: obj.height ? obj.height : obj.offsetHeight
		};

		if ( obj.style.width !== "" ) {
			info.width = obj.style.width.replace("px","");
		}

		if ( obj.style.height !== "" ) {
			info.height = obj.style.height.replace("px","");
		}

		while (obj) {
			info.left += obj.offsetLeft;
			info.top += obj.offsetTop;
			obj = obj.offsetParent;
		}

		return info;
	},

	Client: function(elem) {
		// constructor for new simple upload client
		this.handlers = {};

		// unique ID
		this.id = ZeroClipboard_TableTools.nextId++;
		this.movieId = 'ZeroClipboard_TableToolsMovie_' + this.id;

		// register client with singleton to receive flash events
		ZeroClipboard_TableTools.register(this.id, this);

		// create movie
		if (elem) {
			this.glue(elem);
		}
	}
};

ZeroClipboard_TableTools.Client.prototype = {

	id: 0, // unique ID for us
	ready: false, // whether movie is ready to receive events or not
	movie: null, // reference to movie object
	clipText: '', // text to copy to clipboard
	fileName: '', // default file save name
	action: 'copy', // action to perform
	handCursorEnabled: true, // whether to show hand cursor, or default pointer cursor
	cssEffects: true, // enable CSS mouse effects on dom container
	handlers: null, // user event handlers
	sized: false,

	glue: function(elem, title) {
		// glue to DOM element
		// elem can be ID or actual DOM element object
		this.domElement = ZeroClipboard_TableTools.$(elem);

		// float just above object, or zIndex 99 if dom element isn't set
		var zIndex = 99;
		if (this.domElement.style.zIndex) {
			zIndex = parseInt(this.domElement.style.zIndex, 10) + 1;
		}

		// find X/Y position of domElement
		var box = ZeroClipboard_TableTools.getDOMObjectPosition(this.domElement);

		// create floating DIV above element
		this.div = document.createElement('div');
		var style = this.div.style;
		style.position = 'absolute';
		style.left = '0px';
		style.top = '0px';
		style.width = (box.width) + 'px';
		style.height = box.height + 'px';
		style.zIndex = zIndex;

		if ( typeof title != "undefined" && title !== "" ) {
			this.div.title = title;
		}
		if ( box.width !== 0 && box.height !== 0 ) {
			this.sized = true;
		}

		// style.backgroundColor = '#f00'; // debug
		if ( this.domElement ) {
			this.domElement.appendChild(this.div);
			this.div.innerHTML = this.getHTML( box.width, box.height ).replace(/&/g, '&amp;');
		}
	},

	positionElement: function() {
		var box = ZeroClipboard_TableTools.getDOMObjectPosition(this.domElement);
		var style = this.div.style;

		style.position = 'absolute';
		//style.left = (this.domElement.offsetLeft)+'px';
		//style.top = this.domElement.offsetTop+'px';
		style.width = box.width + 'px';
		style.height = box.height + 'px';

		if ( box.width !== 0 && box.height !== 0 ) {
			this.sized = true;
		} else {
			return;
		}

		var flash = this.div.childNodes[0];
		flash.width = box.width;
		flash.height = box.height;
	},

	getHTML: function(width, height) {
		// return HTML for movie
		var html = '';
		var flashvars = 'id=' + this.id +
			'&width=' + width +
			'&height=' + height;

		if (navigator.userAgent.match(/MSIE/)) {
			// IE gets an OBJECT tag
			var protocol = location.href.match(/^https/i) ? 'https://' : 'http://';
			// [OT] Removed <param name="allowScriptAccess" value="always" /> to silence Fortify.
			// If the toolar start to be used, this needs to be re-added again.
			html += '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="'+protocol+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=10,0,0,0" width="'+width+'" height="'+height+'" id="'+this.movieId+'" align="middle"><param name="allowFullScreen" value="false" /><param name="movie" value="'+ZeroClipboard_TableTools.moviePath+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><param name="wmode" value="transparent"/></object>';
		}
		else {
			// all other browsers get an EMBED tag
      // [OT] Removed allowScriptAccess="always" to silence Fortify.
      // If the toolar start to be used, this needs to be re-added again.
			html += '<embed id="'+this.movieId+'" src="'+ZeroClipboard_TableTools.moviePath+'" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+width+'" height="'+height+'" name="'+this.movieId+'" align="middle" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'" wmode="transparent" />';
		}
		return html;
	},

	hide: function() {
		// temporarily hide floater offscreen
		if (this.div) {
			this.div.style.left = '-2000px';
		}
	},

	show: function() {
		// show ourselves after a call to hide()
		this.reposition();
	},

	destroy: function() {
		// destroy control and floater
		if (this.domElement && this.div) {
			this.hide();
			this.div.innerHTML = '';

			var body = document.getElementsByTagName('body')[0];
			try { body.removeChild( this.div ); } catch(e) {}

			this.domElement = null;
			this.div = null;
		}
	},

	reposition: function(elem) {
		// reposition our floating div, optionally to new container
		// warning: container CANNOT change size, only position
		if (elem) {
			this.domElement = ZeroClipboard_TableTools.$(elem);
			if (!this.domElement) {
				this.hide();
			}
		}

		if (this.domElement && this.div) {
			var box = ZeroClipboard_TableTools.getDOMObjectPosition(this.domElement);
			var style = this.div.style;
			style.left = '' + box.left + 'px';
			style.top = '' + box.top + 'px';
		}
	},

	clearText: function() {
		// clear the text to be copy / saved
		this.clipText = '';
		if (this.ready) {
			this.movie.clearText();
		}
	},

	appendText: function(newText) {
		// append text to that which is to be copied / saved
		this.clipText += newText;
		if (this.ready) { this.movie.appendText(newText) ;}
	},

	setText: function(newText) {
		// set text to be copied to be copied / saved
		this.clipText = newText;
		if (this.ready) { this.movie.setText(newText) ;}
	},

	setCharSet: function(charSet) {
		// set the character set (UTF16LE or UTF8)
		this.charSet = charSet;
		if (this.ready) { this.movie.setCharSet(charSet) ;}
	},

	setBomInc: function(bomInc) {
		// set if the BOM should be included or not
		this.incBom = bomInc;
		if (this.ready) { this.movie.setBomInc(bomInc) ;}
	},

	setFileName: function(newText) {
		// set the file name
		this.fileName = newText;
		if (this.ready) {
			this.movie.setFileName(newText);
		}
	},

	setAction: function(newText) {
		// set action (save or copy)
		this.action = newText;
		if (this.ready) {
			this.movie.setAction(newText);
		}
	},

	addEventListener: function(eventName, func) {
		// add user event listener for event
		// event types: load, queueStart, fileStart, fileComplete, queueComplete, progress, error, cancel
		eventName = eventName.toString().toLowerCase().replace(/^on/, '');
		if (!this.handlers[eventName]) {
			this.handlers[eventName] = [];
		}
		this.handlers[eventName].push(func);
	},

	setHandCursor: function(enabled) {
		// enable hand cursor (true), or default arrow cursor (false)
		this.handCursorEnabled = enabled;
		if (this.ready) {
			this.movie.setHandCursor(enabled);
		}
	},

	setCSSEffects: function(enabled) {
		// enable or disable CSS effects on DOM container
		this.cssEffects = !!enabled;
	},

	receiveEvent: function(eventName, args) {
		var self;

		// receive event from flash
		eventName = eventName.toString().toLowerCase().replace(/^on/, '');

		// special behavior for certain events
		switch (eventName) {
			case 'load':
				// movie claims it is ready, but in IE this isn't always the case...
				// bug fix: Cannot extend EMBED DOM elements in Firefox, must use traditional function
				this.movie = document.getElementById(this.movieId);
				if (!this.movie) {
					self = this;
					setTimeout( function() { self.receiveEvent('load', null); }, 1 );
					return;
				}

				// firefox on pc needs a "kick" in order to set these in certain cases
				if (!this.ready && navigator.userAgent.match(/Firefox/) && navigator.userAgent.match(/Windows/)) {
					self = this;
					setTimeout( function() { self.receiveEvent('load', null); }, 100 );
					this.ready = true;
					return;
				}

				this.ready = true;
				this.movie.clearText();
				this.movie.appendText( this.clipText );
				this.movie.setFileName( this.fileName );
				this.movie.setAction( this.action );
				this.movie.setCharSet( this.charSet );
				this.movie.setBomInc( this.incBom );
				this.movie.setHandCursor( this.handCursorEnabled );
				break;

			case 'mouseover':
				if (this.domElement && this.cssEffects) {
					//this.domElement.addClass('hover');
					if (this.recoverActive) {
						this.domElement.addClass('binf-active');
					}
				}
				break;

			case 'mouseout':
				if (this.domElement && this.cssEffects) {
					this.recoverActive = false;
					if (this.domElement.hasClass('binf-active')) {
						this.domElement.removeClass('binf-active');
						this.recoverActive = true;
					}
					//this.domElement.removeClass('hover');
				}
				break;

			case 'mousedown':
				if (this.domElement && this.cssEffects) {
					this.domElement.addClass('binf-active');
				}
				break;

			case 'mouseup':
				if (this.domElement && this.cssEffects) {
					this.domElement.removeClass('binf-active');
					this.recoverActive = false;
				}
				break;
		} // switch eventName

		if (this.handlers[eventName]) {
			for (var idx = 0, len = this.handlers[eventName].length; idx < len; idx++) {
				var func = this.handlers[eventName][idx];

				if (typeof(func) == 'function') {
					// actual function reference
					func(this, args);
				}
				else if ((typeof(func) == 'object') && (func.length == 2)) {
					// PHP style object + method, i.e. [myObject, 'myMethod']
					func[0][ func[1] ](this, args);
				}
				else if (typeof(func) == 'string') {
					// name of function
					window[func](this, args);
				}
			} // foreach event handler defined
		} // user defined handler for event
	}

};

// For the Flash binding to work, ZeroClipboard_TableTools must be on the global
// object list
window.ZeroClipboard_TableTools = ZeroClipboard_TableTools;
//include TableTools.js
/* TableTools
 * 2009-2014 SpryMedia Ltd - datatables.net/license
 */

/*globals TableTools,ZeroClipboard_TableTools*/


(function($, window, document) {

/** 
 * TableTools provides flexible buttons and other tools for a DataTables enhanced table
 * @class TableTools
 * @constructor
 * @param {Object} oDT DataTables instance. When using DataTables 1.10 this can
 *   also be a jQuery collection, jQuery selector, table node, DataTables API
 *   instance or DataTables settings object.
 * @param {Object} oOpts TableTools options
 * @param {String} oOpts.sSwfPath ZeroClipboard SWF path
 * @param {String} oOpts.sRowSelect Row selection options - 'none', 'single', 'multi' or 'os'
 * @param {Function} oOpts.fnPreRowSelect Callback function just prior to row selection
 * @param {Function} oOpts.fnRowSelected Callback function just after row selection
 * @param {Function} oOpts.fnRowDeselected Callback function when row is deselected
 * @param {Array} oOpts.aButtons List of buttons to be used
 */
TableTools = function( oDT, oOpts )
{
	/* Santiy check that we are a new instance */
	if ( ! this instanceof TableTools )
	{
		alert( "Warning: TableTools must be initialised with the keyword 'new'" );
	}

	// In 1.10 we can use the API to get the settings object from a number of
	// sources
	var dtSettings = $.fn.dataTable.Api ?
		new $.fn.dataTable.Api( oDT ).settings()[0] :
		oDT.fnSettings();


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public class variables
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * @namespace Settings object which contains customisable information for TableTools instance
	 */
	this.s = {
		/**
		 * Store 'this' so the instance can be retrieved from the settings object
		 * @property that
		 * @type	 object
		 * @default  this
		 */
		"that": this,

		/** 
		 * DataTables settings objects
		 * @property dt
		 * @type	 object
		 * @default  <i>From the oDT init option</i>
		 */
		"dt": dtSettings,

		/**
		 * @namespace Print specific information
		 */
		"print": {
			/** 
			 * DataTables draw 'start' point before the printing display was shown
			 *  @property saveStart
			 *  @type	 int
			 *  @default  -1
			 */
			"saveStart": -1,

			/** 
			 * DataTables draw 'length' point before the printing display was shown
			 *  @property saveLength
			 *  @type	 int
			 *  @default  -1
			 */
			"saveLength": -1,

			/** 
			 * Page scrolling point before the printing display was shown so it can be restored
			 *  @property saveScroll
			 *  @type	 int
			 *  @default  -1
			 */
			"saveScroll": -1,

			/** 
			 * Wrapped function to end the print display (to maintain scope)
			 *  @property funcEnd
			 *  @type	 Function
			 *  @default  function () {}
			 */
			"funcEnd": function () {}
		},

		/**
		 * A unique ID is assigned to each button in each instance
		 * @property buttonCounter
		 *  @type	 int
		 * @default  0
		 */
		"buttonCounter": 0,

		/**
		 * @namespace Select rows specific information
		 */
		"select": {
			/**
			 * Select type - can be 'none', 'single' or 'multi'
			 * @property type
			 *  @type	 string
			 * @default  ""
			 */
			"type": "",

			/**
			 * Array of nodes which are currently selected
			 *  @property selected
			 *  @type	 array
			 *  @default  []
			 */
			"selected": [],

			/**
			 * Function to run before the selection can take place. Will cancel the select if the
			 * function returns false
			 *  @property preRowSelect
			 *  @type	 Function
			 *  @default  null
			 */
			"preRowSelect": null,

			/**
			 * Function to run when a row is selected
			 *  @property postSelected
			 *  @type	 Function
			 *  @default  null
			 */
			"postSelected": null,

			/**
			 * Function to run when a row is deselected
			 *  @property postDeselected
			 *  @type	 Function
			 *  @default  null
			 */
			"postDeselected": null,

			/**
			 * Indicate if all rows are selected (needed for server-side processing)
			 *  @property all
			 *  @type	 boolean
			 *  @default  false
			 */
			"all": false,

			/**
			 * Class name to add to selected TR nodes
			 *  @property selectedClass
			 *  @type	 String
			 *  @default  ""
			 */
			"selectedClass": ""
		},

		/**
		 * Store of the user input customisation object
		 *  @property custom
		 *  @type	 object
		 *  @default  {}
		 */
		"custom": {},

		/**
		 * SWF movie path
		 *  @property swfPath
		 *  @type	 string
		 *  @default  ""
		 */
		"swfPath": "",

		/**
		 * Default button set
		 *  @property buttonSet
		 *  @type	 array
		 *  @default  []
		 */
		"buttonSet": [],

		/**
		 * When there is more than one TableTools instance for a DataTable, there must be a 
		 * master which controls events (row selection etc)
		 *  @property master
		 *  @type	 boolean
		 *  @default  false
		 */
		"master": false,

		/**
		 * Tag names that are used for creating collections and buttons
		 *  @namesapce
		 */
		"tags": {}
	};


	/**
	 * @namespace Common and useful DOM elements for the class instance
	 */
	this.dom = {
		/**
		 * DIV element that is create and all TableTools buttons (and their children) put into
		 *  @property container
		 *  @type	 node
		 *  @default  null
		 */
		"container": null,

		/**
		 * The table node to which TableTools will be applied
		 *  @property table
		 *  @type	 node
		 *  @default  null
		 */
		"table": null,

		/**
		 * @namespace Nodes used for the print display
		 */
		"print": {
			/**
			 * Nodes which have been removed from the display by setting them to display none
			 *  @property hidden
			 *  @type	 array
			 *  @default  []
			 */
			"hidden": [],

			/**
			 * The information display saying telling the user about the print display
			 *  @property message
			 *  @type	 node
			 *  @default  null
			 */
			"message": null
	  },

		/**
		 * @namespace Nodes used for a collection display. This contains the currently used collection
		 */
		"collection": {
			/**
			 * The div wrapper containing the buttons in the collection (i.e. the menu)
			 *  @property collection
			 *  @type	 node
			 *  @default  null
			 */
			"collection": null,

			/**
			 * Background display to provide focus and capture events
			 *  @property background
			 *  @type	 node
			 *  @default  null
			 */
			"background": null
		}
	};

	/**
	 * @namespace Name space for the classes that this TableTools instance will use
	 * @extends TableTools.classes
	 */
	this.classes = $.extend( true, {}, TableTools.classes );
	if ( this.s.dt.bJUI )
	{
		$.extend( true, this.classes, TableTools.classes_themeroller );
	}


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public class methods
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Retreieve the settings object from an instance
	 *  @method fnSettings
	 *  @returns {object} TableTools settings object
	 */
	this.fnSettings = function () {
		return this.s;
	};


	/* Constructor logic */
	if ( typeof oOpts == 'undefined' )
	{
		oOpts = {};
	}


	TableTools._aInstances.push( this );
	this._fnConstruct( oOpts );

	return this;
};



TableTools.prototype = {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Retreieve the settings object from an instance
	 *  @returns {array} List of TR nodes which are currently selected
	 *  @param {boolean} [filtered=false] Get only selected rows which are  
	 *    available given the filtering applied to the table. By default
	 *    this is false -  i.e. all rows, regardless of filtering are 
	      selected.
	 */
	"fnGetSelected": function ( filtered )
	{
		var
			out = [],
			data = this.s.dt.aoData,
			displayed = this.s.dt.aiDisplay,
			i, iLen;

		if ( filtered )
		{
			// Only consider filtered rows
			for ( i=0, iLen=displayed.length ; i<iLen ; i++ )
			{
				if ( data[ displayed[i] ]._DTTT_selected )
				{
					out.push( data[ displayed[i] ].nTr );
				}
			}
		}
		else
		{
			// Use all rows
			for ( i=0, iLen=data.length ; i<iLen ; i++ )
			{
				if ( data[i]._DTTT_selected )
				{
					out.push( data[i].nTr );
				}
			}
		}

		return out;
	},


	/**
	 * Get the data source objects/arrays from DataTables for the selected rows (same as
	 * fnGetSelected followed by fnGetData on each row from the table)
	 *  @returns {array} Data from the TR nodes which are currently selected
	 */
	"fnGetSelectedData": function ()
	{
		var out = [];
		var data=this.s.dt.aoData;
		var i, iLen;

		for ( i=0, iLen=data.length ; i<iLen ; i++ )
		{
			if ( data[i]._DTTT_selected )
			{
				out.push( this.s.dt.oInstance.fnGetData(i) );
			}
		}

		return out;
	},


	/**
	 * Get the indexes of the selected rows
	 *  @returns {array} List of row indexes
	 *  @param {boolean} [filtered=false] Get only selected rows which are  
	 *    available given the filtering applied to the table. By default
	 *    this is false -  i.e. all rows, regardless of filtering are 
	      selected.
	 */
	"fnGetSelectedIndexes": function ( filtered )
	{
		var
			out = [],
			data = this.s.dt.aoData,
			displayed = this.s.dt.aiDisplay,
			i, iLen;

		if ( filtered )
		{
			// Only consider filtered rows
			for ( i=0, iLen=displayed.length ; i<iLen ; i++ )
			{
				if ( data[ displayed[i] ]._DTTT_selected )
				{
					out.push( displayed[i] );
				}
			}
		}
		else
		{
			// Use all rows
			for ( i=0, iLen=data.length ; i<iLen ; i++ )
			{
				if ( data[i]._DTTT_selected )
				{
					out.push( i );
				}
			}
		}

		return out;
	},


	/**
	 * Check to see if a current row is selected or not
	 *  @param {Node} n TR node to check if it is currently selected or not
	 *  @returns {Boolean} true if select, false otherwise
	 */
	"fnIsSelected": function ( n )
	{
		var pos = this.s.dt.oInstance.fnGetPosition( n );
		return (this.s.dt.aoData[pos]._DTTT_selected===true) ? true : false;
	},


	/**
	 * Select all rows in the table
	 *  @param {boolean} [filtered=false] Select only rows which are available 
	 *    given the filtering applied to the table. By default this is false - 
	 *    i.e. all rows, regardless of filtering are selected.
	 */
	"fnSelectAll": function ( filtered )
	{
		this._fnRowSelect( filtered ?
			this.s.dt.aiDisplay :
			this.s.dt.aoData
		);
	},


	/**
	 * Deselect all rows in the table
	 *  @param {boolean} [filtered=false] Deselect only rows which are available 
	 *    given the filtering applied to the table. By default this is false - 
	 *    i.e. all rows, regardless of filtering are deselected.
	 */
	"fnSelectNone": function ( filtered )
	{
		this._fnRowDeselect( this.fnGetSelectedIndexes(filtered) );
	},


	/**
	 * Select row(s)
	 *  @param {node|object|array} n The row(s) to select. Can be a single DOM
	 *    TR node, an array of TR nodes or a jQuery object.
	 */
	"fnSelect": function ( n )
	{
		if ( this.s.select.type == "single" )
		{
			this.fnSelectNone();
			this._fnRowSelect( n );
		}
		else
		{
			this._fnRowSelect( n );
		}
	},


	/**
	 * Deselect row(s)
	 *  @param {node|object|array} n The row(s) to deselect. Can be a single DOM
	 *    TR node, an array of TR nodes or a jQuery object.
	 */
	"fnDeselect": function ( n )
	{
		this._fnRowDeselect( n );
	},


	/**
	 * Get the title of the document - useful for file names. The title is retrieved from either
	 * the configuration object's 'title' parameter, or the HTML document title
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns {String} Button title
	 */
	"fnGetTitle": function( oConfig )
	{
		var sTitle = "";
		if ( typeof oConfig.sTitle != 'undefined' && oConfig.sTitle !== "" ) {
			sTitle = oConfig.sTitle;
		} else {
			var anTitle = document.getElementsByTagName('title');
			if ( anTitle.length > 0 )
			{
				sTitle = anTitle[0].innerHTML;
			}
		}

		/* Strip characters which the OS will object to - checking for UTF8 support in the scripting
		 * engine
		 */
		if ( "\u00A1".toString().length < 4 ) {
			return sTitle.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");
		} else {
			return sTitle.replace(/[^a-zA-Z0-9_\.,\-_ !\(\)]/g, "");
		}
	},


	/**
	 * Calculate a unity array with the column width by proportion for a set of columns to be
	 * included for a button. This is particularly useful for PDF creation, where we can use the
	 * column widths calculated by the browser to size the columns in the PDF.
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns {Array} Unity array of column ratios
	 */
	"fnCalcColRatios": function ( oConfig )
	{
		var
			aoCols = this.s.dt.aoColumns,
			aColumnsInc = this._fnColumnTargets( oConfig.mColumns ),
			aColWidths = [],
			iWidth = 0, iTotal = 0, i, iLen;

		for ( i=0, iLen=aColumnsInc.length ; i<iLen ; i++ )
		{
			if ( aColumnsInc[i] )
			{
				iWidth = aoCols[i].nTh.offsetWidth;
				iTotal += iWidth;
				aColWidths.push( iWidth );
			}
		}

		for ( i=0, iLen=aColWidths.length ; i<iLen ; i++ )
		{
			aColWidths[i] = aColWidths[i] / iTotal;
		}

		return aColWidths.join('\t');
	},


	/**
	 * Get the information contained in a table as a string
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns {String} Table data as a string
	 */
	"fnGetTableData": function ( oConfig )
	{
		/* In future this could be used to get data from a plain HTML source as well as DataTables */
		if ( this.s.dt )
		{
			return this._fnGetDataTablesData( oConfig );
		}
	},


	/**
	 * Pass text to a flash button instance, which will be used on the button's click handler
	 *  @param   {Object} clip Flash button object
	 *  @param   {String} text Text to set
	 */
	"fnSetText": function ( clip, text )
	{
		this._fnFlashSetText( clip, text );
	},


	/**
	 * Resize the flash elements of the buttons attached to this TableTools instance - this is
	 * useful for when initialising TableTools when it is hidden (display:none) since sizes can't
	 * be calculated at that time.
	 */
	"fnResizeButtons": function ()
	{
		for ( var cli in ZeroClipboard_TableTools.clients )
		{
			if ( cli )
			{
				var client = ZeroClipboard_TableTools.clients[cli];
				if ( typeof client.domElement != 'undefined' &&
					 client.domElement.parentNode )
				{
					client.positionElement();
				}
			}
		}
	},


	/**
	 * Check to see if any of the ZeroClipboard client's attached need to be resized
	 */
	"fnResizeRequired": function ()
	{
		for ( var cli in ZeroClipboard_TableTools.clients )
		{
			if ( cli )
			{
				var client = ZeroClipboard_TableTools.clients[cli];
				if ( typeof client.domElement != 'undefined' &&
					 client.domElement.parentNode == this.dom.container &&
					 client.sized === false )
				{
					return true;
				}
			}
		}
		return false;
	},


	/**
	 * Programmatically enable or disable the print view
	 *  @param {boolean} [bView=true] Show the print view if true or not given. If false, then
	 *    terminate the print view and return to normal.
	 *  @param {object} [oConfig={}] Configuration for the print view
	 *  @param {boolean} [oConfig.bShowAll=false] Show all rows in the table if true
	 *  @param {string} [oConfig.sInfo] Information message, displayed as an overlay to the
	 *    user to let them know what the print view is.
	 *  @param {string} [oConfig.sMessage] HTML string to show at the top of the document - will
	 *    be included in the printed document.
	 */
	"fnPrint": function ( bView, oConfig )
	{
		if ( oConfig === undefined )
		{
			oConfig = {};
		}

		if ( bView === undefined || bView )
		{
			this._fnPrintStart( oConfig );
		}
		else
		{
			this._fnPrintEnd();
		}
	},


	/**
	 * Show a message to the end user which is nicely styled
	 *  @param {string} message The HTML string to show to the user
	 *  @param {int} time The duration the message is to be shown on screen for (mS)
	 */
	"fnInfo": function ( message, time ) {
		var info = $('<div/>')
			.addClass( this.classes.print.info )
			.html( message )
			.appendTo( 'body' );

		setTimeout( function() {
			info.fadeOut( "normal", function() {
				info.remove();
			} );
		}, time );
	},



	/**
	 * Get the container element of the instance for attaching to the DOM
	 *   @returns {node} DOM node
	 */
	"fnContainer": function () {
		return this.dom.container;
	},



	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods (they are of course public in JS, but recommended as private)
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Constructor logic
	 *  @method  _fnConstruct
	 *  @param   {Object} oOpts Same as TableTools constructor
	 *  @returns void
	 *  @private 
	 */
	"_fnConstruct": function ( oOpts )
	{
		var that = this;

		this._fnCustomiseSettings( oOpts );

		/* Container element */
		this.dom.container = document.createElement( this.s.tags.container );
		this.dom.container.className = this.classes.container;

		/* Row selection config */
		if ( this.s.select.type != 'none' )
		{
			this._fnRowSelectConfig();
		}

		/* Buttons */
		this._fnButtonDefinations( this.s.buttonSet, this.dom.container );

		/* Destructor */
		this.s.dt.aoDestroyCallback.push( {
			"sName": "TableTools",
			"fn": function () {
				$(that.s.dt.nTBody).off( 'click.DTTT_Select', 'tr' );
				$(that.dom.container).empty();

				// Remove the instance
				var idx = $.inArray( that, TableTools._aInstances );
				if ( idx !== -1 ) {
					TableTools._aInstances.splice( idx, 1 );
				}
			}
		} );
	},


	/**
	 * Take the user defined settings and the default settings and combine them.
	 *  @method  _fnCustomiseSettings
	 *  @param   {Object} oOpts Same as TableTools constructor
	 *  @returns void
	 *  @private 
	 */
	"_fnCustomiseSettings": function ( oOpts )
	{
		/* Is this the master control instance or not? */
		if ( typeof this.s.dt._TableToolsInit == 'undefined' )
		{
			this.s.master = true;
			this.s.dt._TableToolsInit = true;
		}

		/* We can use the table node from comparisons to group controls */
		this.dom.table = this.s.dt.nTable;

		/* Clone the defaults and then the user options */
		this.s.custom = $.extend( {}, TableTools.DEFAULTS, oOpts );

		/* Flash file location */
		this.s.swfPath = this.s.custom.sSwfPath;
		if ( typeof ZeroClipboard_TableTools != 'undefined' )
		{
			ZeroClipboard_TableTools.moviePath = this.s.swfPath;
		}

		/* Table row selecting */
		this.s.select.type = this.s.custom.sRowSelect;
		this.s.select.preRowSelect = this.s.custom.fnPreRowSelect;
		this.s.select.postSelected = this.s.custom.fnRowSelected;
		this.s.select.postDeselected = this.s.custom.fnRowDeselected;

		// Backwards compatibility - allow the user to specify a custom class in the initialiser
		if ( this.s.custom.sSelectedClass )
		{
			this.classes.select.row = this.s.custom.sSelectedClass;
		}

		this.s.tags = this.s.custom.oTags;

		/* Button set */
		this.s.buttonSet = this.s.custom.aButtons;
	},


	/**
	 * Take the user input arrays and expand them to be fully defined, and then add them to a given
	 * DOM element
	 *  @method  _fnButtonDefinations
	 *  @param {array} buttonSet Set of user defined buttons
	 *  @param {node} wrapper Node to add the created buttons to
	 *  @returns void
	 *  @private 
	 */
	"_fnButtonDefinations": function ( buttonSet, wrapper )
	{
		var buttonDef;

		for ( var i=0, iLen=buttonSet.length ; i<iLen ; i++ )
		{
			if ( typeof buttonSet[i] == "string" )
			{
				if ( typeof TableTools.BUTTONS[ buttonSet[i] ] == 'undefined' )
				{
					alert( "TableTools: Warning - unknown button type: "+buttonSet[i] );
					continue;
				}
				buttonDef = $.extend( {}, TableTools.BUTTONS[ buttonSet[i] ], true );
			}
			else
			{
				if ( typeof TableTools.BUTTONS[ buttonSet[i].sExtends ] == 'undefined' )
				{
					alert( "TableTools: Warning - unknown button type: "+buttonSet[i].sExtends );
					continue;
				}
				var o = $.extend( {}, TableTools.BUTTONS[ buttonSet[i].sExtends ], true );
				buttonDef = $.extend( o, buttonSet[i], true );
			}

			var button = this._fnCreateButton(
				buttonDef,
				$(wrapper).hasClass(this.classes.collection.container)
			);

			if ( button ) {
				wrapper.appendChild( button );
			}
		}
	},


	/**
	 * Create and configure a TableTools button
	 *  @method  _fnCreateButton
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns {Node} Button element
	 *  @private 
	 */
	"_fnCreateButton": function ( oConfig, bCollectionButton )
	{
	  var nButton = this._fnButtonBase( oConfig, bCollectionButton );

		if ( oConfig.sAction.match(/flash/) )
		{
			if ( ! this._fnHasFlash() ) {
				return false;
			}

			this._fnFlashConfig( nButton, oConfig );
		}
		else if ( oConfig.sAction == "text" )
		{
			this._fnTextConfig( nButton, oConfig );
		}
		else if ( oConfig.sAction == "div" )
		{
			this._fnTextConfig( nButton, oConfig );
		}
		else if ( oConfig.sAction == "collection" )
		{
			this._fnTextConfig( nButton, oConfig );
			this._fnCollectionConfig( nButton, oConfig );
		}

		if ( this.s.dt.iTabIndex !== -1 ) {
			$(nButton)
				.attr( 'tabindex', this.s.dt.iTabIndex )
				.attr( 'aria-controls', this.s.dt.sTableId )
				.on( 'keyup.DTTT', function (e) {
					// Trigger the click event on return key when focused.
					// Note that for Flash buttons this has no effect since we
					// can't programmatically trigger the Flash export
					if ( e.keyCode === 13 ) {
						e.stopPropagation();

						$(this).trigger( 'click' );
					}
				} )
				.on( 'mousedown.DTTT', function (e) {
					// On mousedown we want to stop the focus occurring on the
					// button, focus is used only for the keyboard navigation.
					// But using preventDefault for the flash buttons stops the
					// flash action. However, it is not the button that gets
					// focused but the flash element for flash buttons, so this
					// works
					if ( ! oConfig.sAction.match(/flash/) ) {
						e.preventDefault();
					}
				} );
		}

		return nButton;
	},


	/**
	 * Create the DOM needed for the button and apply some base properties. All buttons start here
	 *  @method  _fnButtonBase
	 *  @param   {o} oConfig Button configuration object
	 *  @returns {Node} DIV element for the button
	 *  @private
	 */
	"_fnButtonBase": function ( o, bCollectionButton )
	{
		var sTag, sLiner, sClass;

		if ( bCollectionButton )
		{
			sTag = o.sTag && o.sTag !== "default" ? o.sTag : this.s.tags.collection.button;
			sLiner = o.sLinerTag && o.sLinerTag !== "default" ? o.sLiner : this.s.tags.collection.liner;
			sClass = this.classes.collection.buttons.normal;
		}
		else
		{
			sTag = o.sTag && o.sTag !== "default" ? o.sTag : this.s.tags.button;
			sLiner = o.sLinerTag && o.sLinerTag !== "default" ? o.sLiner : this.s.tags.liner;
			sClass = this.classes.buttons.normal;
		}

		var
		  nButton = document.createElement( sTag ),
		  nSpan = document.createElement( sLiner ),
		  masterS = this._fnGetMasterSettings();

		nButton.className = sClass+" "+o.sButtonClass;
		nButton.setAttribute('id', "ToolTables_"+this.s.dt.sInstance+"_"+masterS.buttonCounter );
		nButton.appendChild( nSpan );
		nSpan.innerHTML = o.sButtonText;

		masterS.buttonCounter++;

		return nButton;
	},


	/**
	 * Get the settings object for the master instance. When more than one TableTools instance is
	 * assigned to a DataTable, only one of them can be the 'master' (for the select rows). As such,
	 * we will typically want to interact with that master for global properties.
	 *  @method  _fnGetMasterSettings
	 *  @returns {Object} TableTools settings object
	 *  @private 
	 */
	"_fnGetMasterSettings": function ()
	{
		if ( this.s.master )
		{
			return this.s;
		}
		else
		{
			/* Look for the master which has the same DT as this one */
			var instances = TableTools._aInstances;
			for ( var i=0, iLen=instances.length ; i<iLen ; i++ )
			{
				if ( this.dom.table == instances[i].s.dt.nTable )
				{
					return instances[i].s;
				}
			}
		}
	},



	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Button collection functions
	 */

	/**
	 * Create a collection button, when activated will present a drop down list of other buttons
	 *  @param   {Node} nButton Button to use for the collection activation
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns void
	 *  @private
	 */
	"_fnCollectionConfig": function ( nButton, oConfig )
	{
		var nHidden = document.createElement( this.s.tags.collection.container );
		nHidden.style.display = "none";
		nHidden.className = this.classes.collection.container;
		oConfig._collection = nHidden;
		document.body.appendChild( nHidden );

		this._fnButtonDefinations( oConfig.aButtons, nHidden );
	},


	/**
	 * Show a button collection
	 *  @param   {Node} nButton Button to use for the collection
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns void
	 *  @private
	 */
	"_fnCollectionShow": function ( nButton, oConfig )
	{
		var
			that = this,
			oPos = $(nButton).offset(),
			nHidden = oConfig._collection,
			iDivX = oPos.left,
			iDivY = oPos.top + $(nButton).outerHeight(),
			iWinHeight = $(window).height(), iDocHeight = $(document).height(),
			iWinWidth = $(window).width(), iDocWidth = $(document).width();

		nHidden.style.position = "absolute";
		nHidden.style.left = iDivX+"px";
		nHidden.style.top = iDivY+"px";
		nHidden.style.display = "block";
		$(nHidden).css('opacity',0);

		var nBackground = document.createElement('div');
		nBackground.style.position = "absolute";
		nBackground.style.left = "0px";
		nBackground.style.top = "0px";
		nBackground.style.height = ((iWinHeight>iDocHeight)? iWinHeight : iDocHeight) +"px";
		nBackground.style.width = ((iWinWidth>iDocWidth)? iWinWidth : iDocWidth) +"px";
		nBackground.className = this.classes.collection.background;
		$(nBackground).css('opacity',0);

		document.body.appendChild( nBackground );
		document.body.appendChild( nHidden );

		/* Visual corrections to try and keep the collection visible */
		var iDivWidth = $(nHidden).outerWidth();
		var iDivHeight = $(nHidden).outerHeight();

		if ( iDivX + iDivWidth > iDocWidth )
		{
			nHidden.style.left = (iDocWidth-iDivWidth)+"px";
		}

		if ( iDivY + iDivHeight > iDocHeight )
		{
			nHidden.style.top = (iDivY-iDivHeight-$(nButton).outerHeight())+"px";
		}

		this.dom.collection.collection = nHidden;
		this.dom.collection.background = nBackground;

		/* This results in a very small delay for the end user but it allows the animation to be
		 * much smoother. If you don't want the animation, then the setTimeout can be removed
		 */
		setTimeout( function () {
			$(nHidden).animate({"opacity": 1}, 500);
			$(nBackground).animate({"opacity": 0.25}, 500);
		}, 10 );

		/* Resize the buttons to the Flash contents fit */
		this.fnResizeButtons();

		/* Event handler to remove the collection display */
		$(nBackground).click( function () {
			that._fnCollectionHide.call( that, null, null );
		} );
	},


	/**
	 * Hide a button collection
	 *  @param   {Node} nButton Button to use for the collection
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns void
	 *  @private
	 */
	"_fnCollectionHide": function ( nButton, oConfig )
	{
		if ( oConfig !== null && oConfig.sExtends == 'collection' )
		{
			return;
		}

		if ( this.dom.collection.collection !== null )
		{
			$(this.dom.collection.collection).animate({"opacity": 0}, 500, function (e) {
				this.style.display = "none";
			} );

			$(this.dom.collection.background).animate({"opacity": 0}, 500, function (e) {
				this.parentNode.removeChild( this );
			} );

			this.dom.collection.collection = null;
			this.dom.collection.background = null;
		}
	},



	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Row selection functions
	 */

	/**
	 * Add event handlers to a table to allow for row selection
	 *  @method  _fnRowSelectConfig
	 *  @returns void
	 *  @private 
	 */
	"_fnRowSelectConfig": function ()
	{
		if ( this.s.master )
		{
			var
				that = this,
				i, iLen,
				dt = this.s.dt,
				aoOpenRows = this.s.dt.aoOpenRows;

			$(dt.nTable).addClass( this.classes.select.table );

			// When using OS style selection, we want to cancel the shift text
			// selection, but only when the shift key is used (so you can
			// actually still select text in the table)
			if ( this.s.select.type === 'os' ) {
				$(dt.nTBody).on( 'mousedown.DTTT_Select', 'tr', function(e) {
					if ( e.shiftKey ) {

						$(dt.nTBody)
							.css( '-moz-user-select', 'none' )
							.one('selectstart.DTTT_Select', 'tr', function () {
								return false;
							} );
					}
				} );

				$(dt.nTBody).on( 'mouseup.DTTT_Select', 'tr', function(e) {
					$(dt.nTBody).css( '-moz-user-select', '' );
				} );
			}

			// Row selection
			$(dt.nTBody).on( 'click.DTTT_Select', this.s.custom.sRowSelector, function(e) {
				var row = this.nodeName.toLowerCase() === 'tr' ?
					this :
					$(this).parents('tr')[0];

				var select = that.s.select;
				var pos = that.s.dt.oInstance.fnGetPosition( row );

				/* Sub-table must be ignored (odd that the selector won't do this with >) */
				if ( row.parentNode != dt.nTBody ) {
					return;
				}

				/* Check that we are actually working with a DataTables controlled row */
				if ( dt.oInstance.fnGetData(row) === null ) {
				    return;
				}

				// Shift click, ctrl click and simple click handling to make
				// row selection a lot like a file system in desktop OSs
				if ( select.type == 'os' ) {
					if ( e.ctrlKey || e.metaKey ) {
						// Add or remove from the selection
						if ( that.fnIsSelected( row ) ) {
							that._fnRowDeselect( row, e );
						}
						else {
							that._fnRowSelect( row, e );
						}
					}
					else if ( e.shiftKey ) {
						// Add a range of rows, from the last selected row to
						// this one
						var rowIdxs = that.s.dt.aiDisplay.slice(); // visible rows
						var idx1 = $.inArray( select.lastRow, rowIdxs );
						var idx2 = $.inArray( pos, rowIdxs );

						if ( that.fnGetSelected().length === 0 || idx1 === -1 ) {
							// select from top to here - slightly odd, but both
							// Windows and Mac OS do this
							rowIdxs.splice( $.inArray( pos, rowIdxs )+1, rowIdxs.length );
						}
						else {
							// reverse so we can shift click 'up' as well as down
							if ( idx1 > idx2 ) {
								var tmp = idx2;
								idx2 = idx1;
								idx1 = tmp;
							}

							rowIdxs.splice( idx2+1, rowIdxs.length );
							rowIdxs.splice( 0, idx1 );
						}

						if ( ! that.fnIsSelected( row ) ) {
							// Select range
							that._fnRowSelect( rowIdxs, e );
						}
						else {
							// Deselect range - need to keep the clicked on row selected
							rowIdxs.splice( $.inArray( pos, rowIdxs ), 1 );
							that._fnRowDeselect( rowIdxs, e );
						}
					}
					else {
						// No cmd or shift click. Deselect current if selected,
						// or select this row only
						if ( that.fnIsSelected( row ) && that.fnGetSelected().length === 1 ) {
							that._fnRowDeselect( row, e );
						}
						else {
							that.fnSelectNone();
							that._fnRowSelect( row, e );
						}
					}
				}
				else if ( that.fnIsSelected( row ) ) {
					that._fnRowDeselect( row, e );
				}
				else if ( select.type == "single" ) {
					that.fnSelectNone();
					that._fnRowSelect( row, e );
				}
				else if ( select.type == "multi" ) {
					that._fnRowSelect( row, e );
				}

				select.lastRow = pos;
			} );//.on('selectstart', function () { return false; } );

			// Bind a listener to the DataTable for when new rows are created.
			// This allows rows to be visually selected when they should be and
			// deferred rendering is used.
			dt.oApi._fnCallbackReg( dt, 'aoRowCreatedCallback', function (tr, data, index) {
				if ( dt.aoData[index]._DTTT_selected ) {
					$(tr).addClass( that.classes.select.row );
				}
			}, 'TableTools-SelectAll' );
		}
	},

	/**
	 * Select rows
	 *  @param   {*} src Rows to select - see _fnSelectData for a description of valid inputs
	 *  @private 
	 */
	"_fnRowSelect": function ( src, e )
	{
		var
			that = this,
			data = this._fnSelectData( src ),
			firstTr = data.length===0 ? null : data[0].nTr,
			anSelected = [],
			i, len;

		// Get all the rows that will be selected
		for ( i=0, len=data.length ; i<len ; i++ )
		{
			if ( data[i].nTr )
			{
				anSelected.push( data[i].nTr );
			}
		}

		// User defined pre-selection function
		if ( this.s.select.preRowSelect !== null && !this.s.select.preRowSelect.call(this, e, anSelected, true) )
		{
			return;
		}

		// Mark them as selected
		for ( i=0, len=data.length ; i<len ; i++ )
		{
			data[i]._DTTT_selected = true;

			if ( data[i].nTr )
			{
				$(data[i].nTr).addClass( that.classes.select.row );
			}
		}

		// Post-selection function
		if ( this.s.select.postSelected !== null )
		{
			this.s.select.postSelected.call( this, anSelected );
		}

		TableTools._fnEventDispatch( this, 'select', anSelected, true );
	},

	/**
	 * Deselect rows
	 *  @param   {*} src Rows to deselect - see _fnSelectData for a description of valid inputs
	 *  @private 
	 */
	"_fnRowDeselect": function ( src, e )
	{
		var
			that = this,
			data = this._fnSelectData( src ),
			firstTr = data.length===0 ? null : data[0].nTr,
			anDeselectedTrs = [],
			i, len;

		// Get all the rows that will be deselected
		for ( i=0, len=data.length ; i<len ; i++ )
		{
			if ( data[i].nTr )
			{
				anDeselectedTrs.push( data[i].nTr );
			}
		}

		// User defined pre-selection function
		if ( this.s.select.preRowSelect !== null && !this.s.select.preRowSelect.call(this, e, anDeselectedTrs, false) )
		{
			return;
		}

		// Mark them as deselected
		for ( i=0, len=data.length ; i<len ; i++ )
		{
			data[i]._DTTT_selected = false;

			if ( data[i].nTr )
			{
				$(data[i].nTr).removeClass( that.classes.select.row );
			}
		}

		// Post-deselection function
		if ( this.s.select.postDeselected !== null )
		{
			this.s.select.postDeselected.call( this, anDeselectedTrs );
		}

		TableTools._fnEventDispatch( this, 'select', anDeselectedTrs, false );
	},

	/**
	 * Take a data source for row selection and convert it into aoData points for the DT
	 *   @param {*} src Can be a single DOM TR node, an array of TR nodes (including a
	 *     a jQuery object), a single aoData point from DataTables, an array of aoData
	 *     points or an array of aoData indexes
	 *   @returns {array} An array of aoData points
	 */
	"_fnSelectData": function ( src )
	{
		var out = [], pos, i, iLen;

		if ( src.nodeName )
		{
			// Single node
			pos = this.s.dt.oInstance.fnGetPosition( src );
			out.push( this.s.dt.aoData[pos] );
		}
		else if ( typeof src.length !== 'undefined' )
		{
			// jQuery object or an array of nodes, or aoData points
			for ( i=0, iLen=src.length ; i<iLen ; i++ )
			{
				if ( src[i].nodeName )
				{
					pos = this.s.dt.oInstance.fnGetPosition( src[i] );
					out.push( this.s.dt.aoData[pos] );
				}
				else if ( typeof src[i] === 'number' )
				{
					out.push( this.s.dt.aoData[ src[i] ] );
				}
				else
				{
					out.push( src[i] );
				}
			}

			return out;
		}
		else
		{
			// A single aoData point
			out.push( src );
		}

		return out;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Text button functions
	 */

	/**
	 * Configure a text based button for interaction events
	 *  @method  _fnTextConfig
	 *  @param   {Node} nButton Button element which is being considered
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns void
	 *  @private 
	 */
	"_fnTextConfig": function ( nButton, oConfig )
	{
		var that = this;

		if ( oConfig.fnInit !== null )
		{
			oConfig.fnInit.call( this, nButton, oConfig );
		}

		if ( oConfig.sToolTip !== "" )
		{
			nButton.title = oConfig.sToolTip;
		}

		$(nButton).hover( function () {
			if ( oConfig.fnMouseover !== null )
			{
				oConfig.fnMouseover.call( this, nButton, oConfig, null );
			}
		}, function () {
			if ( oConfig.fnMouseout !== null )
			{
				oConfig.fnMouseout.call( this, nButton, oConfig, null );
			}
		} );

		if ( oConfig.fnSelect !== null )
		{
			TableTools._fnEventListen( this, 'select', function (n) {
				oConfig.fnSelect.call( that, nButton, oConfig, n );
			} );
		}

		$(nButton).click( function (e) {
			//e.preventDefault();

			if ( oConfig.fnClick !== null )
			{
				oConfig.fnClick.call( that, nButton, oConfig, null, e );
			}

			/* Provide a complete function to match the behaviour of the flash elements */
			if ( oConfig.fnComplete !== null )
			{
				oConfig.fnComplete.call( that, nButton, oConfig, null, null );
			}

			that._fnCollectionHide( nButton, oConfig );
		} );
	},



	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Flash button functions
	 */
	
	/**
	 * Check if the Flash plug-in is available
	 *  @method  _fnHasFlash
	 *  @returns {boolean} `true` if Flash available, `false` otherwise
	 *  @private 
	 */
	"_fnHasFlash": function ()
	{
		try {
			var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
			if (fo) {
				return true;
			}
		}
		catch (e) {
			if (
				navigator.mimeTypes &&
				navigator.mimeTypes['application/x-shockwave-flash'] !== undefined &&
				navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin
			) {
				return true;
			}
		}

		return false;
	},


	/**
	 * Configure a flash based button for interaction events
	 *  @method  _fnFlashConfig
	 *  @param   {Node} nButton Button element which is being considered
	 *  @param   {o} oConfig Button configuration object
	 *  @returns void
	 *  @private 
	 */
	"_fnFlashConfig": function ( nButton, oConfig )
	{
		var that = this;
		var flash = new ZeroClipboard_TableTools.Client();

		if ( oConfig.fnInit !== null )
		{
			oConfig.fnInit.call( this, nButton, oConfig );
		}

		flash.setHandCursor( true );

		if ( oConfig.sAction == "flash_save" )
		{
			flash.setAction( 'save' );
			flash.setCharSet( (oConfig.sCharSet=="utf16le") ? 'UTF16LE' : 'UTF8' );
			flash.setBomInc( oConfig.bBomInc );
			flash.setFileName( oConfig.sFileName.replace('*', this.fnGetTitle(oConfig)) );
		}
		else if ( oConfig.sAction == "flash_pdf" )
		{
			flash.setAction( 'pdf' );
			flash.setFileName( oConfig.sFileName.replace('*', this.fnGetTitle(oConfig)) );
		}
		else
		{
			flash.setAction( 'copy' );
		}

		flash.addEventListener('mouseOver', function(client) {
			if ( oConfig.fnMouseover !== null )
			{
				oConfig.fnMouseover.call( that, nButton, oConfig, flash );
			}
		} );

		flash.addEventListener('mouseOut', function(client) {
			if ( oConfig.fnMouseout !== null )
			{
				oConfig.fnMouseout.call( that, nButton, oConfig, flash );
			}
		} );

		flash.addEventListener('mouseDown', function(client) {
			if ( oConfig.fnClick !== null )
			{
				oConfig.fnClick.call( that, nButton, oConfig, flash );
			}
		} );

		flash.addEventListener('complete', function (client, text) {
			if ( oConfig.fnComplete !== null )
			{
				oConfig.fnComplete.call( that, nButton, oConfig, flash, text );
			}
			that._fnCollectionHide( nButton, oConfig );
		} );

		this._fnFlashGlue( flash, nButton, oConfig.sToolTip );
	},


	/**
	 * Wait until the id is in the DOM before we "glue" the swf. Note that this function will call
	 * itself (using setTimeout) until it completes successfully
	 *  @method  _fnFlashGlue
	 *  @param   {Object} clip Zero clipboard object
	 *  @param   {Node} node node to glue swf to
	 *  @param   {String} text title of the flash movie
	 *  @returns void
	 *  @private 
	 */
	"_fnFlashGlue": function ( flash, node, text )
	{
		var that = this;
		var id = node.getAttribute('id');

		if ( document.getElementById(id) )
		{
			flash.glue( node, text );
		}
		else
		{
			setTimeout( function () {
				that._fnFlashGlue( flash, node, text );
			}, 100 );
		}
	},


	/**
	 * Set the text for the flash clip to deal with
	 * 
	 * This function is required for large information sets. There is a limit on the 
	 * amount of data that can be transferred between Javascript and Flash in a single call, so
	 * we use this method to build up the text in Flash by sending over chunks. It is estimated
	 * that the data limit is around 64k, although it is undocumented, and appears to be different
	 * between different flash versions. We chunk at 8KiB.
	 *  @method  _fnFlashSetText
	 *  @param   {Object} clip the ZeroClipboard object
	 *  @param   {String} sData the data to be set
	 *  @returns void
	 *  @private 
	 */
	"_fnFlashSetText": function ( clip, sData )
	{
		var asData = this._fnChunkData( sData, 8192 );

		clip.clearText();
		for ( var i=0, iLen=asData.length ; i<iLen ; i++ )
		{
			clip.appendText( asData[i] );
		}
	},



	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Data retrieval functions
	 */

	/**
	 * Convert the mixed columns variable into a boolean array the same size as the columns, which
	 * indicates which columns we want to include
	 *  @method  _fnColumnTargets
	 *  @param   {String|Array} mColumns The columns to be included in data retrieval. If a string
	 *			 then it can take the value of "visible" or "hidden" (to include all visible or
	 *			 hidden columns respectively). Or an array of column indexes
	 *  @returns {Array} A boolean array the length of the columns of the table, which each value
	 *			 indicating if the column is to be included or not
	 *  @private 
	 */
	"_fnColumnTargets": function ( mColumns )
	{
		var aColumns = [];
		var dt = this.s.dt;
		var i, iLen;
		var columns = dt.aoColumns;
		var columnCount = columns.length;

		if ( typeof mColumns == "function" )
		{
			var a = mColumns.call( this, dt );

			for ( i=0, iLen=columnCount ; i<iLen ; i++ )
			{
				aColumns.push( $.inArray( i, a ) !== -1 ? true : false );
			}
		}
		else if ( typeof mColumns == "object" )
		{
			for ( i=0, iLen=columnCount ; i<iLen ; i++ )
			{
				aColumns.push( false );
			}

			for ( i=0, iLen=mColumns.length ; i<iLen ; i++ )
			{
				aColumns[ mColumns[i] ] = true;
			}
		}
		else if ( mColumns == "visible" )
		{
			for ( i=0, iLen=columnCount ; i<iLen ; i++ )
			{
				aColumns.push( columns[i].bVisible ? true : false );
			}
		}
		else if ( mColumns == "hidden" )
		{
			for ( i=0, iLen=columnCount ; i<iLen ; i++ )
			{
				aColumns.push( columns[i].bVisible ? false : true );
			}
		}
		else if ( mColumns == "sortable" )
		{
			for ( i=0, iLen=columnCount ; i<iLen ; i++ )
			{
				aColumns.push( columns[i].bSortable ? true : false );
			}
		}
		else /* all */
		{
			for ( i=0, iLen=columnCount ; i<iLen ; i++ )
			{
				aColumns.push( true );
			}
		}

		return aColumns;
	},


	/**
	 * New line character(s) depend on the platforms
	 *  @method  method
	 *  @param   {Object} oConfig Button configuration object - only interested in oConfig.sNewLine
	 *  @returns {String} Newline character
	 */
	"_fnNewline": function ( oConfig )
	{
		if ( oConfig.sNewLine == "auto" )
		{
			return navigator.userAgent.match(/Windows/) ? "\r\n" : "\n";
		}
		else
		{
			return oConfig.sNewLine;
		}
	},


	/**
	 * Get data from DataTables' internals and format it for output
	 *  @method  _fnGetDataTablesData
	 *  @param   {Object} oConfig Button configuration object
	 *  @param   {String} oConfig.sFieldBoundary Field boundary for the data cells in the string
	 *  @param   {String} oConfig.sFieldSeperator Field separator for the data cells
	 *  @param   {String} oConfig.sNewline New line options
	 *  @param   {Mixed} oConfig.mColumns Which columns should be included in the output
	 *  @param   {Boolean} oConfig.bHeader Include the header
	 *  @param   {Boolean} oConfig.bFooter Include the footer
	 *  @param   {Boolean} oConfig.bSelectedOnly Include only the selected rows in the output
	 *  @returns {String} Concatenated string of data
	 *  @private 
	 */
	"_fnGetDataTablesData": function ( oConfig )
	{
		var i, iLen, j, jLen;
		var aRow, aData=[], sLoopData='', arr;
		var dt = this.s.dt, tr, child;
		var regex = new RegExp(oConfig.sFieldBoundary, "g"); /* Do it here for speed */
		var aColumnsInc = this._fnColumnTargets( oConfig.mColumns );
		var bSelectedOnly = (typeof oConfig.bSelectedOnly != 'undefined') ? oConfig.bSelectedOnly : false;

		/*
		 * Header
		 */
		if ( oConfig.bHeader )
		{
			aRow = [];

			for ( i=0, iLen=dt.aoColumns.length ; i<iLen ; i++ )
			{
				if ( aColumnsInc[i] )
				{
					sLoopData = dt.aoColumns[i].sTitle.replace(/\n/g," ").replace( /<.*?>/g, "" ).replace(/^\s+|\s+$/g,"");
					sLoopData = this._fnHtmlDecode( sLoopData );

					aRow.push( this._fnBoundData( sLoopData, oConfig.sFieldBoundary, regex ) );
				}
			}

			aData.push( aRow.join(oConfig.sFieldSeperator) );
		}

		bSelectedOnly = true;

		/*
		 * Body
		 */
		var aDataIndex;
		var aSelected = this.fnGetSelectedIndexes();
		bSelectedOnly = this.s.select.type !== "none" && bSelectedOnly && aSelected.length !== 0;

		if ( bSelectedOnly ) {
			// Use the selected indexes
			aDataIndex = aSelected;
		}
		else if ( DataTable.Api ) {
			// 1.10+ style
			aDataIndex = new DataTable.Api( dt )
				.rows( oConfig.oSelectorOpts )
				.indexes()
				.flatten()
				.toArray();
		}
		else {
			// 1.9- style
			aDataIndex = dt.oInstance
				.$('tr', oConfig.oSelectorOpts)
				.map( function (id, row) {
					return dt.oInstance.fnGetPosition( row );
				} )
				.get();
		}

		for ( j=0, jLen=aDataIndex.length ; j<jLen ; j++ )
		{
			tr = dt.aoData[ aDataIndex[j] ].nTr;
			aRow = [];

			/* Columns */
			for ( i=0, iLen=dt.aoColumns.length ; i<iLen ; i++ )
			{
				if ( aColumnsInc[i] )
				{
					/* Convert to strings (with small optimisation) */
					var mTypeData = dt.oApi._fnGetCellData( dt, aDataIndex[j], i, 'display' );
					if ( oConfig.fnCellRender )
					{
						sLoopData = oConfig.fnCellRender( mTypeData, i, tr, aDataIndex[j] )+"";
					}
					else if ( typeof mTypeData == "string" )
					{
						/* Strip newlines, replace img tags with alt attr. and finally strip html... */
						sLoopData = mTypeData.replace(/\n/g," ");
						sLoopData =
						    sLoopData.replace(/<img.*?\s+alt\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s>]+)).*?>/gi,
						        '$1$2$3');
						sLoopData = sLoopData.replace( /<.*?>/g, "" );
					}
					else
					{
						sLoopData = mTypeData+"";
					}

					/* Trim and clean the data */
					sLoopData = sLoopData.replace(/^\s+/, '').replace(/\s+$/, '');
					sLoopData = this._fnHtmlDecode( sLoopData );

					/* Bound it and add it to the total data */
					aRow.push( this._fnBoundData( sLoopData, oConfig.sFieldBoundary, regex ) );
				}
			}

			aData.push( aRow.join(oConfig.sFieldSeperator) );

			/* Details rows from fnOpen */
			if ( oConfig.bOpenRows )
			{
				arr = $.grep(dt.aoOpenRows, function(o) { return o.nParent === tr; });

				if ( arr.length === 1 )
				{
					sLoopData = this._fnBoundData( $('td', arr[0].nTr).html(), oConfig.sFieldBoundary, regex );
					aData.push( sLoopData );
				}
			}
		}

		/*
		 * Footer
		 */
		if ( oConfig.bFooter && dt.nTFoot !== null )
		{
			aRow = [];

			for ( i=0, iLen=dt.aoColumns.length ; i<iLen ; i++ )
			{
				if ( aColumnsInc[i] && dt.aoColumns[i].nTf !== null )
				{
					sLoopData = dt.aoColumns[i].nTf.innerHTML.replace(/\n/g," ").replace( /<.*?>/g, "" );
					sLoopData = this._fnHtmlDecode( sLoopData );

					aRow.push( this._fnBoundData( sLoopData, oConfig.sFieldBoundary, regex ) );
				}
			}

			aData.push( aRow.join(oConfig.sFieldSeperator) );
		}

		var _sLastData = aData.join( this._fnNewline(oConfig) );
		return _sLastData;
	},


	/**
	 * Wrap data up with a boundary string
	 *  @method  _fnBoundData
	 *  @param   {String} sData data to bound
	 *  @param   {String} sBoundary bounding char(s)
	 *  @param   {RegExp} regex search for the bounding chars - constructed outside for efficiency
	 *			 in the loop
	 *  @returns {String} bound data
	 *  @private 
	 */
	"_fnBoundData": function ( sData, sBoundary, regex )
	{
		if ( sBoundary === "" )
		{
			return sData;
		}
		else
		{
			return sBoundary + sData.replace(regex, sBoundary+sBoundary) + sBoundary;
		}
	},


	/**
	 * Break a string up into an array of smaller strings
	 *  @method  _fnChunkData
	 *  @param   {String} sData data to be broken up
	 *  @param   {Int} iSize chunk size
	 *  @returns {Array} String array of broken up text
	 *  @private 
	 */
	"_fnChunkData": function ( sData, iSize )
	{
		var asReturn = [];
		var iStrlen = sData.length;

		for ( var i=0 ; i<iStrlen ; i+=iSize )
		{
			if ( i+iSize < iStrlen )
			{
				asReturn.push( sData.substring( i, i+iSize ) );
			}
			else
			{
				asReturn.push( sData.substring( i, iStrlen ) );
			}
		}

		return asReturn;
	},


	/**
	 * Decode HTML entities
	 *  @method  _fnHtmlDecode
	 *  @param   {String} sData encoded string
	 *  @returns {String} decoded string
	 *  @private 
	 */
	"_fnHtmlDecode": function ( sData )
	{
		if ( sData.indexOf('&') === -1 )
		{
			return sData;
		}

		var n = document.createElement('div');

		return sData.replace( /&([^\s]*?);/g, function( match, match2 ) {
			if ( match.substr(1, 1) === '#' )
			{
				return String.fromCharCode( Number(match2.substr(1)) );
			}
			else
			{
				n.innerHTML = match;
				return n.childNodes[0].nodeValue;
			}
		} );
	},



	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Printing functions
	 */

	/**
	 * Show print display
	 *  @method  _fnPrintStart
	 *  @param   {Event} e Event object
	 *  @param   {Object} oConfig Button configuration object
	 *  @returns void
	 *  @private 
	 */
	"_fnPrintStart": function ( oConfig )
	{
	  var that = this;
	  var oSetDT = this.s.dt;

		/* Parse through the DOM hiding everything that isn't needed for the table */
		this._fnPrintHideNodes( oSetDT.nTable );

		/* Show the whole table */
		this.s.print.saveStart = oSetDT._iDisplayStart;
		this.s.print.saveLength = oSetDT._iDisplayLength;

		if ( oConfig.bShowAll )
		{
			oSetDT._iDisplayStart = 0;
			oSetDT._iDisplayLength = -1;
			if ( oSetDT.oApi._fnCalculateEnd ) {
				oSetDT.oApi._fnCalculateEnd( oSetDT );
			}
			oSetDT.oApi._fnDraw( oSetDT );
		}

		/* Adjust the display for scrolling which might be done by DataTables */
		if ( oSetDT.oScroll.sX !== "" || oSetDT.oScroll.sY !== "" )
		{
			this._fnPrintScrollStart( oSetDT );

			// If the table redraws while in print view, the DataTables scrolling
			// setup would hide the header, so we need to readd it on draw
			$(this.s.dt.nTable).bind('draw.DTTT_Print', function () {
				that._fnPrintScrollStart( oSetDT );
			} );
		}

		/* Remove the other DataTables feature nodes - but leave the table! and info div */
		var anFeature = oSetDT.aanFeatures;
		for ( var cFeature in anFeature )
		{
			if ( cFeature != 'i' && cFeature != 't' && cFeature.length == 1 )
			{
				for ( var i=0, iLen=anFeature[cFeature].length ; i<iLen ; i++ )
				{
					this.dom.print.hidden.push( {
						"node": anFeature[cFeature][i],
						"display": "block"
					} );
					anFeature[cFeature][i].style.display = "none";
				}
			}
		}

		/* Print class can be used for styling */
		$(document.body).addClass( this.classes.print.body );

		/* Show information message to let the user know what is happening */
		if ( oConfig.sInfo !== "" )
		{
			this.fnInfo( oConfig.sInfo, 3000 );
		}

		/* Add a message at the top of the page */
		if ( oConfig.sMessage )
		{
			$('<div/>')
				.addClass( this.classes.print.message )
				.html( oConfig.sMessage )
				.prependTo( 'body' );
		}

		/* Cache the scrolling and the jump to the top of the page */
		this.s.print.saveScroll = $(window).scrollTop();
		window.scrollTo( 0, 0 );

		/* Bind a key event listener to the document for the escape key -
		 * it is removed in the callback
		 */
		$(document).bind( "keydown.DTTT", function(e) {
			/* Only interested in the escape key */
			if ( e.keyCode == 27 )
			{
				e.preventDefault();
				that._fnPrintEnd.call( that, e );
			}
		} );
	},


	/**
	 * Printing is finished, resume normal display
	 *  @method  _fnPrintEnd
	 *  @param   {Event} e Event object
	 *  @returns void
	 *  @private 
	 */
	"_fnPrintEnd": function ( e )
	{
		var that = this;
		var oSetDT = this.s.dt;
		var oSetPrint = this.s.print;
		var oDomPrint = this.dom.print;

		/* Show all hidden nodes */
		this._fnPrintShowNodes();

		/* Restore DataTables' scrolling */
		if ( oSetDT.oScroll.sX !== "" || oSetDT.oScroll.sY !== "" )
		{
			$(this.s.dt.nTable).unbind('draw.DTTT_Print');

			this._fnPrintScrollEnd();
		}

		/* Restore the scroll */
		window.scrollTo( 0, oSetPrint.saveScroll );

		/* Drop the print message */
		$('div.'+this.classes.print.message).remove();

		/* Styling class */
		$(document.body).removeClass( 'DTTT_Print' );

		/* Restore the table length */
		oSetDT._iDisplayStart = oSetPrint.saveStart;
		oSetDT._iDisplayLength = oSetPrint.saveLength;
		if ( oSetDT.oApi._fnCalculateEnd ) {
			oSetDT.oApi._fnCalculateEnd( oSetDT );
		}
		oSetDT.oApi._fnDraw( oSetDT );

		$(document).unbind( "keydown.DTTT" );
	},


	/**
	 * Take account of scrolling in DataTables by showing the full table
	 *  @returns void
	 *  @private 
	 */
	"_fnPrintScrollStart": function ()
	{
		var
			oSetDT = this.s.dt,
			nScrollHeadInner = oSetDT.nScrollHead.getElementsByTagName('div')[0],
			nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
			nScrollBody = oSetDT.nTable.parentNode,
			nTheadSize, nTfootSize;

		/* Copy the header in the thead in the body table, this way we show one single table when
		 * in print view. Note that this section of code is more or less verbatim from DT 1.7.0
		 */
		nTheadSize = oSetDT.nTable.getElementsByTagName('thead');
		if ( nTheadSize.length > 0 )
		{
			oSetDT.nTable.removeChild( nTheadSize[0] );
		}

		if ( oSetDT.nTFoot !== null )
		{
			nTfootSize = oSetDT.nTable.getElementsByTagName('tfoot');
			if ( nTfootSize.length > 0 )
			{
				oSetDT.nTable.removeChild( nTfootSize[0] );
			}
		}

		nTheadSize = oSetDT.nTHead.cloneNode(true);
		oSetDT.nTable.insertBefore( nTheadSize, oSetDT.nTable.childNodes[0] );

		if ( oSetDT.nTFoot !== null )
		{
			nTfootSize = oSetDT.nTFoot.cloneNode(true);
			oSetDT.nTable.insertBefore( nTfootSize, oSetDT.nTable.childNodes[1] );
		}

		/* Now adjust the table's viewport so we can actually see it */
		if ( oSetDT.oScroll.sX !== "" )
		{
			oSetDT.nTable.style.width = $(oSetDT.nTable).outerWidth()+"px";
			nScrollBody.style.width = $(oSetDT.nTable).outerWidth()+"px";
			nScrollBody.style.overflow = "visible";
		}

		if ( oSetDT.oScroll.sY !== "" )
		{
			nScrollBody.style.height = $(oSetDT.nTable).outerHeight()+"px";
			nScrollBody.style.overflow = "visible";
		}
	},


	/**
	 * Take account of scrolling in DataTables by showing the full table. Note that the redraw of
	 * the DataTable that we do will actually deal with the majority of the hard work here
	 *  @returns void
	 *  @private 
	 */
	"_fnPrintScrollEnd": function ()
	{
		var
			oSetDT = this.s.dt,
			nScrollBody = oSetDT.nTable.parentNode;

		if ( oSetDT.oScroll.sX !== "" )
		{
			nScrollBody.style.width = oSetDT.oApi._fnStringToCss( oSetDT.oScroll.sX );
			nScrollBody.style.overflow = "auto";
		}

		if ( oSetDT.oScroll.sY !== "" )
		{
			nScrollBody.style.height = oSetDT.oApi._fnStringToCss( oSetDT.oScroll.sY );
			nScrollBody.style.overflow = "auto";
		}
	},


	/**
	 * Resume the display of all TableTools hidden nodes
	 *  @method  _fnPrintShowNodes
	 *  @returns void
	 *  @private 
	 */
	"_fnPrintShowNodes": function ( )
	{
	  var anHidden = this.dom.print.hidden;

		for ( var i=0, iLen=anHidden.length ; i<iLen ; i++ )
		{
			anHidden[i].node.style.display = anHidden[i].display;
		}
		anHidden.splice( 0, anHidden.length );
	},


	/**
	 * Hide nodes which are not needed in order to display the table. Note that this function is
	 * recursive
	 *  @method  _fnPrintHideNodes
	 *  @param   {Node} nNode Element which should be showing in a 'print' display
	 *  @returns void
	 *  @private 
	 */
	"_fnPrintHideNodes": function ( nNode )
	{
		var anHidden = this.dom.print.hidden;

		var nParent = nNode.parentNode;
		var nChildren = nParent.childNodes;
		for ( var i=0, iLen=nChildren.length ; i<iLen ; i++ )
		{
			if ( nChildren[i] != nNode && nChildren[i].nodeType == 1 )
			{
				/* If our node is shown (don't want to show nodes which were previously hidden) */
				var sDisplay = $(nChildren[i]).css("display");
				if ( sDisplay != "none" )
				{
					/* Cache the node and it's previous state so we can restore it */
					anHidden.push( {
						"node": nChildren[i],
						"display": sDisplay
					} );
					nChildren[i].style.display = "none";
				}
			}
		}

		if ( nParent.nodeName.toUpperCase() != "BODY" )
		{
			this._fnPrintHideNodes( nParent );
		}
	}
};



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Static variables
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * Store of all instances that have been created of TableTools, so one can look up other (when
 * there is need of a master)
 *  @property _aInstances
 *  @type	 Array
 *  @default  []
 *  @private
 */
TableTools._aInstances = [];


/**
 * Store of all listeners and their callback functions
 *  @property _aListeners
 *  @type	 Array
 *  @default  []
 */
TableTools._aListeners = [];



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Static methods
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * Get an array of all the master instances
 *  @method  fnGetMasters
 *  @returns {Array} List of master TableTools instances
 *  @static
 */
TableTools.fnGetMasters = function ()
{
	var a = [];
	for ( var i=0, iLen=TableTools._aInstances.length ; i<iLen ; i++ )
	{
		if ( TableTools._aInstances[i].s.master )
		{
			a.push( TableTools._aInstances[i] );
		}
	}
	return a;
};

/**
 * Get the master instance for a table node (or id if a string is given)
 *  @method  fnGetInstance
 *  @returns {Object} ID of table OR table node, for which we want the TableTools instance
 *  @static
 */
TableTools.fnGetInstance = function ( node )
{
	if ( typeof node != 'object' )
	{
		node = document.getElementById(node);
	}

	for ( var i=0, iLen=TableTools._aInstances.length ; i<iLen ; i++ )
	{
		if ( TableTools._aInstances[i].s.master && TableTools._aInstances[i].dom.table == node )
		{
			return TableTools._aInstances[i];
		}
	}
	return null;
};


/**
 * Add a listener for a specific event
 *  @method  _fnEventListen
 *  @param   {Object} that Scope of the listening function (i.e. 'this' in the caller)
 *  @param   {String} type Event type
 *  @param   {Function} fn Function
 *  @returns void
 *  @private
 *  @static
 */
TableTools._fnEventListen = function ( that, type, fn )
{
	TableTools._aListeners.push( {
		"that": that,
		"type": type,
		"fn": fn
	} );
};


/**
 * An event has occurred - look up every listener and fire it off. We check that the event we are
 * going to fire is attached to the same table (using the table node as reference) before firing
 *  @method  _fnEventDispatch
 *  @param   {Object} that Scope of the listening function (i.e. 'this' in the caller)
 *  @param   {String} type Event type
 *  @param   {Node} node Element that the event occurred on (may be null)
 *  @param   {boolean} [selected] Indicate if the node was selected (true) or deselected (false)
 *  @returns void
 *  @private
 *  @static
 */
TableTools._fnEventDispatch = function ( that, type, node, selected )
{
	var listeners = TableTools._aListeners;
	for ( var i=0, iLen=listeners.length ; i<iLen ; i++ )
	{
		if ( that.dom.table == listeners[i].that.dom.table && listeners[i].type == type )
		{
			listeners[i].fn( node, selected );
		}
	}
};






/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Constants
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



TableTools.buttonBase = {
	// Button base
	"sAction": "text",
	"sTag": "default",
	"sLinerTag": "default",
	"sButtonClass": "DTTT_button_text",
	"sButtonText": "Button text",
	"sTitle": "",
	"sToolTip": "",

	// Common button specific options
	"sCharSet": "utf8",
	"bBomInc": false,
	"sFileName": "*.csv",
	"sFieldBoundary": "",
	"sFieldSeperator": "\t",
	"sNewLine": "auto",
	"mColumns": "all", /* "all", "visible", "hidden" or array of column integers */
	"bHeader": true,
	"bFooter": true,
	"bOpenRows": false,
	"bSelectedOnly": false,
	"oSelectorOpts": undefined, // See http://datatables.net/docs/DataTables/1.9.4/#$ for full options

	// Callbacks
	"fnMouseover": null,
	"fnMouseout": null,
	"fnClick": null,
	"fnSelect": null,
	"fnComplete": null,
	"fnInit": null,
	"fnCellRender": null
};


/**
 * @namespace Default button configurations
 */
TableTools.BUTTONS = {
	"csv": $.extend( {}, TableTools.buttonBase, {
		"sAction": "flash_save",
		"sButtonClass": "DTTT_button_csv",
		"sButtonText": "CSV",
		"sFieldBoundary": '"',
		"sFieldSeperator": ",",
		"fnClick": function( nButton, oConfig, flash ) {
			this.fnSetText( flash, this.fnGetTableData(oConfig) );
		}
	} ),

	"xls": $.extend( {}, TableTools.buttonBase, {
		"sAction": "flash_save",
		"sCharSet": "utf16le",
		"bBomInc": true,
		"sButtonClass": "DTTT_button_xls",
		"sButtonText": "Excel",
		"fnClick": function( nButton, oConfig, flash ) {
			this.fnSetText( flash, this.fnGetTableData(oConfig) );
		}
	} ),

	"copy": $.extend( {}, TableTools.buttonBase, {
		"sAction": "flash_copy",
		"sButtonClass": "DTTT_button_copy",
		"sButtonText": "Copy",
		"fnClick": function( nButton, oConfig, flash ) {
			this.fnSetText( flash, this.fnGetTableData(oConfig) );
		},
		"fnComplete": function(nButton, oConfig, flash, text) {
			var lines = text.split('\n').length;
            if (oConfig.bHeader) lines--;
            if (this.s.dt.nTFoot !== null && oConfig.bFooter) lines--;
			var plural = (lines==1) ? "" : "s";
			this.fnInfo( '<h6>Table copied</h6>'+
				'<p>Copied '+lines+' row'+plural+' to the clipboard.</p>',
				1500
			);
		}
	} ),

	"pdf": $.extend( {}, TableTools.buttonBase, {
		"sAction": "flash_pdf",
		"sNewLine": "\n",
		"sFileName": "*.pdf",
		"sButtonClass": "DTTT_button_pdf",
		"sButtonText": "PDF",
		"sPdfOrientation": "portrait",
		"sPdfSize": "A4",
		"sPdfMessage": "",
		"fnClick": function( nButton, oConfig, flash ) {
			this.fnSetText( flash,
				"title:"+ this.fnGetTitle(oConfig) +"\n"+
				"message:"+ oConfig.sPdfMessage +"\n"+
				"colWidth:"+ this.fnCalcColRatios(oConfig) +"\n"+
				"orientation:"+ oConfig.sPdfOrientation +"\n"+
				"size:"+ oConfig.sPdfSize +"\n"+
				"--/TableToolsOpts--\n" +
				this.fnGetTableData(oConfig)
			);
		}
	} ),

	"print": $.extend( {}, TableTools.buttonBase, {
		"sInfo": "<h6>Print view</h6><p>Please use your browser's print function to "+
		  "print this table. Press escape when finished.</p>",
		"sMessage": null,
		"bShowAll": true,
		"sToolTip": "View print view",
		"sButtonClass": "DTTT_button_print",
		"sButtonText": "Print",
		"fnClick": function ( nButton, oConfig ) {
			this.fnPrint( true, oConfig );
		}
	} ),

	"text": $.extend( {}, TableTools.buttonBase ),

	"select": $.extend( {}, TableTools.buttonBase, {
		"sButtonText": "Select button",
		"fnSelect": function( nButton, oConfig ) {
			if ( this.fnGetSelected().length !== 0 ) {
				$(nButton).removeClass( this.classes.buttons.disabled );
			} else {
				$(nButton).addClass( this.classes.buttons.disabled );
			}
		},
		"fnInit": function( nButton, oConfig ) {
			$(nButton).addClass( this.classes.buttons.disabled );
		}
	} ),

	"select_single": $.extend( {}, TableTools.buttonBase, {
		"sButtonText": "Select button",
		"fnSelect": function( nButton, oConfig ) {
			var iSelected = this.fnGetSelected().length;
			if ( iSelected == 1 ) {
				$(nButton).removeClass( this.classes.buttons.disabled );
			} else {
				$(nButton).addClass( this.classes.buttons.disabled );
			}
		},
		"fnInit": function( nButton, oConfig ) {
			$(nButton).addClass( this.classes.buttons.disabled );
		}
	} ),

	"select_all": $.extend( {}, TableTools.buttonBase, {
		"sButtonText": "Select all",
		"fnClick": function( nButton, oConfig ) {
			this.fnSelectAll();
		},
		"fnSelect": function( nButton, oConfig ) {
			if ( this.fnGetSelected().length == this.s.dt.fnRecordsDisplay() ) {
				$(nButton).addClass( this.classes.buttons.disabled );
			} else {
				$(nButton).removeClass( this.classes.buttons.disabled );
			}
		}
	} ),

	"select_none": $.extend( {}, TableTools.buttonBase, {
		"sButtonText": "Deselect all",
		"fnClick": function( nButton, oConfig ) {
			this.fnSelectNone();
		},
		"fnSelect": function( nButton, oConfig ) {
			if ( this.fnGetSelected().length !== 0 ) {
				$(nButton).removeClass( this.classes.buttons.disabled );
			} else {
				$(nButton).addClass( this.classes.buttons.disabled );
			}
		},
		"fnInit": function( nButton, oConfig ) {
			$(nButton).addClass( this.classes.buttons.disabled );
		}
	} ),

	"ajax": $.extend( {}, TableTools.buttonBase, {
		"sAjaxUrl": "/xhr.php",
		"sButtonText": "Ajax button",
		"fnClick": function( nButton, oConfig ) {
			var sData = this.fnGetTableData(oConfig);
			$.ajax( {
				"url": oConfig.sAjaxUrl,
				"data": [
					{ "name": "tableData", "value": sData }
				],
				"success": oConfig.fnAjaxComplete,
				"dataType": "json",
				"type": "POST",
				"cache": false,
				"error": function () {
					alert( "Error detected when sending table data to server" );
				}
			} );
		},
		"fnAjaxComplete": function( json ) {
			alert( 'Ajax complete' );
		}
	} ),

	"div": $.extend( {}, TableTools.buttonBase, {
		"sAction": "div",
		"sTag": "div",
		"sButtonClass": "DTTT_nonbutton",
		"sButtonText": "Text button"
	} ),

	"collection": $.extend( {}, TableTools.buttonBase, {
		"sAction": "collection",
		"sButtonClass": "DTTT_button_collection",
		"sButtonText": "Collection",
		"fnClick": function( nButton, oConfig ) {
			this._fnCollectionShow(nButton, oConfig);
		}
	} )
};
/*
 *  on* callback parameters:
 *     1. node - button element
 *     2. object - configuration object for this button
 *     3. object - ZeroClipboard reference (flash button only)
 *     4. string - Returned string from Flash (flash button only - and only on 'complete')
 */

// Alias to match the other plug-ins styling
TableTools.buttons = TableTools.BUTTONS;


/**
 * @namespace Classes used by TableTools - allows the styles to be override easily.
 *   Note that when TableTools initialises it will take a copy of the classes object
 *   and will use its internal copy for the remainder of its run time.
 */
TableTools.classes = {
	"container": "DTTT_container",
	"buttons": {
		"normal": "DTTT_button",
		"disabled": "DTTT_disabled"
	},
	"collection": {
		"container": "DTTT_collection",
		"background": "DTTT_collection_background",
		"buttons": {
			"normal": "DTTT_button",
			"disabled": "DTTT_disabled"
		}
	},
	"select": {
		"table": "DTTT_selectable",
		"row": "DTTT_selected selected"
	},
	"print": {
		"body": "DTTT_Print",
		"info": "DTTT_print_info",
		"message": "DTTT_PrintMessage"
	}
};


/**
 * @namespace ThemeRoller classes - built in for compatibility with DataTables' 
 *   bJQueryUI option.
 */
TableTools.classes_themeroller = {
	"container": "DTTT_container ui-buttonset ui-buttonset-multi",
	"buttons": {
		"normal": "DTTT_button ui-button ui-state-default"
	},
	"collection": {
		"container": "DTTT_collection ui-buttonset ui-buttonset-multi"
	}
};


/**
 * @namespace TableTools default settings for initialisation
 */
TableTools.DEFAULTS = {
	"sSwfPath":        "../swf/copy_csv_xls_pdf.swf",
	"sRowSelect":      "none",
	"sRowSelector":    "tr",
	"sSelectedClass":  null,
	"fnPreRowSelect":  null,
	"fnRowSelected":   null,
	"fnRowDeselected": null,
	"aButtons":        [ "copy", "csv", "xls", "pdf", "print" ],
	"oTags": {
		"container": "div",
		"button": "a", // We really want to use buttons here, but Firefox and IE ignore the
		                 // click on the Flash element in the button (but not mouse[in|out]).
		"liner": "span",
		"collection": {
			"container": "div",
			"button": "a",
			"liner": "span"
		}
	}
};

// Alias to match the other plug-ins
TableTools.defaults = TableTools.DEFAULTS;


/**
 * Name of this class
 *  @constant CLASS
 *  @type	 String
 *  @default  TableTools
 */
TableTools.prototype.CLASS = "TableTools";


/**
 * TableTools version
 *  @constant  VERSION
 *  @type	  String
 *  @default   See code
 */
TableTools.version = "2.2.3";



// DataTables 1.10 API
// 
// This will be extended in a big way in in TableTools 3 to provide API methods
// such as rows().select() and rows.selected() etc, but for the moment the
// tabletools() method simply returns the instance.

if ( $.fn.dataTable.Api ) {
	$.fn.dataTable.Api.register( 'tabletools()', function () {
		var tt = null;

		if ( this.context.length > 0 ) {
			tt = TableTools.fnGetInstance( this.context[0].nTable );
		}

		return tt;
	} );
}




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Initialisation
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * Register a new feature with DataTables
 */
if ( typeof $.fn.dataTable == "function" &&
	 typeof $.fn.dataTableExt.fnVersionCheck == "function" &&
	 $.fn.dataTableExt.fnVersionCheck('1.9.0') )
{
	$.fn.dataTableExt.aoFeatures.push( {
		"fnInit": function( oDTSettings ) {
			var init = oDTSettings.oInit;
			var opts = init ?
				init.tableTools || init.oTableTools || {} :
				{};

			return new TableTools( oDTSettings.oInstance, opts ).dom.container;
		},
		"cFeature": "T",
		"sFeature": "TableTools"
	} );
}
else
{
	alert( "Warning: TableTools requires DataTables 1.9.0 or newer - www.datatables.net/download");
}

$.fn.DataTable.TableTools = TableTools;

})(jQuery, window, document);

/*
 * Register a new feature with DataTables
 */
if ( typeof $.fn.dataTable == "function" &&
	 typeof $.fn.dataTableExt.fnVersionCheck == "function" &&
	 $.fn.dataTableExt.fnVersionCheck('1.9.0') )
{
	$.fn.dataTableExt.aoFeatures.push( {
		"fnInit": function( oDTSettings ) {
			var oOpts = typeof oDTSettings.oInit.oTableTools != 'undefined' ?
				oDTSettings.oInit.oTableTools : {};

			var oTT = new TableTools( oDTSettings.oInstance, oOpts );
			TableTools._aInstances.push( oTT );

			return oTT.dom.container;
		},
		"cFeature": "T",
		"sFeature": "TableTools"
	} );
}
else
{
	alert( "Warning: TableTools 2 requires DataTables 1.9.0 or newer - www.datatables.net/download");
}


$.fn.dataTable.TableTools = TableTools;
$.fn.DataTable.TableTools = TableTools;


return TableTools;
}; // /factory


if ( jQuery && !jQuery.fn.dataTable.TableTools ) {
	// Otherwise simply initialise as normal, stopping multiple evaluation
	factory( jQuery, jQuery.fn.dataTable );
}

})(window, document);

    return jQuery.fn.dataTable.TableTools;

});

csui.define('csui/controls/table/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/impl/nls/root/lang',{
  searchPlaceholder: 'Search {0}',
  searchByNamePlaceholder: 'Search by name',
  searchIconTooltip: 'Search by {0}',
  searchClearIconTooltip: 'Clear',
  collapseSearch: 'Close search',
  selectAll: 'Select all items',
  selectAllAria: 'Select all items',
  selectItem: 'Select {0}',
  selectItemAria: 'Select {0}. When selected an action bar of options can be reached per shift-tab',
  selectedItemActionBarAria: 'Action bar of selected items',
  nameAria: '{0}',
  nameNoOpenAria: '{0}. Can not be opened.',
  NodeTableNoItems: "No results found.",
  NodeTableLoadingItems: "Loading...",
  NodeTableProcessingItems: "",
  NodeTablePageInfo: "Showing _START_ to _END_ of _TOTAL_ items",
  NodeTableEmptyPageInfo: "Showing 0 items",
  NodeTableFilteredPageInfo: "(filtered from _MAX_ total items)",
  NodeTablePageInfoSuffix: "",
  NodeTablePageThousandsSeparator: ",",
  NodeTablePagingFirst: "First",
  NodeTablePagingLast: "Last",
  NodeTablePagingPrevious: "Previous",
  NodeTablePagingNext: "Next",
  NodeTablePageSizeSelector: "Show _MENU_ items",
  NodeTablePageFilterLabel: "Filter by:",
  NodeTableSortAscending: ": Click to sort ascending",
  NodeTableSortDescending: ": Click to sort descending",
  NodeTableSortByAria: '{0}: Click to sort by {0}',
  backButtonTooltip: 'Go back',
  typeAndNameAria: '{0} {1}', // MSWord document report12.doc
  tableApplicationAria: 'Table',
  descriptionColumnTitle: 'Description',
  cellNoTexAria: 'No text'
});


csui.define('csui/utils/focusable',[
  'csui/lib/ally'
], function (ally) {
  'use strict';

  function findFocusables (selector, rootElement) {
    var context = rootElement ? rootElement.querySelector(selector) : selector;
    return ally.query.focusable({
      context: context,
      includeContext: false,
      strategy: 'quick',
    });
  }

  function isFocusable (element) {
    return ally.is.focusable(element);
  }

  return {
    findFocusables: findFocusables,
    isFocusable: isFocusable
  };
});

csui.define('csui/controls/table/cells/cell.registry',['csui/lib/underscore'], function (_) {

  function CellViewRegistry() {
    this._columnKeys = {};
    this._columnOtherKeys = {};
    this._dataTypes = {};
  }

  _.extend(CellViewRegistry.prototype, {

    hasCellViewByOtherKey: function (columnKey) {
      return !!this._columnOtherKeys[columnKey];
    },

    getCellView: function (columnDefinition) {
     var columnTypeIdentifier = columnDefinition.get('column_type_identifier');
     // The CellView registry is global which can cause conflicts when existing registered
     // cells e.g. 'name' and 'type' are used as the column_key value for custom columns.
     // column_type_identifier set as 'type' or 'key' will explicitly tell the registry which
     // setting to favor when there is a potential conflict.
     if (columnTypeIdentifier !== 'type') {
       // Choosing the handler by the column key is the most concrete way
       // to address a column; by the data type it is more general.
       var columnKey = columnDefinition.get('column_key'),
           CellView = columnKey && this._columnKeys[columnKey];
       if (CellView) {
         return CellView;
       }
     }
     var dataType = columnDefinition.get('type');
     return dataType && this._dataTypes[dataType.toString()];
    },

    registerByColumnKey: function (columnKey, handlerClass) {
      if (!(_.isString(columnKey) && columnKey)) {
        throw new Error('Column key must be a non-empty string');
      }
      this._registerCellView(this._columnKeys, columnKey, handlerClass);
    },

    registerByOtherColumnKey: function(columnKey, handlerClass) {
      if (!(_.isString(columnKey) && columnKey)) {
        throw new Error('Column key must be a non-empty string');
      }
      this._registerCellView(this._columnOtherKeys, columnKey, handlerClass);
    },

    registerByDataType: function (dataType, handlerClass) {
      if (!(_.isNumber(dataType) && dataType)) {
        throw new Error('Data type must be a non-zero number');
      }
      this._registerCellView(this._dataTypes, dataType.toString(),
          handlerClass);
    },

    _registerCellView: function (handlerMap, handlerKey, handlerClass) {
      if (typeof handlerClass !== 'function') {
        throw new Error('Column handler must be a function object');
      }
      handlerMap[handlerKey] = handlerClass;
    }

  });

  return new CellViewRegistry();

});

csui.define('csui/controls/table/cells/cell/cell.view',[
  'module', 'csui/lib/underscore', 'csui/lib/marionette',
  'csui/utils/focusable'
], function (module, _, Marionette, focusable) {
  'use strict';

  var config = _.extend({
    multiValueSeparator: ', '
  }, module.config());

  var CellView = Marionette.View.extend({
    tagName: 'td',

    constructor: function CellView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);
      this.listenTo(this, 'before:render', this._detachClickHandler)
          .listenTo(this, 'before:destroy', this._detachClickHandler);
    },

    render: function () {
      this._ensureViewIsIntact();
      this.triggerMethod('before:render', this);
      this._renderContent();
      this.bindUIElements();
      this._attachClickHandler();
      this.triggerMethod('render', this);
      return this;
    },

    _renderContent: function () {
      var classes = _.result(this, 'className');
      if (classes) {
        this.$el.addClass(classes);
      }
      var column = this.options.column;
      if (column) {
        var columnName = column.name;
        this.$el.attr('data-csui-attribute', columnName);
        // Making null valued attributes non-accessible through keypad navigation
        if (!!this.model.get("addEmptyAttribute") && !this.model.get(columnName) &&
            this.model.get(columnName) !== undefined) {
          this.el.setAttribute('data-csui-empty-cell', true);
        }
      }
      this.renderValue();
      this._ensureAriaLabel();
    },

    _ensureAriaLabel: function () {
      // Disable ARIA label explicitly
      if (this.needsAriaLabel === false) {
        return;
      }
      // Guess, if ARIA label should be added or not
      if (this.needsAriaLabel === undefined) {
        var focusables = focusable.findFocusables(this.el);
        // If just one focusable element is present, that element
        // will be focused directly and has to carry the ARA label;
        // the cell view should not add another (unused) one
        if (focusables.length === 1) {
          return;
        }
      }
      // Enable ARIA label either explicitly or by guess
      var label = this.getAriaLabel();
      if (label) {
        this.$el.attr('aria-label', label);
      }
    },

    _attachClickHandler: function () {
      var self = this;
      this.$el.on('click.' + this.cid, function (event) {
        self.triggerMethod('clicked:cell', event);
      });
    },

    _detachClickHandler: function () {
      this.$el.off('click.' + this.cid);
    },

    renderValue: function () {
      var text = this.getValueText();
      this.$el.text(text);
      this.$el.attr('title', text);
    },

    getValueText: function () {
      var column = this.options.column;
      if (column) {
        var columnName = column.name,
            model = this.model,
            value = model.get(columnName + "_formatted");
        if (value === null || value === undefined) {
          value = model.get(columnName);
          if (value === null || value === undefined) {
            value = '';
          }
        }
        return this.getSingleOrMultipleValueText(value);
      }
      return '';
    },

    getAriaLabel: function () {
      return this.getValueText();
    },

    getSingleOrMultipleValueText: function (propertyValue, formatter) {
      var value;

      formatter = this._validateFormater(formatter);
      if (Array.isArray(propertyValue)) {
        value = this.concatenateTextValues(propertyValue, formatter);
      } else {
        value = formatter(propertyValue);
      }
      return value;
    },

    concatenateTextValues: function (array, formatter) {
      formatter = this._validateFormater(formatter);
      return array.map(formatter).join(config.multiValueSeparator);
    },

    _validateFormater: function (formatter) {
      return formatter || function (value) { return value };
    }
  }, {
    // distribute available width equally if false. Use pixel from stylesheet if true
    hasFixedWidth: false,

    // css class names that get set on every th and td
    columnClassName: '',

    // factor for column width calculation
    //widthFactor: 1.0,

    getValue: function (model, column) {
      var value = model.get(column.name);
      // DataTables do not accept undefined values; ensure that we return
      // null if the server omits a property in the response
      if (Array.isArray(value)) {
        for (var i = 0; i< value.length; i++) {
          // return the first value in the multi value attribute to be used for sorting.
          // returning a comma separated string will not produce the expected sorting.
          if (value[i] !== undefined && value[i] !== null) {
            value = value[i];
            break;
          }
        }
      }
      return value !== undefined ? value : null;
    }
  });

  return CellView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/templated/value',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<span title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.formattedValue || (depth0 != null ? depth0.formattedValue : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"formattedValue","hash":{}}) : helper)))
    + "</span>\r\n";
}});
Handlebars.registerPartial('csui_controls_table_cells_templated_value', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/templated/templated.view',[
  'csui/controls/table/cells/cell/cell.view',
  'hbs!csui/controls/table/cells/templated/value'
], function (CellView, template) {
  'use strict';

  var TemplatedCellView = CellView.extend({
    template: template,

    renderValue: function () {
      var data = this.getValueData(),
          // Making the entire data object undefined renders nothing; if the object
          // contains undefined value the template should be prepared for it
          html = data ? this.template(data) : '';
      this.$el.html(html);
    },

    getValueData: function () {
      var model          = this.model,
          column         = this.options.column,
          columnName     = column.name,
          value          = model.get(columnName),
          formattedValue = model.get(columnName + "_formatted");

      function formatValue(singleValue) {
        return singleValue;
      }

      function formatFormattedValue(singleValue) {
        if (formattedValue) {
          return formattedValue;
        }
        if (singleValue === null) {
          singleValue = '';
        }
        return singleValue;
      }

      return this.getSingleOrMultipleValueData(value, formatValue, formatFormattedValue);
    },

    getSingleOrMultipleValueData: function (propertyValue, valueFormatter,
        formattedValueFormatter) {
      var value, formattedValue;
      if (Array.isArray(propertyValue)) {
        value = this.concatenateTextValues(propertyValue, valueFormatter);
        formattedValue = this.concatenateTextValues(propertyValue,
            formattedValueFormatter);
      } else {
        value = valueFormatter(propertyValue);
        formattedValue = formattedValueFormatter(propertyValue);
      }
      return {
        value: value,
        formattedValue: formattedValue
      };
    }

  });

  return TemplatedCellView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/text/impl/text',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-table-cell-text\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">&nbsp;</div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-table-cell-text\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "</div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isEmpty : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_text_impl_text', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/text/impl/text',[],function(){});
csui.define('csui/controls/table/cells/text/text.view',['csui/controls/table/cells/templated/templated.view',
  'i18n!csui/controls/table/impl/nls/lang',
  'hbs!csui/controls/table/cells/text/impl/text',
  'css!csui/controls/table/cells/text/impl/text',
], function (TemplatedCellView, lang, template) {

  var TextCellView = TemplatedCellView.extend({

    className: 'csui-truncate',
    template: template,

    renderValue: function () {
      var text = this.getValueText();
      var isEmpty = text === undefined || text.length === 0;
      if (isEmpty) {
        text = lang.cellNoTexAria;
      }
      var html = this.template({value: text, isEmpty: isEmpty});
      this.$el.html(html);
    }

  });

  // The TextCellView needs no registration, because it is used as a fallback
  // by the CellViewFactory.

  return TextCellView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/name/impl/name',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.inactive : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-table-cell-name-div\">\r\n      <div class=\"csui-table-cell-name-justify-div\">\r\n        <p class=\"csui-table-cell-name-value csui-table-cell-no-default-action\"\r\n           title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nameNoOpenAria || (depth0 != null ? depth0.nameNoOpenAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nameNoOpenAria","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</p>\r\n      </div>\r\n      <div class=\"csui-table-cell-name-appendix\"></div>\r\n    </div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-table-cell-name-div\">\r\n      <a href=\""
    + this.escapeExpression(((helper = (helper = helpers.defaultActionUrl || (depth0 != null ? depth0.defaultActionUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"defaultActionUrl","hash":{}}) : helper)))
    + "\"\r\n         class=\"csui-table-cell-name-value csui-table-cell-default-action csui-table-cell-name-justify-div\"\r\n         title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nameAria || (depth0 != null ? depth0.nameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nameAria","hash":{}}) : helper)))
    + "\">\r\n        <span class=\"csui-table-cell-name-link-text\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n      </a>\r\n      <div class=\"csui-table-cell-name-appendix\"></div>\r\n    </div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-table-cell-name-div\">\r\n    <div class=\"csui-table-cell-name-justify-div\">\r\n      <p class=\"csui-table-cell-name-value csui-table-cell-no-default-action\"\r\n         title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nameNoOpenAria || (depth0 != null ? depth0.nameNoOpenAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nameNoOpenAria","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</p>\r\n    </div>\r\n    <div class=\"csui-table-cell-name-appendix\"></div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.defaultAction : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_name_impl_name', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/name/impl/name',[],function(){});
csui.define('csui/controls/table/cells/name/name.view',[
  'csui/lib/underscore', 'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'csui/utils/base', 'csui/utils/node.links/node.links',
  'hbs!csui/controls/table/cells/name/impl/name',
  'i18n!csui/controls/table/impl/nls/lang',
  'css!csui/controls/table/cells/name/impl/name'
], function (_, TemplatedCellView, cellViewRegistry, base, nodeLinks, template, lang) {
  'use strict';

  var NameCellView = TemplatedCellView.extend({
      template: template,
      className: 'csui-truncate',

      constructor: function NameCellView(options) {
        TemplatedCellView.prototype.constructor.apply(this, arguments);
        this.listenTo(this, 'before:render', function () {
          this.needsAriaLabel = !(this.options.column.defaultAction &&
            !this.model.get('inactive'));
        });
      },

      getValueData: function () {
        var column = this.options.column,
            node = this.model,
            name = node.get(column.name),
            defaultActionUrl = nodeLinks.getUrl(node);
        return {
          defaultAction: column.defaultAction,
          defaultActionUrl: defaultActionUrl,
          contextualMenu: column.contextualMenu,
          name: name,
          nameAria: _.str.sformat(lang.nameAria, name),
          nameNoOpenAria: _.str.sformat(lang.nameNoOpenAria, name),
          inactive: node.get('inactive')
        };
      }
    },
    {
      // make this column wider
      widthFactor: 1.5,
      columnClassName: 'csui-table-cell-name',
      permanentColumn: true // don't wrap column due to responsiveness into details row
    }
  );

  return NameCellView;
});


csui.define('css!csui/controls/table/cells/date/impl/date',[],function(){});
csui.define('csui/controls/table/cells/date/date.view',[
  'csui/lib/underscore', 'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'csui/utils/base',
  'css!csui/controls/table/cells/date/impl/date'
], function (_, TemplatedCellView, cellViewRegistry, base) {
  'use strict';

  var DateCellView = TemplatedCellView.extend({
    className: 'csui-nowrap',
    needsAriaLabel: true,

    formatFunction: base.formatExactDateTime,

    constructor: function DateCellView(options) {
      TemplatedCellView.prototype.constructor.apply(this, arguments);
    },

    getValueData: function () {
      var propertyValue = this.model.get(this.options.column.name);
      var formatFunction = this.formatFunction;
      function format (singleValue) {
        return formatFunction(singleValue);
      }
      return this.getSingleOrMultipleValueData(propertyValue, format, format);
    },

    // also implement this function to get the formatted text for the metadata detail row in
    // the table
    getValueText: function () {
      return this.getValueData().formattedValue;
    }
  }, {
    flexibleWidth: true,
    columnClassName: 'csui-table-cell-date',

    getValue: function (model, column) {
      var value = TemplatedCellView.getValue(model, column);
      return value && base.parseDate(value);
    }
  });

  cellViewRegistry.registerByDataType(-7, DateCellView);

  return DateCellView;
});

csui.define('csui/controls/table/cells/datetime/datetime.view',['csui/controls/table/cells/date/date.view',
  'csui/controls/table/cells/cell.registry', 'csui/utils/base'
], function (DateCellView, cellViewRegistry, base) {

  var DateTimeCellView = DateCellView.extend({

    formatFunction: base.formatDateTime

  });

  cellViewRegistry.registerByDataType(401, DateTimeCellView);

  return DateTimeCellView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/duedate/duedate',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <span class=\"cellview_warning\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.formattedValue || (depth0 != null ? depth0.formattedValue : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"formattedValue","hash":{}}) : helper)))
    + "</span>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "  <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.formattedValue || (depth0 != null ? depth0.formattedValue : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"formattedValue","hash":{}}) : helper)))
    + "</span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.pastDueDate : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_duedate_duedate', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/duedate/duedate.view',['csui/lib/underscore', 'csui/controls/table/cells/date/date.view',
  'csui/controls/table/cells/cell.registry', 'csui/utils/base',
  'hbs!csui/controls/table/cells/duedate/duedate'
], function (_, DateCellView, cellViewRegistry, base, template) {

  var DueDateCellView = DateCellView.extend({

    template: template,
    formatFunction: base.formatDateTime,

    getValueData: function () {
      var value = this.model.get(this.options.column.name);
      return _.extend(DateCellView.prototype.getValueData.call(this),  {
        pastDueDate: new Date(value) < new Date()
      });
    }

  });

  cellViewRegistry.registerByColumnKey("date_due", DueDateCellView);

  return DueDateCellView;

});

csui.define('csui/controls/table/cells/member/member.view',[
  'csui/lib/underscore', 'csui/controls/table/cells/cell/cell.view',
  'csui/controls/table/cells/cell.registry', 'csui/utils/base'
], function (_, CellView, cellViewRegistry, base) {
  'use strict';

  var MemberCellView = CellView.extend({
    className: 'csui-truncate',
    needsAriaLabel: true,

    getValueText: function () {
      return MemberCellView.getValue(this.model, this.options.column);
    }
  }, {
    getValue: function (model, column) {
      var columnName = column.name,
          value = model.get(columnName + "_expand") ||
                  model.get(columnName) || '',
          text;
      if (_.isObject(value)) {
        // Prefer the expanded user information
        text = base.formatMemberName(value);
      } else {
        // Then try the server-pre-formatted value and fall back to the id
        text = model.get(columnName + "_formatted") || value.toString();
      }
      return text;
    },

    getModelExpand: function (options) {
      return {properties: [options.column.name]};
    }
  });

  cellViewRegistry.registerByDataType(14, MemberCellView);
  cellViewRegistry.registerByDataType(19, MemberCellView);
  cellViewRegistry.registerByColumnKey('owner_id', MemberCellView);

  return MemberCellView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/node.state/impl/reservation/reservation',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.canUnreserve : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <span class=\"icon "
    + this.escapeExpression(((helper = (helper = helpers.iconPrefix || (depth0 != null ? depth0.iconPrefix : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconPrefix","hash":{}}) : helper)))
    + "_"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isReservedByOther : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "\"\r\n        title=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedTooltip || (depth0 != null ? depth0.reservedTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.canUnreserve : depth0),{"name":"if","hash":{},"fn":this.program(8, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedAria || (depth0 != null ? depth0.reservedAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedAria","hash":{}}) : helper)))
    + "\">\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "other";
},"6":function(depth0,helpers,partials,data) {
    return "self";
},"8":function(depth0,helpers,partials,data) {
    return "    </button>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isReserved : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_node.state_impl_reservation_reservation', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/node.state/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/node.state/nls/root/lang',{
  reservedTooltip: 'Reserved by {0}\r\n{1}',
  reservedAria: 'Reserved by {0} at {1}, click to unreserve',
  reservedSharedCollaborationTooltip: 'Shared for collaboration by {0}\r\n{1}',
  reservedSharedCollaborationAria: 'Shared for collaboration by {0} at {1}, click to unshare',
  reserved_attribute_title: 'Reserved',
  reserved_attribute_name: 'reserved',
  reserved_shared_collaboration_attribute_title: 'Shared for collaboration',
  reserved_shared_collaboration_attribute_name: 'reserved_shared_collaboration'
});



csui.define('css!csui/controls/table/cells/node.state/impl/reservation/reservation',[],function(){});
csui.define('csui/controls/table/cells/node.state/impl/reservation/reservation.view',[
  'csui/lib/underscore', 'csui/lib/marionette', 'csui/utils/base',
  'csui/utils/contexts/factories/user', 'csui/models/nodes',
  'csui/utils/commands', 'csui/utils/commandhelper',
  'hbs!csui/controls/table/cells/node.state/impl/reservation/reservation',
  'i18n!csui/controls/table/cells/node.state/nls/lang',
  'css!csui/controls/table/cells/node.state/impl/reservation/reservation'
], function (_, Marionette, base, UserModelFactory, NodeCollection,
    commands, CommandHelper, template, publicLang) {
  'use strict';

  var ReservationIconView = Marionette.ItemView.extend({
    tagName: 'li',

    className: 'csui-node-state-reservation',

    template: template,

    triggers: {
      'click button': 'remove:reservation'
    },

    constructor: function ReservationIconView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      var user = this.options.context.getModel(UserModelFactory);
      this.userId = user.get('id');
      this.unreserveCommand = commands.get('UnreserveDoc');
      this.revokeShareCommand = commands.get('RevokeShare');
      this.commandStatus = {
        nodes: new NodeCollection([this.model]),
        context: this.options.context
      };
      // Refresh the state icon for collections with delayed action loading
      // (when the delayed actions are loaded, the model.actions are updated)
      var actions = this.model.actions;
      actions && this.listenTo(actions, 'update', function () {
        if (!this._isDestroyed) {
          this.render();
        }
      });
    },

    templateHelpers: function () {
      var reservedStatus = this._getReservedStatus(),
          isReserved = reservedStatus.isReserved,
          isSharedCollaboration = reservedStatus.isSharedCollaboration,
          reservedBy = reservedStatus.reservedBy,
          reservedTooltip, reservedAria, iconPrefix;

      if (isReserved) {
        var reservedDate = base.formatExactDate(this.model.get('reserved_date')),
            reservedUser = base.formatMemberName(reservedBy);
        if (isSharedCollaboration) {
          reservedTooltip = publicLang.reservedSharedCollaborationTooltip;
          reservedAria = publicLang.reservedSharedCollaborationAria;
        } else {
          reservedTooltip = publicLang.reservedTooltip;
          reservedAria = publicLang.reservedAria;
        }
        reservedTooltip = _.str.sformat(reservedTooltip, reservedUser, reservedDate);
        reservedAria = _.str.sformat(reservedAria, reservedUser, reservedDate);
        iconPrefix = isSharedCollaboration ? 'icon-shared_collaborate' : 'icon-reserved';
      }

      // Share the status with the click handler.
      this._reservedStatus = {
        isReserved: isReserved,
        isSharedCollaboration: isSharedCollaboration,
        isReservedByOther: reservedBy && this.userId !== reservedBy.id,
        canUnreserve: reservedStatus.canUnreserve,
        reservedTooltip: reservedTooltip,
        reservedAria: reservedAria,
        iconPrefix: iconPrefix
      };

      return this._reservedStatus;
    },

    onRemoveReservation: function (e) {
      if (this._reservedStatus.canUnreserve) {
        var command = this._reservedStatus.isSharedCollaboration ?
                      this.revokeShareCommand : this.unreserveCommand,
            promise = command.execute(this.commandStatus);
        CommandHelper.handleExecutionResults(
            promise, {
              command: command,
              suppressSuccessMessage: this.commandStatus.suppressSuccessMessage,
              suppressFailMessage: this.commandStatus.suppressFailMessage
            });
      }
    },

    _getReservedStatus: function () {
      var isReserved = this.model.get('reserved'),
          isSharedCollaboration = this.model.get('reserved_shared_collaboration'),
          command = isSharedCollaboration ? this.revokeShareCommand : this.unreserveCommand,
          reservedBy = this.model.get('reserved_user_id_expand');
      // handle both v1-expanded and not expanded (or v2-expanded) reserved_user_id scenarios
      if (!reservedBy) {
        reservedBy = this.model.get('reserved_user_id');
        if (reservedBy && typeof reservedBy === 'number') {
          reservedBy = {id: reservedBy};
        }
      }
      return {
        // Unreserving is made by emptying in the reserving user. Until the
        // server updates all properties, the model is inconsistent. That is
        // why both properties are tested here. A better fix will be welcome.
        isReserved: (isReserved && (reservedBy !== undefined)) || isSharedCollaboration,
        isSharedCollaboration: isSharedCollaboration,
        reservedBy: reservedBy,
        canUnreserve: command.enabled(this.commandStatus)
      };
    },

    getAttributes: function() {
      var data = this.templateHelpers(),
          label, name;

      if (data.isSharedCollaboration) {
        label = publicLang.reserved_shared_collaboration_attribute_title;
        name = publicLang.reserved_shared_collaboration_attribute_name;
      } else {
        label = publicLang.reserved_attribute_title;
        name = publicLang.reserved_attribute_name;
      }

      return [
        {
          label: label,
          value: data.isReserved,
          name: name,
          tooltip: data.reservedTooltip,
          aria: data.reservedAria
        }
      ];
    }
  }, {
    enabled: function (status) {
      var model = status.node,
          isReserved = model.get('reserved'),
          isSharedCollaboration = model.get('reserved_shared_collaboration'),
          reservedBy = model.get('reserved_user_id');
      return isReserved && reservedBy || isSharedCollaboration;
    },

    getModelExpand: function (options) {
      return {properties: ['reserved_user_id']};
    }
  });

  return ReservationIconView;
});


csui.define('csui/controls/table/cells/node.state/node.state.icons',['csui/lib/underscore', 'csui/lib/backbone',
  // TODO: Move this to csui-extensions.json
  'csui/controls/table/cells/node.state/impl/reservation/reservation.view',
  // Load external icon views maintaining node states
  'csui-ext!csui/controls/table/cells/node.state/node.state.icons'
], function (_, Backbone, ReservationIconView, extraNodeStateIcons) {
  'use strict';

  var NodeStateIconModel = Backbone.Model.extend({

    defaults: {
      sequence: 100,
      iconView: null,
      iconViewOptions: null
    },

    constructor: function NodeStateIconModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);
    }

  });

  var NodeStateIconCollection = Backbone.Collection.extend({

    model: NodeStateIconModel,
    comparator: 'sequence',

    constructor: function NodeStateIconCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
    }

  });

  var nodeStateIcons = new NodeStateIconCollection();

  if (extraNodeStateIcons) {
    extraNodeStateIcons = _.flatten(extraNodeStateIcons, true);
    nodeStateIcons.add(extraNodeStateIcons);
  }

  return nodeStateIcons;

});

csui.define('csui/controls/table/cells/node.state/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/node.state/impl/nls/root/lang',{
  stateListAria: 'List of states',
  someStateIconsAria: 'State available',
  noStateIconsAria: 'No state',
  bool_value_true: 'true',
  bool_value_false: 'false'
});



csui.define('css!csui/controls/table/cells/node.state/impl/node.state',[],function(){});
csui.define('csui/controls/table/cells/node.state/node.state.view',[
  'module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/log', 'csui/utils/base', 'csui/controls/table/cells/cell/cell.view',
  'csui/controls/table/cells/cell.registry',
  'csui/controls/table/cells/node.state/node.state.icons',
  'csui/models/mixins/v2.fields/v2.fields.mixin',
  'i18n!csui/controls/table/cells/node.state/impl/nls/lang',
  'css!csui/controls/table/cells/node.state/impl/node.state'
], function (module, _, $, Marionette, log, base, CellView,
    cellViewRegistry, nodeStateIcons, FieldsV2Mixin, lang) {
  'use strict';

  var accessibleTable = /\baccessibleTable\b(?:=([^&]*)?)?/i.exec(location.search);
  accessibleTable = accessibleTable && accessibleTable[1] !== 'false';

  log = log(module.id);

  var NodeStateCollectionView = Marionette.CollectionView.extend({
    tagName: 'ul',

    attributes: {
      'aria-label': lang.stateListAria
    },

    getChildView: function (iconModel) {
      return iconModel.get('iconView');
    },

    childViewOptions: function (iconModel) {
      return _.extend({
        context: this.options.context,
        model: this.options.node,
        tableView: this.options.tableView
      }, iconModel.get('iconViewOptions'));
    }
  });

  var NodeStateCellView = CellView.extend({
    needsAriaLabel: true,

    events: {
      // The mild trap may have been left by other navigation means. Once
      // the cell is focused again, remove the flags about the previous trap.
      focus: '_disengageKeyTrap',
      // Handle special keys and prevent bubbling of keyup events,
      // if the trap is engaged.
      keydown: '_handleKeys',
      // Prevent bubbling of keyup events, if the trap is engaged.
      keyup: '_trapKeys'
    },

    constructor: function NodeStateCellView(options) {
      CellView.prototype.constructor.apply(this, arguments);
      this.cellRegion = new Marionette.Region({el: this.el});
      this.listenTo(this, 'before:render', this._rememberFocus)
          .listenTo(this, 'before:render', this._disengageKeyTrap)
          .listenTo(this, 'before:render', this._destroyStateIcons)
          .listenTo(this, 'render', this._restoreFocus)
          .listenTo(this, 'before:destroy', this._disengageKeyTrap)
          .listenTo(this, 'before:destroy', this._destroyStateIcons);
    },

    _destroyStateIcons: function () {
      this.cellRegion.empty();
    },

    _getEnabledNodeStateIcons: function() {
      var nodeStateIconsPrototype;
      var enabledNodeStateIcons;

      nodeStateIconsPrototype = Object.getPrototypeOf(nodeStateIcons);
      enabledNodeStateIcons = new nodeStateIconsPrototype.constructor(
          nodeStateIcons.filter(function (iconModel) {
            var IconView = iconModel.get('iconView');
            return IconView && (!IconView.enabled || IconView.enabled({
                context: this.options.context,
                node: this.model
              }));
          }, this));

      return enabledNodeStateIcons;
    },

    renderValue: function () {
      var enabledStateIcons = this._getEnabledNodeStateIcons();
      if (enabledStateIcons.length) {
        var iconsView = new NodeStateCollectionView({
            context: this.options.context,
            node: this.model,
            tableView:this.options.tableView,
            collection: enabledStateIcons
         });
        this.cellRegion.show(iconsView);
      } else {
        this._renderEmpty();
      }
    },

    getAriaLabel: function () {
      var hasState = this.cellRegion.currentView;
      return hasState ? lang.someStateIconsAria : lang.noStateIconsAria;
    },

    getAttributes: function() {
      var self = this;
      var attributes = [];
      this._getEnabledNodeStateIcons().each(function(iconModel) {
        var IconView = iconModel.get('iconView');
        var tmpView = new IconView({
          context: self.options.context,
          model: self.model
        });
        if (_.isFunction(tmpView.getAttributes)) {
          attributes = attributes.concat(tmpView.getAttributes());
        }
      });

      // convert boolean values to string
      _.each(attributes, function(attribute) {
        if (_.isBoolean(attribute.value)) {
          attribute.value = (attribute.value === true ? lang.bool_value_true : lang.bool_value_false);
        }
      });

      return attributes;
    },

    _renderEmpty: function () {
      if (accessibleTable) {
        $('<span>', {title: lang.noStateIconsAria})
            .text(lang.noStateIconsAria)
            .appendTo(this.$el);
      }
    },

    _handleKeys: function (event) {
      if (event.key === 'Enter') {
        // Do not handle Enter key bubbled from child elements, which may be
        // hyperlinks, buttons or inputs.
        if (event.target === this.el) {
          this._disengageKeyTrap();
          this._engageKeyTrap();
        }
      } else if (this._hasEngagedKeyTrap()) {
        if (event.key === 'Escape') {
          this._disengageKeyTrap();
          this.el.focus();
        } else if (event.key === 'ArrowLeft') {
          event.preventDefault(); // stop browser from scrolling
          event.stopPropagation();
          this._moveFocus(-1);
        } else if (event.key === 'ArrowRight') {
          event.preventDefault(); // stop browser from scrolling
          event.stopPropagation();
          this._moveFocus(1);
        } else {
          this._trapKeys(event);
        }
      }
    },

    _trapKeys: function (event) {
      if (this._hasEngagedKeyTrap() && (event.key === 'ArrowUp' ||
          event.key === 'ArrowDown' || event.key === 'Tab')) {
        event.preventDefault(); // Stop browser from tabbing
        event.stopPropagation();
      }
    },

    _rememberFocus: function () {
      this._focusTrapped = this.el.contains(document.activeElement) &&
                           this._hasEngagedKeyTrap();
    },

    _restoreFocus: function () {
      if (this._focusTrapped) {
        this._engageKeyTrap();
      }
    },

    _engageKeyTrap: function () {
      var elements = base.findFocusables(this.el);
      if (elements.length) {
        this._keysTrapped = true;
        elements[0].focus();
      }
    },

    _disengageKeyTrap: function () {
      if (this._hasEngagedKeyTrap()) {
        this._keysTrapped = false;
      }
    },

    _hasEngagedKeyTrap: function () {
      return this._keysTrapped;
    },

    _moveFocus: function (direction) {
      var elements = base.findFocusables(this.el),
          lastElement = elements.length - 1,
          activeElement = elements.index(document.activeElement) + direction;
      if (activeElement < 0) {
        activeElement = lastElement;
      } else if (activeElement > lastElement) {
        activeElement = 0;
      }
      activeElement = elements[activeElement];
      if (activeElement) {
        activeElement.focus();
      } else {
        log.warn('Focusable elements were unexpectedly removed from {0} ({1}).',
            log.getObjectName(this), this.cid) && console.warn(log.last);
      }
    }
  }, {
    columnClassName: 'csui-table-cell-node-state',

    flexibleWidth: true,

    getModelFields: function (options) {
      return nodeStateIcons.reduce(function (fields, iconModel) {
        var IconView = iconModel.get('iconView');
        if (IconView && IconView.getModelFields) {
          var field = IconView.getModelFields(options);
          if (field) {
            FieldsV2Mixin.mergePropertyParameters(fields, field);
          }
        }
        return fields;
      }, {});
    },

    getModelExpand: function (options) {
      return nodeStateIcons.reduce(function (expands, iconModel) {
        var IconView = iconModel.get('iconView');
        if (IconView && IconView.getModelExpand) {
          var expand = IconView.getModelExpand(options);
          if (expand) {
            FieldsV2Mixin.mergePropertyParameters(expands, expand);
          }
        }
        return expands;
      }, {});
    }
  });

  // This column is registered for the reserved flag.  If another column
  // needs to show the reserved flag, this one has to be removed.
  cellViewRegistry.registerByColumnKey('reserved', NodeStateCellView);
  cellViewRegistry.registerByOtherColumnKey('reserved_user_id', NodeStateCellView);

  return NodeStateCellView;
});

csui.define('csui/controls/table/cells/parent/impl/parent.base.view',[
  'csui/lib/underscore', 'csui/lib/marionette',
  'csui/behaviors/default.action/default.action.behavior',
  'csui/utils/defaultactionitems', 'csui/utils/commands'
], function (_, Marionette, DefaultActionBehavior, defaultActionItems, commands) {
  'use strict';

  var ParentBaseView = Marionette.ItemView.extend({
    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      }
    },

    constructor: function ParentBaseView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);

      this.listenTo(this, 'cell:node:request', function () {
        if (this.model.actions.length > 0) {
          this.triggerMethod('execute:defaultAction', this.model);
        } else {
          this.model.resetCommands();
          this.model.setCommands(defaultActionItems.getAllCommandSignatures(commands));
          var self = this;
          this.model.fetch().done(function () {
            self.triggerMethod('execute:defaultAction', self.model);
          });
        }
      });
    }
  });

  return ParentBaseView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/parent/impl/parent.with.icon',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<a href=\""
    + this.escapeExpression(((helper = (helper = helpers.defaultActionUrl || (depth0 != null ? depth0.defaultActionUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"defaultActionUrl","hash":{}}) : helper)))
    + "\" class=\"csui-parent-name\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</a>\r\n";
}});
Handlebars.registerPartial('csui_controls_table_cells_parent_impl_parent.with.icon', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/parent/impl/parent.with.icon',[],function(){});
csui.define('csui/controls/table/cells/parent/impl/parent.with.icon.view',[
  'csui/lib/underscore', 'csui/utils/node.links/node.links',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/controls/table/cells/parent/impl/parent.base.view',
  'hbs!csui/controls/table/cells/parent/impl/parent.with.icon',
  'css!csui/controls/table/cells/parent/impl/parent.with.icon'
], function (_, nodeLinks, NodeTypeIconView, ParentBaseView, template) {
  'use strict';

  var ParentIconView = ParentBaseView.extend({
    template: template,
    className: 'csui-parent-location',

    triggers: {
      'click a.csui-parent-name': 'cell:node:request',
      // TODO: Place this entire view to a hyperlink.  The hyperlink
      // is supposed to provide keyboard support and a URL to copy to
      // clipboard.  As long as the node icon view is no hyperlink,
      // it should not trigger click actions and leave it on views,
      // which embed it and place the hyperlink around it.
      'click .cs-icon-group': 'cell:node:request'
    },

    templateHelpers: function () {
      var name = this.model.get('name');
      var defaultActionUrl = nodeLinks.getUrl(this.model);
      return {
        name: name,
        defaultActionUrl: defaultActionUrl
      };
    },

    constructor: function ParentIconView(options) {
      ParentBaseView.prototype.constructor.apply(this, arguments);

      this.iconView = new NodeTypeIconView({node: this.model});
    },

    onRender: function () {
      this.iconView.render();
      this.$el.prepend(this.iconView.$el);
    }
  });

  return ParentIconView;
});

csui.define('csui/controls/table/cells/parent/impl/parent.with.text.view',[
  'csui/lib/underscore', 'csui/utils/node.links/node.links',
  'csui/controls/table/cells/parent/impl/parent.base.view'
], function (_, nodeLinks, ParentBaseView) {
  'use strict';

  var ParentTextView = ParentBaseView.extend({
    tagName: 'a',
    attributes: function () {
      return {
        title: this.model.get('name'),
        href: nodeLinks.getUrl(this.model)
      };
    },

    template: false,

    triggers: {
      click: 'cell:node:request',
    },

    constructor: function ParentTextView(options) {
      ParentBaseView.prototype.constructor.apply(this, arguments);
    },

    onRender: function () {
      this.el.textContent = this.model.get('name');
    }
  });

  return ParentTextView;
});

csui.define('csui/controls/table/cells/parent/parent.view',[
  'csui/lib/underscore', 'csui/lib/marionette',
  'csui/models/node/node.model',
  'csui/controls/table/cells/cell/cell.view',
  'csui/controls/table/cells/cell.registry',
  'csui/controls/table/cells/parent/impl/parent.with.icon.view',
  'csui/controls/table/cells/parent/impl/parent.with.text.view'
], function (_, Marionette, NodeModel, CellView, cellViewRegistry,
    ParentIconView, ParentTextView) {
  'use strict';

  var ParentCellView = CellView.extend({
    events: {
      keydown: 'onKeyInView'
    },

    constructor: function ParentCellView(options) {
      CellView.prototype.constructor.apply(this, arguments);

      var parent = this.model.get('parent_id_expand') || this.model.get('parent_id') ||
                   this.model.get('location_id_expand') || this.model.get('location_id');
      if (this.model.get("type") === 153) {
        parent = this.model.get('workflow_id_expand') || this.model.get('workflow_id');
      }
      this.parentModel = new NodeModel(parent, {connector: this.model.connector});
      this.parentIconView = new ParentIconView({
        model: this.parentModel,
        context: this.options.context
      });
      this.parentTextView = new ParentTextView({
        model: this.parentModel,
        context: this.options.context
      });

      this.contentRegion = new Marionette.Region({el: this.el});
    },

    renderValue: function () {
      this.contentRegion.show(this.parentIconView);
    },

    // also implement this method to get the formatted text for the table's metadata detail row
    getValueText: function () {
      return this.parentModel.get('name');
    },

    getContentView: function() {
      return this.parentIconView;
    }
  }, {
    getModelExpand: function (options) {
      return {properties: ['parent_id']};
    }
  });

  cellViewRegistry.registerByColumnKey('parent_id', ParentCellView);
  cellViewRegistry.registerByColumnKey('location_id', ParentCellView);

  return ParentCellView;
});

csui.define('csui/controls/table/cells/priority/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/priority/impl/nls/root/lang',{
  priority_name_high: 'High',
  priority_name_medium: 'Medium',
  priority_name_low: 'Low'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/priority/impl/priority',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "  <span class=\"icon icon-priorityHigh\"></span>\r\n";
},"3":function(depth0,helpers,partials,data) {
    return "  <span class=\"icon icon-priorityMedium\"></span>\r\n";
},"5":function(depth0,helpers,partials,data) {
    return "  <span class=\"icon icon-priorityLow\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.priority_high : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.priority_medium : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.priority_low : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "<span title=\""
    + this.escapeExpression(((helper = (helper = helpers.priority_name || (depth0 != null ? depth0.priority_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"priority_name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.priority_name || (depth0 != null ? depth0.priority_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"priority_name","hash":{}}) : helper)))
    + "</span>\r\n";
}});
Handlebars.registerPartial('csui_controls_table_cells_priority_impl_priority', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/priority/impl/priority',[],function(){});
csui.define('csui/controls/table/cells/priority/priority.view',[
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'i18n!csui/controls/table/cells/priority/impl/nls/lang',
  'hbs!csui/controls/table/cells/priority/impl/priority',
  'css!csui/controls/table/cells/priority/impl/priority'
], function (TemplatedCellView, cellViewRegistry, lang, template) {
  'use strict';

  var PriorityCellView = TemplatedCellView.extend({
      template: template,
      needsAriaLabel: true,

      getValueData: function () {
        var priorityObj = this._getPriorityObject();
        return {
          priority: priorityObj.priority,
          priority_name: priorityObj.priority_name,
          priority_high: priorityObj.priority_high,
          priority_medium: priorityObj.priority_medium,
          priority_low: priorityObj.priority_low
        };
      },

      // also implement this function to get the formatted text for the metadata detail row in
      // the table
      getValueText: function () {
        return this._getPriorityObject().priority_name;
      },

      _getPriorityObject: function () {
        var priorityObj = {};
        priorityObj.priority = this.model.get(this.options.column.name);
        var priority_name_clientside;
        var priority_name_from_server = this.model.get(this.options.column.name + "_name");
        priorityObj.priority_high = false;
        priorityObj.priority_medium = false;
        priorityObj.priority_low = false;
        if (priorityObj.priority > 50) {
          priorityObj.priority_high = true;
          priority_name_clientside = lang.priority_name_high;
        } else if (priorityObj.priority === 50) {
          priorityObj.priority_medium = true;
          priority_name_clientside = lang.priority_name_medium;
        } else if (priorityObj.priority < 50) {
          priorityObj.priority_low = true;
          priority_name_clientside = lang.priority_name_low;
        }
        priorityObj.priority_name = priority_name_clientside || priority_name_from_server;

        return priorityObj;
      }
    },
    {
      hasFixedWidth: true,
      columnClassName: 'csui-table-cell-priority'
    }
  );

  cellViewRegistry.registerByColumnKey("priority", PriorityCellView);

  return PriorityCellView;
});


csui.define('css!csui/controls/table/cells/select/impl/select.view',[],function(){});
csui.define('csui/controls/table/cells/select/select.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  "csui/lib/backbone",
  'csui/lib/marionette',
  'csui/controls/checkbox/checkbox.view',
  'csui/controls/table/cells/cell/cell.view',
  'csui/controls/table/cells/cell.registry',
  'i18n!csui/controls/table/impl/nls/lang',
  'css!csui/controls/table/cells/select/impl/select.view'
], function (_, $, Backbone, Marionette, CheckboxView, CellView, cellViewRegistry, lang) {

  var SelectCellView = CellView.extend({

        constructor: function (options) {
          SelectCellView.__super__.constructor.apply(this, arguments);
        },

        renderValue: function () {
          var self = this;
          this.$el.empty();

          var checked = this.model.get(SelectCellView.isSelectedModelAttributeName) === true;
          var checkboxTitle = _.str.sformat(lang.selectItem, this.model.get('name'));
          var checkboxAriaLabel = _.str.sformat(lang.selectItemAria, this.model.get('name'));

          var selectable = this.model.get('selectable') !== false;
          this.checkboxView = new CheckboxView({
            checked: checked ? 'true' : 'false',
            disabled: !selectable,
            ariaLabel: checkboxAriaLabel,
            title: checkboxTitle
          });
          var checkboxRegion = new Marionette.Region({el: this.el});
          checkboxRegion.show(this.checkboxView);

          var viewModel = this.checkboxView.model;

          this.listenTo(this.model, 'change:' + SelectCellView.isSelectedModelAttributeName,
              function (model, changedValue, options) {
                this.checkboxView.setChecked(changedValue);
              });

          this.checkboxView.listenTo(this.checkboxView, 'clicked', function (e) {
            e.cancel = true;
            var state = viewModel.get('checked');
            // forward checked state to table (note that this is the state it has before the click)
            self.triggerMethod('clicked:checkbox', {checked: state});
          });

        }

      },
      {
        // ### S T A T I C ###
        columnKey: '_select',
        hasFixedWidth: true,
        columnClassName: 'csui-table-cell-_select',
        isSelectedModelAttributeName: 'csuiIsSelected'
      }
  );

  // This column key is used on the client side only to give a hint that
  // one or multiple rows can be and/or are selected
  cellViewRegistry.registerByColumnKey(SelectCellView.columnKey, SelectCellView);

  return SelectCellView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/toggledetails/impl/toggledetails',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <a class=\"expand-details-row-toggle\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.expandToggleTooltip || (depth0 != null ? depth0.expandToggleTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"expandToggleTooltip","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.expandToggleAria || (depth0 != null ? depth0.expandToggleAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"expandToggleAria","hash":{}}) : helper)))
    + "\"\r\n     href=\"#csui-details-row-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\" data-binf-toggle=\"collapse\" aria-expanded=\"false\"\r\n     aria-controls=\"csui-details-row-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.rowIsExpanded : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "  </a>\r\n";
},"2":function(depth0,helpers,partials,data) {
    return "      <span class=\"csui-button-icon icon-expandArrowUp\"></span>\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "      <span class=\"csui-button-icon icon-expandArrowDown\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.hasMetadataRow : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_toggledetails_impl_toggledetails', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/toggledetails/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/toggledetails/impl/nls/root/lang',{
  expandAllTooltip: 'Show all',
  expandAllAria: 'Show more details of all items',
  collapseAllTooltip: 'Show less',
  collapseAllAria: 'Show less details of all items',
  showMoreTooltip: 'Show more',
  showMoreAria: 'Show more details',
  showLessTooltip: 'Show less',
  showLessAria: 'Show less details'
});



csui.define('css!csui/controls/table/cells/toggledetails/impl/toggledetails',[],function(){});
csui.define('csui/controls/table/cells/toggledetails/toggledetails.view',[
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'hbs!csui/controls/table/cells/toggledetails/impl/toggledetails',
  'i18n!csui/controls/table/cells/toggledetails/impl/nls/lang',
  'css!csui/controls/table/cells/toggledetails/impl/toggledetails',
  'csui/lib/binf/js/binf'
], function (TemplatedCellView, cellViewRegistry, template, lang) {
  'use strict';

  var ToggleDetailsCellView = TemplatedCellView.extend({
        template: template,

        triggers: {
          'click a': 'toggle' // this disables handling the click event through bootstrap collapse
        },

        events: {"keydown": "onKeyInView"},

        getValueData: function () {
          return {
            hasMetadataRow: this.model.get('hasMetadataRow'),
            id: this.model.cid,
            rowIsExpanded: this.options.rowIsExpanded,
            expandToggleTooltip: this.options.rowIsExpanded ? lang.showLessTooltip : lang.showMoreTooltip,
            expandToggleAria: this.options.rowIsExpanded ? lang.showLessAria : lang.showMoreAria,
          };
        },

        onToggle: function (event) {
          var href = this.$('a').attr('href');
          // LPAD-53237. Tables with wrapped columns + description view
          // have two details rows with the same id. Both rows
          // must be collapsed or expanded
          var toToggle = this.$el.parent().parent().find("[id=" + href.replace("#", '') + "]"),
              self     = this;

          if (toToggle.hasClass("binf-collapse")) {
            this.options.rowIsExpanded = false;
            if (toToggle.hasClass("binf-in")) {
              toToggle.binf_collapse('hide').on('hidden.binf.collapse', function () {
                self.trigger("toggle:detailsrow",
                    {model: self.model, detailsRowIsExpanded: self.options.rowIsExpanded});
              });
            } else {
              toToggle.binf_collapse('show');
              this.options.rowIsExpanded = true;
            }
            this.trigger("toggle:detailsrow",
                {model: this.model, detailsRowIsExpanded: this.options.rowIsExpanded});
            this.render();
          }
        }
      },
      {
        hasFixedWidth: true,
        columnClassName: 'csui-table-cell-_toggledetails',
        rowIsExpandedModelAttributeName: 'csui-toggledetails-rowIsExpanded',
        widthFactor: 1 / 3.0
      }
  );

  // This column key is used on the client side only to give a hint that
  // one or multiple rows can be and/or are selected
  cellViewRegistry.registerByColumnKey('_toggledetails', ToggleDetailsCellView);

  return ToggleDetailsCellView;
});

csui.define('csui/controls/table/cells/size/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/size/impl/nls/root/localized.strings',{
  ColumnTitle: "Size",
  containerSize: {
    formatForNone: "{0} items",
    formatForOne: "{0} item",
    formatForTwo: "{0} items",
    formatForFive: "{0} items",
  },
  sizeUnavailable: "No size",
  sizeUnavailableAria: "Size unavailable for {0}"
});



csui.define('css!csui/controls/table/cells/size/impl/size',[],function(){});
csui.define('csui/controls/table/cells/size/size.view',[
  'csui/lib/underscore', 'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry', 'csui/utils/base',
  'i18n!csui/controls/table/cells/size/impl/nls/localized.strings',
  'css!csui/controls/table/cells/size/impl/size'
], function (_, TemplatedCellView, cellViewRegistry, base, lang) {
  'use strict';

  var accessibleTable = /\baccessibleTable\b(?:=([^&]*)?)?/i.exec(location.search);
  accessibleTable = accessibleTable && accessibleTable[1] !== 'false';

  var SizeCellView = TemplatedCellView.extend({
    className: 'csui-nowrap',
    needsAriaLabel: true,

    getValueData: function () {
      var model      = this.model,
          column     = this.options.column,
          columnName = column.name,
          value      = model.get(columnName),
          type       = model.get('type'),
          formattedValue;

      if (value == null) {
        // Perform the common formatting for empty value
        if (accessibleTable) {
          value = formattedValue = lang.sizeUnavailable;
        } else {
          return TemplatedCellView.prototype.getValueData.apply(this, arguments);
        }
      } else if (model.get('container')) {
        //899 = virtual folder
        value = formattedValue = type !== 202 && type !== 899 ?
                                 base.formatMessage(value, lang.containerSize) : '';
        if (accessibleTable && !value) {
          value = formattedValue = lang.sizeUnavailable;
        }
      } else if (type === 144 || type === 749 || type === 736 || type === 30309) {
        //Perform formatting for document(144) and active view(30309) types
        formattedValue = base.formatFriendlyFileSize(value);
        value = base.formatExactFileSize(value);
      } else {
        // Perform the common formatting for other node types
        return TemplatedCellView.prototype.getValueData.apply(this, arguments);
      }

      return {
        value: value,
        formattedValue: formattedValue
      };
    },

    getValueText: function () {
      var data           = this.getValueData(),
          formattedValue = data && data.formattedValue || data.value;
      return formattedValue;
    },

    getTooltipValueText: function () {
      var data           = this.getValueData(),
          formattedValue = data && data.value || this.getValueText();
      return formattedValue;
    },

    getAriaLabel: function () {
      var data = this.getValueData();
      return data && data.value ||
        _.str.sformat(lang.sizeUnavailableAria, this.model.get('type_name'));
    }
  }, {
    hasFixedWidth: true,
    columnClassName: 'csui-table-cell-size'
  });

  cellViewRegistry.registerByColumnKey('size', SizeCellView);
  // TODO: the REST API does not return homogenous nodes, unfortunately...
  cellViewRegistry.registerByColumnKey('container_size', SizeCellView);
  cellViewRegistry.registerByColumnKey('file_size', SizeCellView);

  return SizeCellView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/status/impl/status',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <span class=\"cellview_warning\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.status_name || (depth0 != null ? depth0.status_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status_name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.status_name || (depth0 != null ? depth0.status_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status_name","hash":{}}) : helper)))
    + "</span>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "  <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.status_name || (depth0 != null ? depth0.status_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status_name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.status_name || (depth0 != null ? depth0.status_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"status_name","hash":{}}) : helper)))
    + "</span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.status_late : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_status_impl_status', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/status/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/status/impl/nls/root/lang',{
  // format of the key: 'status_name'_ + type number + status number

  // task type = 206
  status_name_206_0: 'Pending',
  status_name_206_1: 'In Progress',
  status_name_206_2: 'Issue',
  status_name_206_3: 'On Hold',

  // workflow type = 153
  status_name_153_1: 'OK',
  status_name_153_2: 'Halted',
  status_name_153_3: 'Step Late',
  status_name_153_4: 'Milestone Late',
  status_name_153_5: 'Late',
  status_name_153_6: 'Suspended',
  status_name_153_7: 'Completed',
  status_name_153_8: 'Stopped',
  status_name_153_9: 'Archived',
  status_name_153_10: 'Subwork Late'

});



csui.define('css!csui/controls/table/cells/status/impl/status',[],function(){});
csui.define('csui/controls/table/cells/status/status.view',[
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'hbs!csui/controls/table/cells/status/impl/status',
  'i18n!csui/controls/table/cells/status/impl/nls/lang',
  'css!csui/controls/table/cells/status/impl/status'
], function (TemplatedCellView, cellViewRegistry, template, lang) {
  'use strict';

  var StatusCellView = TemplatedCellView.extend({
      template: template,
      needsAriaLabel: true,

      getValueData: function () {
        var statusName = this._getStatusName();

        // with workflow: status 3 = step late, 4 = milestone late, 5 = late and 10 = subwork late
        var type = this.model.get('type');
        var statusLate = false;
        if (type === 153 && (status === 3 || status === 4 || status === 5 || status === 10)) {
          statusLate = true;
        }

        return {
          status_name: statusName,
          status_late: statusLate
        };
      },

      // also implement this function to get the formatted text for the metadata detail row in
      // the table
      getValueText: function () {
        return this._getStatusName();
      },

      _getStatusName: function () {
        var type = this.model.get('type');
        var status = this.model.get(this.options.column.name);
        var status_name_from_clientside = lang['status_name_' + type + '_' + status];
        var status_name_from_server = this.model.get(this.options.column.name + "_name");

        return status_name_from_clientside || status_name_from_server;
      }
    },
    {
      hasFixedWidth: true,
      columnClassName: 'csui-table-cell-status'
    }
  );

  cellViewRegistry.registerByColumnKey("status", StatusCellView);

  return StatusCellView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorite.star/favorite.add.form',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <label for=\"grpSelectId\" class='favorite-group-label'>"
    + this.escapeExpression(((helper = (helper = helpers.group_label || (depth0 != null ? depth0.group_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"group_label","hash":{}}) : helper)))
    + "</label>\r\n  <div class='favorite-groups-container'></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div role=\"heading\" aria-level=\"3\" aria-label=\"Add favorite\">\r\n<label for=\""
    + this.escapeExpression(((helper = (helper = helpers.name_input_id || (depth0 != null ? depth0.name_input_id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name_input_id","hash":{}}) : helper)))
    + "\" class='favorite-name-label'>"
    + this.escapeExpression(((helper = (helper = helpers.name_label || (depth0 != null ? depth0.name_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name_label","hash":{}}) : helper)))
    + "</label>\r\n<input id=\""
    + this.escapeExpression(((helper = (helper = helpers.name_input_id || (depth0 != null ? depth0.name_input_id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name_input_id","hash":{}}) : helper)))
    + "\" class='favorite-name-input binf-form-control' type='text' placeholder='"
    + this.escapeExpression(((helper = (helper = helpers.name_place_holder || (depth0 != null ? depth0.name_place_holder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name_place_holder","hash":{}}) : helper)))
    + "' value='"
    + this.escapeExpression(((helper = (helper = helpers.favorite_name || (depth0 != null ? depth0.favorite_name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"favorite_name","hash":{}}) : helper)))
    + "'>\r\n<div class='favorite-name-input-error-div'>\r\n  <span class='favorite-name-input-error'></span>\r\n</div>\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.groups : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n<div class='favorite-buttons-container'>\r\n  <button title=\""
    + this.escapeExpression(((helper = (helper = helpers.add_button_label || (depth0 != null ? depth0.add_button_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"add_button_label","hash":{}}) : helper)))
    + "\" class='add-btn binf-btn binf-btn-primary binf-btn-default'>"
    + this.escapeExpression(((helper = (helper = helpers.add_button_label || (depth0 != null ? depth0.add_button_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"add_button_label","hash":{}}) : helper)))
    + "</button>\r\n  <button title=\""
    + this.escapeExpression(((helper = (helper = helpers.cancel_button_label || (depth0 != null ? depth0.cancel_button_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cancel_button_label","hash":{}}) : helper)))
    + "\" class='cancel-btn binf-btn binf-btn-default'>"
    + this.escapeExpression(((helper = (helper = helpers.cancel_button_label || (depth0 != null ? depth0.cancel_button_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cancel_button_label","hash":{}}) : helper)))
    + "</button>\r\n</div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorite.star_favorite.add.form', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorite.star/favorite.add.form.group',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<a href=\"#\" tabindex=\"-1\">\r\n  <span class=\"favorite_group\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n</a>\r\n";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorite.star_favorite.add.form.group', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorite.star/favorite.add.form.groups',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<button id=\"grpSelectId\" type=\"button\" class=\"binf-btn binf-btn-default binf-dropdown-toggle\"\r\n        data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n  <span class=\"selected-group-label\"></span>\r\n  <span class=\"cs-icon icon-caret-down\"></span>\r\n</button>\r\n<div class=\"binf-dropdown-menu favorite-groups-dropdown-container\" role=\"menu\">\r\n  <ul class=\"favorite-groups-dropdown\"></ul>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorite.star_favorite.add.form.groups', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/favorites/impl/favorite.star/favorite.add.form.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/dropdown.menu/dropdown.menu.behavior',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior', 'csui/utils/namedsessionstorage',
  'hbs!csui/widgets/favorites/impl/favorite.star/favorite.add.form',
  'hbs!csui/widgets/favorites/impl/favorite.star/favorite.add.form.group',
  'hbs!csui/widgets/favorites/impl/favorite.star/favorite.add.form.groups',
  'i18n!csui/widgets/favorites/impl/nls/lang'
], function (_, $, Backbone, Marionette, LayoutViewEventsPropagationMixin, DropdownMenuBehavior,
    PerfectScrollingBehavior, NamedSessionStorage, template, templateGroup, templateGroups, lang) {

  var csuiSessionStorage = new NamedSessionStorage();
  var constCSUIFavoriteTabID = 'csuiFavoriteTabID';

  var FavoriteGroupView = Marionette.ItemView.extend({

    tagName: 'li',

    attributes: function () {
      return {role: 'menuitem'};
    },

    template: templateGroup,

    triggers: {
      'click a': 'click:item'
    },

    constructor: function FavoriteGroupView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }

  });

  var FavoriteGroupsView = Marionette.CompositeView.extend({

    className: 'favorite-groups-dropdown-container binf-dropdown',

    template: templateGroups,

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.favorite-groups-dropdown',
        suppressScrollX: true
      },
      DropdownMenuBehavior: {
        behaviorClass: DropdownMenuBehavior
      }
    },

    ui: {
      toggle: '>.binf-dropdown-toggle',
      selectedLabel: '>.binf-btn >.selected-group-label',
      groupsScrollbarContainer: '.favorite-groups-dropdown'
    },

    events: {
      'shown.binf.dropdown': 'onShownDropdown'
    },

    childViewContainer: '.favorite-groups-dropdown',
    childView: FavoriteGroupView,
    childEvents: {
      'click:item': 'onClickItem',
      'render': '_onChildRender'
    },

    _onChildRender: function (childView) {
      var $item = childView.$el;
      if (childView.model.get('tab_id') === this.options.favModel.get('tab_id')) {
        $item.addClass('binf-active');
      }
    },

    constructor: function FavoriteGroupsView(options) {
      Marionette.CompositeView.call(this, options);
    },

    onRender: function () {
      var selectedModel = this.options.collection.findWhere({
        tab_id: this.options.favModel.get('tab_id')
      });
      var groupName = selectedModel.get('name');
      this.ui.selectedLabel.text(groupName);
      this.ui.selectedLabel.attr('title', groupName);
      this.ui.toggle.attr('aria-label', lang.addFavoriteGroupLabel + ' - ' + groupName);
      this.ui.toggle.binf_dropdown();
    },

    onClickItem: function (src) {
      this.$el.find('ul li').removeClass('binf-active');
      src.$el.addClass('binf-active');
      this.ui.toggle.binf_dropdown('toggle');
      this.ui.toggle.focus();
      var tabId = src.model.get('tab_id');
      this.options.favModel.set('tab_id', tabId);
      var groupName = src.model.get('name');
      this.ui.selectedLabel.text(groupName);
      this.ui.selectedLabel.attr('title', groupName);
      this.ui.toggle.attr('aria-label',  lang.addFavoriteGroupLabel + ' - ' + groupName);
      // set the selected tab_id to sessionStorage for sticky selection as UX requested
      csuiSessionStorage.set(constCSUIFavoriteTabID, tabId);
    },

    _computeDropdownMenuMaxHeight: function () {
      var maxHeight = 170;  // default max-height to about 6 menu items
      var elem = this.ui.groupsScrollbarContainer[0];
      if (!elem.getBoundingClientRect) {
        return maxHeight;
      }
      var elRect = elem.getBoundingClientRect();
      // see UX specs in LPAD-59445
      maxHeight = $(window).height() - elRect.top - 16;
      return maxHeight;
    },

    onShownDropdown: function () {
      this.ui.groupsScrollbarContainer.css('max-height', this._computeDropdownMenuMaxHeight());
      // note: only trigger dom:refresh after the dropdown menu is shown so that the perfect
      // scrollbar can be initialized correctly. No need to trigger update:scrollbar.
      this.ui.toggle.attr('aria-expanded', 'true');
      this.triggerMethod('dom:refresh');
    },

    closeDropdownMenu: function () {
      // close the dropdown menu if it is currently open
      if (this.$el.hasClass('binf-open')) {
        this.ui.toggle.attr('aria-expanded', 'false');
        this.ui.toggle.binf_dropdown('toggle', false);
      }
    }

  });

  var FavoriteAddFormView = Marionette.LayoutView.extend({

    template: template,

    templateHelpers: function () {
      return {
        name_label: lang.addFavoriteNameLabel,
        name_place_holder: lang.addFavoriteNamePlaceHolder,
        name_input_id: _.uniqueId('nameInp'),
        favorite_name: this.options.favModel.get('name'),
        groups: this.showGroups,
        group_label: lang.addFavoriteGroupLabel,
        // grp_select_id: _.uniqueId('grpSelect'),
        add_button_label: lang.addFavoriteAddButtonLabel,
        cancel_button_label: lang.addFavoriteCancelButtonLabel
      };
    },

    regions: {
      favGroupsRegion: '.favorite-groups-container'
    },

    triggers: {
      'click .add-btn': 'click:add:button',
      'click .cancel-btn': 'click:cancel:button'
    },

    ui: {
      nameInput: '.favorite-name-input',
      nameInputError: '.favorite-name-input-error',
      addButton: '.add-btn',
      cancelButton: '.cancel-btn'
    },

    events: {
      'click @ui.nameInput': 'onClickNameInput',
      'keyup': 'onKeyupEvent',
      'keyup @ui.nameInput': 'onNameInputEvent',  // validate Name field on key input
      'blur @ui.nameInput': 'onNameInputEvent',  // also validate Name field on leaving the field
      'keydown @ui.nameInput': 'controlsOnKeydownEvent',  // On Enter triggers save as UX asks
      'keydown @ui.addButton': 'controlsOnKeydownEvent',  // On Enter triggers save as UX asks
      'keydown @ui.cancelButton': 'cancelButtonOnKeydownEvent'
    },

    constructor: function FavoriteAddFormView(options) {
      Marionette.LayoutView.call(this, options);
      this.showGroups = true;
      if (this.options.collection.length === 1 &&
          this.options.collection.at(0).get('tab_id') === -1) {
        this.showGroups = false;
      }

      if (this.showGroups) {
        this.groupsView = new FavoriteGroupsView(options);
        // read the sessionStorage for sticky tab_id and use it if found
        var storedTabId = csuiSessionStorage.get(constCSUIFavoriteTabID);
        // validate the stored tab_id to make sure it is still valid
        var storedGroup = this.options.collection.findWhere({tab_id: storedTabId});
        if (!storedGroup) {
          // not found a group with the stored tab_id, use unsorted group and update the storage
          storedTabId = -1;
          csuiSessionStorage.set(constCSUIFavoriteTabID, storedTabId);
        }
        storedTabId && this.options.favModel && this.options.favModel.set('tab_id', storedTabId);
      }

      this.propagateEventsToRegions();
    },

    onRender: function () {
      if (this.showGroups) {
        this.groupsView.render();
        this.favGroupsRegion.show(this.groupsView);
      }
      this.validateNameInputAndSetAddButtonState(true);
    },

    currentlyFocusedElement: function (event) {
      return this.ui.nameInput;
    },

    showInlineError: function (error) {
      this.ui.nameInputError.attr('title', error);
      this.ui.nameInputError.text(error);
    },

    clearInlineError: function () {
      this.ui.nameInputError.attr('title', '');
      this.ui.nameInputError.text('');
    },

    validateNameInputAndSetAddButtonState: function (suppressError) {
      var valid = false;
      var name = this.ui.nameInput.val();
      name = name.trim();
      if (name.length < 1) {
        valid = false;  // this scope is needed to just disable the Add button
      } else if (name.length > 248) {
        suppressError !== true && this.showInlineError(lang.nameErrorMaxLengthExceed);
      } else if (name.indexOf(':') >= 0) {
        suppressError !== true && this.showInlineError(lang.nameErrorContainSemiColon);
      } else {
        this.clearInlineError();
        valid = true;
      }

      if (valid) {
        this.options.favModel.set('name', name);
        this.ui.addButton.prop('disabled', false);
      } else {
        this.ui.addButton.prop('disabled', true);
      }
      return valid;
    },

    cancelButtonOnKeydownEvent: function (event) {
      if (event && event.keyCode === 13) {  // Enter
        event.preventDefault();
        event.stopPropagation();
        this.trigger('click:cancel:button');
      }
    },

    controlsOnKeydownEvent: function (event) {
      if (event && event.keyCode === 13) {  // Enter
        event.preventDefault();
        event.stopPropagation();
        // On Enter triggers save as UX asks
        this.validateNameInputAndSetAddButtonState() && this.trigger('click:add:button');
      }
    },

    onKeyupEvent: function (event) {
      if (event && event.keyCode === 27) {  // Escape
        // Modal dialog is watching 'keyup' event, prevent default to let it know not to close.
        // Only the Popover is closed on Escape key.
        event.preventDefault();
        this.trigger('click:cancel:button');
      }
    },

    onNameInputEvent: function (event) {
      if (event && event.keyCode === 27) {  // Escape
        // Escape keyup is handled in the above method onKeyupEvent
        return;
      }
      // validating any key input on Name field and when leaving the field
      var valid = this.validateNameInputAndSetAddButtonState();
    },

    onClickNameInput: function (event) {
      // prevent the TableView keyboard from handling and setting the focus elsewhere incorrectly
      event && event.stopPropagation();
      // close the group dropdown menu if it is currently open
      this.groupsView && this.groupsView.closeDropdownMenu();
    }

  });

  _.extend(FavoriteAddFormView.prototype, LayoutViewEventsPropagationMixin);

  return FavoriteAddFormView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorite.star/favorite.star.view',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return "  <div class='csui-favorite-star-view-container csui-favorite-popover-container'>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(7, data, 0)})) != null ? stack1 : "")
    + "  </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <button type=\"button\" class=\"csui-favorite-star selected csui-acc-focusable\"\r\n              "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.focusable : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(5, data, 0)})) != null ? stack1 : "")
    + "\r\n               title=\""
    + this.escapeExpression(((helper = (helper = helpers.removeFav || (depth0 != null ? depth0.removeFav : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"removeFav","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.removeFav || (depth0 != null ? depth0.removeFav : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"removeFav","hash":{}}) : helper)))
    + "\">\r\n        <span class=\"icon icon-socialFav\"></span>\r\n      </button>\r\n";
},"3":function(depth0,helpers,partials,data) {
    return "tabindex=\"0\"";
},"5":function(depth0,helpers,partials,data) {
    return "tabindex=\"-1\"";
},"7":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <button type=\"button\" class=\"csui-favorite-star csui-acc-focusable\"\r\n              "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.focusable : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(5, data, 0)})) != null ? stack1 : "")
    + "\r\n              "
    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.showInFavoritesTable : depth0),{"name":"unless","hash":{},"fn":this.program(8, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n               title=\""
    + this.escapeExpression(((helper = (helper = helpers.addFav || (depth0 != null ? depth0.addFav : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"addFav","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.addFav || (depth0 != null ? depth0.addFav : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"addFav","hash":{}}) : helper)))
    + "\">\r\n        <span class=\"icon icon-socialFavOpen\"></span>\r\n      </button>\r\n";
},"8":function(depth0,helpers,partials,data) {
    return "aria-haspopup=\"dialog\"";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.enabled : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorite.star_favorite.star.view', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/favorites/impl/favorite.star/favorite.star.view',[],function(){});
csui.define('csui/widgets/favorites/favorite.star.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/models/favorite.model', 'csui/dialogs/modal.alert/modal.alert', 'csui/utils/base', 'i18n',
  'csui/controls/progressblocker/blocker',
  'csui/utils/contexts/factories/favorite2groups',
  'csui/widgets/favorites/impl/favorite.star/favorite.add.form.view',
  'csui/controls/mixins/keyboard.navigation/modal.keyboard.navigation.mixin',
  'hbs!csui/widgets/favorites/impl/favorite.star/favorite.star.view',
  'i18n!csui/widgets/favorites/impl/nls/lang',
  'css!csui/widgets/favorites/impl/favorite.star/favorite.star.view'
], function (_, $, Backbone, Marionette, FavoriteModel, ModalAlert, base, i18n,
    BlockingView, Favorite2GroupsCollectionFactory, FavoriteAddFormView,
    ModalKeyboardNavigationMixin, template, lang) {

  //
  // This view shows the favorite star view that can be inserted anywhere such as a row cell in the
  // nodes table row, the table header item name's toolbar, etc.
  //
  // Params in the constructor options:
  // - model <required> : the CS node model (NodeModel)
  // - context <required> : the application context object
  // - checkVisible <optional> : to check Add Favorite form visibility and adjust its top position
  // - formPopoverPlacement <optional> : the default is placing form popover on 'left' of the star
  // - popoverAtBodyElement <optional> : true/false for popover created at 'body'; default is false
  //
  // If the node model is already favorited, the star will be solid; otherwise, a non-solid star.
  // Clicking on the star will un-favorite the node model or show a simple add favorite form.
  //
  var FavoriteStarView = Marionette.ItemView.extend({

    template: template,

    templateHelpers: function () {
      return {
        enabled: this.enabled(),
        showInFavoritesTable: this.favTableOptions.isFavoritesTable,
        focusable: this.options.focusable,
        addFav: lang.addFav,
        removeFav: lang.removeFav,
        selected: this.favModel.get('selected')
      };
    },

    events: {
      'keydown': 'onKeyInView',
      'click': '_onClickView',
      'click button.csui-favorite-star': '_onClickStarButton',
      'click button > span.icon-socialFav': '_clickRemoveFavoriteStar',
      'click button > span.icon-socialFavOpen': '_clickAddFavoriteStar'
    },

    constructor: function FavoriteStarView(options) {
      options || (options = {});
      _.defaults(options, {
        formPopoverPlacement: 'left',
        popoverAtBodyElement: false,
        focusable: true
      });

      this.favTableOptions = options.favoritesTableOptions || {};

      Marionette.ItemView.call(this, options);

      if (options && options.blockingParentView) {
        BlockingView.delegate(this, options.blockingParentView);
      }

      this.favGroupsCollection = options.context && options.context.getCollection(
              Favorite2GroupsCollectionFactory,
              {detached: true, permanent: true}
          );

      // View already has an assigned node model. Use the id of the node model
      // to create a Favorite Model that will send commands to add/remove from Favorites.
      var connector = this.model && this.model.connector;
      var favModelOptions = {};
      if (this.model) {
        favModelOptions = _.extend(
            this._getModelDataForFavoriteModel(),
            {selected: this.model.get('favorite')});
      }
      this.favModel = new FavoriteModel(favModelOptions, {connector: connector});
      this.listenTo(this.favModel, 'change:selected', this.render);

      this.uniqueViewId = 'view' + _.uniqueId();

      this.popoverContainerClassname = 'csui-favorite-popover-container ' + this.uniqueViewId;
      this.popoverContainerSelector = '.csui-favorite-popover-container.' + this.uniqueViewId;

      $(window).bind('resize.' + this.uniqueViewId, {view: this}, this._onWindowResize);
    },

    onBeforeDestroy: function () {
      this.triggerMethod('close:add:favorite:form');
      this.closePopover();
      $(window).unbind('resize.' + this.uniqueViewId, this._onWindowResize);
    },

    enabled: function () {
      return this.model && this.options.context ? true : false;
    },

    onRender: function () {
      // restore focus on the Favorite Star button if it was focused previously
      if (this._previousFocusElm) {
        if ($(this._previousFocusElm).hasClass('csui-favorite-star')) {
          // previous element was the star, after re-rendering focus on the star again
          this.$el.find('button.csui-favorite-star').focus();
          this._previousFocusElm = undefined;
        }
      }

      // clear the previously stored title because Favorite Star button is being re-rendered
      this._previousTitle = undefined;

      // The groups and favorites collection is only fetched once for the app context.
      // For performance and better user experience when bringing up the Add Favorite form without
      // delaying until the groups are available, asynchronously prefetch this collection in the
      // background when a favorite star is rendered on the page.
      this.favGroupsCollection.ensureFetched();

      this.delegateEvents();
    },

    _onWindowResize: function (event) {
      // iPad/mobile onscreen keyboard showing causes the popover to close on opening
      if (base.isTouchBrowser() || base.isAppleMobile) {
        return;
      }
      if (event && event.data && event.data.view) {
        var self = event.data.view;
        self.showingForm && self.closePopover();
      }
    },

    _getPopoverParent: function () {
      return this.options.popoverAtBodyElement ? $(this.popoverContainerSelector) : this.$el;
    },

    _handleClickEvent: function (event) {
      // check to see if the click is NOT on the popover
      if (!$(event.target).closest('.binf-popover').length) {
        var self;
        if (event && event.data && event.data.view) {
          self = event.data.view;
          if (self.commandBlocked) {
            return;
          }
          // always turn off the click event in case the popover was already closed
          $(document).off('click', self._handleClickEvent);
        }
        // the click was outside of the popover, so find the popover and close it
        self && self.closePopover();
        self && self._setBlocked();
      }
    },

    _handleScrollEvent: function (event) {
      // iPad/mobile onscreen keyboard showing causes the popover to close on opening
      if (base.isTouchBrowser() || base.isAppleMobile) {
        return;
      }
      // check to see if the scroll event is NOT on the popover
      if (!$(event.target).closest('.binf-popover').length) {
        var self;
        if (event && event.data && event.data.view) {
          self = event.data.view;
          // always turn off the scroll event in case the popover was already closed
          $(document).off('scroll', self._handleScrollEvent);
        }
        self && self.closePopover();
      }
    },

    _getModelDataForFavoriteModel: function () {
      var tabId;
      if (this.favTableOptions.isFavoritesTable && this.favTableOptions.selectedGroup) {
        tabId = this.favTableOptions.selectedGroup.get('tab_id');
      } else {
        tabId = this.model.get('favorite_tab_id') || -1;  // default to the unsorted group
      }
      return {
        id: this.model.get('id'),
        name: this.model.get('favorite_name') || this.model.get('name'),
        tab_id: tabId
      };
    },

    _onClickView: function (event) {
      // skip if the view is not enabled
      // or the event was triggered by a child element (let the child element handle the click)
      //    only handle the case like when the click is triggered by parent cell view
      if (!this.enabled() || this.$el.find(event.target).length > 0) {
        return;
      }
      this._onClickStarButton(event);
    },

    _onClickStarButton: function (event) {
      if (this.$el.find('span.icon-socialFav').length > 0) {
        this._clickRemoveFavoriteStar(event);
      } else {
        this._clickAddFavoriteStar(event);
      }
    },

    _setBlocked: function () {
      // block the command to avoid double clicks or multiple fast clicks
      this.commandBlocked = true;
      setTimeout(_.bind(function () {
        this.commandBlocked = false;
      }, this), 500);
    },

    _clickAddFavoriteStar: function (event) {
      event && event.preventDefault();
      if (this.commandBlocked) {
        return;
      }
      // only block when the popover is currently NOT shown
      if (this._getPopoverParent().find('.binf-popover').length === 0) {
        this._setBlocked();
      }
      // capture focus element before adding the favorite
      this._capturePreviousFocusElement();
      // always initialize favModel for re-initialization if changed
      this.favModel.set(this._getModelDataForFavoriteModel());
      if (this.favTableOptions.isFavoritesTable) {
        // when in the expanded Favorites table, let the table perform bulk update
        this._addFavoriteToClientSideCollection(true);
        this.favGroupsCollection.trigger('bulk:update');
      } else {
        // show the Add Favorite form
        this._addFavoriteWithForm();
      }
    },

    _clickRemoveFavoriteStar: function (event) {
      event && event.preventDefault();
      event && event.stopPropagation();
      if (this.commandBlocked) {
        return;
      }
      this._setBlocked();
      // capture focus element before removing the favorite
      this._capturePreviousFocusElement();
      if (this.favTableOptions.isFavoritesTable) {
        // when in the expanded Favorites table, let the table perform bulk update
        this._removeFavoriteFromClientSideCollection(true);
        this.favGroupsCollection.trigger('bulk:update');
      } else {
        this._removeFavoriteFromServer();
      }
    },

    _clickAddButton: function () {
      if (this.commandBlocked) {
        return;
      }
      this._addFavoriteToServer()
          .done(_.bind(function () {
            // clear the previously stored title because Favorite Star button is being re-rendered
            this._previousTitle = undefined;
            // for some scenarios such as when the star is in bulk action toolbar, the popover is
            // already destroyed when favorite is added to server. Manually calling cleanup methods
            // here just for those cases. The cleanup methods have safeguards for repeated calling.
            this.disengageModalKeyboardFocusOnClose();
            this.closePopover();
            this._restorePreviousFocusAfterClosingPopover();
          }, this));
    },

    _clickCancelButton: function () {
      this.closePopover();
    },

    scrollCheckToClosePopover: function () {
      // optimization: only the favorite star showing the popover has _elTop defined
      if (this._elTop) {
        var tolerance = 15;
        var top = this.$el.offset().top;
        if (this._elTop && this._elTop < top - tolerance || this._elTop > top + tolerance) {
          this.closePopover();
        }
      }
    },

    _capturePreviousFocusElement: function () {
      // capture focus element before popover opens
      this._previousFocusElm = document.activeElement;
    },

    _restorePreviousFocusAfterClosingPopover: function () {
      // restore focus on previous focusing element
      if (this._previousFocusElm) {
        var $previousElm = $(this._previousFocusElm);
        if ($previousElm.hasClass('csui-favorite-star')) {
          // previous element was the star, after re-rendering focus on the star again
          this.$el.find('button.csui-favorite-star').focus();
        } else {
          $previousElm.focus();
        }
        this._previousFocusElm = undefined;
      }
    },

    closePopover: function () {
      // check if popover is currently open, close it
      if (this._getPopoverParent().find('.binf-popover').length > 0) {
        $(document).off('click', this._handleClickEvent);
        $(document).off('scroll', this._handleScrollEvent);
        this.disengageModalKeyboardFocusOnClose();
        this.triggerMethod('close:add:favorite:form');
        this.showingForm = false;
        this.commandBlocked = false;
        this._elTop = undefined;
        var $popoverEl = $(this.$el.find('.csui-favorite-star')[0]);
        $popoverEl.binf_popover('destroy');
        // restore the previous title due to an issue with binf_popover (tooltip impl)
        if (this._previousTitle) {
          $popoverEl.attr('title', this._previousTitle);
          this._previousTitle = undefined;
        }
        setTimeout(_.bind(function () {
          this.addForm && this.addForm.destroy();
          this.addForm = undefined;
          // Bootstrap popover has a bug: removing this too early will cause issue with next showing.
          // There is no event after destroy. The hidden event is not triggered for destroy.
          this.options.popoverAtBodyElement && $(this.popoverContainerSelector).remove();
          // restore focus on previous focusing element
          this._restorePreviousFocusAfterClosingPopover();
        }, this), 500);
      }
    },

    _removeFavoriteFromClientSideCollection: function (listenToEvent) {
      var self = this;
      this.model.set('favorite', false, {silent: true});
      this.$el.trigger('favorite:change');
      if (listenToEvent === true) {
        this.listenToOnce(this.favGroupsCollection, 'bulk:update:succeed', function () {
          self.stopListening(self.favGroupsCollection, 'bulk:update:fail');
          self.favModel.set('selected', false);
        });
        this.listenToOnce(this.favGroupsCollection, 'bulk:update:fail', function () {
          self.stopListening(self.favGroupsCollection, 'bulk:update:succeed');
          this.model.set('favorite', true, {silent: true});
        });
      }
      // remove favorite model from collection.
      // note: tab_id may not have set corectly yet, do not rely on it to filter to just that group
      this.favGroupsCollection.each(function (group) {
        group.favorites && group.favorites.remove({id: self.favModel.get('id')});
      });
    },

    _removeFavoriteFromServer: function () {
      var self = this;
      this.blockActions();
      this.favModel.removeFromFavorites()
          .always(function (data) {
            self.unblockActions();
          })
          .done(function (resp) {
            self._removeFavoriteFromClientSideCollection();
          })
          .fail(function (err) {
            self._showErrorMessage(self.favModel, err);
          });
    },

    _addFavoriteWithForm: function () {
      // if the Add Favorite Popover is currently shown, do nothing when the user clicks on the star
      if (this._getPopoverParent().find('.binf-popover').length > 0) {
        return;
      }

      // the groups and favorites collection is only fetched once for the app context
      this.favGroupsCollection.ensureFetched()
          .always(_.bind(function () {
            this._showAddFavoriteForm();
          }, this));
    },

    _showAddFavoriteForm: function () {
      // always initialize favModel for re-initialization if changed
      this.favModel.set(this._getModelDataForFavoriteModel());

      // show the Favorite Add Form in a popover
      this.addForm && this.addForm.destroy();
      this.addForm = new FavoriteAddFormView({
        context: this.options.context,
        model: this.model,
        favModel: this.favModel,
        collection: this.favGroupsCollection
      });
      this.addForm.render();
      this.listenTo(this.addForm, 'click:add:button', this._clickAddButton);
      this.listenTo(this.addForm, 'click:cancel:button', this._clickCancelButton);

      var placement = this.options.formPopoverPlacement;
      if (i18n && i18n.settings.rtl) {
        if (placement === 'left') {
          placement = 'right';
        } else {
          placement = 'left';
        }
      }

      var popoverOptions = {
        html: true,
        content: this.addForm.el,
        trigger: 'manual',
        placement: placement
      };

      if (this.options.popoverAtBodyElement) {
        // append a div element to the 'body'
        var $parent = $('body');
        // if the view is inside a modal dialog, append the div element to 'binf-modal-body'
        var modal = this.$el.closest('.binf-modal-body');
        (modal && modal.length > 0) && ($parent = $(modal[0]));
        $parent.append('<div class="binf-widgets ' + this.popoverContainerClassname + '"></div>');
        popoverOptions = _.extend(popoverOptions, {container: this.popoverContainerSelector});
      }

      // store the previous title due to an issue with binf_popover (tooltip impl)
      var $popoverEl = $(this.$el.find('.csui-favorite-star')[0]);
      this._previousTitle = $popoverEl.attr('title');

      var rightPercent = (($popoverEl.offset().left + $popoverEl.outerWidth()) /
                          $(window).width()) * 100;
      if ($(window).devicePixelRatio === 2) {
        if ((rightPercent < 29 && !i18n.settings.rtl) || (rightPercent > 70 && i18n.settings.rtl)) {
          placement = (placement === 'left') ? 'right' : 'left';
          popoverOptions.placement = placement;
        }
      } else {
        if ($(window).width() < 1280) {
          if ((rightPercent < 44 && !i18n.settings.rtl) ||
              (rightPercent > 58 && i18n.settings.rtl)) {
            placement = (placement === 'left') ? 'right' : 'left';
            popoverOptions.placement = placement;
          }
        } else {
          if ((rightPercent < 25 && !i18n.settings.rtl) ||
              (rightPercent > 80 && i18n.settings.rtl)) {
            placement = (placement === 'left') ? 'right' : 'left';
            popoverOptions.placement = placement;
          }
        }
      }
      // creating the popover
      $popoverEl.binf_popover(popoverOptions).binf_popover('show');
      var $popoverDiv = this._getPopoverParent().find('.binf-popover');

      if (this.favGroupsCollection.length > 1) {
        // besides the default unsorted group, there are other groups
        $popoverDiv.addClass('show-groups');
      }

      // adjusting popover top and arrow top as in UX specs
      var adjustedTop = parseInt($popoverDiv.css('top'), 10) + 52;
      $popoverDiv.css('top', adjustedTop);
      var $popoverArrow = $popoverDiv.find('.binf-arrow');
      $popoverArrow.css('top', 20);
      // switch to bottom alignment if the popover is not fully visible near the screen bottom
      if (this.options.popoverAtBodyElement === true) {  // popover is appended to body element
        // if the popover is outside of the view port vertically, bottom align it
        if (base.isVisibleInWindowViewportVertically($popoverDiv) !== true) {
          adjustedTop = parseInt($popoverDiv.css('top'), 10) - $popoverDiv.height() + 45;
          $popoverDiv.css('top', adjustedTop);
          $popoverArrow.css('top', $popoverDiv.height() - 20);
        }
      } else {  // popover is created at target element
        // for scenarios such as in table view row, UX wants bottom aligned popover for bottom rows
        if (this.options.checkVisible) {
          var $parentDiv = $popoverDiv.closest('.csui-perfect-scrolling');
          $parentDiv.length === 0 && ($parentDiv = $popoverDiv.closest('.csui-normal-scrolling'));
          if (base.isElementVisibleInParent($popoverDiv, $parentDiv, 90, 90) !== true) {
            adjustedTop = parseInt($popoverDiv.css('top'), 10) - $popoverDiv.height() + 45;
            $popoverDiv.css('top', adjustedTop);
            $(this.$el.find('.binf-arrow')[0]).css('top', $popoverDiv.height() - 23);
          }
        }
      }

      // when the star icon is very the top, Bootstrap tooltip position calculation offsets this.
      // final adjustment for the popover top to align it with the star icon
      var $starEl = $(this.$el.find('.csui-favorite-star > .icon')[0]);
      var starMiddle = $starEl.offset().top + ($starEl.height() / 2);
      var arrowMiddle = $popoverArrow.offset().top + 11; // arrowHeight = 22px
      var topOffset = starMiddle - arrowMiddle;
      $popoverDiv.offset({top: $popoverDiv.offset().top + topOffset});

      // trap keyboard focus in the popover
      this.engageModalKeyboardFocusOnOpen(this.addForm.el);
      // set modal attributes for WAI-ARIA
      var popoverLabelElemId = _.uniqueId('popoverLabelId');
      $popoverDiv.find('>.binf-popover-title').attr('id', popoverLabelElemId);
      $popoverDiv.attr('role', 'dialog');
      $popoverDiv.attr('aria-labelledby', popoverLabelElemId);

      // on shown.binf.popover event that the popover is shown, set focus on name field
      $popoverEl.on('shown.binf.popover', _.bind(function (event) {
        this._elTop = this.$el.offset().top;
        this.addForm && this.addForm.currentlyFocusedElement().focus();
        $(document).on('click', {view: this}, this._handleClickEvent);
        if (this.options.popoverAtBodyElement) {
          $(document).on('scroll', {view: this}, this._handleScrollEvent);
        }
        this.triggerMethod('show:add:favorite:form');
      }, this));

      this.showingForm = true;
    },

    _addFavoriteToClientSideCollection: function (listenToEvent) {
      var self = this;
      this.model.set('favorite', true, {silent: true});
      this.$el.trigger('favorite:change', this.favModel);
      if (listenToEvent === true) {
        this.listenToOnce(this.favGroupsCollection, 'bulk:update:succeed', function () {
          self.stopListening(self.favGroupsCollection, 'bulk:update:fail');
          self.favModel.set('selected', true);
        });
        this.listenToOnce(this.favGroupsCollection, 'bulk:update:fail', function () {
          self.stopListening(self.favGroupsCollection, 'bulk:update:succeed');
          this.model.set('favorite', false, {silent: true});
        });
      }

      // insert favorite model into the client-side collection
      var group = this.favGroupsCollection.findWhere({tab_id: this.favModel.get('tab_id')});
      var model = this.model.clone();
      model.set('favorite', true);
      model.set('favorite_name', this.favModel.get('name'));
      model.set('favorite_tab_id', this.favModel.get('tab_id'));
      group.favorites.add(model);
    },

    _addFavoriteToServer: function () {
      var deferred = $.Deferred();
      var self = this;
      this.blockActions();
      this.favModel.addToFavorites()
          .always(function (data) {
            self.unblockActions();
          })
          .done(function (resp) {
            self.model.setExpand('properties', ['parent_id']);
            self.model.fetch().always(function(){
              deferred.resolve(resp);
              self._addFavoriteToClientSideCollection();
            });

          })
          .fail(function (err) {
            deferred.reject(err);
            self._showErrorMessage(self.favModel, err);
          });
      return deferred.promise();
    },

    _suspendPopoverBehaviors: function () {
      // check if popover is currently open, then suspend some of its behaviors
      if (this._getPopoverParent().find('.binf-popover').length > 0) {
        // capture focus element before the Error dialog is shown
        this._focusElementBeforeErrorDialog = document.activeElement;
        // turn off click event handler so that clicking on ModalAlert does not close the form
        $(document).off('click', this._handleClickEvent);
        // disengage modal keyboard focus for Error dialog interaction
        this.disengageModalKeyboardFocusOnClose();
      }
    },

    _resumePopoverBehaviors: function () {
      // check if popover is currently open, then resume the suspended behaviors
      if (this._getPopoverParent().find('.binf-popover').length > 0) {
        // turn on click event handler again
        $(document).on('click', {view: this}, this._handleClickEvent);
        // re-engage modal keyboard focus for popover
        this.addForm && this.engageModalKeyboardFocusOnOpen(this.addForm.el);
        // restore focus on previous focusing element
        this._focusElementBeforeErrorDialog && $(this._focusElementBeforeErrorDialog).focus();
        this._focusElementBeforeErrorDialog = undefined;
      }
    },

    _showErrorMessage: function (model, iError) {
      var error = new base.Error(iError);
      var title = lang.updateFavoriteFailTitle;
      var message = _.str.sformat(lang.updateFavoriteFailMessage, model.get("id"), error.message);
      this._suspendPopoverBehaviors();
      ModalAlert.showError(message, title)
          .always(_.bind(function () {
            this._resumePopoverBehaviors();
          }, this));
    },

    toggleFavorite: function () {
      if (this.model.get('favorite')) {
        this._clickRemoveFavoriteStar();
      } else {
        this._clickAddFavoriteStar();
      }
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {  // space or enter key
        // if the Add Favorite Popover is currently shown, do nothing here
        if (this._getPopoverParent().find('.binf-popover').length > 0) {
          event.stopPropagation();
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.enabled() && this.toggleFavorite();
      }
    },

    // because this view does not support being itself the view for the progress blocker, implement
    // the block functions as nop functions
    blockActions: function () {},
    unblockActions: function () {}

  });

  ModalKeyboardNavigationMixin.mixin(FavoriteStarView.prototype);

  return FavoriteStarView;

});


csui.define('css!csui/controls/table/cells/favorite/impl/favorite',[],function(){});
csui.define('csui/controls/table/cells/favorite/favorite.view',["csui/lib/underscore",
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'csui/widgets/favorites/favorite.star.view',
  'css!csui/controls/table/cells/favorite/impl/favorite'
], function (_, TemplatedCellView, cellViewRegistry, FavoriteStarView) {

  var FavoriteStarCellView = TemplatedCellView.extend({

        getValueData: function () {
          return this.model.toJSON();
        },

        constructor: function FavoriteStarCellView(options) {
          TemplatedCellView.prototype.constructor.apply(this, arguments);
        },

        onBeforeDestroy: function () {
          this.triggerMethod('close:add:favorite:form');
          if (this.favStarView) {
            this.favStarView.destroy();
            this.favStarView = undefined;
          }
        },

        onRender: function () {
          if (!this.favStarView) {
            this.favStarView = new FavoriteStarView(_.extend({
              checkVisible: true,
              popoverAtBodyElement: true,
              focusable: false
            }, this.options));
          }
          this.listenTo(this.favStarView, 'show:add:favorite:form', function () {
            this.triggerMethod('show:add:favorite:form');
          });
          this.listenTo(this.favStarView, 'close:add:favorite:form', function () {
            this.triggerMethod('close:add:favorite:form');
          });
          this.favStarView.render();
          this.$el.append(this.favStarView.el);

          this.listenTo(this.options.tableView, 'scroll', function () {
            this.favStarView && this.favStarView.scrollCheckToClosePopover();
          });
        }

      },
      {
        hasFixedWidth: true,
        columnClassName: 'csui-table-cell-favorite'
      }
  );

  // This column key is used on the client side only to give a hint that
  // one or multiple rows can be and/or are selected
  cellViewRegistry.registerByColumnKey('favorite', FavoriteStarCellView);

  return FavoriteStarCellView;

});

csui.define('csui/controls/table/cells/favorite/favorite.name.view',['csui/controls/table/cells/name/name.view', 'csui/controls/table/cells/cell.registry'
], function (NameCellView, cellViewRegistry) {

  // currently no difference between the normal name view but use different column_key to register
  var FavoriteNameCellView = NameCellView.extend({});

  cellViewRegistry.registerByColumnKey('favorite_name', FavoriteNameCellView);

  return FavoriteNameCellView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/type.icon/impl/type.icon',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.inactive : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    return "    <div class=\"csui-table-cell-no-default-action\"></div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "    <a class=\"csui-table-cell-default-action\" href=\""
    + this.escapeExpression(((helper = (helper = helpers.defaultActionUrl || (depth0 != null ? depth0.defaultActionUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"defaultActionUrl","hash":{}}) : helper)))
    + "\"\r\n       aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.typeAndNameAria || (depth0 != null ? depth0.typeAndNameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"typeAndNameAria","hash":{}}) : helper)))
    + "\"></a>\r\n";
},"6":function(depth0,helpers,partials,data) {
    return "  <div class=\"csui-table-cell-no-default-action\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.defaultAction : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_type.icon_impl_type.icon', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/type.icon/impl/type.icon',[],function(){});
csui.define('csui/controls/table/cells/type.icon/type.icon.view',[
  'csui/lib/underscore', 'csui/lib/marionette',
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/controls/table/cells/cell.registry','csui/utils/node.links/node.links',
  'hbs!csui/controls/table/cells/type.icon/impl/type.icon',
  'i18n!csui/controls/table/impl/nls/lang',
  'css!csui/controls/table/cells/type.icon/impl/type.icon'
], function (_, Marionette, TemplatedCellView, NodeTypeIconView,
    cellViewRegistry, nodeLinks, template, lang) {
  'use strict';

  var TypeIconCellView = TemplatedCellView.extend({
    events: {
      'keydown': 'onKeyInView'
    },

    template: template,

    constructor: function TypeIconCellView(options) {
      TemplatedCellView.prototype.constructor.apply(this, arguments);
      this.needsAriaLabel = !this.options.column.defaultAction;
      this.listenTo(this, 'render', this._createNodeTypeIcon)
          .listenTo(this, 'before:render', this._destroyNodeTypeIcon)
          .listenTo(this, 'before:destroy', this._destroyNodeTypeIcon);
    },

    getValueData: function () {
      var node = this.model,
          defaultActionUrl = nodeLinks.getUrl(this.model),
          typeAndName = _.str.sformat(lang.typeAndNameAria, node.get('type_name'), node.get('name'));
      // these type_name values are less specific but also shorter

      return {
        defaultAction: this.options.column.defaultAction,
        defaultActionUrl: defaultActionUrl,
        typeAndNameAria: typeAndName,
        inactive: node.get('inactive')
      };
    },

    _createNodeTypeIcon: function () {
      var iconView = new NodeTypeIconView({node: this.model});
      this.cellRegion = new Marionette.Region({el: this.$('> *')});
      this.cellRegion.show(iconView);
    },

    _destroyNodeTypeIcon: function () {
      if (this.cellRegion) {
        this.cellRegion.empty();
        this.cellRegion = null;
      }
    },

    getValueText: function () {
      return this.model.get('type_name') || '';
    }
  }, {
    hasFixedWidth: true,
    columnClassName: 'csui-table-cell-type',

    getModelExpand: function (options) {
      return {'versions.element(0)': ['mime_type']};
    }
  });

  cellViewRegistry.registerByColumnKey('type', TypeIconCellView);

  return TypeIconCellView;
});

csui.define('csui/dialogs/members.picker/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/dialogs/members.picker/impl/nls/root/lang',{
  ViewDenied: 'Access denied, you do not have permission to view "{0}".',
  cancelButtonLabel: "Cancel",
  dialogTitle: "View group membership",
  serverError: 'Server request failed with error code {0}.',
  backButtonTooltip: 'Go back',
  missingConnector: 'Missing connector information!',
  emptyMembersText: 'No results found.',
  UserPickerPlaceHolder: 'Enter user or group',
  addButtonLabel: 'Add',
  selectPermissionLevel: 'Select permission level',
  nextButtonLabel: 'Next',
  doneButtonLabel: 'Done',
  groupSymbolAlt: 'Group symbol',
  userSymbolAlt: 'User symbol',
  disabledItemTypeNameAria: 'Disabled: {0}: {1}',
  itemTypeNameAria: '{0}: {1}', // like "User: XYZ"
  AddUserOrGroup: 'Add user or group',
  AddMember: 'Add member',
  userSearchPlaceHolder: 'Search for user',
  addAnotherNamePlaceHolder: 'Add another user or group',
  removeSelectedUser: 'Remove member',
  removeSelectedUserAria: 'Remove {0} from selection list',
  singleUserText: '{0} added to the {1} group.',
  singleUserFailureText: '{0} failed to add to the {1} group.',
  SinglePassMoreThanOneFail: '{0} added to the {1} group and {2} members failed to added to the' +
                             ' group.',
  onlyFailUsersText: '{0} members failed to add to the {1} group',
  onlyAllSuccessText: '{0} members Successfully added to the {1} group',
  onlyAllFailureText: '{0} members failed to add to the {1} group',
  manyUserText: '{0} members Successfully added, {1} members failed to add to the {2} group .',
  searchIconTitle: 'Open user or group search box',
  searchIconAria: 'Click or press enter to open user or group search box',
  openSearchBar: 'Open search bar',
  closeSearchBar: 'Close search bar'
});



/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/member.list/list.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "";
},"3":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <a class=\"csui-item-standard csui-list-group-item\" href=\"\">\r\n    <span class=\"csui-icon csui-start-icon "
    + this.escapeExpression(((helper = (helper = helpers.selected || (depth0 != null ? depth0.selected : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selected","hash":{}}) : helper)))
    + "\"></span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isGroup : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "    <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" class=\"csui-list-item-title\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n  </a>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span class=\"csui-user-default-picture-dlg csui-icon image_group_placeholder_permission\"></span>\r\n      <span><img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imgSrc || (depth0 != null ? depth0.imgSrc : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imgSrc","hash":{}}) : helper)))
    + "\" alt=\""
    + this.escapeExpression(((helper = (helper = helpers.imgAlt || (depth0 != null ? depth0.imgAlt : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imgAlt","hash":{}}) : helper)))
    + "\"\r\n                 class=\"binf-hidden csui-user-profile-picture-dlg csui-member-group-icon csui-icon\" /></span>\r\n      <span class=\"csui-icon csui-end-icon icon-sidebar-expand24 binf-hidden\"></span>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span\r\n          class=\"csui-user-default-picture-dlg csui-icon image_user_placeholder\">"
    + this.escapeExpression(((helper = (helper = helpers.initials || (depth0 != null ? depth0.initials : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"initials","hash":{}}) : helper)))
    + "</span>\r\n      <span><img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imgSrc || (depth0 != null ? depth0.imgSrc : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imgSrc","hash":{}}) : helper)))
    + "\" alt=\""
    + this.escapeExpression(((helper = (helper = helpers.imgAlt || (depth0 != null ? depth0.imgAlt : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imgAlt","hash":{}}) : helper)))
    + "\"\r\n                 class=\"binf-hidden csui-user-profile-picture-dlg csui-member-group-icon csui-icon\" /></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.totalcount : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "\r\n";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_member.list_list.item', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/search.list/search.location.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<span class=\"csui-type-location-icon\" aria-hidden=\"true\"></span><span title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\"\r\n                                                                      class=\"csui-list-item-title\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_search.list_search.location.item', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/members.picker/impl/members.picker',[],function(){});
// Shows a list of links
csui.define('csui/dialogs/members.picker/impl/member.list/list.item.view',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/controls/listitem/listitemstandard.view',
  'csui/utils/url',
  'csui/utils/user.avatar.color',
  'hbs!csui/dialogs/members.picker/impl/member.list/list.item',
  'hbs!csui/dialogs/node.picker/impl/search.list/search.location.item',
  'i18n!csui/dialogs/members.picker/impl/nls/lang',
  'css!csui/dialogs/members.picker/impl/members.picker'
], function (_, $, StandardListItem, Url, UserAvatarColor, itemTemplate, searchLocationTemplate,
    lang) {

  var ListItem = StandardListItem.extend({

    template: itemTemplate,
    searchLocationTemplate: searchLocationTemplate,

    templateHelpers: function () {
      return {
        defaultProfilePictureClass: this._isGroup() ? 'image_group_placeholder_permission' :
                                    'image_user_placeholder',
        imgAlt: this._isGroup() ? lang.groupSymbolAlt : lang.userSymbolAlt,
        totalcount: !this.options.model.collection.totalCount,
        isGroup: !!this._isGroup(),
        name: this.options.model.get("name_formatted"),
        selected: this.selected ? 'icon-listview-checkmark' : '',
        imgSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs="
      };
    },

    tagName: 'li',

    events: {
      'keydown': 'onKeyInView'
    },

    ui: {
      link: '.csui-list-group-item'
    },

    onKeyInView: function (event) {
      //left arrow is the same and enter/space
      if (event.keyCode === 39 || event.keyCode === 32 || event.keyCode === 13) {
        this.$el.trigger('click');
        this.$el.focus();
        return false;
      }
      return true;
    },

    _isUser: function () {
      return (this.options.model.get("type") === 0);
    },

    _isGroup: function () {
      return (this.options.model.get("type") === 1);
    },

    _isInActiveUser: function () {
      return (this.options.model.get("type") < 0);
    },

    constructor: function ListItem(options) {
      StandardListItem.apply(this, arguments);
      this.browsed = false;
    },

    toggleSelect: function () {
      this.selected = !this.selected;
      this.render();
    },

    toggleBrowse: function () {
      this.browsed = !this.browsed;
      this.render();
    },

    assignedBrowseNSelect: function () {
      this.browsed = this.selected = true;
      this.render();
    },

    unassignBrowseNSelect: function () {
      if (!this.isDestroyed) {
        this.browsed = this.selected = false;
        this.render();
      }
    },

    isSelected: function () {
      return this.selected;
    },

    isBrowsed: function () {
      return this.browsed;
    },

    setValidity: function (valid) {
      this.valid = valid;
    },

    onRender: function () {
      this.$el.addClass('cs-left-item-' + this.model.get('id'));
      this.$el.removeClass('select');
      this.$el.removeClass('browse');
      this.ui.link.removeAttr('aria-selected');
      this.$el.attr('role', 'option');
      var elementNamePlus = _.str.sformat(lang.itemTypeNameAria, this.model.get('type_name'),
          this.model.get('name'));
      if (!this.valid) {
        elementNamePlus = _.str.sformat(lang.disabledItemTypeNameAria, this.model.get('type_name'),
            this.model.get('name'));
      }
      this.$el.attr('aria-label', elementNamePlus);

      if (this.selected) {
        if (this._isGroup()) {
          this.$el.find("span").removeClass('binf-hidden');
        }
        this.$el.addClass('select');
        this.$el.attr('aria-selected', 'true');
      } else if (this.browsed) {
        this.$el.addClass('browse');
        this.$el.find("span.csui-end-icon").removeClass('binf-hidden');
      }

      if (this._isBrowsable(this.model)) {
        this.ui.link.attr('aria-haspopup', 'true');
        this.ui.link.attr('aria-expanded', 'false');
      }

      /*if (!this._isGroup()) {
        this.$el.addClass('csui-disabled');
      }*/
      this._renderPhoto();
    },

    _renderPhoto: function () {
      var photoUrl = this.model.get("photo_url");
      var userbackgroundcolor = UserAvatarColor.getUserAvatarColor(
          this.options.model.attributes.data.properties);
      this.$el.find('.csui-user-default-picture-dlg.image_user_placeholder').css("background-color",
          userbackgroundcolor);
      if (this._isGroup() || photoUrl === null) {

      } else {
        var that = this;
        this._resolvePhoto(photoUrl).done(
            _.bind(function (photo) {
              var profieEle = that.$el.find('.csui-user-profile-picture-dlg');
              that.$el.find('.csui-user-default-picture-dlg').addClass('binf-hidden');
              that.url = URL.createObjectURL(photo);
              profieEle
                  .removeClass('binf-hidden')
                  .attr("src", that.url);
            })
        ).fail(function () {
          var profieEle = that.$el.find('.csui-user-profile-picture-dlg');
          profieEle
              .attr("src",
                  "data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=");
        });
      }
    },

    _resolvePhoto: function (photoUrl) {
      var connector  = this.options.model.connector,
          connection = connector.connection,
          cgiUrl     = new Url(connection.url).getCgiScript(),
          dPhoto     = $.Deferred(),
          imgUrl     = Url.combine(cgiUrl, photoUrl);

      var getPhotoConnector = connector.extendAjaxOptions({
        url: imgUrl,
        dataType: 'binary',
        connection: connection
      });

      $.ajax(getPhotoConnector).done(function (response) {
        dPhoto.resolve(response);
      }).fail(dPhoto.reject);

      return dPhoto.promise();
    },

    _isBrowsable: function (node) {
      // FIXME: Use permitted commands as soon as the server sends browse
      //return node.actions.get('browse');
      return node.get('container') && node.get('perm_see_contents') !== false;
    }

  });

  return ListItem;
});

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/member.list/member.list',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"list-content\">\r\n  <ul class=\"binf-list-group\" role=\"listbox\"></ul>\r\n  <div class=\"binf-search-location-group\"></div>\r\n</div>";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_member.list_member.list', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/member.list/empty.members.list',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<p class='csui-members-empty'> "
    + this.escapeExpression(((helper = (helper = helpers.emptyTableText || (depth0 != null ? depth0.emptyTableText : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"emptyTableText","hash":{}}) : helper)))
    + " </p>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_member.list_empty.members.list', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/members.picker/impl/member.list/member.list',[],function(){});
// Shows a list of items
csui.define('csui/dialogs/members.picker/impl/member.list/member.list.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/dialogs/members.picker/impl/member.list/list.item.view',
  "csui/controls/progressblocker/blocker",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'hbs!csui/dialogs/members.picker/impl/member.list/member.list',
  'hbs!csui/dialogs/members.picker/impl/member.list/empty.members.list',
  'i18n!csui/dialogs/members.picker/impl/nls/lang',
  'css!csui/dialogs/members.picker/impl/member.list/member.list'
], function (_, $, Marionette, ListItem, BlockingView, TabableRegion,
    PerfectScrollingBehavior, listTemplate, emptyTemplate, lang) {
  'use strict';

  var MemberListView = Marionette.CompositeView.extend({

    className: 'cs-list',
    template: listTemplate,
    childViewContainer: '.binf-list-group',
    childView: ListItem,

    childViewOptions: function () {
      return {
        locationEle: this.ui.location
      };
    },

    childEvents: {
      'click:item': 'onItemClick',
      'before:add:child': 'onBeforeAddChild'
    },

    ui: {
      listParent: '.list-content',
      list: '.binf-list-group',
      location: '.binf-search-location-group'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    onBeforeAddChild: function (child) {
      var validTarget = this.commandType.validateTarget(child.model);
      child.setValidity(validTarget);
    },

    //with infinite scrolling, need to keep track of selected members and
    //reselect them after a re-render.
    //Also need to reset items after a filter request.
    onAddChild: function (child) {
      var id = child.model.get('id');

      if (!!this.selectedItem && this.selectedItem.model.get('id') === id) {
        this.selectedItem = child;
        this.toggleSelectedChild(child);
      }

      if (!this.commandType.validateMember(child.model)) {
        child.$el.hide();
      } else {
        child.$el.addClass('csui-acc-focusable');
      }

      if (!this.commandType.isSelectable(child.model) && !this._isBrowsable(child.model)) {
        child.$el.addClass('csui-disabled');
        var disabledTitle = _.str.sformat(lang.disabledItemTypeNameAria,
          child.model.get('type_name'), child.model.get('name'));
        child.$el.attr('aria-label', disabledTitle);
      }
      if (this._isBrowsable(child.model)){
        child.ui.link.attr('aria-haspopup', 'true');
        child.ui.link.attr('aria-expanded', 'false');
      }else{
        child.ui.link.removeAttr('aria-haspopup');
        child.ui.link.removeAttr('aria-expanded');
      }

      if (this.browsedChild && (this.browsedChild.model.get('id') === id )) {
        this.browsedChild = child;
        this.toggleBrowsedChild(child);
      }
      return true;
    },

    collectionEvents: {'sync': 'syncUpdate', 'reset': 'rebuild'},

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '> .list-content',
        suppressScrollX: true
      },

      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    isTabable: function () {
      return this.children.find(function (view) {
        var $el = view.$el;
        return ($el.is(':visible') && !$el.is(':disabled'));
      });
    },

    currentlyFocusedElement: function () {
      var focusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');
      if (focusables.length) {
        return $(focusables[this.focusIndex]);
      }
    },

    setFocus: function () {
      var focusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');
      $(focusables[this.focusIndex]).focus();
    },

    onKeyInView: function (event) {
      var keyCode    = event.keyCode,
          focusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');

      switch (keyCode) {
        //up arrow
        //down arrow
      case 38:
      case 40:
        if (keyCode === 38) {
          this.focusIndex > 0 && --this.focusIndex;
        } else {
          this.focusIndex < focusables.length && ++this.focusIndex;
        }
        this.trigger('changed:focus');
        $(focusables[this.focusIndex]).focus();
        break;
      }
    },

    constructor: function MemberListView(options) {
      options || (options = {});
      _.defaults(options, {pageSize: 30});

      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this.jQuery = $;
      BlockingView.imbue(this);

      this.selectedItem = options.selection ? options.selection : null;
      this.blockScroll = true;
      this.notFetching = true;
      this.init = true;         //makes sure only one blocker is activated at a given time due to an end-of-scroll.
      this.nextCollectionPage = _.bind(this.addNextCollectionPage, this);
      this.commandType = options.commandType;
      this.focusIndex = 0;         //used for accessiblity
      this.listenTo(this.collection, 'sync', function () {
        this.ui.listParent.find('p.csui-members-empty').remove();
        if (this.collection.length === 0) {
          this.ui.listParent.addClass("csui-members-empty");
          var emptyEl = emptyTemplate.call(this, {emptyTableText: lang.emptyMembersText});
          this.ui.listParent.append(emptyEl);
        } else {
          this.ui.listParent.removeClass("csui-members-empty");
        }
      });
      this.listenTo(this.collection, "request", this.setBlocker);
      this.listenTo(this.collection, "reset", this.setBlocker);
      this.listenTo(this, "browse:complete", function () {
        this.notFetching = true;
      });

    },

    syncUpdate: function () {
      this.nextTriggerSetting = this.options.pageSize / 2;
      this.blockScroll = true;
      this.notFetching = true;
      this.init = true;

      this.unblockActions();
    },

    rebuild: function () {
      this.ui.listParent.find('p.csui-members-empty').remove();
      if (this.collection.length === 0) {
        this.ui.listParent.addClass("csui-members-empty");
        var emptyEl = emptyTemplate.call(this, {emptyTableText: lang.emptyMembersText});
        this.ui.listParent.append(emptyEl);
      } else {
        this.ui.listParent.removeClass("csui-members-empty");
      }
      this.reset();
      this.trigger('dom:refresh');
    },

    //Public - called to reset the scroll position after a search.
    reset: function () {
      this.init = true;
      var that = this;
      if (this.scrollBar) {
        this.scrollBar.scrollTop(0);
        //which reset scrollbar to none when collection is empty
        if (!this.collection.length) {
          setTimeout(function () {
            that.triggerMethod('update:scrollbar', this);
          }, 0);
        }
      }
    },

    stopBlocker: function () {
      this.unblockActions();
      return true;
    },

    //Make sure to only set the blocker once.
    setBlocker: function () {
      if (this.blockScroll) {
        this.blockScroll = false;
        this.blockActions();
      }
      return true;
    },

    addNextCollectionPage: function (/*event, args*/) {
      var collectionLength  = this.collection.length,
          scrollableHeight  = this.ui.list.height() - this.ui.listParent.height(),
          scrollRelativePos = this.ui.listParent.scrollTop() / scrollableHeight,
          nextJump          = (collectionLength - this.nextTriggerSetting) / collectionLength;

      if (collectionLength && (collectionLength < this.collection.totalCount) &&
          ( scrollRelativePos >= nextJump )) {

        if (this.notFetching) {
          this.notFetching = false;
          this.collection.setSkip(collectionLength, false);
          this.collection.fetch({
            reset: false,
            remove: false,
            merge: false
          });
        }

        //Postpone progress blocker until user scrolls to the bottom. In the mean time
        //a request for more items has been made.
        if (scrollRelativePos > 0.98 && this.init) {
          this.setBlocker();
          this.init = false;
        }

      }
    },

    onDomRefresh: function () {
      if (!this.scrollBar) {
        this.scrollBar = this.ui.listParent;
        this.scrollBar.on('scroll', this.nextCollectionPage);
      }
    },

    onItemClick: function (child) {
      if (child.$el.hasClass('csui-disabled')) {
        return;
      }
      this._processClickedItem(child);
    },

    _processClickedItem: function (child) {
      //ignore click item if still fetching collections.
      if (this.notFetching) {
        this.notFetching = false;
        var browseable = this._isBrowsable(child.model);
        if (!browseable) {
          // removing selection of target, as we are not supporting 
          // selecting member or group from members picker.
          this._targetSelection(child);
        } else {
          this._browseSelection(child);
        }
        child.$el.blur();
      }

      // In order set focus to the parent view after a 'enter/space' keycode event, we send a setCurrentTabFocus event.
      // The parent will then set focus to itself. This is needed for Dialog accessiblity.
      this.$el.trigger('setCurrentTabFocus');
      return true;
    },

    clearSelect: function () {
      var self = this;

      if (this.selectedItem) {
        self.toggleSelectedChild(this.selectedItem);
      }
      this.selectedItem = null;
      return true;
    },

    toggleSelectedChild: function (child) {
      if (this.commandType.isSelectable(child.model)) {
        child.toggleSelect();
      }
    },

    toggleBrowsedChild: function (child) {
      child && child.toggleBrowse();
    },

    _isBrowsable: function (member) {
      return member.get('type') === 1;
    },

    //Selection without browse
    _targetSelection: function (child) {
      var model        = child.model,
          childId      = model.get('id'),
          prevSelected = child.isSelected(),
          type         = model.get('type');

      //remove previous selection as multiSelect is not supported
      this.clearSelect();
      // new selected item
      if (!prevSelected) {
        this.selectedItem = child;
        this.toggleSelectedChild(child);
      }
      this.trigger('selection:change',
          {type: type, member: model, add: !prevSelected});
      this.notFetching = true;
    },

    _browseSelection: function (child) {
      var selectableType = this.commandType.isSelectableType(child.model),
          selectable     = this.commandType.isSelectable(child.model),
          browsable     = this.commandType.browseAllowed(child.model),
          alreadyBrowsed = child.isBrowsed(),
          addToSelection = false,
          type           = child.model.attributes.type;
      if (alreadyBrowsed) {
        selectable && this._targetSelection(child);
        this.notFetching = true;
      } else {
        if (selectable) {
          this._browseNSelect(child);
          addToSelection = true;
        } else {
          if (browsable || selectableType) {
            this.clearSelect();
            addToSelection = true;
          }
          this.toggleBrowsedChild(child);
        }

        if (browsable) {
          this.trigger('selection:change', {
            member: child.model,
            silent: false,
            add: addToSelection,
            type: type
          });
        }
        this._browse(child, addToSelection);
      }
    },

    _browse: function (child, addToSelection) {
      this.browsedChild && this.browsedChild.toggleBrowse();
      this.browsedChild = child;
      child.ui.link.attr('aria-expanded', 'true');
      this.trigger('browse:select', {member: child.model, add: addToSelection});
    },

    _browseNSelect: function (child) {
      this.clearSelect();
      this.selectedItem = child;
      child.assignedBrowseNSelect();
    }

  });

  return MemberListView;

});

csui.define('csui/behaviors/input/placeholder',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette'
], function (_, Backbone, Marionette) {
  "use strict";

  var PlaceholderBehavior = Marionette.Behavior.extend({

    events: {
      'keydown @ui.inputField': 'onKeyDown',
      'keyup @ui.inputField': 'onKeyUp',
      'focus @ui.inputField': 'onFocus'
    },

    initialize: function(options, view) {
      this.isEmpty = true;
    },

    onKeyDown: function() {
      var fldVal = this.view.ui.inputField.val();
      var placeholderText = this.view.ui.inputField.attr('placeholder');

      if (this.isEmpty === true && fldVal === placeholderText) {
        this.view.ui.inputField.val('');
      }
    },

    onKeyUp: function() {
      var fldVal = this.view.ui.inputField.val();
      var placeholderText = this.view.ui.inputField.attr('placeholder');

      if (fldVal.length === 0 || fldVal === placeholderText) {
        this.isEmpty = true;
        this.view.ui.inputField.val(placeholderText);
        this.view.ui.inputField[0].setSelectionRange(0, 0);
      }
      else {
        this.isEmpty = false;
      }
    },

    onFocus: function() {
      var placeholderText = this.view.ui.inputField.attr('placeholder');

      if (this.view.ui.inputField.val().length === 0) {
        this.isEmpty = true;
        this.view.ui.inputField.val(placeholderText);
        this.view.ui.inputField[0].setSelectionRange(0, 0);
      }
    }

  });

  return PlaceholderBehavior;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/select.view/impl/header/header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-search-item-left-panel\">\r\n    <div class=\"csui-search-item-type\">\r\n      <span class=\"csui-type-label\"> "
    + this.escapeExpression(((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"type","hash":{}}) : helper)))
    + " </span>\r\n    </div>\r\n    <div class=\"csui-search-item\">\r\n      <div class=\"csui-search-item-name\">\r\n        "
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div class=\"csui-search-item-right-panel\">\r\n    <div class=\"csui-search-item-location\">\r\n      <div class=\"csui-search-toolbar-container\">\r\n        "
    + this.escapeExpression(((helper = (helper = helpers.location || (depth0 != null ? depth0.location : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"location","hash":{}}) : helper)))
    + "\r\n      </div>\r\n    </div>\r\n  </div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <div class=\"csui-targetbrowse-history\">\r\n      <span class=\"csui-targetbrowse-arrow-back\">\r\n        <span class=\"icon arrow_back cs-go-back\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.backButtonTooltip || (depth0 != null ? depth0.backButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"backButtonTooltip","hash":{}}) : helper)))
    + "\" tabindex=\"0\"\r\n              aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.backButtonAria || (depth0 != null ? depth0.backButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"backButtonAria","hash":{}}) : helper)))
    + "\" data-cstabindex=\"-1\" role=\"link\"></span>\r\n      </span>\r\n  </div>\r\n  <div class=\"csui-folder-name\">\r\n    <span class=\"folder-name\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.allMembers : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  </div>\r\n\r\n  <form class=\"cs-modal-filter\">\r\n    <div class=\"binf-form-group\">\r\n      <input class=\"binf-form-control cs-filter-input\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\"\r\n             tabindex=\"0\" data-cstabindex=\"-1\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\">\r\n      <span class=\"binf-form-control-feedback cs-icon icon-formfield-clear\" role=\"button\"\r\n            aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.clearSearchButtonAria || (depth0 != null ? depth0.clearSearchButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"clearSearchButtonAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\" data-cstabindex=\"-1\"></span>\r\n      <button class=\"binf-btn csui-form-control-search\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.collapseSearch || (depth0 != null ? depth0.collapseSearch : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"collapseSearch","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.collapseSearch || (depth0 != null ? depth0.collapseSearch : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"collapseSearch","hash":{}}) : helper)))
    + "\" aria-expanded=\"true\" aria-haspopup=\"true\"\r\n              tabindex=\"0\" data-cstabindex=\"-1\">\r\n      <span class=\"form-control-search cs-icon icon-sv-search-hide\"></span>\r\n      </button>\r\n    </div>\r\n  </form>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span class=\"cs-icon icon-sv-search csui-acc-focusable\" tabindex=\"0\" data-cstabindex=\"-1\"\r\n            role=\"button\" aria-expanded=\"false\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.openSearchBar || (depth0 != null ? depth0.openSearchBar : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"openSearchBar","hash":{}}) : helper)))
    + "\"\r\n            aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.searchInButtonAria || (depth0 != null ? depth0.searchInButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"searchInButtonAria","hash":{}}) : helper)))
    + "\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.searchView : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_select.view_impl_header_header', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/node.picker/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/dialogs/node.picker/impl/nls/root/lang',{
  noSearchResultMessage: "No results found",
  PermissionDenied: "Permission denied",
  ViewDenied: 'Access denied, you do not have permission to view "{0}".',
  InsufficientContent: 'Insufficient content to open the browse dialog',
  selectButtonLabel: "Select",
  cancelButtonLabel: "Cancel",
  copyButtonLabel: 'Copy',
  moveButtonLabel: 'Move',
  clearSearchButtonAria: 'Clear Search',
  collapseSearch: 'Clear and collapse search',
  saveFilterButtonLabel: 'Save',
  placeHolderName: 'Enter name',

  itemTypeNameAria: '{0}: {1}', // like "Folder XYZ"
  disabledItemTypeNameAria: 'Disabled: {0}: {1}', // like "Disabled Folder XYZ" for screen reader

  dialogTitle: "Select an object",
  dialogTitleForContainers: "Select a Container",
  dialogTitleForDocuments: "Select a Document",
  dialogTitleForCategories: "Select a Category",

  breadcrumbAria: 'Breadcrumb in Dialog',

  serverError: 'Server request failed with error code {0}.',
  backButtonTooltip: 'Go back',
  backToFolderView: 'Go back to Folder View',
  backToSearchAria: 'Go back to Search View',
  Type: "Type",
  Name: "Name",
  Location: "Location",
  searchResults: "Search results",
  searchFoundAbout: "About {0} items",
  searchFoundZero: "No items",
  nameCannotContainColon: "Name cannot contain a colon",
  nameCannotBeEmpty: "This is a required field.",
  SelectOneItemMessage: "{0} item selected",
  SelectManyItemsMessage: "{0} items selected",
  noValue: "(no value)",
  nodePickerChoices: "Choices"
});



csui.define('csui/dialogs/members.picker/impl/select.view/impl/header/header.view',["csui/lib/underscore", "csui/lib/jquery", "csui/lib/marionette", 'csui/lib/backbone',
  "csui/behaviors/input/placeholder",
  "i18n!csui/controls/table/impl/nls/lang",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/models/member/member.model',
  'csui/models/member/membercollection',
  "hbs!csui/dialogs/members.picker/impl/select.view/impl/header/header",
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'i18n!csui/dialogs/members.picker/impl/nls/root/lang'
], function (_, $, Marionette, Backbone, PlaceholderBehavior, lang, TabableRegionBehavior,
    MemberModel, MemberChildrenCollection, template, dialogLang, memberPickerDialogLang) {

  var HeaderView = Marionette.ItemView.extend({

    template: template,
    tagName: 'div',

    templateHelpers: function () {
      return {
        title: this.options.title ||
               !!this.options && !!this.options.container && this.options.container.get('name'),
        search_icon_tooltip: _.str.sformat(lang.searchIconTooltip, this.options.columnTitle),
        search_placeholder: lang.searchByNamePlaceholder,
        search_clear_icon_tooltip: lang.searchClearIconTooltip,
        backButtonTooltip: dialogLang.backButtonTooltip || lang.backButtonTooltip,
        type: dialogLang.Type,
        name: dialogLang.Name,
        location: dialogLang.Location,
        searchView: this.options.searchView,
        searchInButtonAria: _.str.sformat(lang.searchPlaceholder, this.title),
        clearSearchButtonAria: dialogLang.clearSearchButtonAria,
        allMembers: (this.container.id || this.container.groupId) ? false : true,
        openSearchBar: memberPickerDialogLang.openSearchBar,
        closeSearchBar: memberPickerDialogLang.closeSearchBar,
        collapseSearch: dialogLang.collapseSearch,
        backButtonAria: lang.backButtonTooltip
      };
    },

    ui: {
      searchBox: '> form.cs-modal-filter',
      openSearchIcon: '> .csui-folder-name .icon-sv-search',
      headerTitle: '> .csui-folder-name',
      searchInput: '> form .cs-filter-input',
      clearer: '> form .binf-form-control-feedback',
      tabElements: '> *[tabindex]',
      closeSearchButton: '> form .csui-form-control-search',
      backButton: ".csui-targetbrowse-arrow-back"
    },

    events: {
      'click .icon-sv-search': 'searchClicked',
      'click @ui.closeSearchButton': 'searchClicked',
      'paste @ui.searchInput': 'contentPasted',
      'change @ui.searchInput': 'filterChanged',
      'click @ui.clearer': 'searchFieldClearerClicked',
      'submit @ui.searchBox': 'filterChanged',
      'keydown': 'onKeyInView'
    },

    behaviors: {
      Placeholder: {
        behaviorClass: PlaceholderBehavior
      },

      TabableRegionBehavior: {
        behaviorClass: TabableRegionBehavior
      }
    },

    constructor: function HeaderView(options) {
      this.options = options || {};
      this.container = options.container;
      this.title = options.title;
      this.headerView = this;
      Marionette.ItemView.prototype.constructor.apply(this, arguments);

      if (this.container) {
        this.listenTo(this.container, 'change:name', function (member) {
          this.title = member.get('name');
          this.render();
        });
      }
    },

    onRender: function () {
      this.ui.clearer.toggle(false);
      this.ui.searchBox.toggleClass('binf-hidden');
      this.ui.closeSearchButton.toggleClass('binf-hidden');
      this.ui.searchInput.hide();

      var self = this;
      this.ui.searchInput.keyup(function (e) {
        self.filterChanged(e);
      });
      this.$el.find('*[data-cstabindex]').on('focus', function () {
        var target = $(this);
        self.focusedElement &&
        self.focusedElement.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        target.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        self.focusedElement = target;
      });
    },

    currentlyFocusedElement: function () {
      //change the input and icons back to tabindex = 0. Tabable behavior sets all tabindex to -1, which doesn't work for
      //this scenario
      var focusables = this.$el.find('*[data-cstabindex=-1]');
      if (focusables.length) {
        focusables.prop('tabindex', 0);
      }
      if (this.focusedElement) {
        return this.focusedElement;
      }
      if (this.$el.find('.csui-folder-name.binf-hidden').length) {
        this.focusElement = this.$el.find('input');
      } else if (this.$el.find('.csui-targetbrowse-arrow-back .cs-go-back').is(':visible')) {
        this.focusElement = this.$el.find('.csui-targetbrowse-arrow-back .cs-go-back');
      }
      else {
        if (this.$el.find('.csui-folder-name .icon-sv-search').is(':visible')) {
          this.focusElement = this.$el.find('.csui-folder-name .icon-sv-search');
        }

      }
      return this.focusElement;
    },

    onLastTabElement: function (shiftTab) {
      var tabItems = this.$('[data-cstabindex=-1]'),
          lastItem = tabItems.length - 1;
      if (tabItems.length) {
        //var focusElement = shiftTab ? tabItems[0] : tabItems[lastItem];
        var focusElement,
            focusElementIndex = 0,
            lastIndex = lastItem + 1,
            change = 1;
        if(!shiftTab){
          focusElementIndex = lastItem;
          lastIndex = -1;
          change = -1;
        }
        for(var i= focusElementIndex; i!=lastIndex ; i=i+change){
          if($(tabItems[i]).is(':visible')){
            focusElementIndex = i;
            break;
          }
        }
        if(focusElementIndex >= 0 && focusElementIndex <= lastItem){
          focusElement = tabItems[focusElementIndex];
        }
        this.$('.csui-focus').removeClass('csui-focus');
        return $(focusElement).hasClass(TabableRegionBehavior.accessibilityActiveElementClass) &&
               !shiftTab;
      }

      return true;
    },

    onKeyInView: function (event) {
      var bubbleEvent = false,
          target      = $(event.target);
      switch (event.keyCode) {
          //Enter
      case 13:
        target.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        $(event.target).trigger('click');
        break;

          //escape
      case 27:
        if (!$(event.target).hasClass('.icon-sv-search')) {
          this.$el.trigger('tabNextRegion');
        }
        break;
      default:
        return true;
      }
      return bubbleEvent;
    },
    searchClicked: function (event) {
      event.preventDefault();
      event.stopPropagation();
      //Trigger action to close any binf-dropdown
      Backbone.trigger('closeToggleAction');

      this.ui.headerTitle.toggleClass('binf-hidden');
      this.ui.searchInput.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);

      this.ui.clearer.toggle(false);
      if (this.getValue().length) {
        // If the filer has just been hidden, reset the filtering value to show all items again
        this.ui.searchInput.val('');
        this.filterChanged(event);
      }
      this.ui.searchInput.toggle(200, 'linear', _.bind(function () {
        this.ui.searchInput.focus();
      }, this));

      this.ui.closeSearchButton.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.ui.closeSearchButton.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);

      this.ui.openSearchIcon.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.ui.searchBox.toggleClass('binf-hidden');
      this.ui.closeSearchButton.toggleClass('binf-hidden');

      if ($(event.target).hasClass('form-control-search')) {
        this.ui.searchInput.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        this.ui.openSearchIcon.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        this.$el.trigger('setCurrentTabFocus');
      } else {
        this.ui.searchInput.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        this.ui.openSearchIcon.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
      }
      this.trigger('changed:focus');
      this.focusElement.focus();
    },

    searchFieldClearerClicked: function (e) {
      e.preventDefault();
      e.stopPropagation();
      this.ui.clearer.removeClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.ui.clearer.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
      this.ui.searchInput.val('');
      this.filterChanged(e);
      this.ui.searchInput.focus();
      this.ui.searchInput.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
    },

    getColumn: function () {
      return this.options.column;
    },

    getValue: function () {
      var filterValue;

      filterValue = this.ui.searchInput.val();
      if (filterValue === this.ui.searchInput.attr('placeholder')) {
        filterValue = '';
      }

      return filterValue;
    },

    setValue: function (val) {
      if (val && val.length) {
        this.ui.searchInput.val(val);
        this.lastFilterValue = val;
      }
    },

    getShown: function () {
      return this.ui.searchInput.hasClass('binf-show');
    },

    setShown: function (show) {
      if (show === true && this.ui.searchInput.hasClass('binf-hidden')) {
        this.ui.searchInput.toggleClass('show binf-hidden');
      } else if (show === false && this.ui.searchInput.hasClass('binf-show')) {
        this.ui.searchInput.toggleClass('show binf-hidden');
      }
    },

    setFocus: function () {
      var textLen = this.ui.searchInput.val().length;
      this.ui.searchInput.focus();
      this.ui.searchInput[0].setSelectionRange(textLen, textLen);
    },

    contentPasted: function (event) {
      this.applyFilter();
    },

    filterChanged: function (event) {
      this.applyFilter();

      return false;
    },

    applyFilter: function () {
      var filterValue = this.getValue();
      var filterHasValue = !!filterValue.length;
      this.ui.clearer.toggle(filterHasValue);

      if (filterHasValue) {
        this.ui.clearer.addClass(TabableRegionBehavior.accessibilityFocusableClass);
      } else {
        this.ui.clearer.removeClass(TabableRegionBehavior.accessibilityFocusableClass);
      }

      if (this.lastFilterValue != filterValue) {
        this.lastFilterValue = filterValue;
        var self = this;
        if (this.filterTimeout) {
          clearTimeout(this.filterTimeout);
        }
        this.filterTimeout = setTimeout(function () {
          self.filterTimeout = undefined;
          self.trigger('change:filterValue',
              {name: self.getValue(), collection: self.options.collection});
        }, 1000);
      }
    }
  });

  return HeaderView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/select.view/impl/select.view',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div>\r\n  <div class=\"csui-mp-header cs-folder-name\"></div>\r\n</div>\r\n<div class=\"csui-mp-content\"></div>\r\n\r\n";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_select.view_impl_select.view', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/members.picker/impl/select.view/impl/select.view',[],function(){});
csui.define(
    'csui/dialogs/members.picker/impl/select.view/select.view',["module", "csui/lib/jquery", "csui/lib/underscore", 'csui/lib/backbone', "csui/lib/marionette",
      "csui/utils/log", "csui/utils/base",
      'csui/dialogs/members.picker/impl/member.list/member.list.view',
      'csui/controls/list/list.view',
      'csui/behaviors/keyboard.navigation/tabable.region.behavior',
      'csui/dialogs/members.picker/impl/select.view/impl/header/header.view',
      'hbs!csui/dialogs/members.picker/impl/select.view/impl/select.view',
      'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
      'i18n!csui/dialogs/members.picker/impl/nls/lang',
      'css!csui/dialogs/members.picker/impl/select.view/impl/select.view'
    ], function (module, $, _, Backbone, Marionette, log, base,
        MemberListView, Lview,TabableRegionBehavior, HeaderView, template, LayoutViewEventsPropagationMixin, lang) {

      var SelectView = Marionette.LayoutView.extend({

        template: template,
        templateHelpers: function () {
          return {
            backButtonTooltip: lang.backButtonTooltip,
            backButtonAria: lang.backButtonTooltip
          };
        },
        regions: {
          viewHeaderRegion: '.csui-mp-header',
          viewContentRegion: '.csui-mp-content'
        },
        ui: {
          "backButton": ".csui-targetbrowse-arrow-back"
        },

        behaviors: {
          TabableRegion: {
            behaviorClass: TabableRegionBehavior
          }
        },

        events: {
          'click @ui.backButton': 'onClickFolderBack',
          'keydown @ui.backButton': 'selectFolderBack'
        },

        constructor: function SelectView(options) {
          options || (options = {});
          _.defaults(options, {pageSize: 30});

          Marionette.LayoutView.prototype.constructor.call(this, options);

          this.rendered = false;
          this.selectedMember = null;

          this.collection = options.collection;
          this.completeCollection = options.collection;
          this.originalModels = options.collection.models;
          this.container = options.container;

          this.propagateEventsToRegions();

          this.setHeader(options);
          this.setListView(options);
          this.onWinRefresh = _.bind(this.windowRefresh, this);
          $(window).bind("resize.app", this.onWinRefresh);
        },

        windowRefresh: function () {
          //due to chrome not recognizingg parent height, dynamically set through css,
          //the select view height must be coded.
          var parentHeight = this.options.parentEl.height();
          if ((!!window.chrome || (navigator.userAgent.indexOf("Firefox") > 0)) &&
              parentHeight > 0) {
            this.$el.css('height', parentHeight + 'px');
          }
        },

        onDestroy: function () {
          this.$el.off();
          $(window).unbind("resize.app", this.onWinRefresh);
        },

        onRender: function () {
          var self        = this,
              contentList = self.$el.find('.csui-mp-content');

          this.viewHeaderRegion.show(this.headerView);
          this.viewContentRegion.show(this.listView);
          this.$el.hover(function () {
            contentList.addClass('binf-focus');
          }, function () {
            contentList.removeClass('binf-focus');
          });

          this.rendered = true;
        },

        onDomRefresh: function () {
          this.windowRefresh();
        },

        onShow: function () {
          if (!this.rendered) {
            this.render();
          }

          _.each(this.regionManager._regions, function (region) {
            if (region.currentView) {
              region.currentView.trigger('show');
            }
          });
        },

        getNumberOfSelectItems: function () {
          return this.selectedMember !== null ? 1 : 0;
        },

        setNewSelect: function (member, silent) {
          this.clearSelect();
          this._setSelection({member: member, add: true, silent: silent});
        },

        clearSelect: function () {
          !!this.listView && this.listView.clearSelect();
          this.selectedMember = null;
        },

        setListView: function (options) {
          options || (options = {});
          var args = {
            collection: this.collection,
            container: this.container,
            commandType: options.commandType,
            pageSize: options.pageSize
          };

          var listView = this.listView = new MemberListView(args);
          this.listenTo(listView, 'selection:change', this._setSelection)
              .listenTo(listView, 'browse:select',
                  _.bind(this.trigger, this, 'browse:select', this))
              .listenTo(this, "browse:complete",
                  _.bind(listView.trigger, listView, 'browse:complete'));
        },

        selectFolderBack: function (event) {
          if (event.keyCode === 13 || event.keyCode === 32) {
            event.preventDefault();
            event.stopPropagation();
            this.trigger("backbutton:click", this);
          }
        },

        onClickFolderBack: function (event) {
          event.preventDefault();
          event.stopPropagation();
          this.trigger("backbutton:click", this);
        },

        setHeader: function () {
          var title = this.container && (this.container.get('name') || this.options.displayName);
          title = (title === null) ? this.options.locationName : title;

          this.headerView = new HeaderView({
            title: title,
            container: this.container,
            searchView: this.options.searchView
          });
          this.listenTo(this.headerView, 'change:filterValue', this.applyFilter);

        },

        applyFilter: function (searchInfo) {
          //add supported types
          _.extend(searchInfo, {type: this.options.listTypes});
          if (this.collection.fetching) {
            this.filterValuePending = searchInfo;
          }
          else {
            //reset the collections start position
            var self = this;
            this.collection.setLimit(0, this.options.pageSize, false);
            this.collection.setFilter(searchInfo, false);
            this.collection.fetch({reset: true})
                .fail(function (resp) {
                  self.listView.stopBlocker();
                  self.trigger('search:failed', {resp: resp, view: self});
                });
            this.listView.reset();
          }

        },

        refresh: function () {
          var self = this;
          this.collection.fetch({reset: true})
              .fail(function () {
                self.listView.stopBlocker();
              });
        },

        stopBlocker: function () {
          this.listView.stopBlocker();
        },

        addMemberSelection: function (member) {
          this._setSelection({
            browse: true,
            add: true,
            breadCrumbSelection: true,
            member: member,
            type: 1
          });
        },

        _setSelection: function (args) {
          var id          = args.member.get('id'),
              commandType = this.options.commandType;

          this.selectedMember = null;

          if (args.add && commandType.isSelectable(args.member)) {
            this.selectedMember = args.member;
          }

          if (!args.silent) {
            this.trigger('selection:change', args, this);
          }
        }
      });

      _.extend(SelectView.prototype, LayoutViewEventsPropagationMixin);

      return SelectView;

    });


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/select.views/selectviews',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "\r\n";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_select.views_selectviews', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/members.picker/impl/select.views/select.views',['module', 'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/marionette',
  'csui/utils/log', 'csui/utils/base',
  'i18n!csui/dialogs/members.picker/impl/nls/lang',
  'csui/models/member/member.model',
  'csui/models/member/membercollection',
  'csui/dialogs/members.picker/impl/select.view/select.view',
  'csui/dialogs/modal.alert/modal.alert',
  'csui/utils/commands',
  'hbs!csui/dialogs/members.picker/impl/select.views/selectviews',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/lib/jquery.ui/js/jquery-ui'
], function (module, $, _, Marionette, log, base, lang, MemberModel, MemberChildrenCollection,
    SelectView, ModalAlert, commands, template, ViewEventsPropagationMixin) {
  'use strict';

  var SelectViews = Marionette.ItemView.extend({

    className: 'csui-select-lists',
    template: template,

    constructor: function SelectViews(options) {
      options || (options = {});
      _.defaults(options, {pageSize: 30});

      Marionette.ItemView.prototype.constructor.call(this, options);

      this.commandType = options.commandType;
      this.leftView = this.rightView = null;
      this.rootGroup = options.rootGroup;
      this.invalidMembers = [];

      this.ancestorCollection = options.ancestorCollection;

      this.connector = options.connector;
    },

    onRender: function () {
      this.setLeftOnly();

      if (this.leftView) {
        this.leftView.render();
      }

      if (this.rightView) {
        this.rightView.render();
      }
    },

    onDomRefresh: function () {
      this.leftView.triggerMethod('dom:refresh', this.leftView);
      if (this.rightView) {
        this.rightView.triggerMethod('dom:refresh', this.rightView);
      }
    },

    onShow: function () {
      this.leftView.triggerMethod('show');

      if (this.rightView) {
        this.rightView.triggerMethod('show');
      }
    },

    setParentGroupAsTarget: function (member) {
      var selectable = this.commandType.isSelectable(member);
      this.rightView && this.rightView.clearSelect();
      this.leftView && this.leftView.setNewSelect(member, true);
      return selectable;
    },

    getSelection: function () {
      var rightSelection = this.rightView ? this.rightView.selectedMember : null,
          leftSelection  = rightSelection === null ? this.leftView.selectedMember : null;

      return rightSelection !== null ? rightSelection : leftSelection;
    },

    getNumberOfSelectItems: function () {
      return this.rightView && this.rightView.getNumberOfSelectItems() > 0 ?
             this.rightView.getNumberOfSelectItems() : this.leftView.getNumberOfSelectItems();
    },

    //Public - used by breadcrumbs to get the ancestors for the latest container.
    leftNodeId: function () {
      var container = this.leftView.container;
      return container ? container.get('id') : -1;
    },

    setLeftOnly: function () {
      var left   = this._setView(this.rootGroup, 'cs-start-locations left-only', false,
          this.options),
          member = left.view.container,
          self   = this;

      left.promise
          .done(function () {
            if (member) {
              self.leftView.addMemberSelection(member);
            }
            if (self.options.targetBrowseHistory.length > 0) {
              self.showBackButton();
            } else if (self.options.targetBrowseHistory.length > 1 ||
                       (self.options.targetBrowseHistory.length === 1 &&
                        self.options.navigateFromHistory)) {
              self.showBackButton();
            }
          })
          .fail(function (resp) {
            self.forceClose(resp);
          });

      this.leftView = left.view;
      return left.promise;
    },

    forceClose: function (resp) {
      this
          ._displayAlert(resp)
          .always(this.trigger('close'));
    },

    //called during a breadcrumb change
    newLeftView: function (member, pageSize) {
      var self = this;
      this.options.pageSize = pageSize;
      return this._drillUp(member).done(function (view) {
            self.leftView = view;
            self.leftView.addMemberSelection(member);
            //trigger to update breadcrumbs
            self.trigger('changed');
            self.onDomRefresh();
          })
          .fail(function (resp) {
            self._displayAlert(resp);
          });
    },

    onSelectionChange: function (args, view) {
      var isRightView = view && this._isRightView(view),
          replaceRightView;
      if (args && !args.breadCrumbSelection) {
        if (isRightView) {
          args.add && this.leftView.clearSelect();
        } else {
          if (this.rightView) {
            args.add && this.rightView.clearSelect();
            replaceRightView = this.rightView.container.id !== args.member.id;
          }
        }
      }
      if (args.type === 1) {
        this._updateAncestorCollection(args.member, {
          isLeftView: !isRightView,
          replaceRightView: replaceRightView
        });
      }
      args.member.add = args.add;
      //trigger to let members.picker release dialog blockingView and update select button
      // enable status.
      this.trigger('change:complete', args.member);

      return true;
    },

    onBrowse: function (view, args) {
      var isRightView = this._isRightView(view),
          promise     = null;

      this.trigger('changing:selection');

      promise = isRightView ? this.selectRight(args) : this.selectLeft(args);

      promise.done(function () {
        view.trigger('browse:complete');
      }).fail(function () {
        view.clearSelect();
      });

      return promise;
    },

    selectLeft: function (args) {
      var self = this;
      return this._runSelection(args, '.cs-pane-view')
          .done(function (view) {
            if (view) {
              self.rightView = view;
              self.onDomRefresh();
            }
          });

    },

    selectRight: function (args) {
      var self        = this,
          page        = Math.floor((this.leftView.collection.skipCount || 0) /
                                   this.leftView.collection.topCount) + 1,
          pageSize    = parseInt(this.leftView.collection.topCount) * parseInt(page),
          parentId    = args.member.get("parentId"),
          parent      = this.ancestorCollection.get(parentId),
          grandParent = parent && this.ancestorCollection.get(parent.get('parentId'));

      if (this.options.targetBrowseHistory.length === 0) {
        this.options.targetBrowseHistory.push('start.location');
      }
      else {
        var memberObj = {
          "leftId": grandParent ? grandParent.get('id') : null,
          "leftName": grandParent ? grandParent.get("name") : undefined,
          "leftParent": grandParent ? grandParent.get("parentId") : undefined,
          "leftType": grandParent ? grandParent.get("type") : undefined,
          "rightId": parent ? parent.get("id") : undefined,
          "rightName": parent ? parent.get("name") : undefined,
          "rightParent": parent ? parent.get("parentId") : undefined,
          "rightType": parent ? parent.get("type") : undefined,
          "pageSize": pageSize
        };

        this.options.targetBrowseHistory.push(memberObj);
      }
      return this._runSelection(args, '.csui-panel.cs-start-locations').done(function (newView) {
        if (newView) {
          self.leftView = self.rightView;
          self.showBackButton();
          self.rightView = newView;
          self.onDomRefresh();
        }
      });
    },

    showBackButton: function () {
      if (this.leftView && this.options.targetBrowseHistory.length >= 1) {
        this.leftView.headerView.ui.backButton.parent().show();
      }
    },

    hideBackButton: function () {
      if (this.leftView && this.options.targetBrowseHistory.length < 1) {
        this.leftView.headerView.ui.backButton.parent().hide();
      }
    },

    _runSelection: function (args, shiftViewClass) {
      var member   = args.member,
          self     = this,
          deferred = $.Deferred();

      //Drill down item
      this._drillDown(member, shiftViewClass)
          .done(function (view) {
            //trigger to update breadcrumbs
            self.trigger('changed');

            //trigger to let members.picker release dialog blockingView and update
            //select button enable status.
            self.trigger('change:complete', member);
            deferred.resolve(view);
          })
          .fail(function (resp) {
            self._displayAlert(resp);
            //trigger to let members.picker release dialog blockingView and update
            //select button enable status.
            self.trigger('change:complete');
            deferred.reject();
          });

      return deferred;
    },

    // rightFlag is never set
    _drillUp: function (member, rightFlag) {
      var newView  = this._setView(member, 'csui-new-view left-only binf-hidden', 'prepend'),
          view     = newView.view,
          self     = this,
          deferred = $.Deferred();

      view.$el.addClass('zeroWidth')
          .removeClass('binf-hidden');

      view.render();
      if (!rightFlag) {
        self._removeRightView(newView.promise).done(function () {
          deferred.resolve(newView.view);
        }).fail(function (resp) {
          deferred.reject(resp);
        });
      }
      return deferred;
    },

    _drillDown: function (member, removeClass) {
      var newView      = this._setView(member, 'csui-new-view', false),
          panelPromise = null,
          view         = newView.view;

      view.render();

      if (!this.rightView) {
        panelPromise = this._addRightView(newView.promise, view);
      } else {
        panelPromise = this._replaceView(newView.promise, view, removeClass);
      }

      return panelPromise;
    },

    _showLeftOnly: function () {
      var leftView  = this.$el.find('.csui-panel.cs-start-locations'),//leftView  = this.leftView,
          rightView = this.$el.find('.csui-panel.cs-pane-view.csui-slideMidLeft'),
          self      = this,
          width     = '100%';

      rightView.hide();

      leftView.animate({width: width}, {
        duration: 200, complete: animateComplete
      });

      function animateComplete() {
        if (!!rightView) {
          var selectView = rightView[0].selectView;
          self.cancelEventsToViewsPropagation(selectView);
          selectView.destroy();   //selectView is the view object that was added to the DOM element
          rightView.remove();
          self.rightView = null;
        }
      }
    },

    _removeRightView: function (fetchPromise) {
      var newView   = this.$el.find('.csui-new-view'),
          leftView  = this.$el.find('.csui-panel.cs-start-locations'),
          rightView = this.$el.find('.cs-pane-view'),
          deferred  = $.Deferred(),
          self      = this;

      leftView.hide();
      rightView.hide();
      newView[0].className = 'csui-panel cs-start-locations left-only';

      fetchPromise.done(function () {
        self._finishRightRemove(newView, leftView, rightView);
        deferred.resolve();
      }).fail(function (resp) {
        self._removeNewView(newView, leftView, rightView);
        deferred.reject(resp);
      });

      return deferred;
    },

    _removeNewView: function (newView, leftView, rightView) {
      newView || ( newView = this.$el.find('.csui-new-view'));
      var selectView = newView[0].selectView;
      this.cancelEventsToViewsPropagation(selectView);
      selectView.destroy();
      newView.remove();
      leftView && leftView.show();
      rightView && rightView.show();
    },

    _finishRightRemove: function (newView, leftView, rightView) {
      var selectView;
      if (rightView.length > 0) {
        selectView = rightView[0].selectView;
        this.cancelEventsToViewsPropagation(selectView);
        selectView.destroy();   //selectView is the view object that was added to the DOM element
        rightView.remove();
        this.rightView = null;
      }

      selectView = leftView[0].selectView;
      this.cancelEventsToViewsPropagation(selectView);
      selectView.destroy();
      leftView.remove();
      this.leftView = null;

      return true;
    },

    _addRightView: function (fetchPromise, selectView) {
      var leftView = this.$el.find('.csui-panel.cs-start-locations'),
          newView  = this.$el.find('.csui-new-view'),
          deferred = $.Deferred(),
          self     = this;

      leftView[0].className = 'csui-panel cs-start-locations';
      newView[0].className = 'csui-panel cs-pane-view csui-slideMidLeft';

      fetchPromise.done(function () {
        deferred.resolve(selectView);
      }).fail(function (resp) {
        self._removeNewView(newView);
        leftView.animate({width: '100%'}, 200);
        self.leftView.clearSelect();
        self.leftView.refresh();
        deferred.reject(resp);
      });

      return deferred;
    },

    _replaceView: function (fetchPromise, selectView, removeClass) {
      var view      = this.$el.find(removeClass),
          newView   = $('.csui-new-view'),
          rightView = $('.cs-pane-view'),
          deferred  = $.Deferred(),
          self      = this;

      view.hide();
      switch (removeClass) {
      case '.csui-panel.cs-start-locations':
        rightView[0].className = 'csui-panel cs-start-locations csui-slideLeft';
        newView[0].className = 'csui-panel cs-pane-view csui-slideMidLeft';
        break;
      case '.cs-pane-view':
        newView[0].className = 'csui-panel cs-pane-view csui-slideMidLeft';
      }
      fetchPromise.done(function () {
        self._removeView(view);
        deferred.resolve(selectView);
      }).fail(function (resp) {
        self._reverseRemoveView(newView, removeClass, rightView);
        if (removeClass === '.csui-panel.cs-start-locations') {
          view.show();
        }
        deferred.reject(resp);
      });

      return deferred;
    },

    _reverseRemoveView: function (domView, className, rightView) {
      this._removeNewView(domView);
      switch (className) {
      case '.csui-panel.cs-start-locations':
        rightView[0].className = 'csui-panel cs-pane-view csui-slideRight';
        this.rightView.refresh();
        break;
      case '.cs-pane-view':
        this._removeView(rightView);
        this.leftView.$el[0].className = 'csui-panel cs-start-locations left-only';
        this.leftView.clearSelect();
        this.leftView.refresh();
      }
      return true;
    },

    _removeView: function (domView) {
      var selectView = domView[0].selectView;
      this.cancelEventsToViewsPropagation(selectView);
      selectView.destroy();   //selectView is the view object that was added to the DOM element
      domView.remove();

      return true;
    },

    //Member - member whose contents are to be displayed in a view
    //callBack - call back function for any item clicked in the member view
    //className - class name to give the new ('csui-new-view', 'cs-start-locations', 'cs-pane-view')
    //appendAction - jquery action to either 'append' or 'prepend' the new view the list of views.
    //Returns: View and fetch promise.
    _setView: function (member, className, appendAction, viewOptions) {
      viewOptions || (viewOptions = this._getViewOptions(member, this.connector));
      _.defaults(viewOptions, this.options, {invalidMembers: this.invalidMembers});
      appendAction || (appendAction = 'append');

      var view    = this._newView(viewOptions, className),
          promise = this._fetchView(view);

      //attach the view to its div so that we know which left/right view we are dealing with
      //when sliding in/out panels.
      view.el.selectView = view;
      this.$el[appendAction](view.el);

      return {view: view, promise: promise};
    },

    _fetchView: function (view) {
      return this._fetchCollection(view);
    },

    _fetchCollection: function (view) {
      view.collection.setOrder(this.options.orderBy, false);
      // view.collection.setFilter({type: this.listTypes}, false);
      view.collection.setLimit(0, this.options.pageSize, false);
      return view.collection.fetch({reset: false, merge: false, remove: false});
    },

    _newView: function (args, className) {
      var options = _.extend({
        // listTypes: this.listTypes,
        className: className + ' csui-panel',
        parentEl: this.$el
      }, args);

      var selectView = new SelectView(options);
      this.propagateEventsToViews(selectView);
      this.listenTo(selectView, 'selection:change', this.onSelectionChange);
      this.listenTo(selectView, 'backbutton:click', this._onClickBackButton);
      this.listenTo(selectView, 'browse:select', _.bind(this.onBrowse, this));
      return selectView;
    },

    _onClickBackButton: function () {
      var self = this;
      var lastVisited = this.options.targetBrowseHistory.length > 0 ?
                        this.options.targetBrowseHistory.pop() : undefined;
      this.options.navigateFromHistory = this.options.targetBrowseHistory.length === 1;

      if (!!lastVisited.leftId) {
        var leftMember  = new MemberModel({
              id: lastVisited.leftId,
              name: lastVisited.leftName,
            }, {connector: this.connector}),
            rightMember = new MemberModel({
              id: lastVisited.rightId,
              name: lastVisited.rightName,
            }, {connector: this.connector});
        this.newLeftView(leftMember, lastVisited.pageSize).done(function () {
          self.setParentGroupAsTarget(leftMember);
          self.trigger('change:complete');

          if (self.options.targetBrowseHistory.length > 0 && rightMember && rightMember.get('id')) {
            if (self.$el.find('.cs-left-item-' + rightMember.get('id')).length > 0) {
              self.$el.find('.cs-left-item-' + rightMember.get('id')).trigger("click");
            }
          }
          self.showBackButton();
        });
      } else if (lastVisited === "start.location") {
        this.trigger('change:location', this.options.startLocation);
      }
      else {
        self.hideBackButton();
        var lefMember = new MemberModel({id: this.options.container.groupId},
            {connector: this.connector});
        var nodeId = this.options.container.groupId;
        this.newLeftView(lefMember, lastVisited.pageSize).done(function () {
          self.setParentGroupAsTarget(lefMember);
          var previousIndex = self.ancestorCollection.findByIndex(lastVisited.rightId);
          self.ancestorCollection.findByIndex(lastVisited.rightId);
          self.ancestorCollection.reset(self.ancestorCollection.slice(0, previousIndex));
        });
      }
    },

    _isRightView: function (view) {
      var viewClasses = view.$el[0].className.split(' ');
      return _.contains(viewClasses, 'cs-pane-view');
    },

    _addNewPanel: function (className, action) {
      var div = document.createElement('div');
      div.className = className;
      this.$el[action](div);

      return div;
    },

    _getViewOptions: function (member, connector) {
      var memberModel = new MemberModel({
            id: member.get("id"),
            name: member.get("name"),
            parentId: member.get("parentId"),
            nodeId: member.get("nodeId"),
            categoryId: member.get("categoryId"),
            groupId: member.get("groupId")
          },
          {connector: connector}),
          collection  = new MemberChildrenCollection(undefined, {
            member: memberModel,
            autofetch: true,
            orderBy: this.options.orderBy,
            // TODO:  This will not be enough for the consumer.  How to work
            // around the skinflint in the REST API?
            //expand: ['member'],
            commands: commands.getAllSignatures(),
            connector: this.connector,
            type: this.options.startLocation === "all.groups" ? 1 : null
          });

      return {container: memberModel, collection: collection};
    },

    _displayAlert: function (resp) {
      var msg = _.str.sformat(lang.serverError, 'unknown');
      if (resp) {
        if (resp instanceof SelectView) {
          msg = _.str.sformat(lang.ViewDenied, resp.member.get('name'));
        } else {
          if (resp.responseJSON) {
            msg = resp.responseJSON.error;
          }
        }
      }
      return ModalAlert.showInformation(msg);
    },

    _updateAncestorCollection: function (member, options) {
      var previousIndex = this.ancestorCollection.findByIndex(member.id);
      if (previousIndex >= 0) {
        this.ancestorCollection.reset(this.ancestorCollection.slice(0, previousIndex + 1));
      } else {
        if (options.isLeftView) {
          if (options.replaceRightView) {
            this.ancestorCollection.pop();
          }
        }
        this.ancestorCollection.add(member.clone());
      }
    }

  });

  _.extend(SelectViews.prototype, ViewEventsPropagationMixin);

  return SelectViews;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/selectedMembers/impl/selectedMember',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-selected-member\" id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n  <div class=\"member-picture binf-pull-left\">\r\n    <span class=\"csui-icon-paceholder csui-icon image_user_placeholder\">"
    + this.escapeExpression(((helper = (helper = helpers.initials || (depth0 != null ? depth0.initials : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"initials","hash":{}}) : helper)))
    + "</span>\r\n    <img class=\"csui-icon-user csui-icon binf-img-circle binf-hidden\" alt=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\"\r\n         src=\""
    + this.escapeExpression(((helper = (helper = helpers.userImgSrc || (depth0 != null ? depth0.userImgSrc : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"userImgSrc","hash":{}}) : helper)))
    + "\">\r\n  </div>\r\n  <div class=\"member-info binf-pull-left\">\r\n    <span class=\"name binf-pull-left\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n    <span class=\"department binf-pull-left\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.department || (depth0 != null ? depth0.department : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"department","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.department || (depth0 != null ? depth0.department : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"department","hash":{}}) : helper)))
    + "</span>\r\n\r\n  </div>\r\n  <button type=\"button\" class=\"close notification_error\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.removeSelectedUserAria || (depth0 != null ? depth0.removeSelectedUserAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"removeSelectedUserAria","hash":{}}) : helper)))
    + "\"\r\n          title=\""
    + this.escapeExpression(((helper = (helper = helpers.removeSelectedUser || (depth0 != null ? depth0.removeSelectedUser : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"removeSelectedUser","hash":{}}) : helper)))
    + "\"></button>\r\n</div>\r\n \r\n";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_selectedMembers_impl_selectedMember', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/members.picker/impl/selectedMembers/selectedMember',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/utils/url',
  'csui/utils/user.avatar.color',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/dialogs/members.picker/impl/selectedMembers/impl/selectedMember',
  'i18n!csui/dialogs/members.picker/impl/nls/lang'
], function (_, $, Marionette, base, Url, UserAvatarColor, TabableRegion, template, lang) {

  var SelectedMemberView = Marionette.ItemView.extend({
    template: template,
    tagName: 'div',
    className: 'csui-userpicker-item',
    ui: {
      closeButton: '.close',
      personalizedImage: '.csui-icon-user',
      defaultImage: '.csui-icon-paceholder'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    events: {
      'click @ui.closeButton': 'onRemoveButtonClicked'
    },

    currentlyFocusedElement: function () {
      return this.ui.closeButton;
    },

    templateHelpers: function () {
      return {
        'name': base.formatMemberName(this.model),
        'department': this.model.get('group_id') && this.model.get('group_id').name,
        'id': this.model.get('id'),
        'initials': this.model.get('initials'),
        'userImgSrc': "data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=",
        'removeSelectedUser': lang.removeSelectedUser,
        'removeSelectedUserAria': _.str.sformat(lang.removeSelectedUserAria,
            this.model.get('name_formatted'))
      };
    },

    constructor: function SelectedMemberView(options) {
      options || (options = {});
      options.disabledMessage || (options.disabledMessage = '');
      // apply properties to parent
      Marionette.ItemView.prototype.constructor.call(this, options);
      this.listenTo(this, 'render', this._assignUserColor);
    },

    onRender: function () {
      if (!this.options.lightWeight) {
        // render profile image
        this._displayProfileImage();
      }
    },

    onDestroy: function () {
      this._releasePhotoUrl();
    },

    onRemoveButtonClicked: function (event) {
      event.stopPropagation();
      event.preventDefault();
      this._parent.trigger('remove:selectItem', this.model);
    },

    _displayProfileImage: function () {
      var photoUrl = this._getUserPhotoUrl();
      // esoc-userprofile-img-{userid} - the common class for all profile pictures of given userid
      this.ui.personalizedImage.addClass("esoc-userprofile-img-" + this.model.get('id'));
      if (photoUrl) {
        var getPhotoOptions = this.options.model.connector.extendAjaxOptions({
          url: photoUrl,
          dataType: 'binary'
        });
        this._releasePhotoUrl();
        $.ajax(getPhotoOptions)
            .always(_.bind(function (response, statusText, jqxhr) {
              if (jqxhr.status === 200) {
                this._showPersonalizedImage(response);
              } else {
                this._showDefaultImage();
              }
            }, this));
      } else {
        this._showDefaultImage();
      }
    },

    _getUserPhotoUrl: function () {
      var connection = (this.options.model && this.options.model.connector.connection) ||
                       (this.options.connector && this.options.connector.connection),
          cgiUrl     = new Url(connection.url).getCgiScript(),
          photoPath  = this.model.get('photo_url');
      // If the URL does not contain the cache-busting parameter derived from
      // the picture's latest change, there was a problem retrieving it.  It
      // does not make sense to try it once more from the client side, waste
      // time and server resources and litter the log by 404 errors.
      if (photoPath && photoPath.indexOf('?') > 0) {
        return Url.combine(cgiUrl, photoPath);
      }
    },

    _showPersonalizedImage: function (imageContent) {
      this._releasePhotoUrl();
      this._photoUrl = URL.createObjectURL(imageContent);
      this.ui.personalizedImage.attr("src", this._photoUrl);
      this.ui.defaultImage.addClass('binf-hidden');
      this.ui.personalizedImage.removeClass('binf-hidden');
    },

    _showDefaultImage: function (imageContent) {
      this._releasePhotoUrl();
      this.ui.personalizedImage.addClass('binf-hidden');
      this.ui.defaultImage.removeClass('binf-hidden');
    },

    _releasePhotoUrl: function () {
      if (this._photoUrl) {
        URL.revokeObjectURL(this._photoUrl);
        this._photoUrl = undefined;
      }
    },

    _assignUserColor: function () {
      var userbackgroundcolor = UserAvatarColor.getUserAvatarColor(this.model.attributes);
      this.ui.defaultImage.css("background", userbackgroundcolor);
    }

  });

  return SelectedMemberView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/selectedMembers/impl/selectedMemberList',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-selected-member-list\"></div>";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_selectedMembers_impl_selectedMemberList', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/members.picker/impl/selectedMembers/impl/selectedMember',[],function(){});
csui.define('csui/dialogs/members.picker/impl/selectedMembers/selectedMemberList',["csui/lib/jquery", "csui/lib/underscore", 'csui/lib/backbone', "csui/lib/marionette",
  'csui/dialogs/members.picker/impl/selectedMembers/selectedMember',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'hbs!csui/dialogs/members.picker/impl/selectedMembers/impl/selectedMemberList',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'css!csui/dialogs/members.picker/impl/selectedMembers/impl/selectedMember'
], function ($, _, Backbone, Marionette,
    MemberView, PerfectScrollingBehavior, template, LayoutViewEventsPropagationMixin) {

  var SelectedMemberList = Marionette.CollectionView.extend({
    template: template,
    childView: MemberView,
    childViewContainer: '.csui-selected-member-list',
    childViewOptions: {
      collection: this.collection
    },

    ui: {
      memberListContainer: '.csui-selected-member-list'
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        suppressScrollX: true,
        // like bottom padding of container, otherwise scrollbar is shown always
        scrollYMarginOffset: 15
      }
    },

    constructor: function SelectedMemberList(options) {
      options || (options = {});
      this.collection = options.collection || new Backbone.Collection();

      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
      this.listenTo(this, 'show:selectItem', _.bind(function (selectedMember) {
        this.collection.add(selectedMember);
      }, this));
    },

    onRender: function () {
      this.listenTo(this, 'remove:selectItem', _.bind(function (selectedMember) {
        this.collection.remove(selectedMember);
      }, this));
    }
  });
  _.extend(SelectedMemberList.prototype, LayoutViewEventsPropagationMixin);
  return SelectedMemberList;
});
csui.define('csui/models/memberancestorcollection',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone'
], function (module, _, $, Backbone) {
  'use strict';

  var MemberAncestorCollection = Backbone.Collection.extend({

    constructor: function MemberAncestorCollection(model, options, context) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
      this.context = context;
    },

    clone: function () {
      return new this.constructor(this.attributes, {
        connector: this.connector
      });
    },

    isFetchable: function () {
      return false;
    },

    add: function( models, options ) {
      Backbone.Collection.prototype.add.apply(this, arguments); // (this, models, options) doesn't work
      this.trigger('sync', this);
    },

    findByIndex: function(id){
      for (var i = 0; i < this.models.length; i++) {
        if( this.models[i].id === id ) {
          return i;
        }
      }
      return -1;
    }

  });

  return MemberAncestorCollection;

});



/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/members.picker',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div id=\"csui-mp-selected-member-list-container\"\r\n     class=\"csui-mp-selected-member-list-container\"></div>\r\n<div id=\"csui-mp-breadcrumbs\" class=\"cs-breadcrumb\">\r\n  <div role=\"navigation\" class=\"breadcrumb-inner\"></div>\r\n  <div class=\"searchheader-inner\"></div>\r\n</div>\r\n<div id=\"csui-mp-selectviews\"></div>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_members.picker', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/members.picker/impl/members.picker.view',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/marionette",
  "csui/utils/log", "csui/utils/base",
  "csui/models/member/member.model",
  "csui/dialogs/members.picker/impl/select.views/select.views",
  "csui/dialogs/members.picker/impl/selectedMembers/selectedMemberList",
  "csui/controls/breadcrumbs/breadcrumbs.view",
  "csui/models/memberancestorcollection",
  "hbs!csui/dialogs/members.picker/impl/members.picker",
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin'
], function (module, $, _, Marionette, log, base, MemberModel, SelectViews, selectedMemberList,
    BreadcrumbsView, MemberAncestorCollection, template, LayoutViewEventsPropagationMixin) {

  var MemberPickerView = Marionette.LayoutView.extend({

    template: template,

    regions: {
      breadcrumbRegion: '#csui-mp-breadcrumbs > .breadcrumb-inner',
      searchHeaderRegion: '#csui-mp-breadcrumbs > div.searchheader-inner',
      selectViewRegion: '#csui-mp-selectviews',
      selectedMemberListRegion: '#csui-mp-selected-member-list-container'
    },

    ui: {
      breadcrumb: '#csui-mp-breadcrumbs',
      breadcrumbContent: '.breadcrumb-inner',
      selectViews: '#csui-mp-selectviews'
    },

    constructor: function MemberPickerView(options) {
      options || (options = {});

      Marionette.LayoutView.prototype.constructor.call(this, options);

      this.propagateEventsToRegions();
      this.rootGroup = options.container;
      this.ancestorCollection = new MemberAncestorCollection(this.rootGroup.clone(), options,
          options.context);
      options.rootGroup = this.rootGroup;
      options.ancestorCollection = this.ancestorCollection;

      this.setBreadcrumbs(options);
      //Set left and right panel collection. Keep in mind that Enterprise has no parent group, so
      //the left parent will contain the current table member content, and the right will be blank.
      this.setViews(options);

      this.onWinRefresh = _.bind(this.windowRefresh, this);
      $(window).bind("resize.app", this.onWinRefresh);
     },

    windowRefresh: function () {
      //due to chrome not recognizingg parent height, dynamically set through css, the select view height must be coded.
      var breadCrumb       = $('.cs-breadcrumb'),
          breadCrumbHeight = breadCrumb.is(':visible') ? breadCrumb.height() : 0,
          viewHeight       = this.$el.height() - breadCrumbHeight;
      if (!!window.chrome && viewHeight > 0) {
        //this.selectViews.$el.css('height', viewHeight + 'px');
      }
      this.selectViews.triggerMethod('dom:refresh', this.selectViews);
    },

    onDestroy: function () {
      $(window).unbind("resize.app", this.onWinRefresh);
    },

    onRender: function () {

      if (this.options.searchView) {
        this.searchHeaderRegion.show(this.searchHeaderView);
      }
      if (this.breadcrumbs) {
        this.breadcrumbRegion.show(this.breadcrumbs);
      }
      this.selectViews.options.navigateFromHistory = this.options.navigateFromHistory;
      this.selectViewRegion.show(this.selectViews);
     this.selectedMemberListRegion.show(this.selectedMemberList);
    },

    onDomRefresh: function () {
      this.windowRefresh();
    },

    onShow: function () {
      _.each(this.regionManager.regions, function (region) {
        if (region.currentView) {
          region.currentView.trigger('show');
        }
      });

      //If the container provided by startLocation is null, then hide
      //breadcrumbs
      if (this.options.adduserorgroup && this.ancestorCollection.length === 1) {
        this.ui.breadcrumb.hide();
        this.ui.selectViews.addClass('csui-full-height');
      }
    },

    setViews: function (options) {
      var views = this.selectViews = new SelectViews(options);
      this.selectedMemberList = new selectedMemberList();
      this.listenTo(views, 'changed', this.updateBreadcrumbs);
      this.listenTo(views, 'change:location', _.bind(this.trigger, this, 'change:location'));
      this.listenTo(views, 'change:complete', _.bind(this.trigger, this, 'change:complete'));
      this.listenTo(views, 'close', this.close);
      this.listenTo(this.selectedMemberList, 'add:child remove:child', this.onMemberListChange);
    },

    onMemberListChange: function () {
      this.adjustSelectViews();
      this.trigger("update:button", this.selectedMemberList.collection);
    },

    adjustSelectViews: function () {
      var len            = this.selectedMemberList.collection.length < 3 ?
                           this.selectedMemberList.collection.length : 3,
          adjust = len ? len * this.selectedMemberList.$el.find('.csui-userpicker-item').height() :
                   0,
          adjustedHeight = adjust ? "calc(" + 100 + '% - ' + adjust + "px)" : "100%";
      this.selectViews.$el.find('.list-content').css({
        'height': adjustedHeight
      });
    },

    getSelection: function () {
      return this.selectViews.getSelection();
    },

    getNumberOfSelectItems: function () {
      return this.selectViews.getNumberOfSelectItems();
    },

    close: function () {
      this.destroy();
      this.trigger('close');
    },

    updateBreadcrumbs: function () {
      if (this.options.adduserorgroup && this.ancestorCollection.length === 1) {
        this.ui.breadcrumb.hide();
        this.ui.selectViews.addClass('csui-full-height');
      }
      else {
        this.ui.breadcrumb.show();
        this.ui.breadcrumbContent.show();
        this.ui.selectViews.removeClass('csui-full-height');

      }
      this.windowRefresh();
      this.adjustSelectViews();
      return true;
    },

    setBreadcrumbs: function (options) {
      this.breadcrumbs = new BreadcrumbsView({
        node: options.rootGroup, // breadcrumb view works with node
        collection: options.ancestorCollection
        // TODO: Use {fetchOnCollectionUpdate: false} to prevent
        // the control from an extra fetching of the collection.
      });

      this.setBreadcrumbEvents();

      return true;
    },

    setBreadcrumbEvents: function () {
      this.listenTo(this.breadcrumbs, 'before:defaultAction', function (args) {
        var selectViews = this.selectViews,
            self        = this;
        selectViews.newLeftView(args.node).done(function (view) { // breadcrumb works with node!
          selectViews.setParentGroupAsTarget(view.container);
          self.trigger('change:complete', view.container);
        });
      });
    }

  });

  _.extend(MemberPickerView.prototype, LayoutViewEventsPropagationMixin);

  return MemberPickerView;

});

csui.define('csui/models/permission/nodepermission.model',[
  'module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/uploadable/uploadable.mixin'
], function (module, _, $, Backbone, Url, ConnectableMixin, UploadableMixin) {
  'use strict';

  var config = _.extend({
    idAttribute: null
  }, module.config());

  var NodePermissionModel = Backbone.Model.extend({
    idAttribute: config.idAttribute,

    defaults: {
      "addEmptyAttribute": true
    },

    constructor: function NodePermissionModel(attributes, options) {
      attributes || (attributes = {});
      options || (options = {});

      Backbone.Model.prototype.constructor.call(this, attributes, options);

      this.options = _.pick(options, ['connector']);
      this.makeConnectable(options)
          .makeUploadable(options);
    },

    isNew: function () {
      return !this.get('type') || !(this.has('right_id') || this.get('type') === 'public');
    },

    urlBase: function () {
      var type              = this.get('type'),
          right_id          = this.get('right_id'),
          nodeId            = this.nodeId,
          apply_to          = this.apply_to,
          include_sub_types = this.include_sub_types,
          queryString       = "",
          url               = this.options.connector.connection.url;
      if (!_.isNumber(nodeId) || nodeId > 0) {
        // Add an existing node by VERB /nodes/:id
        url = Url.combine(url, 'nodes', nodeId, 'permissions');
        if (apply_to) {
          queryString = Url.combineQueryString(queryString, {apply_to: apply_to});
        }
        if (include_sub_types) {
          _.each(include_sub_types, function (subtype) {
            queryString = Url.combineQueryString(queryString, {include_sub_types: subtype});
          });
        }

        queryString = queryString.length > 0 ? "?" + queryString : queryString;
        if (!type) {
          // Create a new permission model by POST
          url = Url.combine(url, 'custom' + queryString);
        } else if (type !== 'custom') {
          //Access an existing permission model by VERB /:type where type is public/owner/group
          url = Url.combine(url, type + queryString);
        } else if (!_.isNumber(right_id) || right_id > 0) {
          //Access an existing permission model by VERB /custom/:right_id
          url = Url.combine(url, type, right_id + queryString);
        } else {
          throw new Error('Unsupported permission type or user id');
        }
      } else {
        throw new Error('Unsupported id value');
      }
      return url;
    },

    url: function () {
      var url   = this.urlBase(),
          query = null;
      url = url.replace("/v1", "/v2");
      return query ? url + '?' + query : url;
    },

    parse: function(response, options) {
      var addItemsOptionIndex = response.permissions ? response.permissions.indexOf('add_items') : -1;
      if (this.collection && !this.collection.isContainer && addItemsOptionIndex !== -1) {
        response.permissions.splice(addItemsOptionIndex, 1);
      }
      return response;
    },

    getPermissionLevel: function () {
      return NodePermissionModel.getPermissionLevel(this.get("permissions"), this.collection.isContainer);
    }
  }, {
    getPermissionLevel: getPermissionLevel,
    getReadPermissions: getReadPermissions,
    getWritePermissions: getWritePermissions,
    getFullControlPermissions: getFullControlPermissions,
    getPermissionsByLevelExceptCustom: getPermissionsByLevelExceptCustom
  });

  function getPermissionLevel(permissions, isContainer) {
    var value = NodePermissionModel.PERMISSION_LEVEL_NONE;
    if (permissions && permissions.length > 0) {
      if (permissions.indexOf("edit_permissions") >= 0 &&
          permissions.length === (isContainer ? 10 : 9)) {
        value = NodePermissionModel.PERMISSION_LEVEL_FULL_CONTROL;
      } else if (permissions.indexOf("edit_permissions") < 0 &&
                 permissions.indexOf("delete") >= 0 &&
                 permissions.length === (isContainer ? 9 : 8)) {
        value = NodePermissionModel.PERMISSION_LEVEL_WRITE;
      } else if (permissions.indexOf("see_contents") >= 0 &&
                 permissions.length === 2) {
        value = NodePermissionModel.PERMISSION_LEVEL_READ;
      } else {
        value = NodePermissionModel.PERMISSION_LEVEL_CUSTOM;
      }
    }
    return value;
  }

  function getReadPermissions() {
    return ["see", "see_contents"];
  }

  function getWritePermissions(isContainer) {
    var permissions = ["see", "see_contents", "modify", "edit_attributes", "add_items", "reserve",
      "add_major_version", "delete_versions", "delete"];
      if (!isContainer) {
        permissions.splice(permissions.indexOf('add_items'), 1);
      }
      return permissions;
  }

  function getFullControlPermissions(isContainer) {
    var permissions = ["see", "see_contents", "modify", "edit_attributes", "add_items", "reserve",
      "add_major_version", "delete_versions", "delete", "edit_permissions"]; 
      if (!isContainer) {
        permissions.splice(permissions.indexOf('add_items'), 1);
      }
      return permissions;
  }

  function getPermissionsByLevelExceptCustom(level, isContainer) {
    var permissions = null;
    switch (level) {
    case NodePermissionModel.PERMISSION_LEVEL_NONE:
      permissions = [];
      break;
    case NodePermissionModel.PERMISSION_LEVEL_READ:
      permissions = getReadPermissions();
      break;
    case NodePermissionModel.PERMISSION_LEVEL_WRITE:
      permissions = getWritePermissions(isContainer);
      break;
    case NodePermissionModel.PERMISSION_LEVEL_FULL_CONTROL:
      permissions = getFullControlPermissions(isContainer);
      break;
    }
    return permissions;
  }

  NodePermissionModel.prototype.PERMISSION_LEVEL_NONE = NodePermissionModel.PERMISSION_LEVEL_NONE = 0;
  NodePermissionModel.prototype.PERMISSION_LEVEL_READ = NodePermissionModel.PERMISSION_LEVEL_READ = 1;
  NodePermissionModel.prototype.PERMISSION_LEVEL_WRITE = NodePermissionModel.PERMISSION_LEVEL_WRITE = 2;
  NodePermissionModel.prototype.PERMISSION_LEVEL_FULL_CONTROL = NodePermissionModel.PERMISSION_LEVEL_FULL_CONTROL = 3;
  NodePermissionModel.prototype.PERMISSION_LEVEL_CUSTOM = NodePermissionModel.PERMISSION_LEVEL_CUSTOM = 4;

  NodePermissionModel.prototype.getReadPermissions = NodePermissionModel.getReadPermissions;
  NodePermissionModel.prototype.getWritePermissions = NodePermissionModel.getWritePermissions;
  NodePermissionModel.prototype.getFullControlPermissions = NodePermissionModel.getFullControlPermissions;
  NodePermissionModel.prototype.getPermissionsByLevelExceptCustom = NodePermissionModel.getPermissionsByLevelExceptCustom;

  ConnectableMixin.mixin(NodePermissionModel.prototype);
  UploadableMixin.mixin(NodePermissionModel.prototype);

  return NodePermissionModel;
});

// Provides a list of starting locations for the node picker
csui.define('csui/dialogs/members.picker/start.locations/start.location.collection',['require', 'module', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone'
], function (require, module, _, $, Backbone) {
  'use strict';

  var config = module.config(),
      startLocations = config.startLocations || [],
      masks = config.masks || {};

  // Support either array of module IDs or a map with keys pointing
  // to arrays of module IDs; the latter can be used for decentralized
  // configuration (multiple calls to require.config, which merge maps,
  // but not arrays)
  if (!_.isArray(startLocations)) {
    startLocations = Array.prototype.concat.apply([], _.values(startLocations));
  }

  masks = _.reduce(_.values(masks), function (result, mask) {
    return {
      blacklist: result.blacklist.concat(mask.blacklist || []),
      whitelist: result.whitelist.concat(mask.whitelist || [])
    };
  }, {
    blacklist: [],
    whitelist: []
  });
  masks = {
    blacklist: _.unique(masks.blacklist),
    whitelist: _.unique(masks.whitelist)
  };

  function normalizeLocationName(location) {
    var lastSlash = location.lastIndexOf('/');
    // Enable start location names without the module path
    // for the core modules from historical reasons
    return lastSlash >= 0 ? location :
            'csui/dialogs/members.picker/start.locations/' +
            location;
  }

  function filterLocationByMask(location) {
    return !_.contains(masks.blacklist, location) &&
           (!masks.whitelist.length ||
            _.contains(masks.whitelist, location));
  }

  startLocations = _.chain(startLocations)
                    .map(normalizeLocationName)
                    .filter(filterLocationByMask)
                    .unique()
                    .value();

  var StartLocationModel = Backbone.Model.extend({
    defaults: {
      id: null,
      name: null,
      icon: null,
      invalid: false,
      factory: null,
      unselectable: true
    },

    constructor: function StartLocationModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);
    },

    sync: function (method, collection, options) {
      if (method !== 'read') {
        throw new Error('Only fetching the widget is supported.');
      }
      var self = this;
      options || (options = {});
      return this._resolveFactory(options)
          .then(function () {
            var factory = self.get('factory');
            return factory.updateLocationModel(self);
          })
          .then(function () {
            var response = self.toJSON();
            options.success && options.success(response, options);
            self.trigger('sync', self, response, options);
          }, function () {
            var error = self.get('error');
            options.error && options.error(error, options);
            self.trigger('error', self, error, options);
            return $.Deferred().reject(error);
          });
    },

    _resolveFactory: function (options) {
      var self = this,
          deferred = $.Deferred(),
          factoryData = this.getFactoryData(),
          factoryPath = this.getFactoryModulePath(factoryData);
      require([factoryPath],
          function (Factory) {
            self.set('factory', new Factory(options));
            deferred.resolve();
          }, function (error) {
            self.set('error', error);
            if (options.ignoreErrors) {
              deferred.resolve();
            } else {
              deferred.reject(error);
            }
          });
      return deferred.promise();
    },

    getFactoryData: function () {
      var name = this.get('id'),
          lastSlash = name.lastIndexOf('/'),
          path;
      // Enable start location names without the module path for the core modules
      if (lastSlash < 0) {
        path = 'csui/dialogs/members.picker/start.locations/' + name;
      } else {
        path = name;
        name = name.substring(lastSlash + 1);
      }
      return {
        name: name,
        path: path
      };
    },

    getFactoryModulePath: function (moduleData) {
      return moduleData.path + '/' + moduleData.name + '.factory';
    }
  });

  var StartLocationCollection = Backbone.Collection.extend({
    model: StartLocationModel,

    constructor: function StartLocationCollection(options) {
      options || (options = {});
      var locations = options.startLocations;
      if (locations) {
        locations = _.chain(locations)
                     .concat(['current.group'])
                     .map(normalizeLocationName)
                     .filter(filterLocationByMask)
                     .unique()
                     .value();
      } else {
        locations = startLocations;
      }
      var models = _.map(locations,
          function (id) {
            return {id: id};
          });
      Backbone.Collection.prototype.constructor.call(this, models, options);
    },

    sync: function (method, collection, options) {
      if (method !== 'read') {
        throw new Error('Only fetching the start locations is supported.');
      }
      var self = this;
      options || (options = {});
      return this._resolveFactories(options)
          .then(function () {
            if (options.removeInvalid !== false) {
              var invalidModels = self.where({invalid: true});
              self.remove(invalidModels);
            }
            var response = self.toJSON();
            options.success && options.success(response, options);
            self.trigger('sync', self, response, options);
          });
    },

    _resolveFactories: function (options) {
      var resolvableModels = this.filter(function (model) {
            // A resolvable factory must have an ID and it was already resolved
            // neither with a success nor with a failure
            return model.has('id') && !(model.has('factory') || model.has('error'));
          }),
          modelOptions = _.defaults({ignoreErrors: true},
              _.omit(options, 'success', 'error')),
          promises = _.invoke(resolvableModels, 'fetch', modelOptions);
      return $.when.apply($, promises);
    }
  });

  return StartLocationCollection;
});

csui.define('csui/dialogs/members.picker/impl/command.type',['module',
  'csui/lib/underscore',
  'i18n!csui/dialogs/members.picker/impl/nls/lang'
], function (module, _, lang) {

  var config = module.config();

  var CommandTypes = function (options) {
    var member = options.initialContainer;
    this.unselectableMembers = options.unselectableMembers;
    this.selectableMembers = options.selectableMembers;
    this.invalidMembers = options.invalidMembers;
    this.selectableTypes = options.selectableTypes || [];
    this.unselectableTypes = options.unselectableTypes || [];
    this.showAllTypes = options.showAllTypes || false;
    this.parentId = !!member ? member.get('id') : -1;
    this.addButtonLabel = options.addButtonLabel || lang.addButtonLabel;
  };

  _.extend(CommandTypes.prototype, {

    getSelectableMemberTypes: function () {
      if (this.showAllTypes) {
        return [];
      }

      return this.selectableTypes;
    },

    //Validate that the target member is of select type, or allows requested addable types to complete the action.
    //Used by select.views to remove unselectable types that should not be part of the display list.
    //Used by select.view and its member.list to determine if an item should still be displayed, but marked as unselectable.
    validateTarget: function (targetMember) {
      var targetId   = targetMember.data ? targetMember.data.id : targetMember.get('id'),
          targetType = targetMember.get('type'),
          retVal     = _.every(this.unselectableMembers, function (id) {
            return (targetId !== id);
          });

      if (this.browseAllowed(targetMember)) {
        retVal = _.every(this.unselectableTypes, function (type) {
          return targetType !== type;
        });
      }

      return retVal;
    },

    //parent groups, are not valid target items.
    validId: function (targetMember) {
      var targetId = targetMember.data ? targetMember.data.id : targetMember.get('id');
      return (targetId !== this.parentId);
    },

    validateAddableTypes: function (targetMember) {
      return !targetMember.addable_types;
    },

    isSelectableType: function (targetMember) {
      var targetType = targetMember.get('type');
      //for start location: "All Users and  Groups" type is not defined
      if (!targetType && targetType !== 0) {
        return false;
      }
      //Check against command provided unselectable types
      var retVal = _.every(this.unselectableTypes, function (type) {
        return (targetType !== type);
      });
      if (retVal && !_.isEmpty(this.selectableTypes)) {
        retVal = _.indexOf(this.selectableTypes, targetType) !== -1;
        if (!retVal && this.browseAllowed(targetMember) &&
            _.indexOf(this.selectableTypes, -1) > -1) {
          retVal = true;
        }
      }
      return retVal;
    },
    //returns if the member is selectable based on given action type
    isSelectable: function (targetMember) {
      var targetId = targetMember.data ? targetMember.data.id : targetMember.get('id');

      //Identify start location member that is not selectable.
      if (targetMember.get('unselectable')) {
        return false;
      }

      var retVal = this.isSelectableType(targetMember);

      //Check against command provided unselectable member
      retVal && (retVal = _.every(this.unselectableMembers, function (id) {
        return (targetId !== id);
      }));
      //Check for adding user to group
      if (this.selectableMembers) {
        retVal = targetMember.get("type") === 1;
      }
      return retVal;
    },

    //returns if the member can be opened for browsing.
    browseAllowed: function (member) {
      return member.get('type') === 1;
    },

    //Called to find out if a member should be part of a list or not.
    validateMember: function (member) {
      var valid = this._hasValidId(member);
      if (valid && !this.showAllTypes) {
        if (!this.browseAllowed(member)) {
          if ((this.selectableTypes.length > 0) &&
              (this.selectableTypes.indexOf(member.get('type')) === -1)) {
            valid = false;
          }
        }
      }
      return valid;
    },

    _hasValidId: function (member) {
      return _.every(this.invalidmembers, function (invalidmembers) {
        return invalidmembers.get('id') !== member.get('id');
      });
    }

  });

  return CommandTypes;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <span class=\"cs-icon "
    + this.escapeExpression(((helper = (helper = helpers.iconClass || (depth0 != null ? depth0.iconClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconClass","hash":{}}) : helper)))
    + "\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<a role=\"menuitem\" tabindex=\"-1\" href=\"#\" class="
    + this.escapeExpression(((helper = (helper = helpers['class'] || (depth0 != null ? depth0['class'] : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"class","hash":{}}) : helper)))
    + ">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.icon : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <span class=\"cs-label\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n</a>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_header_start.location.selector_start.location.selector.item', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<button id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\" class=\"binf-btn binf-btn-default binf-dropdown-toggle csui-acc-focusable\"\r\n        data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\r\n        aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.labelSelectLocation || (depth0 != null ? depth0.labelSelectLocation : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"labelSelectLocation","hash":{}}) : helper)))
    + "\">\r\n  <span class=\""
    + this.escapeExpression(((helper = (helper = helpers.iconClass || (depth0 != null ? depth0.iconClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconClass","hash":{}}) : helper)))
    + "\"></span>\r\n  <span class=\"cs-label\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n  <span class=\"cs-icon icon-caret-down\"></span>\r\n</button>\r\n<div class=\"csui-separator\"></div>\r\n<ul class=\"binf-dropdown-menu\" role=\"menu\" aria-labelledby=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\"></ul>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_header_start.location.selector_start.location.selector', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/node.picker/start.locations/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/dialogs/node.picker/start.locations/impl/nls/root/lang',{
  labelNoSelection: 'Go to...',
  labelSearch: 'Search',
  labelCurrentLocation: 'Current location',
  labelFavorites: 'Favorites',
  labelEnterpriseVolume: 'Enterprise Volume',
  labelPersonalVolume: 'Personal Volume',
  labelPerspectiveAssetsVolume: 'Perspective Assets Volume',
  labelRecentContainers: 'Recent Places',
  labelSelectLocation: 'Select start location'
});



csui.define('css!csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector',[],function(){});
// Renders a selector of the starting location for the node picker
csui.define('csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector.view',['csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector.item',
  'hbs!csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang',
  'css!csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector',
  'csui/lib/binf/js/binf'
], function (_, Backbone, Marionette, TabableRegion, itemTemplate, collectionTemplate, lang) {
  "use strict";

  var StartLocationItemView = Marionette.ItemView.extend({

    tagName: 'li',
    attributes: {
      role: 'presentation'
    },

    template: itemTemplate,
    templateHelpers: function () {
      return {
        iconClass: getIconClass(this.model)
      };
    },

    triggers: {
      'click >a': 'click:link'
    },

    constructor: function StartLocationItemView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.model, 'change', this.render);
    }

  });

  var StartLocationCollectionView = Marionette.CompositeView.extend({

    className: 'dropdown-locations',

    template: collectionTemplate,

    childView: StartLocationItemView,
    childViewContainer: '> .binf-dropdown-menu',
    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    ui: {
      toggle: '> .binf-dropdown-toggle',
      selectedLabel: '>.binf-dropdown-toggle >.cs-label',
      selectedIcon: '>.binf-dropdown-toggle >.cs-icon:not(.icon-caret-down)',
      selectedLocation: '>.binf-dropdown-toggle >span:not(.icon-caret-down)'
    },

    events: {
      'keyup': 'onKeyInView'
    },
    constructor: function StartLocationCollectionView(options) {
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this.selected = new Backbone.Model();
      if (this.options.selected) {
        this._setSelection(this.options.selected.attributes);
      } else {
        this.resetSelection();
      }
      this.listenTo(this.collection, 'change', this._refreshSelection);
      this.listenTo(this.selected, 'change', this._updateSelection);
      this.listenTo(Backbone, 'closeToggleAction', this._closeToggle);
    },

    //filter models which should not be rendered as a menu item
    filter: function (child, index, collection) {
      return !child.get('hide');
    },

    currentlyFocusedElement: function () {
      return this.$el.find('button');
    },

    accDeactivateTabableRegion: function () {
      this._closeToggle();
    },

    reset: function () {
      this.resetSelection();
    },

    resetSelection: function () {
      this.selected.set({
        id: _.uniqueId(),
        name: lang.labelNoSelection,
        icon: ''
      });
    },

    serializeData: function () {
      var selectedData = _.pick(this.selected.toJSON(), ['id', 'name', 'icon']);
      return _.defaults({
        id: _.uniqueId()
      }, selectedData);
    },

    templateHelpers: function () {
      return {
        search: lang.labelSearch,
        iconClass: getIconClass(this.selected),
        labelSelectLocation: lang.labelSelectLocation
      };
    },

    onKeyInView: function (event) {
      var open = this.$el.hasClass('binf-open');
      if (event.keyCode === 27 && open) {
        this.$el.removeClass('binf-open');
        this.$('*[tabindex = "0"]').focus();
        return false;
      }
    },

    onRender: function () {
      this.ui.toggle.binf_dropdown();
    },

    onChildviewClickLink: function (childView) {
      this.ui.selectedLabel.removeClass('select-prompt');
      this._setSelection(childView.model.attributes);
      this.ui.toggle.binf_dropdown('toggle');
      this.ui.selectedLocation.removeClass('binf-hide');
      this.triggerMethod('change:location', childView.model);
      //In order set focus to the parent view after a 'enter/space' keycode event,
      //we  send a setCurrentTabFocus event. The parent will
      //then set focus to itself. This is needed for Dialog accessiblity.
      this.$el.trigger('setCurrentTabFocus');
    },

    hideDropDownLabel: function (node) {
      var locationFactory   = this.selected.get('factory'),
          locationContainer = locationFactory.getLocationParameters().container,
          locationId        = locationContainer && locationContainer.get('id'),
          nodeId            = node && node.get('id');
      if (nodeId !== locationId) {
        this._setSelection({name: lang.labelSelectLocation, id: ''});
        this.ui.selectedLabel.addClass('select-prompt');
        this.ui.selectedIcon.addClass('binf-hide');
        //this.ui.selectedLocation.addClass('binf-hide');
      }
    },
    _setSelection: function (attributes) {
      this.selected.set(attributes);
    },

    _updateSelection: function () {
      this.ui.selectedLabel.text(this.selected.get('name'));
      this.ui.selectedIcon.attr('class', getIconClass(this.selected));
    },

    _refreshSelection: function (model) {
      if (model.get('id') === this.selected.get('id')) {
        this._setSelection(model.attributes);
      }
    },

    _closeToggle: function () {
      var locationSelector = this.$el;
      if (locationSelector.hasClass && locationSelector.hasClass('binf-open')) {
        this.ui.toggle.binf_dropdown('toggle');
      }
      this.ui.toggle && this.ui.toggle.attr && this.ui.toggle.attr('aria-expanded', 'false');
    }

  });

  function getIconClass(model) {
    var icon = model.get('icon') || '';
    if (icon && icon.indexOf('-') < 0) {
      icon = 'icon-menu-' + icon;
    }
    return 'cs-icon ' + icon;
  }

  return StartLocationCollectionView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/header/user.search/user.search',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-user-search-container\">\r\n  <div class=\"csui-user-search-bar\"></div>\r\n</div><a href=\"javascript:void(0);\" class=\"icon icon-global-search csui-header-userpicker-icon\r\n         icon-header-search csui-acc-focusable\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.searchIconTitle || (depth0 != null ? depth0.searchIconTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"searchIconTitle","hash":{}}) : helper)))
    + "\" tabindex=\"0\"\r\n         data-cstabindex=\"-1\" role=\"button\" aria-expanded=\"false\"\r\n         aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.searchIconAria || (depth0 != null ? depth0.searchIconAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"searchIconAria","hash":{}}) : helper)))
    + "\"></a>";
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_header_user.search_user.search', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/members.picker/impl/header/user.search/user.search.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  "csui/lib/marionette",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior', 'i18n',
  'i18n!csui/dialogs/members.picker/impl/nls/lang',
  "hbs!csui/dialogs/members.picker/impl/header/user.search/user.search"
], function ($, _, Marionette, TabableRegionBehavior, i18n, lang, template) {

  var UserSearchView = Marionette.ItemView.extend({

    className: 'csui-user-lookup',
    template: template,

    templateHelpers: {
      searchIconTitle: lang.searchIconTitle,
      searchIconAria: lang.searchIconAria
    },

    ui: {
      input: '.cs-search',
      userPickerIcon: '.csui-header-userpicker-icon'
    },

    events: {
      'click @ui.userPickerIcon': 'userPickerIconClicked'
    },

    /**
     * disabling behavior for member picker for now because it is hidden in dom but is getting
     * registered in tabable behavior regions and causing problem by not letting the tabable region
     * shift to select location dropdown when it will be usable we will enable it.
     behaviors: {
        TabableRegion: {
          behaviorClass: TabableRegionBehavior
        }
      },
     */

    initialize: function (options) {
      this.options = options;
    },

    constructor: function UserSearchView(options) {
      var self = this;
      options || (options = {});
      options.data || (options.data = {});
      this.options = options;
      this.direction = i18n.settings.rtl ? 'left' : 'right';
      Marionette.ItemView.prototype.constructor.call(this, options);
    },

    onShow: function () {
      var self = this;
      csui.require(['csui/controls/userpicker/userpicker.view'
      ], function (UserPickerView) {
        self.pickerView = new UserPickerView({
          context: self.options.context,
          limit: 5,
          memberFilter: {type: [0, 1]},
          widgetoptions: self.options,
          placeholder: self.options.placeHolder || lang.UserPickerPlaceHolder,
          prettyScrolling: true,
          scrollContainerHeight: 'auto',
          model: self.options.userPickerModel,
          id_input: _.uniqueId("csui-inline-permissions-user-picker-input"),
          lightWeight: false
        });
        var pickerRegion = new Marionette.Region({
          el: self.$el.find('.csui-user-search-bar')
        });
        pickerRegion.show(self.pickerView);
        self.listenTo(self.pickerView, "item:change", self.processItemChange);
        self.listenTo(self.pickerView, "item:clear", self.processItemChange);
      });
    },

    processItemChange: function () {
      var selectedModel = arguments.length > 0 && arguments[0].item;
      this.param = selectedModel;
      this.trigger("show:selectItem", this.param);
      this.processAfterSelect();
    },

    processAfterSelect: function () {
      if (this.pickerView.ui.searchbox.val() !== "") {
        this.pickerView && this.pickerView.ui && this.pickerView.ui.searchclear &&
        this.pickerView.ui.searchclear.trigger("click");
      }
    },

    updatePlaceHolder: function (memberExists) {
      if (memberExists) {
        this.$el.find("input").attr("placeholder", lang.addAnotherNamePlaceHolder);
      } else {
        this.$el.find("input").attr("placeholder", lang.UserPickerPlaceHolder);
      }
    },

    currentlyFocusedElement: function (arg) {
      if (this.$el) {
        var focusables = this.$el.find('*[data-cstabindex=-1]');
        if (focusables.length) {
          focusables.prop('tabindex', 0);
        }
        var shiftKey = !!arg && arg.shiftKey;
        if (!shiftKey && this.$el.find(".search-bar").length &&
            this.$el.find(".search-bar").is(":visible")) {
          this.focusElement = this.$el.find('.csui-input');
        } else if (this.$el.find('a.csui-acc-focusable').length) {
          this.focusElement = this.$el.find('a.csui-acc-focusable');
        }
      }
      return this.focusElement;
    },

    userPickerIconClicked: function (event) {
      $(document).bind('click.' + this.cid + ' keydown.' + this.cid, this, this._hideSearchBar);
      this.ui.input.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);
      if (this.$el.find(".csui-user-search-container").is(':visible')) {
      } else {
        if (this.$el && this.$el.parents()) {
          var that = this;
          this.hideStartLocations();
          this.$el.find('.csui-user-search-container').show('blind', {direction: this.direction},
              '200',
              function () {
                that.$el.find('.csui-user-search-container input').focus();
              });
        }
      }
      this.ui.userPickerIcon.attr('aria-expanded', true);
    },

    _hideSearchBar: function (event) {
      var _e   = event || window.event,
          ele  = $('.csui-user-search-container'),
          that = event.data;
      if (ele.is(':visible')) {
        if ((_e.type === 'keydown' && (_e.keyCode === 27 || _e.which === 27)) ||
            (!$(_e.target).closest(ele).length &&
            _e.type === 'click') && !$(_e.target).closest('.csui-header-userpicker-icon').length) {
          that.$el.find('.csui-user-search-container input').val('');
          that.$el.find(ele).hide('blind', {direction: event.data.direction}, '200', function () {
            that.showStartLocations();
            that.focusedElement = undefined;
            var fe = that.currentlyFocusedElement();
            fe.focus();
          });
          $(document).unbind('click.' + that.cid + ' keydown.' + that.cid);
          if (that.ui.userPickerIcon instanceof Object) {
            that.ui.userPickerIcon.attr('aria-expanded', false);
          }
        }
      }
    },

    showStartLocations: function (event) {
      this.trigger("show:startLocation");
    },

    hideStartLocations: function (event) {
      this.trigger("hide:startLocation");
    }
  });
  return UserSearchView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/members.picker/impl/header/members.picker.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <h2 class=\"member-title\">"
    + ((stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper))) != null ? stack1 : "")
    + "</h2><span class=\"csui-separator\"></span>\r\n  <div class=\"csui-target-controls\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.locationSelector : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "    <div class=\"csui-member-picker-container\">\r\n      <div class=\"csui-member-picker\"></div>\r\n    </div>\r\n  </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    var stack1;

  return "      <div class=\"csui-start-locations binf-dropdown "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.displayStartLocation : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\"></div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    return "binf-hidden";
},"5":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <h2 class=\"member-title member-picker-view-header\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2><span\r\n      class=\"csui-view-separator csui-separator binf-hidden\"></span>\r\n  <div class=\"csui-target-controls\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isNotDeleted : depth0),{"name":"if","hash":{},"fn":this.program(6, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  </div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-member-picker-container\">\r\n        <span class=\"csui-member-picker\"></span>\r\n        <span tabindex=\"-1\" class=\"csui-add-member icon-toolbarAdd binf-hidden\"\r\n              title=\""
    + this.escapeExpression(((helper = (helper = helpers.addMemberTitle || (depth0 != null ? depth0.addMemberTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"addMemberTitle","hash":{}}) : helper)))
    + "\"></span>\r\n      </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.adduserorgroup : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(5, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_dialogs_members.picker_impl_header_members.picker.header', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/members.picker/impl/header/members.picker.header',[],function(){});
csui.define('csui/dialogs/members.picker/impl/header/members.picker.header.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector.view',
  'csui/dialogs/members.picker/impl/header/user.search/user.search.view',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/dialogs/members.picker/impl/header/members.picker.header',
  'i18n!csui/dialogs/members.picker/impl/nls/lang',
  'css!csui/dialogs/members.picker/impl/header/members.picker.header'
], function (_, $, Marionette, StartLocationCollectionView, UserSearchView, TabableRegionBehavior,
    headerTemplate, lang) {

  var HeaderView = Marionette.LayoutView.extend({
    template: headerTemplate,
    className: 'cs-header-control',
    regions: {
      startLocations: '.csui-start-locations',
      userSearch: '.csui-member-picker'
    },

    templateHelpers: function () {
      return {
        adduserorgroup: this.options.adduserorgroup,
        locationSelector: this.options.locationSelector,
        displayStartLocation: this.options.displayStartLocation,
        isNotDeleted: !(this.options.headerViewoptions.selectedGroup && 
                        this.options.headerViewoptions.selectedGroup.get("right_id_expand").deleted),
        title: this.options.title ? this.options.title : lang.dialogTitle,
        addMemberTitle: lang.AddMember
      };
    },

    ui: {
      addIcon: '.csui-add-member.icon-toolbarAdd',
      memberPickerContainer: '.csui-member-picker-container',
      viewSeparator: '.csui-view-separator',
      headerTitle: '.member-picker-view-header'
    },

    events: {
      'click @ui.addIcon': 'onAddMemberClick',
      'keyup': 'onKeyInView'
    },

    onAddMemberClick: function (event) {
      event.stopPropagation();
      event.preventDefault();
      this.ui.addIcon.addClass("binf-hidden");
      this.ui.viewSeparator.removeClass("binf-hidden");
      this.ui.headerTitle.html(lang.AddUserOrGroup);
      if (this.editPermission) {
        this.showUserSearchView(event);
      }
      this.trigger("enable:add");
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    currentlyFocusedElement: function (args) {
      if (this.$el) {
        var focusables = this.$('*[tabindex]:visible');
        if (focusables.length) {
          focusables.prop('tabindex', 0);
        }
        return !!focusables[0] && $(focusables[0]);
      }
    },

    onKeyInView: function (event) {
      if (event.keyCode === 13) {
        if ($(event.target).hasClass('csui-add-member')) {
          $(event.target).trigger('click');
        }
      }
    },

    initialize: function () {
      var options = this.options;

      if (options.locationSelector && options.adduserorgroup) {
        this.startLocationView = new StartLocationCollectionView({
          collection: this.options.locations,
          title: this.options.dialogTitle,
          selected: this.options.initialLocation
        });

        options.placeHolder = this.options.selectedMember !== undefined ?
                              lang.addAnotherNamePlaceHolder : lang.userSearchPlaceHolder;
        options.addAnotherNamePlaceHolder = lang.addAnotherNamePlaceHolder;
        this.options = options;
      }
    },

    onRender: function () {
      var options = this.options;
      var loginUserId    = this.options.authUser && this.options.authUser.get("id"),
          groupLeaderId  = this.options.headerViewoptions.selectedGroup &&
                           this.options.headerViewoptions.selectedGroup.get(
                               "right_id_expand").leader_id,
          editPermission = false;
      if (groupLeaderId && groupLeaderId === loginUserId) {
        editPermission = true;
      }
      this.editPermission = editPermission || this.options.authUser &&
                            this.options.authUser.get("privilege_user_admin_rights");
      if (this.editPermission) {
        this.ui.addIcon.removeClass('binf-hidden');
      } else {
        this.ui.addIcon.addClass('binf-hidden');
      }
      if (this.options.showUserPicker) {
        this.ui.addIcon.addClass('binf-hidden');
        this.showUserSearchView();
        this.trigger("enable:add");
      }
      if (this.startLocationView && options.adduserorgroup) {
        this.startLocations.show(this.startLocationView);
        if (this.options.showUserPicker) {
          this.showUserSearchView();
          this.userSearchView.on('show:startLocation', this.showStartLocations, this);
          this.userSearchView.on('hide:startLocation', this.hideStartLocations, this);
        }
      }
    },

    showUserSearchView: function (event) {
      this.userSearchView = new UserSearchView(this.options);
      this.userSearch.show(this.userSearchView);
      this.userSearchView.userPickerIconClicked(event);
      this.userSearchView.on('show:selectItem', this.selectUsers, this);
    },

    selectUsers: function (selectedMember) {
      if (selectedMember) {
        this.trigger("show:selectItem", selectedMember);
      }
    },

    showStartLocations: function () {
      this.startLocationView.$el.removeClass("binf-hidden");
    },

    hideStartLocations: function () {
      this.startLocationView.$el.addClass("binf-hidden");
    },

    onDestroy: function () {
      if (this.startLocationView) {
        this.startLocationView.destroy();
      }
    }
  });

  return HeaderView;
});


csui.define('csui/controls/wizard/step/impl/footer.view',['csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior'
], function (Marionette, TabableRegion) {

  var ButtonView = Marionette.ItemView.extend({

    tagName: 'button',

    className: 'binf-btn',

    template: false,

    triggers: {
      'click': 'click'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    constructor: function ButtonView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);
    },

    isTabable: function () {
      return this.$el.is(':not(:disabled)') && this.$el.is(':not(:hidden)');
    },
    currentlyFocusedElement: function () {
      if (this.$el.prop('tabindex') === -1) {
        this.$el.prop('tabindex', 0);
      }
      return this.$el;
    },
    onRender: function () {
      var button     = this.$el,
          attributes = this.model.attributes;
      button.text(attributes.label);
      button.addClass(
          attributes['default'] ? 'binf-btn-primary cs-add-button' : 'binf-btn-default');
      if (attributes.toolTip) {
        button.attr('title', attributes.toolTip);
      }
      if (attributes.separate) {
        button.addClass('cs-separate');
      }
      this.updateButton(attributes);
    },

    updateButton: function (attributes) {
      var $button = this.$el;

      attributes || (attributes = {});
      if (attributes.hidden !== undefined) {
        if (attributes.hidden) {
          $button.addClass('binf-hidden');
        } else {
          $button.removeClass('binf-hidden');
        }
      }
      if (attributes.disabled !== undefined) {
        $button.prop('disabled', attributes.disabled);
      }
    }

  });

  var WizardStepFooterView = Marionette.CollectionView.extend({

    childView: ButtonView,

    constructor: function WizardStepFooterView(options) {
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
      this.listenTo(this, 'update:button', this.selectedMemberCollection, this);
    },
    onDomRefresh: function () {
      this.children.each(function (buttonView) {
        buttonView.trigger('dom:refresh');
      });
    },

    selectedMemberCollection: function(selectedMemberCollection) {
      this.selectedMemberCollection =  selectedMemberCollection;
    },

    getButtons: function () {
      return this.children.toArray();
    },

    updateButton: function (id, attributes) {
      var button = this.collection.get(id);
      if (button) {
        this.children
            .findByModel(button)
            .updateButton(attributes);
      } else {
        // If the footer comes from the dialog template including the buttons,
        // the collection of dynamically created buttons is empty.
        // The template has to provide correct initial classes for the buttons
        // and their identifiers must be present in the "data-cs-id" attribute.
        !!ButtonView.updateButton &&
        ButtonView.updateButton(this.$('[data-cs-id="' + id + '"]'), attributes);
      }
    },

    getPreviousButton: function () {
      return this.children.toArray()[0];
    },

    getNextButton: function () {
      var buttons = this.children.toArray();
      return buttons[buttons.length - 1];
    }

  });

  return WizardStepFooterView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/wizard/step/impl/step.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.actionIconLeft : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.iconLeft : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "    <h4 class=\"tile-title binf-modal-title\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h4>\r\n  </div>\r\n\r\n    <div class=\"cs-header-control\"></div>\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.showCloseBtn : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "    <span class=\"tile-type-action-icon cs-icon-left "
    + this.escapeExpression(((helper = (helper = helpers.actionIconLeft || (depth0 != null ? depth0.actionIconLeft : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"actionIconLeft","hash":{}}) : helper)))
    + "\" tabindex=\"0\"></span>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "    <span class=\"tile-type-icon cs-icon-left "
    + this.escapeExpression(((helper = (helper = helpers.iconLeft || (depth0 != null ? depth0.iconLeft : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconLeft","hash":{}}) : helper)))
    + "\"></span>\r\n    <div class=\"tile-title\">\r\n";
},"6":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.imageLeftUrl : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "");
},"7":function(depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"tile-type-image "
    + this.escapeExpression(((helper = (helper = helpers.imageLeftClass || (depth0 != null ? depth0.imageLeftClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageLeftClass","hash":{}}) : helper)))
    + "\">\r\n          <img src=\""
    + this.escapeExpression(((helper = (helper = helpers.imageLeftUrl || (depth0 != null ? depth0.imageLeftUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"imageLeftUrl","hash":{}}) : helper)))
    + "\" aria-hidden=\"true\" alt=\"\">\r\n        </div>\r\n      <div class=\"tile-title\">\r\n";
},"9":function(depth0,helpers,partials,data) {
    return "      <div class=\"tile-title cs-text-only\">\r\n";
},"11":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"cs-close\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.dialogCloseButtonTooltip || (depth0 != null ? depth0.dialogCloseButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"dialogCloseButtonTooltip","hash":{}}) : helper)))
    + "\">\r\n        <div class=\"icon circular "
    + this.escapeExpression(((helper = (helper = helpers.iconRight || (depth0 != null ? depth0.iconRight : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconRight","hash":{}}) : helper)))
    + "\" tabindex=\"0\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.dialogCloseAria || (depth0 != null ? depth0.dialogCloseAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"dialogCloseAria","hash":{}}) : helper)))
    + "\"\r\n             role=\"button\"></div>\r\n      </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.expandedHeader : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_wizard_step_impl_step.header', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/wizard/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/wizard/impl/nls/root/lang',{

  dialogCloseButtonTooltip: 'Close',
  dialogCloseAria: 'Close dialog',
  back: 'Back',
  next: 'Next',
  cancel: 'Cancel'
});



csui.define('css!csui/controls/wizard/impl/wizard',[],function(){});
csui.define('csui/controls/wizard/step/impl/header.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/controls/wizard/step/impl/step.header',
  'i18n!csui/controls/wizard/impl/nls/lang',
  'css!csui/controls/wizard/impl/wizard'
], function (_, $, Marionette, TabableRegion, headerTemplate, lang) {

  var WizardStepHeaderView = Marionette.ItemView.extend({

    template: headerTemplate,

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    ui: {
      headerControl: '.cs-header-control'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    templateHelpers: function () {
      return {
        iconLeft: this.options.iconLeft,
        actionIconLeft: this.options.actionIconLeft,
        imageLeftUrl: this.options.imageLeftUrl,
        imageLeftClass: this.options.imageLeftClass,
        title: this.options.title,
        showCloseBtn: this.options.showCloseBtn,
        iconRight: this.options.iconRight || 'cs-icon-cross',
        expandedHeader: this.options.expandedHeader,
        dialogCloseButtonTooltip: lang.dialogCloseButtonTooltip,
        dialogCloseAria: lang.dialogCloseAria
      };
    },

    constructor: function WizardStepHeaderView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);
    },

    isTabable: function () {
      return this.$('*[tabindex]').length > 0;
    },

    currentlyFocusedElement: function (event) {
      var tabElements = this.$('*[tabindex]');
      if (tabElements.length) {
        tabElements.prop('tabindex', 0);
      }
      if (!!event && event.shiftKey) {
        return $(tabElements[tabElements.length - 1]);
      } else {
        return $(tabElements[0]);
      }
    },

    onLastTabElement: function (shiftTab, event) {
      // return true if focus is on last tabable element else false.
      return (shiftTab && event.target === this.$('*[tabindex]')[0]);
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode;

      //Enter/space
      if (keyCode === 13 || keyCode === 32) {
        $(event.target).click();
      }
    },

    onRender: function () {
      var headers = this.options.headers || [];
      if (headers.length) {
        _.each(headers, function (header) {
          var $header = this._renderHeader(header);
          this.$el.append($header);
        }, this);
      }
      var headerControl = this.options.headerControl;
      if (headerControl) {
        this.ui.headerControl.append(headerControl.$el);
        headerControl.render();
        headerControl.trigger('dom:refresh');
      }

      if (!!this.options.actionIconLeft) {
        this._adjustTitleCSS();
      }
    },
    onDomRefresh: function () {
      var headerControl = this.options.headerControl;
      if (headerControl) {
        headerControl.triggerMethod('dom:refresh');
        headerControl.triggerMethod('after:show');
      }
    },

    _renderHeader: function (options) {
      var div = $('<div class="modal-header-item"></div>')
          .text(options.label);
      if (options.class) {
        div.addClass(options.class);
      }
      if (options.id) {
        div.attr("id", options.id);
      }
      return div;
    },

    _adjustTitleCSS: function (options) {
      this.$el.find('div.tile-title').addClass('tile-action-icon-tittle');
    }

  });

  return WizardStepHeaderView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/wizard/step/impl/wizard.step',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "  <div class=\"binf-modal-dialog binf-modal-lg\">\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.midSize : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "");
},"4":function(depth0,helpers,partials,data) {
    return "    <div class=\"binf-modal-dialog binf-modal-md\">\r\n";
},"6":function(depth0,helpers,partials,data) {
    return "    <div class=\"binf-modal-dialog\">\r\n";
},"8":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"binf-modal-body cs-dialog cs-dialog-bodymessage\">"
    + this.escapeExpression(((helper = (helper = helpers.bodyMessage || (depth0 != null ? depth0.bodyMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"bodyMessage","hash":{}}) : helper)))
    + "</div>\r\n";
},"10":function(depth0,helpers,partials,data) {
    return "      <div class=\"binf-modal-body\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.largeSize : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "\r\n  <div class=\"binf-modal-content\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.dialogTxtAria || (depth0 != null ? depth0.dialogTxtAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"dialogTxtAria","hash":{}}) : helper)))
    + "\">\r\n\r\n    <div class=\"tile-header binf-modal-header\"></div>\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.bodyMessage : depth0),{"name":"if","hash":{},"fn":this.program(8, data, 0),"inverse":this.program(10, data, 0)})) != null ? stack1 : "")
    + "\r\n    <div class=\"binf-modal-footer binf-hidden\"></div>\r\n\r\n  </div>\r\n\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_wizard_step_impl_wizard.step', t);
return t;
});
/* END_TEMPLATE */
;
// Renders a view in a modal dialog and waits for the user to close it
csui.define('csui/controls/wizard/step/wizard.step.view',['module', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/keyboard.navigation/tabables.behavior',
  'csui/controls/wizard/step/impl/footer.view',
  'csui/controls/wizard/step/impl/header.view',
  'hbs!csui/controls/wizard/step/impl/wizard.step',
  'csui/utils/log',
  'i18n!csui/controls/wizard/impl/nls/lang',
  'i18n'
], function (module, _, $, Backbone, Marionette, LayoutViewEventsPropagationMixin,
    TabablesBehavior, WizardStepFooterView, WizardStepHeaderView, wizardStepTemplate,
    log, lang, i18n) {

  log = log(module.id);

  var WizardStepView = Marionette.LayoutView.extend({

    className: function () {
      var className = 'cs-wizard-step cs-dialog binf-modal binf-fade';
      if (this.options.className) {
        className += ' ' + _.result(this.options, 'className');
      }
      return className;
    },

    attributes: {
      'tabindex': '-1',
      'role': 'dialog',
      'aria-hidden': 'true'
    },

    template: wizardStepTemplate,

    behaviors: {
      TabablesBehavior: {
        behaviorClass: TabablesBehavior,
        recursiveNavigation: true,
        containTabFocus: true
      }
    },

    regions: {
      body: '.binf-modal-body',
      header: '.binf-modal-header',
      footer: '.binf-modal-footer'
    },

    ui: {
      header: '.binf-modal-header',
      footer: '.binf-modal-footer',
      body: '.binf-modal-body'
    },

    events: {
      'hide.binf.modal': 'onHiding',
      'hidden.binf.modal': 'onHidden',
      'click .cs-close': 'onClickClose',
      'shown.binf.modal': 'onShown',
      'keyup': 'onKeyInView', // must be keyup, because subviews want to intercept too
      'setCurrentTabFocus': 'setCurrentTabFocus',
      'tabNextRegion': 'tabNextRegion',
      'click .tile-type-action-icon': 'onClickActionIcon'
    },

    templateHelpers: function () {
      return {
        largeSize: this.options.largeSize,
        midSize: this.options.midSize,
        bodyMessage: this.options.bodyMessage,
        dialogTxtAria: this.options.dialogTxtAria
      };
    },

    constructor: function WizardStepView() {
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);
      this.listenToOnce(this, 'before:hide', TabablesBehavior.popTabableHandler);
      this.propagateEventsToRegions();
    },
    onKeyInView: function (event) {
      if (event.keyCode === 27) {
        event.preventDefault();
        event.stopPropagation();
        this.destroy();
        this.trigger('close:wizard');
      }
    },

    setCurrentTabFocus: function () {
      this.focusOnLastRegion = true;
      this.$el.focus();
    },

    tabNextRegion: function () {
      this.trigger('changed:focus');
    },

    onRender: function () {
      // FIXME: Do not use className for additional classes; it overrides the prototype
      this.$el
          .addClass(WizardStepView.prototype.className.call(this))
          .attr('tabindex', 0);
      this._renderHeader();

      if (this.options.view) {
        this.body.show(this.options.view);
      }

      this._renderFooter();
    },

    onShow: function () {
      // Firefox workaround for absolute modal dialogs, it does not position to active element.
      // Scroll the main-body down e.g. 2/3 and open an absolute modal dialog and in Firefox it will start at window position 0.
      // => navigate to pos 0    (Firefox likes window instead of 'body')
      $(window).scrollTop(0);

      this.$el.binf_modal({
        backdrop: 'static',
        keyboard: false,
        paddingWhenOverflowing: false
      });
    },

    kill: function () {
      WizardStepView.__super__.destroy.apply(this, arguments);
      this._scrollToBegin();
      return true;
    },

    destroy: function () {
      // If destroying was not triggered by the modal plugin, hide the
      // dialog first using that interface to prevent memory leaks
      if (this.$el.is(':visible')) {
        this.$el.binf_modal('hide');
        $('body').removeClass('binf-modal-open');
      } else {
        WizardStepView.__super__.destroy.apply(this, arguments);
      }
      this._scrollToBegin();
      return this;
    },

    updateButton: function (id, options) {
      var footerView = this.footerView;
      if (!footerView.updateButton) {
        throw new Error('Dialog footer does not support button updating.');
      }
      footerView.updateButton(id, options);
    },

    showView: function (view) {
      this.body.show(view);
      view.triggerMethod('after:show');
    },

    onShown: function () {
      if (this.options.view) {
        this.options.view.triggerMethod('dom:refresh');
        this.options.view.triggerMethod('after:show');
      }
      if (this.headerView) {
        this.headerView.triggerMethod('dom:refresh');
        this.headerView.triggerMethod('after:show');
      }
      if (this.footerView) {
        this.footerView.triggerMethod('dom:refresh');
        this.footerView.triggerMethod('after:show');
      }
    },

    onHiding: function () {
      this.triggerMethod('before:hide');
    },

    onHidden: function () {
      this.triggerMethod('hide');
      this.destroy();
    },

    onClickClose: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger('close:wizard');
    },

    onClickActionIcon: function (event) {
      //originating view listens this event and then executes their call back function
      this.options.view.trigger("click:actionIcon");
    },

    onClickButton: function (view) {
      if (view.model.get('id') === 'Add') {
        this.trigger('add:member');
      } else {
        var attributes = view.model.attributes;
        if (attributes.click) {
          attributes.click({
            dialog: this,
            button: this.$el
          });
        }
        if (attributes.close) {
          this.trigger('close:wizard');
        }
      }

    },

    _scrollToBegin: function () {
      // move the scrollbar of the "body" to the leftmost or rightmost position
      if (i18n.settings.rtl === true) {
        var pos = $('body').width();
        $('body').scrollLeft(pos);
      } else {
        $('body').scrollLeft(0);
        $('.csui-add-permission').focus();
      }
    },

    _renderHeader: function () {
      var headerView = this.headerView = this.options.headerView,
          expandedHeader = this.options.standardHeader !== undefined ?
                           this.options.standardHeader : !this.options.template;
      (!!headerView) ?
      (headerView.editpermission = !!this.options.wizard && !!this.options.wizard.edit_permission &&
                                   this.options.wizard.edit_permission) : '';
      if (headerView) {
        this.header.show(headerView);
      }
      else {
        var options = {
          iconLeft: this.options.iconLeft,
          actionIconLeft: this.options.actionIconLeft,
          imageLeftUrl: this.options.imageLeftUrl,
          imageLeftClass: this.options.imageLeftClass,
          title: this.options.title,
          iconRight: this.options.iconRight || 'cs-icon-cross',
          headers: this.options.headers,
          headerControl: this.options.headerControl,
          expandedHeader: expandedHeader,
          el: this.ui.header[0]
        };
        headerView = this.headerView = new WizardStepHeaderView(options);
        headerView.render();
        this.header.attachView(headerView);
        this.headerView.trigger('dom:refresh');
      }
    },

    _renderFooter: function () {
      var footerView = this.footerView = this.options.footerView;
      if (footerView) {
        this.ui.footer.removeClass('binf-hidden');
        this.footer.show(footerView);
      } else {
        var defaultButtons = [];
        if (!this.options.isFirstStep) {
          //Previous button
          defaultButtons.push({
            id: 'previous',
            label: this.options.previousButtonLabel || lang.back,
            toolTip: this.options.previousButtonLabel || lang.back,
            'default': false,
            disabled: false,
            separate: true,
            click: _.bind(this.onClickPreviousButton, this)
          });
        }
        var nextButton = {
              id: 'next',
              label: this.options.nextButtonLabel || lang.next,
              toolTip: this.options.nextButtonLabel || lang.next,
              'default': true,
              disabled: (this.options.disableNext === undefined) ? true : this.options.disableNext,
              click: _.bind(this.onClickNextButton, this)
            },
            doneButton = {
              id: 'done',
              label: this.options.doneButtonLabel || lang.next,
              toolTip: this.options.doneButtonLabel || lang.next,
              'default': true,
              disabled: (this.options.disableDone === undefined) ? true : this.options.disableDone,
              click: _.bind(this.onClickDoneButton, this)
            };
        //Next or Done & Cancel buttons
        if (this.options.nextButton) {
          defaultButtons.push(nextButton);
        } else if (this.options.doneButton) {
          defaultButtons.push(doneButton);
        }
        defaultButtons.push(
            {
              id: 'cancel',
              label: lang.cancel,
              toolTip: lang.cancel,
              close: true
            });

        var buttons = this.options.buttons || defaultButtons;
        /*if (this.options.showUserPicker) {
          _.each(this.options.buttons, function (button) {
            if (button.id === 'Add') {
              button.disabled = true;
            }
          });
        }*/
        if (buttons.length) {
          this.ui.footer.removeClass('binf-hidden');
        }
        footerView = this.footerView = new WizardStepFooterView({
          collection: new Backbone.Collection(buttons),
          wizardView: this,
          el: this.ui.footer[0]
        });
        this.listenTo(footerView, 'childview:click', this.onClickButton);
        footerView.render();
        this.footer.attachView(footerView);
      }
    },

    showPreviousButton: function () {
      var previousBtnView = this.footer.currentView.getPreviousButton();
      previousBtnView.$el.removeClass('binf-hidden');
    },

    hidePreviousButton: function () {
      var previousBtnView = this.footer.currentView.getPreviousButton();
      previousBtnView.$el.addClass('binf-hidden');
    },

    validate: function () {
      if (this.body.currentView && this.body.currentView.validate) {
        return this.body.currentView.validate();
      } else {
        return true;
      }
    },

    onClickNextButton: function () {
      this.trigger('next:clicked');
    },

    onClickDoneButton: function () {
      this.trigger('done:clicked');
    },

    onClickPreviousButton: function () {
      this.trigger('previous:clicked');
    }

  });

  _.extend(WizardStepView.prototype, LayoutViewEventsPropagationMixin);

  return WizardStepView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/wizard/impl/wizard',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "";
}});
Handlebars.registerPartial('csui_controls_wizard_impl_wizard', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/wizard/wizard.view',['module', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/keyboard.navigation/tabables.behavior',
  'csui/controls/wizard/step/wizard.step.view',
  'hbs!csui/controls/wizard/impl/wizard',
  'csui/utils/non-emptying.region/non-emptying.region',
  'csui/utils/log',
  'i18n',
  'css!csui/controls/wizard/impl/wizard',
  'csui/lib/binf/js/binf'
], function (module, _, $, Backbone, Marionette, LayoutViewEventsPropagationMixin,
    TabablesBehavior, WizardStepView, wizardTemplate,
    NonEmptyingRegion, log, i18n) {

  var WizardView = Marionette.LayoutView.extend({

    id: 'wizard',

    template: wizardTemplate,

    behaviors: {
      TabablesBehavior: {
        behaviorClass: TabablesBehavior,
        recursiveNavigation: true,
        containTabFocus: true
      }
    },

    className: function () {
      var className = 'cs-wizard';
      if (this.options.className) {
        className += ' ' + _.result(this.options, 'className');
      }
      return className;
    },

    templateHelpers: function () {
      return {};
    },

    constructor: function WizardView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);
      this.propagateEventsToRegions();
    },

    initialize: function () {
      this.currentStep = 0;
      this.stepViews = [];
      this.direction = "right";
    },

    show: function (options) {
      var container = $.fn.binf_modal.getDefaultContainer(),
          region    = new NonEmptyingRegion({el: container});
      this.edit_permission = options.editpermission;
      region.show(this);
      return this;
    },

    onRender: function () {
      this.renderCurrentStep();
      return this;
    },

    renderCurrentStep: function () {
      this.currentView = this.getCurrentView();
      if (this.currentView._isRendered) {
        this.showCurrentView();
      } else {
        var region = new NonEmptyingRegion({el: this.el});
        region.show(this.currentView);
        //TODO: uncomment below line to get the steps in slide transition
        //this.addDirection();
      }
    },

    getCurrentView: function () {
      if (this.currentStep < this.stepViews.length) {
        return this.stepViews[this.currentStep];
      } else {
        var stepNum = this.currentStep;
        var view = new WizardStepView(_.extend(this.options.steps[stepNum],
            {wizard: this, isFirstStep: this.isFirstStep()}));
        this.stepViews.push(view);
        this.listenTo(view, 'next:clicked', this.nextStep)
            .listenTo(view, 'previous:clicked', this.prevStep)
            .listenTo(view, 'done:clicked', this.save)
            .listenTo(view, 'add:member', this.addMember)
            .listenTo(view, 'close:wizard', this.closeWizard);
        return view;
      }
    },

    nextStep: function () {
      if (this.currentView.validate()) {
        if (!this.isLastStep()) {
          this.hideCurrentView();
          this.currentStep += 1;
          this.direction = i18n && i18n.settings.rtl ? "left" : "right";
          this.renderCurrentStep();
        } else {
          this.save();
        }
      }
    },

    prevStep: function () {
      if (!this.isFirstStep()) {
        this.hideCurrentView();
        this.currentStep -= 1;
        this.direction = i18n && i18n.settings.rtl ? "right" : "left";
        this.renderCurrentStep();
      }
    },

    hideCurrentView: function () {
      this.currentView.$el.addClass('binf-hidden');
    },

    showCurrentView: function () {
      //TODO: uncomment below line to get the steps in slide transition
      //this.addDirection();
      this.currentView.$el.removeClass('binf-hidden');
    },

    addDirection: function () {
      this.currentView.$el.find(".binf-modal-dialog").removeClass("left");
      this.currentView.$el.find(".binf-modal-dialog").removeClass("right");
      this.currentView.$el.find(".binf-modal-dialog").addClass(this.direction);
    },

    updateButton: function (id, options) {
      if (!this.currentView.updateButton) {
        throw new Error('Dialog footer does not support button updating.');
      }
      this.currentView.updateButton(id, options);
    },

    save: function () {
      this.trigger("save:result");
    },

    addMember: function () {
      this.trigger("add:member");
    },

    isFirstStep: function () {
      return (this.currentStep === 0);
    },

    isLastStep: function () {
      return (this.currentStep === this.options.steps.length - 1);
    },

    onBeforeDestroy: function () {
      _.each(this.stepViews, function (stepView, index) {
        stepView.destroy();
      });
    },

    closeWizard: function () {
      this.trigger('closing:wizard');
      this.destroy();
    },

    getStepViewByStepNumber: function (stepNum) {
      if (this.stepViews && (stepNum < this.stepViews.length)) {
        return this.stepViews[stepNum];
      } else {
        return null;
      }
    }

  });

  _.extend(WizardView.prototype, LayoutViewEventsPropagationMixin);

  return WizardView;

});

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/edit/permission.level.selector/impl/permission.level.selector',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return "    <li class=\"csui-permission-level-item\" data-optionid=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.id : depth0), depth0))
    + "\" role=\"listitem\"\r\n        aria-label=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.name : depth0), depth0))
    + "\">\r\n      <a tabindex=\"-1\" href=\"#\">\r\n        <span class=\"cs-icon\"></span>\r\n        <span class=\"cs-label\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.name : depth0), depth0))
    + "</span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.showActionIcon : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "      </a>\r\n    </li>\r\n";
},"2":function(depth0,helpers,partials,data) {
    return "          <span class=\"csui-icon "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.actionIcon : depth0), depth0))
    + "\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<ul class=\"csui-permission-levels\" role=\"listbox\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.permissionLevelOptions : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</ul>\r\n";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_edit_permission.level.selector_impl_permission.level.selector', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/widgets/permissions/impl/nls/root/lang',{
  // tab title
  properties: 'Properties',
  versions: 'Versions',
  general: 'General',
  UserPickerPlaceHolder: 'Enter name or group',
  PermissionLookupPlaceHolder: 'Enter name or group for permissions lookup',
  right_id: 'User / Group',
  permission_level: 'Permission level',
  goBackTooltip: 'Go back',
  emptyPermissionListMsg: "{0} was not found in this permissions list.",
  addMemberToGroup: "Add {0} as a member to a group that currently has permissions",
  grantAccessToMember: "Grant access to a group in which {0} is already a member",
  permissionLevelFullControl: "Full control",
  permissionLevelWrite: "Write",
  permissionLevelRead: "Read",
  permissionLevelCustom: "Custom...",
  permissionLevelNone: "None",

  FullControl: "Full control",
  Write: "Write",
  Read: "Read",
  Custom: "Custom",
  None: "None",
  see: "See",
  see_contents: "See contents",
  modify: "Modify",
  edit_attributes: "Edit attributes",
  add_items: "Add items",
  reserve: "Reserve",
  delete_versions: "Delete version",
  delete: "Delete",
  edit_permissions: "Edit permissions",

  saveButtonLabel: "Ok",
  cancelButtonLabel: "Cancel",
  applyButtonLabel: "Apply",
  AddDropdownTitle: "Add",
  AddUserOrGroup: 'Add user or group',
  NoOwnerAssigned: "No owner assigned",
  addMajorVersion: "Add major version",
  allUsersAndGroups: "Users and Groups",
  addUsersAndGroups: "Add users or groups",
  addButtonLabel: 'Add',
  addButtonTooltip: 'Add member to group',
  cancelButtonTooltip: "Close dialog",
  noPermissionsAvailable: "Permissions page is not available for {0}"
});



csui.define('css!csui/widgets/permissions/impl/permissions',[],function(){});
csui.define('csui/widgets/permissions/impl/edit/permission.level.selector/permission.level.selector.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/models/permission/nodepermission.model',
  'hbs!csui/widgets/permissions/impl/edit/permission.level.selector/impl/permission.level.selector',
  'i18n!csui/widgets/permissions/impl/nls/lang',
  'css!csui/widgets/permissions/impl/permissions',
  'csui/lib/binf/js/binf'
], function (_,
    $,
    Marionette,
    TabableRegion,
    NodePermissionModel,
    selectorTemplate,
    lang) {
  "use strict";

  var PermissionLevelSelectorView = Marionette.ItemView.extend({
    _permissionLevelOptions: undefined,

    selected: undefined,

    openSelectedProperties: false,

    className: 'cs-permission-level-selector',

    template: selectorTemplate,

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    events: {
      'click li[data-optionid]': 'onClickOption',
      'keydown': 'onKeyInView'
    },

    constructor: function PermissionLevelSelectorView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    initialize: function () {
      this.focusIndex = 0;
      this._setupPermissionLevelOptions();

      var selectedLevel = this.options.selected ||
                          this.options.permissionModel.getPermissionLevel();

      if (-1 !== _.indexOf(_.pluck(this._permissionLevelOptions, 'id'), selectedLevel)) {
        this._setSelected(selectedLevel);
      }
      else {
        this._setSelected(NodePermissionModel.PERMISSION_LEVEL_NONE);
      }
    },

    onKeyInView: function (event) {
      var keyCode    = event.keyCode,
          focusables = this.$el.find('a[tabindex]');
      if (focusables.length) {
        if (event.keyCode === 13) { //Enter Key
          //Enter key pressed
          $(focusables[this.focusIndex]).parent().click();
          event.stopPropagation();
          event.preventDefault();

        }
        else if (keyCode === 38 || keyCode === 40) {
          if (keyCode === 38) { //up arrow
            this.focusIndex > 0 && --this.focusIndex;
          }
          else {//down arrow
            this.focusIndex < (focusables.length - 1) && ++this.focusIndex;
          }
          $(focusables[this.focusIndex]).focus();

          event.stopPropagation();
          event.preventDefault();
        }
        else if (keyCode === 9) {
          var popoverTarget = this.$el.parents('body').find(
              '.csui-edit-permission-popover-container' +
              ' .binf-popover');
          popoverTarget.binf_popover('destroy');
        }
      }
    },

    onClickOption: function (e) {
      e.preventDefault();
      e.stopPropagation();

      this._setSelected(parseInt($(e.currentTarget).attr('data-optionid')));
      this._showSelected();
      this.trigger('permission:level:selected');
      //let dialog know to set focus for the next tab request. For the modal dialog
      //focus is initially lost after each enter event.
      this.$el.trigger('setCurrentTabFocus');
    },

    templateHelpers: function () {
      return {
        permissionLevelOptions: this._permissionLevelOptions
      };
    },

    currentlyFocusedElement: function () {
      var focusables = this.$el.find('a[tabindex]');
      if (focusables.length) {
        return $(focusables[this.focusIndex]);
      }
    },

    accDeactivateTabableRegion: function () {
    },

    onRender: function () {
      this._showSelected();
    },

    _getOptionName: function (opt) {
      var i;
      var name;

      i = _.indexOf(_.pluck(this._permissionLevelOptions, 'id'), opt);
      name = (i === -1) ? '' : this._permissionLevelOptions[i].name;

      return name;
    },

    _setupPermissionLevelOptions: function () {
      this._permissionLevelOptions = [
        {
          id: NodePermissionModel.PERMISSION_LEVEL_NONE,
          name: lang.permissionLevelNone
        },
        {
          id: NodePermissionModel.PERMISSION_LEVEL_READ,
          name: lang.permissionLevelRead
        },
        {
          id: NodePermissionModel.PERMISSION_LEVEL_WRITE,
          name: lang.permissionLevelWrite
        },
        {
          id: NodePermissionModel.PERMISSION_LEVEL_FULL_CONTROL,
          name: lang.permissionLevelFullControl
        },
        {
          id: NodePermissionModel.PERMISSION_LEVEL_CUSTOM,
          name: lang.permissionLevelCustom,
          showActionIcon: true
        }
      ];
    },

    _setSelected: function (selectedOption) {
      this.selected = selectedOption;
    },

    _showSelected: function () {
      var allOptions = this.$el.find('li[data-optionid]');
      allOptions.find('.cs-icon').removeClass('icon-listview-checkmark');
      allOptions.removeAttr("aria-selected");

      var selectedItem = this.$el.find('li[data-optionid=' + this.selected + ']');
      selectedItem.find('.cs-icon').addClass('icon-listview-checkmark');
      selectedItem.attr("aria-selected", "true");
    },

    _showOpenSelectedProperties: function () {
      if (this.openSelectedProperties === true) {
        this.ui.toggle.attr('aria-expanded', 'true');
        this.ui.iconOpenSelectedProperties
            .removeClass('icon-checkbox')
            .addClass('icon-checkbox-selected');
      }
      else {
        this.ui.toggle.attr('aria-expanded', 'false');
        this.ui.iconOpenSelectedProperties
            .removeClass('icon-checkbox-selected')
            .addClass('icon-checkbox');
      }
    },

    getSelectedPermissions: function () {
      return NodePermissionModel.getPermissionsByLevelExceptCustom(this.selected,
          this.options.isContainer);
    }

  });

  return PermissionLevelSelectorView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/tree/impl/treeview',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <div class=\"csui-tree-child "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.nodeSplit : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + " "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.nodeClass : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n      <input type=\"checkbox\" id=\"node_"
    + this.escapeExpression(((helper = (helper = helpers.nodeId || (depth0 != null ? depth0.nodeId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeId","hash":{}}) : helper)))
    + "\" tabindex=\"-1\" name=\""
    + this.escapeExpression(((helper = (helper = helpers.nodeId || (depth0 != null ? depth0.nodeId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeId","hash":{}}) : helper)))
    + "\"\r\n             aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nodeName || (depth0 != null ? depth0.nodeName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeName","hash":{}}) : helper)))
    + "\" class=\"csui-tree-checkbox\r\n    "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.readonly : depth0),{"name":"if","hash":{},"fn":this.program(6, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\" "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.readonly : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.program(13, data, 0)})) != null ? stack1 : "")
    + ">\r\n    <label for=\"node_"
    + this.escapeExpression(((helper = (helper = helpers.nodeId || (depth0 != null ? depth0.nodeId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeId","hash":{}}) : helper)))
    + "\"></label>\r\n    <span class=\"csui-node-name\">"
    + this.escapeExpression(((helper = (helper = helpers.nodeName || (depth0 != null ? depth0.nodeName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeName","hash":{}}) : helper)))
    + "</span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.nodeSplit : depth0),{"name":"if","hash":{},"fn":this.program(16, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  </div>\r\n  <ul></ul>\r\n";
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return " "
    + this.escapeExpression(((helper = (helper = helpers.splitClass || (depth0 != null ? depth0.splitClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"splitClass","hash":{}}) : helper)));
},"4":function(depth0,helpers,partials,data) {
    return " nodeClass";
},"6":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.checked : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "");
},"7":function(depth0,helpers,partials,data) {
    return "  icon-checkbox-on_disabled\r\n    ";
},"9":function(depth0,helpers,partials,data) {
    return " icon-checkbox-disabled";
},"11":function(depth0,helpers,partials,data) {
    return "disabled ";
},"13":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.checked : depth0),{"name":"if","hash":{},"fn":this.program(14, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"14":function(depth0,helpers,partials,data) {
    return " tabindex=\"-1\"  checked";
},"16":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-tree-split "
    + this.escapeExpression(((helper = (helper = helpers.splitClass || (depth0 != null ? depth0.splitClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"splitClass","hash":{}}) : helper)))
    + "\">\r\n        <div class=\"csui-splitcontrol-label\">\r\n          <span>"
    + this.escapeExpression(((helper = (helper = helpers.splitName || (depth0 != null ? depth0.splitName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"splitName","hash":{}}) : helper)))
    + "</span>\r\n        </div>\r\n      </div>\r\n      <div class=\"csui-separator\"></div>\r\n";
},"18":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"csui-tree-child "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.nodeSplit : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n      <input type=\"checkbox\" id=\"node_"
    + this.escapeExpression(((helper = (helper = helpers.nodeId || (depth0 != null ? depth0.nodeId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeId","hash":{}}) : helper)))
    + "\" name=\""
    + this.escapeExpression(((helper = (helper = helpers.nodeId || (depth0 != null ? depth0.nodeId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeId","hash":{}}) : helper)))
    + "\"\r\n             aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nodeName || (depth0 != null ? depth0.nodeName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeName","hash":{}}) : helper)))
    + "\"  tabindex=\"-1\" class=\"csui-tree-checkbox\r\n             "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.nodeClass : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n        "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.readonly : depth0),{"name":"if","hash":{},"fn":this.program(19, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\" "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.readonly : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.program(22, data, 0)})) != null ? stack1 : "")
    + ">\r\n      <label for=\"node_"
    + this.escapeExpression(((helper = (helper = helpers.nodeId || (depth0 != null ? depth0.nodeId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeId","hash":{}}) : helper)))
    + "\"></label>\r\n      <span class=\"csui-node-name\">"
    + this.escapeExpression(((helper = (helper = helpers.nodeName || (depth0 != null ? depth0.nodeName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodeName","hash":{}}) : helper)))
    + "</span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.nodeSplit : depth0),{"name":"if","hash":{},"fn":this.program(25, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "    </div>\r\n";
},"19":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.checked : depth0),{"name":"if","hash":{},"fn":this.program(20, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "");
},"20":function(depth0,helpers,partials,data) {
    return " icon-checkbox-on_disabled\r\n    ";
},"22":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.checked : depth0),{"name":"if","hash":{},"fn":this.program(23, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"23":function(depth0,helpers,partials,data) {
    return " checked";
},"25":function(depth0,helpers,partials,data) {
    var helper;

  return "        <div class=\"csui-tree-split "
    + this.escapeExpression(((helper = (helper = helpers.splitClass || (depth0 != null ? depth0.splitClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"splitClass","hash":{}}) : helper)))
    + "\">\r\n          <div class=\"csui-splitcontrol-label\">\r\n            <span>"
    + this.escapeExpression(((helper = (helper = helpers.splitName || (depth0 != null ? depth0.splitName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"splitName","hash":{}}) : helper)))
    + "</span>\r\n          </div>\r\n        </div>\r\n        <div class=\"csui-separator\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isNodesExists : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(18, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_tree_impl_treeview', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/tree/impl/treeview',[],function(){});
csui.define('csui/controls/tree/tree.view',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette',
  'hbs!csui/controls/tree/impl/treeview',
  'css!csui/controls/tree/impl/treeview'
], function (module, _, $, Backbone, Marionette, TreeViewTemplate) {
  "use strict";
  var TreeRootView = Marionette.CompositeView.extend({
    template: TreeViewTemplate,
    templateHelpers: function () {
      return {
        isNodesExists: this.model.nodes && this.model.nodes.length > 0 ? true : false,
        readonly: this.model.attributes ? this.model.attributes.readonly : false
      };
    },
    tagName: "li",
    childViewContainer: "ul",
    className: "csui-tree-root",
    events: {
      'click input.csui-tree-checkbox': 'onNodeClicked'
    },
    initialize: function () {
      this.collection = this.model.nodes;
    },
    onNodeClicked: function (event) {
      this.trigger('Node:clicked', event.target);
    }
  });

  var TreeView = Marionette.CollectionView.extend({
    tagName: "ul",
    className: "csui-tree-container",
    childView: TreeRootView,
    childEvents: {
      'Node:clicked': 'onChildNodeClicked'
    },

    onChildNodeClicked: function (childView, target) {
      if (target.checked) {
        this.trigger("node:selected", target);
      } else {
        this.trigger("node:unselected", target);
      }
    }

  });

  return TreeView;
});
csui.define('csui/models/permission/permissionlevel',['module',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone'
], function (module, $, _, Backbone) {
  'use strict';

  var PermissionLevelNode = Backbone.Model.extend({
    initialize: function(){
      var nodes = this.get("nodes");
      if (nodes){
        this.nodes = new PermissionLevelCollection(nodes);
        this.unset("nodes");
      }
    }
  });

  var PermissionLevelCollection = Backbone.Collection.extend({
    model: PermissionLevelNode
  });

  return PermissionLevelCollection;
});
csui.define('csui/widgets/permissions/impl/edit/permission.attributes/impl/permission.attributes.data',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'csui/models/permission/permissionlevel',
  'i18n!csui/widgets/permissions/impl/nls/lang'
], function ($, _, Marionette, PermissionLevelCollection, lang) {

  function getPermissionAttributes(options) {
    var readonly       = options.readonly !== false ? true : false,
        permissions    = options.permissions || [],
        permissionData = [
          {
            nodeName: lang.see,
            nodeId: "see",
            readonly: readonly,
            checked: permissions.indexOf("see") >= 0,
            nodes: [
              {
                nodeName: lang.see_contents,
                nodeId: "see_contents",
                nodeClass: "",
                nodeSplit: true,
                splitName: lang.Read,
                splitClass: "csui-split-read",
                readonly: readonly,
                checked: permissions.indexOf("see_contents") >= 0,
              },
              {
                nodeName: lang.modify,
                nodeId: "modify",
                readonly: readonly,
                checked: permissions.indexOf("modify") >= 0,
                nodes: [
                  {
                    nodeName: lang.edit_attributes,
                    nodeId: "edit_attributes",
                    readonly: readonly,
                    checked: permissions.indexOf("edit_attributes") >= 0
                  },
                  {
                    nodeName: lang.reserve,
                    nodeId: "reserve",
                    readonly: readonly,
                    checked: permissions.indexOf("reserve") >= 0,
                    nodes: [
                      {
                        nodeName: lang.addMajorVersion,
                        nodeId: "add_major_version",
                        readonly: readonly,
                        checked: permissions.indexOf("add_major_version") >= 0
                      }
                    ]
                  },
                  {
                    nodeName: lang.delete_versions,
                    nodeId: "delete_versions",
                    readonly: readonly,
                    checked: permissions.indexOf("delete_versions") >= 0,
                    nodes: [
                      {
                        nodeName: lang.delete,
                        nodeId: "delete",
                        nodeSplit: true,
                        splitName: lang.Write,
                        splitClass: "csui-split-write",
                        readonly: readonly,
                        checked: permissions.indexOf("delete") >= 0,
                        nodes: [
                          {
                            nodeName: lang.edit_permissions,
                            nodeId: "edit_permissions",
                            nodeSplit: true,
                            splitName: lang.FullControl,
                            splitClass: "csui-split-fullcontrol",
                            readonly: readonly,
                            checked: permissions.indexOf("edit_permissions") >= 0
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];

    if (options.node && options.node.get('container')) {
      permissionData[0].nodes[1].nodes.splice(1, 0, {
        nodeName: lang.add_items,
        nodeId: "add_items",
        readonly: readonly,
        checked: permissions.indexOf("add_items") >= 0
      });
    }

    return new PermissionLevelCollection(permissionData);
  }

  return {

    getPermissionAttributes: getPermissionAttributes
  };
});

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/edit/permission.attributes/impl/permission.attributes',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-permission-attribute-buttons-container\">\r\n    <button class=\"cs-save-btn binf-btn binf-btn-primary\r\n  binf-btn-default\" tabindex=\"-1\">"
    + this.escapeExpression(((helper = (helper = helpers.save_button_label || (depth0 != null ? depth0.save_button_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"save_button_label","hash":{}}) : helper)))
    + "</button>\r\n    <button class=\"cs-cancel-btn binf-btn binf-btn-default\"\r\n            tabindex=\"-1\">"
    + this.escapeExpression(((helper = (helper = helpers.cancel_button_label || (depth0 != null ? depth0.cancel_button_label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cancel_button_label","hash":{}}) : helper)))
    + "</button>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-permission-attribute-tree\"></div>\r\n\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.showButtons : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_edit_permission.attributes_impl_permission.attributes', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/impl/edit/permission.attributes/permission.attributes.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'csui/utils/base',
  'i18n',
  'csui/behaviors/keyboard.navigation/tabables.behavior',
  'csui/controls/tree/tree.view',
  'csui/widgets/permissions/impl/edit/permission.attributes/impl/permission.attributes.data',
  'hbs!csui/widgets/permissions/impl/edit/permission.attributes/impl/permission.attributes',
  'i18n!csui/widgets/permissions/impl/nls/lang'
], function ($, _, Marionette, base, i18n, TabablesBehavior, TreeView, permissionAttributes,
    template, lang) {

  var PermissionAttributesView = Marionette.LayoutView.extend({
    className: "csui-permission-attributes",

    template: template,

    regions: {
      treeRegion: ".csui-permission-attribute-tree"
    },

    events: {
      "click button.cs-save-btn": "onClickSave",
      "click button.cs-cancel-btn": "onClickCancel",
      "keydown": '_handleKeyEvents'
    },

    behaviors: {
      TabablesBehavior: {
        behaviorClass: TabablesBehavior
      }
    },

    _handleKeyEvents: function (event) {
      var focusables = this.$el.find('input.csui-tree-checkbox');
      if (!!event && event.shiftKey && event.keyCode === 9) {

        $(focusables[focusables.length]).focus();
      }
      else if (event.target.textContent === "Cancel" && event.keyCode === 9) {

        if (focusables.length) {
          $(focusables[0]).focus();
        }
      }

    },
    currentlyFocusedElement: function (event) {
      var tabElements = this.$('*[tabindex]');
      if (tabElements.length) {
        tabElements.prop('tabindex', 0);
      }
      if (!!event && event.shiftKey) {
        return $(tabElements[tabElements.length - 1]);
      } else {
        return $(tabElements[0]);
      }
    },

    templateHelpers: function () {
      var showButtons = this.options.showButtons;
      if (showButtons === undefined) {
        showButtons = !this.options.readonly;
      }
      return {
        save_button_label: lang.saveButtonLabel,
        cancel_button_label: lang.cancelButtonLabel,
        showButtons: showButtons
      };
    },

    constructor: function PermissionAttributesView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
      this.options = options;
      this.focusIndex = 0;
    },

    onRender: function () {
      var permissionLevelCollection = permissionAttributes.getPermissionAttributes({
        readonly: this.options.readonly,
        node: this.options.node,
        permissions: this.options.permissions || this.model.get("permissions")
      });

      this.treeView = new TreeView({
        collection: permissionLevelCollection
      });
      this.treeRegion.show(this.treeView);
      this.listenTo(this.treeView, 'node:selected', this.onPermissionNodeSelected);
      this.listenTo(this.treeView, 'node:unselected', this.onPermissionNodeUnselected);
    },

    onPermissionNodeSelected: function (target) {
      var view = this.treeView,
          dependentNodes;
      //edit permissions is selected then select all the nodes
      if (target.attributes.name.value === "edit_permissions") {
        dependentNodes = view.$el.find("input.csui-tree-checkbox");
      }
      //select the parent level  nodes in the hierarchy of the selected node
      else {
        dependentNodes = view.$el.find(target).closest(".csui-tree-root").parents(
            ".csui-tree-root").children(".csui-tree-child").find("input.csui-tree-checkbox");
      }
      dependentNodes.prop('checked', true);
      if (dependentNodes.length) {
        view.$el.find("#node_see_contents")[0].checked = true;
      }
    },

    onPermissionNodeUnselected: function (target) {
      var view = this.treeView,
          dependentNodes;
      //see_contents is unselected then unselect underlying nodes
      if (target.attributes.name.value === "see_contents") {
        dependentNodes = view.$el.find(target).closest(".csui-tree-root").siblings(
            ".csui-tree-root").find("input.csui-tree-checkbox");
      }
      //unselect the child level  nodes in the hierarchy of the unselected node
      else {
        dependentNodes = view.$el.find(target).closest(".csui-tree-root").children("ul").find(
            "input.csui-tree-checkbox");
        if (!dependentNodes.length || target.attributes.name.value === "reserve") {
          view.$el.find("#node_edit_permissions")[0].checked = false;
        }
      }
      dependentNodes.prop('checked', false);
    },

    onClickSave: function () {
      var permissions = this.getSelectedPermissions();
      this.trigger("permission:attribute:save:clicked", permissions);
    },

    onClickCancel: function () {
      this.trigger("permission:attribute:cancel:clicked");
    },

    onDestroy: function () {
    },

    getSelectedPermissions: function () {
      var treeNodes   = this.treeView.$el.find('input.csui-tree-checkbox'),
          permissions = [];
      for (var i = 0; i < treeNodes.length; i++) {
        if (treeNodes[i].checked) {
          permissions.push(treeNodes[i].name);
        }
      }
      return permissions;
    }

  });
  return PermissionAttributesView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/edit/apply.permission/impl/apply.permission',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-apply-permission-content\">\r\n  <span class=\"csui-apply-permission-message\"></span>\r\n</div>\r\n<div class=\"csui-apply-permission-subfolder-container\">\r\n  <div class=\"csui-apply-permission-sub-folder\">\r\n    <span class=\"csui-apply-permission-sub-folder-label\"></span>\r\n    <div class=\"required-fields-switch\"></div>\r\n  </div>\r\n  <div class=\"csui-apply-permission-subitems-container\">\r\n    <div class=\"csui-apply-subitems-message\"></div>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_edit_apply.permission_impl_apply.permission', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/edit/apply.permission/impl/include.subitems',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-selected-checkbox csui-slice-checkbox csui-checkbox-primary\r\n  csui-permisison-subItem\">\r\n    <input type=\"checkbox\" class=\"csui-subtypes-option\" name=\""
    + this.escapeExpression(((helper = (helper = helpers.itemName || (depth0 != null ? depth0.itemName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"itemName","hash":{}}) : helper)))
    + "\" id=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\"\r\n           value=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">\r\n    <label class=\"csui-subtype-name\" for=\""
    + this.escapeExpression(((helper = (helper = helpers.itemName || (depth0 != null ? depth0.itemName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"itemName","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.itemName || (depth0 != null ? depth0.itemName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"itemName","hash":{}}) : helper)))
    + "\">\r\n      <span class=\"cs-ellipsis\">"
    + this.escapeExpression(((helper = (helper = helpers.itemName || (depth0 != null ? depth0.itemName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"itemName","hash":{}}) : helper)))
    + "\r\n        ("
    + this.escapeExpression(((helper = (helper = helpers.total || (depth0 != null ? depth0.total : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"total","hash":{}}) : helper)))
    + " "
    + this.escapeExpression(((helper = (helper = helpers.itemTitle || (depth0 != null ? depth0.itemTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"itemTitle","hash":{}}) : helper)))
    + ")\r\n  </span>\r\n    </label>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.subItems : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_edit_apply.permission_impl_include.subitems', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/impl/edit/apply.permission/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/widgets/permissions/impl/edit/apply.permission/impl/nls/root/lang',{
  applyPermissionHeaderTitle: 'Apply permissions',
  removePermissionHeaderTitle: 'Remove {0}',
  restorePublicAccessHeaderTitle: 'Restore public access',
  applytoSubFolder: 'Apply to sub-folders',
  applytoSubFolderWithCount: 'Apply to sub-folders ( {0} )',
  applyToSubItemsTitle: 'Include special items in {0} and sub-folders',
  applyToItem: 'Permissions will be applied to all items in {0}.',
  applyToThresholdExceeded: 'Permissions will be applied to large number of items in {0}.',
  removeThresholdExceeded: 'Permissions will be removed from large number of items in {0}',
  removeToItem: 'Permissions will be removed from all items in {0}',
  includeSubItems: 'Including {0}',
  publicAccess: "Public Access",
  item: 'item',
  items: 'items',
  204: 'Task lists',
  207: 'Channels',
  215: 'Discussions',
  298: 'Collections',
  3030202: 'Communities'
});


csui.define('csui/widgets/permissions/impl/edit/apply.permission/apply.permission.view',[
  'module',
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/models/permission/nodepermission.model',
  'hbs!csui/widgets/permissions/impl/edit/apply.permission/impl/apply.permission',
  'hbs!csui/widgets/permissions/impl/edit/apply.permission/impl/include.subitems',
  'i18n!csui/widgets/permissions/impl/edit/apply.permission/impl/nls/lang',
  'csui/utils/taskqueue',
  'csui/lib/handlebars.helpers.xif',
  'css!csui/widgets/permissions/impl/permissions'
], function (module, _,
    $,
    Backbone,
    Marionette,
    TabableRegion,
    NodePermissionModel,
    applyPermissionTemplate,
    includeSubitemsTemplate,
    lang,
    TaskQueue) {
  "use strict";

  var config = module.config();
  _.defaults(config, {
    parallelism: 5
  });

  var ApplyPermissionView = Marionette.ItemView.extend({

    className: 'csui-apply-permission',

    template: applyPermissionTemplate,
    includeSubitemsTemplate: includeSubitemsTemplate,

    ui: {
      applyPermissionMsg: '.csui-apply-permission-message',
      appplyToSubFolderContainer: '.csui-apply-permission-sub-folder',
      appplyToSubFolder: '.csui-apply-permission-sub-folder-label',
      applyToSubItemsContainer: 'csui-apply-permission-subitems-container',
      applyToSubItemsTitle: '.csui-apply-subitems-message',
      subItemsCheckBox: '.csui-subtypes-option'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    events: {
      'keydown': 'onKeyInView'
    },

    constructor: function ApplyPermissionView(options) {
      var self = this;
      self._ = _;
      self.userSelectionCount = 0;
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    initialize: function () {
      this.focusIndex = 0;
    },

    onKeyInView: function (event) {
      var keyCode    = event.keyCode,
          focusables = this.$el.find('*[tabindex]');
      if (focusables.length) {
        if (event.keyCode === 13) { //Enter Key
          //Enter key pressed
          $(focusables[this.focusIndex]).parent().click();
          event.stopPropagation();
          event.preventDefault();

        }
        else if (keyCode === 38 || keyCode === 40) {
          if (keyCode === 38) { //up arrow
            this.focusIndex > 0 && --this.focusIndex;
          }
          else {//down arrow
            this.focusIndex < (focusables.length - 1) && ++this.focusIndex;
          }
          $(focusables[this.focusIndex]).focus();

          event.stopPropagation();
          event.preventDefault();
        }
      }
    },

    currentlyFocusedElement: function () {
      var focusables = this.$el.find('*[tabindex]');
      if (focusables.length) {
        return $(focusables[this.focusIndex]);
      }
    },

    onRender: function () {
      var message = "";
      if (this.options.removePermission) {
        message = _.str.sformat(lang.removeToItem, this.options.model.get("container"));
      } else {
        message = _.str.sformat(lang.applyToItem, this.options.model.get("name"));
      }
      this.ui.applyPermissionMsg.html(message);
      if (this.options.model && this.options.model.get("container")) {
        this.loadSubFolderDeatils(this);
        if (this.options.applyTo) {
          this.loadSpecialItems(this.options.applyTo.subTypes,
              this.options.applyTo.thresholdExceeded);
        }
      }
    },

    loadSubFolderDeatils: function (self) {
      var isSubFolderExists = self.options.applyTo && self.options.applyTo.subTypes.indexOf(0);
      if (isSubFolderExists >= 0) {
        self.ui.appplyToSubFolderContainer.removeClass("binf-hidden");
        self.$(self.ui.appplyToSubFolder).html(lang.applytoSubFolder);
        self.requiredFieldSwitchModel = new Backbone.Model({data: false});
        var appplyToSubFolderId = _.uniqueId('appplyToSubFolder');
        self.ui.appplyToSubFolder.attr('id', appplyToSubFolderId);
        csui.require(['csui/controls/form/fields/booleanfield.view'], function (BooleanFieldView) {
          self.requiredFieldSwitchView = new BooleanFieldView({
            mode: 'writeonly',
            model: self.requiredFieldSwitchModel,
            labelId: appplyToSubFolderId
          });
          self.requiredFieldSwitchView.render();
          self.requiredFieldSwitchView.on('field:changed', function (event) {
            self.subFolderSelected = event.fieldvalue;
            if (event.fieldvalue) {
              if (!!self.options.subTypes) {
                self.loadSpecialItems(self.options.subTypes, self.options.thresholdExceeded);
              } else {
                self.fetchSubFoldersSubItems(self.options).then(function (promises) {
                  self.loadSpecialItems(self.options.subTypes, self.options.thresholdExceeded);
                });
              }
            } else if (self.options.applyTo) {
              self.loadSpecialItems(self.options.applyTo.subTypes,
                  self.options.applyTo.thresholdExceeded);
            }
          });
          self.$('.required-fields-switch').append(self.requiredFieldSwitchView.$el);
        });
      } else {
        self.ui.appplyToSubFolderContainer.addClass("binf-hidden");
      }
    },

    loadSpecialItems: function (subTypes, thresholdExceeded) {
      var self               = this,
          subtypes           = subTypes,
          threshold_exceeded = thresholdExceeded,
          isSubFolderExists  = self.options.applyTo && self.options.applyTo.subTypes.indexOf(0),
          folderName         = self.model.get("name"),
          memberName         = this.options.permissionModel &&
                               this.options.permissionModel.get("right_id_expand") &&
                               this.options.permissionModel.get("right_id_expand").name_formatted,
          subTypesStr        = "";
      memberName = this.options.permissionModel &&
                   this.options.permissionModel.get("type") === "public" ? lang.publicAccess :
                   memberName;
      if (subtypes.indexOf(204) >= 0) {
        subTypesStr = subTypesStr === "" ? subTypesStr + lang[204] :
                      subTypesStr + ", " + lang[204];
      }
      if (subtypes.indexOf(207) >= 0) {
        subTypesStr = subTypesStr === "" ? subTypesStr + lang[207] :
                      subTypesStr + ", " + lang[207];
      }
      if (subtypes.indexOf(215) >= 0) {
        subTypesStr = subTypesStr === "" ? subTypesStr + lang[215] :
                      subTypesStr + ", " + lang[215];
      }
      if (subtypes.indexOf(298) >= 0) {
        subTypesStr = subTypesStr === "" ? subTypesStr + lang[298] :
                      subTypesStr + ", " + lang[298];
      }
      if (subtypes.indexOf(3030202) >= 0) {
        subTypesStr = subTypesStr === "" ? subTypesStr + lang[3030202] :
                      subTypesStr + ", " + lang[3030202];
      }

      if (this.options.removePermission) {
        _.str.sformat(lang.removeToItem, folderName);
      }

      if (threshold_exceeded) {
        if (this.options.removePermission) {
          self.ui.applyPermissionMsg.html(
              _.str.sformat(lang.removeThresholdExceeded, folderName));
        } else {
          self.ui.applyPermissionMsg.html(_.str.sformat(lang.applyToThresholdExceeded, folderName));
        }
      } else {
        if (this.options.removePermission) {
          self.ui.applyPermissionMsg.html(
              _.str.sformat(lang.removeToItem, folderName));
        } else {
          !!self.ui.applyPermissionMsg.html && 
              self.ui.applyPermissionMsg.html(_.str.sformat(lang.applyToItem, folderName));
        }
      }
      if (subTypesStr !== "") {
        self.ui.applyToSubItemsContainer.removeClass('binf-hidden');
        self.ui.applyToSubItemsTitle.html(_.str.sformat(lang.includeSubItems, subTypesStr));
      } else {
        !!self.ui.applyToSubItemsTitle.html && self.ui.applyToSubItemsTitle.html("");
        !!self.ui.applyToSubItemsContainer.addClass && 
            self.ui.applyToSubItemsContainer.addClass('binf-hidden');
      }
    },

    fetchSubFoldersSubItems: function (options) {
      this.options = options;
      this.options.subTypes = [];
      var self     = this,
          subTypes = [204, 207, 215, 298, 3030202],
          queue    = new TaskQueue({
            parallelism: config.parallelism
          }),
          nodeID   = self.model.get('id'),
          url      = (self.model.connector.connection.url).replace("v1", "v2") + "/nodes/" +
                     nodeID + "/descendents/subtypes/exists?sub_types=",
          promises = _.map(subTypes, function (subType) {
            var deferred = $.Deferred();
            queue.pending.add({
              worker: function () {
                var permissionPreCheck = self.model.connector.extendAjaxOptions({
                  url: url + subType,
                  type: 'GET',
                  data: {
                    include_sub_items: true
                  }
                });
                $.ajax(permissionPreCheck).done(function (response) {
                  if (response.results.data.subtypes_info !== undefined) {
                    self.options.subTypes.push(response.results.data.subtypes_info[0].id);
                  }
                  self.options.thresholdExceeded = response.results.data.threshold_exceeded;
                  deferred.resolve(response);
                }).fail(function (response) {
                  deferred.reject(response);
                });
                return deferred.promise();
              }
            });
            return deferred.promise(promises);  // return promises
          });
      return $.whenAll.apply($, promises);
    },

    getApplyToFlag: function () {
      return this.subFolderSelected;
    }
  });
  return ApplyPermissionView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/node.list/list.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<a class=\"csui-item-standard csui-list-group-item\" href=\"#\">\r\n<span class=\"csui-icon csui-start-icon "
    + this.escapeExpression(((helper = (helper = helpers.selected || (depth0 != null ? depth0.selected : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selected","hash":{}}) : helper)))
    + "\"></span>\r\n<span class=\"csui-type-icon\" aria-hidden=\"true\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.iconTitle || (depth0 != null ? depth0.iconTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconTitle","hash":{}}) : helper)))
    + "\"></span>\r\n<span title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" class=\"csui-list-item-title\">\r\n  "
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\r\n</span>\r\n<span class=\"csui-icon csui-end-icon "
    + this.escapeExpression(((helper = (helper = helpers.browsed || (depth0 != null ? depth0.browsed : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"browsed","hash":{}}) : helper)))
    + "\"></span>\r\n</a>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_node.list_list.item', t);
return t;
});
/* END_TEMPLATE */
;
// Shows a list of links
csui.define('csui/dialogs/node.picker/impl/node.list/list.item.view',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/controls/listitem/listitemstandard.view',
  'hbs!csui/dialogs/node.picker/impl/node.list/list.item',
  'hbs!csui/dialogs/node.picker/impl/search.list/search.location.item',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/behaviors/default.action/default.action.behavior',
  'i18n!csui/dialogs/node.picker/impl/nls/lang'
], function (_, $, StandardListItem, itemTemplate, searchLocationTemplate, NodeTypeIconView,
    DefaultActionBehavior, npLang) {

  var ListItem = StandardListItem.extend({

    template: itemTemplate,
    searchLocationTemplate: searchLocationTemplate,

    templateHelpers: function () {

      return {
        'selected': this.selected ? 'icon-listview-checkmark' : '',
        'browsed': this.browsed ? 'icon-sidebar-expand24' : ''

      };
    },

    tagName: 'li',

    events: {
      'keydown': 'onKeyInView'
    },

    ui: {
      link: '.csui-list-group-item'
    },

    onKeyInView: function (event) {
      //left arrow is the same and enter/space
      if (event.keyCode === 39 || event.keyCode === 32 || event.keyCode === 13) {
        this.$el.trigger('click');
        this.$el.focus();
        return false;
      }
      return true;
    },

    constructor: function ListItem(options) {
      StandardListItem.apply(this, arguments);

      this.selected = false;
      this.browsed = false;
    },

    toggleSelect: function () {
      this.selected = !this.selected;
      this.render();
    },

    toggleBrowse: function () {
      this.browsed = !this.browsed;
      this.render();
    },

    assignedBrowseNSelect: function () {
      this.browsed = this.selected = true;
      this.render();
    },

    unassignBrowseNSelect: function () {
      if (!this.isDestroyed) {
        this.browsed = this.selected = false;
        this.render();
      }
    },

    isSelected: function () {
      return this.selected;
    },

    isBrowsed: function () {
      return this.browsed;
    },

    setValidity: function (valid) {
      this.valid = valid;
    },

    setEnable: function setEnable(enable) {
      if (enable) {
        this.$el.removeClass('csui-disabled');
        var elementNamePlus = _.str.sformat(npLang.itemTypeNameAria, this.model.get('type_name'),
            this.model.get('name'));
        if (!this.valid) {
          elementNamePlus = _.str.sformat(npLang.disabledItemTypeNameAria,
              this.model.get('type_name'), this.model.get('name'));
        }
        this.$el.attr('aria-label', elementNamePlus);
      } else {
        this.$el.addClass('csui-disabled');
        var disabledTitle = _.str.sformat(npLang.disabledItemTypeNameAria,
            this.model.get('type_name'), this.model.get('name'));
        this.$el.attr('aria-label', disabledTitle);
      }
    },

    onRender: function () {
      this.$el.addClass('cs-left-item-' + this.model.get('id'));
      this.$el.removeClass('select');
      this.$el.removeClass('browse');
      this.ui.link.removeAttr('aria-expanded', 'false');
      this.$el.removeAttr('aria-selected');
      this.$el.attr('role', 'option');
      this.setEnable(true);

      if (!this.options.searchView) {
        $(".binf-list-group").removeClass("search-left-item");
        if ($(".csui-np-content .csui-search-item-left-panel").is(":visible")) {
          $(".binf-list-group").addClass("search-left-folder-right");
        } else if ($(".cs-start-locations .binf-search-location-group").is(":visible")) {
          $(".binf-list-group").removeClass("search-left-folder-right");
        }
        if (this._nodeLocationIconView) {
          this._nodeLocationIconView.destroy();
        }
      }

      if (this._isBrowsable(this.model)) {
        this.ui.link.attr('aria-haspopup', 'true');
      }

      if (this.selected) {
        this.$el.addClass('select');
        this.ui.link.attr('aria-expanded', 'true');
        this.$el.attr('aria-selected', 'true');
      } else if (this.browsed) {
        this.$el.addClass('browse');
      }

      this._nodeIconView = new NodeTypeIconView({
        el: this.$('.csui-type-icon').get(0),
        node: this.model
      });

      var mimeTypeIconClassName = this._nodeIconView.model.get('className');
      mimeTypeIconClassName = this.valid ? mimeTypeIconClassName :
                              mimeTypeIconClassName + '_nonselectable';
      this._nodeIconView.model.set('className', mimeTypeIconClassName);

      var mimeTypeIconMainClassName = this._nodeIconView.model.get('mainClassName');
      mimeTypeIconMainClassName = this.valid ? mimeTypeIconMainClassName :
                                  mimeTypeIconMainClassName + '_nonselectable';
      this._nodeIconView.model.set('mainClassName', mimeTypeIconMainClassName);

      this._nodeIconView.render();
    },

    onBeforeDestroy: function () {
      if (this._nodeIconView) {
        this._nodeIconView.destroy();
      }
    },

    _openSearchLocation: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this._parent.triggerMethod("click:location", this.model.parent);
    },

    _isBrowsable: function (model) {
      // FIXME: Use permitted commands as soon as the server sends browse
      //return node.actions.get('browse');
      return model.get('container') && model.get('perm_see_contents') !== false;
    },

    getResolvedModel: function () {
      var model = this.model;
      if (this.options.resolveShortcuts && model.get('type') === 1 && model.original !==
          undefined) {
        model = model.original;
      }
      return model;
    }

  });

  return ListItem;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/node.list/node.list',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "search-left-item";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "\r\n<div class=\"list-content\">\r\n  <ul class=\"binf-list-group "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.searchView : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nodePickerChoices || (depth0 != null ? depth0.nodePickerChoices : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nodePickerChoices","hash":{}}) : helper)))
    + "\" role=\"listbox\"></ul>\r\n  <div class=\"binf-search-location-group\"></div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_node.list_node.list', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/node.list/empty.node.list',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <p class=\"csui-no-result-message\">\r\n      "
    + this.escapeExpression(((helper = (helper = helpers.noSearchResultMessage || (depth0 != null ? depth0.noSearchResultMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"noSearchResultMessage","hash":{}}) : helper)))
    + "\r\n    </p>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-no-result-wrapper\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,((stack1 = (depth0 != null ? depth0.noSearchResultMessage : depth0)) != null ? stack1.length : stack1),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</div>\r\n\r\n\r\n\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_node.list_empty.node.list', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/node.picker/impl/search.list/search.list',[],function(){});
csui.define('csui/dialogs/node.picker/impl/search.list/search.location.view',[
  'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone', 'csui/lib/marionette',
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'hbs!csui/dialogs/node.picker/impl/search.list/search.location.item',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/behaviors/default.action/default.action.behavior',
  'csui/models/node/node.model',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/utils/node.links/node.links',
  'css!csui/dialogs/node.picker/impl/search.list/search.list'
], function (_, $, Backbone, Marionette, lang, searchLocationTemplate,
    TabableRegion, DefaultActionBehavior, NodeModel, NodeTypeIconView,
    nodeLinks) {
  'use strict';

  var SearchLocationItemView = Marionette.ItemView.extend({
    constructor: function SearchLocationItemView(options) {
      options || (options = {});
      Marionette.View.prototype.constructor.apply(this, arguments); // apply (modified) options to this
    },

    triggers: {
      'click': 'click:location'
    },

    tagName: 'a',
    template: searchLocationTemplate,
    className: 'search-location-name',

    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      }
    },

    templateHelpers: function () {
      return {
        name: this.model.parent.get("name") ? this.model.parent.get("name") : lang.noValue
      };
    },

    onRender: function (e) {
      if (this.model.parent) {
        //adding url to item
        var node                     = new NodeModel(this.model.get(
            "parent_id_expand"), {connector: this.model.connector}),
            defaultLocationActionUrl = nodeLinks.getUrl(node);
        this.$el.prop("href", defaultLocationActionUrl);
        //Adding icon to item
        this._nodeIconViewLocation = new NodeTypeIconView({
          el: this.$('.csui-type-location-icon').get(0),
          node: this.model.parent
        });
        this._nodeIconViewLocation.render();
      }
    }
  });

  var SearchLocationView = Marionette.CollectionView.extend({
    childView: SearchLocationItemView,

    childEvents: {
      'click:location': 'onLocationClick'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    onAddChild: function (child) {
      child.$el.addClass('csui-acc-focusable');
    },

    childViewOptions: function () {
      return {
        notTabableRegion: this.options.notTabableRegion
      };
    },

    updateChildOptions: function (flag) {
      this.childViewOptions.notTabableRegion = true;
    },

    constructor: function SearchLocationView(options) {
      options || (options = {});
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
      this.focusIndex = 0;
      this.on('render', function () {
        var that = this;
        setTimeout(function () {that.trigger("dom:refresh");}, 100);
      });
    },

    onLocationClick: function (node) {
      this.trigger("click:location", node.model.parent);
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    isTabable: function () {
      return this.children.find(function (view) {
        var $el = view.$el;
        return ($el.is(':visible') && !$el.is(':disabled'));
      });
    },

    currentlyFocusedElement: function () {
      var focusables = this.$el.find('.search-location-name.csui-acc-focusable');
      if (focusables.length) {
        return $(focusables[this.focusIndex]);
      }
    },

    setFocus: function () {
      var focusables = this.$el.find('.search-location-name.csui-acc-focusable');
      $(focusables[this.focusIndex]).focus();
    },

    onKeyInView: function (event) {
      var keyCode    = event.keyCode,
          focusables = this.$el.find('.search-location-name.csui-acc-focusable');

      switch (keyCode) {

          //up arrow
          //down arrow
      case 38:
      case 40:
        if (keyCode === 38) {
          this.focusIndex > 0 && --this.focusIndex;
        }
        else {
          this.focusIndex < (focusables.length - 1) && ++this.focusIndex;
        }
        if (document.activeElement.classList.contains("search-location-name")) {
          focusables = this.$el.find('.search-location-name.csui-acc-focusable');
        }
        this.trigger('changed:focus');
        $(focusables[this.focusIndex]).focus();
        break;
      }
    }
  });

  return SearchLocationView;
});

csui.define('css!csui/dialogs/node.picker/impl/node.list/node.list',[],function(){});
// Shows a list of items
csui.define('csui/dialogs/node.picker/impl/node.list/node.list.view',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/marionette', 'csui/lib/backbone',
  'csui/dialogs/node.picker/impl/node.list/list.item.view',
  "csui/controls/progressblocker/blocker",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  "csui/models/node/node.model",
  'hbs!csui/dialogs/node.picker/impl/node.list/node.list',
  'hbs!csui/dialogs/node.picker/impl/node.list/empty.node.list',
  'csui/dialogs/node.picker/impl/search.list/search.location.view',
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'css!csui/dialogs/node.picker/impl/node.list/node.list'
], function (_, $, Marionette, Backbone, ListItem, BlockingView, TabableRegion,
    PerfectScrollingBehavior, NodeModel, listTemplate, empty, SearchLocationView, npLang) {
  'use strict';

  var NoChildrenView = Marionette.ItemView.extend({
    template: empty,

    constructor: function NoSearchResultView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.model, 'change', this.render);
    }
  });

  var NodeListView = Marionette.CompositeView.extend({

    className: 'cs-list',

    template: listTemplate,

    emptyView: NoChildrenView,

    emptyViewOptions: function () {
      return {
        model: this.emptyModel
      };
    },

    templateHelpers: function () {
      return {
        searchView: this.options.searchView,
      };
    },

    childViewContainer: '.binf-list-group',
    childView: ListItem,

    childViewOptions: function () {
      return {
        searchView: this.options.searchView,
        locationEle: this.ui.location,
        resolveShortcuts: this.options.resolveShortcuts
      };
    },

    childEvents: {
      'click:item': 'onItemClick',
      'before:add:child': 'onBeforeAddChild',
      'change:child': 'onChangeChild'
    },

    ui: {
      listParent: '.list-content',
      list: '.binf-list-group',
      location: '.binf-search-location-group'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    onBeforeAddChild: function (child) {
      var childModel  = child.model,
          validTarget = this.commandType.validateTarget(childModel),
          // TODO: Refactor usage of validateTarget and isSelectable, so that
          // only the node, which has been already set in the shortcut location,
          // can be rendered as non-selectable here, but not the other non-selectables
          childId     = childModel.get('id');
      validTarget = validTarget && _.every(this.commandType.unselectableNodes,
          function (unselectableId) {
            return childId !== unselectableId;
          });
      child.setValidity(validTarget);
    },

    onChangeChild: function (childModel) {
      if (childModel === this.collection) {
        // Not interested in collection change. Skip
        return;
      }
      var child = this.children.findByModel(childModel);
      child.render();
      this.validateAndUpdateChild(child);
    },

    //with infinite scrolling, need to keep track of selected nodes and
    //reselect them after a re-render.
    //Also need to reset items after a filter request.
    onAddChild: function (child) {
      var id = child.model.get('id');

      if (this.selectItems[id]) {
        this.selectItems[id] = child;
        this.toggleSelectedChild(child);
      }
      this.validateAndUpdateChild(child);
      if (this.browsedChild && (this.browsedChild.model.get('id') === id)) {
        this.browsedChild = child;
        this.toggleBrowsedChild(child);
      }
      return true;
    },

    shouldDisable: function (node) {
      if (node === undefined) {
        return true;
      }
      if (this.commandType.isActionNode(node)) {
        return true;
      }
      if (this.options.resolveShortcuts && node.get('type') === 1 && node.original !== undefined) {
        return this.shouldDisable(node.original);
      }
      return (!this.commandType.isSelectable(node) && !this._isBrowsable(node));
    },

    validateAndUpdateChild: function (child) {
      if (!this.options.searchView && !this.commandType.validateNode(child.getResolvedModel())) {
        child.$el.hide();
      } else {
        child.$el.addClass('csui-acc-focusable');
      }

      var disable = this.shouldDisable(child.model);
      child.setEnable(!disable);

      if (this._isBrowsable(child.model)) {
        child.ui.link.attr('aria-haspopup', 'true');
        child.ui.link.attr('aria-expanded', 'false');
      } else {
        child.ui.link.removeAttr('aria-haspopup');
        child.ui.link.removeAttr('aria-expanded');
      }
    },

    collectionEvents: {'sync': 'syncUpdate', 'change': 'onChangeChild'},

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '> .list-content',
        suppressScrollX: true
      },

      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    isTabable: function () {
      return this.children.find(function (view) {
        var $el = view.$el;
        return ($el.is(':visible') && !$el.is(':disabled'));
      });
    },

    currentlyFocusedElement: function () {
      var focusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');
      if (focusables.length) {
        return $(focusables[this.focusIndex]);
      }
    },

    setFocus: function () {
      var focusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');
      $(focusables[this.focusIndex]).focus();
    },

    onKeyInView: function (event) {
      var keyCode    = event.keyCode,
          focusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');

      switch (keyCode) {

      case 9:
        if (!document.activeElement.classList.contains("search-location-name")) {
          this.locationView.focusIndex = this.focusIndex;
        }
        break;
          //up arrow
          //down arrow
      case 38:
      case 40:
        if (keyCode === 38) {
          this.focusIndex > 0 && --this.focusIndex;
        }
        else {
          this.focusIndex < (focusables.length - 1) && ++this.focusIndex;
        }
        if (document.activeElement.classList.contains("search-location-name")) {
          focusables = this.$el.find('.search-location-name.csui-acc-focusable');
        }
        this.trigger('changed:focus');
        $(focusables[this.focusIndex]).focus();
        break;
      case 35: //end
        this.focusIndex = this.collection.length - 1;
        this.trigger('changed:focus');
        $(focusables[this.focusIndex]).focus();
        break;
      case 36: //home
        this.focusIndex = 0;
        this.trigger('changed:focus');
        $(focusables[this.focusIndex]).focus();
        break;
      }
    },

    constructor: function NodeListView(options) {
      options || (options = {});
      _.defaults(options, {pageSize: 30});

      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this.jQuery = $;
      BlockingView.imbue(this);

      this.selectItems = _.extend({}, options.selection);
      this.blockScroll = true;
      this.notFetching = true;
      this.init = true;         //makes sure only one blocker is activated at a given time due to an end-of-scroll.
      this.nextCollectionPage = _.bind(this.addNextCollectionPage, this);
      this.commandType = options.commandType;
      this.focusIndex = 0;         //used for accessiblity

      this.emptyModel = new Backbone.Model({
        noSearchResultMessage: ''
      });
      this.listenTo(this.collection, 'sync', function () {
        if (this.collection.totalCount === 0) {
          $(".binf-list-group").removeClass("search-left-item");
          this.$el.find(".binf-list-group").addClass("csui-no-results");
        } else {
          this.$el.find(".binf-list-group").removeClass("csui-no-results");
        }
        this.emptyModel.set('noSearchResultMessage', npLang.noSearchResultMessage);
      });
      this.locationView = new SearchLocationView({
        collection: this.collection
      });
      this.listenTo(this.locationView, "click:location", this.onClickLocation);
      this.listenTo(this.collection, "request", this.setBlocker);
      this.listenTo(this.collection, "reset", this.setBlocker);
      this.listenTo(this, "browse:complete", function () {
        this.notFetching = true;
      });

    },

    onRender: function (e) {
      var locationRegion = new Marionette.Region({
        el: this.ui.location
      });
      if (this.options.searchView) {
        locationRegion.show(this.locationView);
      }
    },

    onClickLocation: function (node) {
      this.trigger("click:location", node);
    },

    syncUpdate: function () {
      this.nextTriggerSetting = this.options.pageSize / 2;
      this.blockScroll = true;
      this.notFetching = true;
      this.init = true;

      this.unblockActions();
      this.confirmSelectionList();
      this.trigger('dom:refresh');
    },

    //Public - called to reset the scroll position after a search.
    reset: function () {
      this.init = true;

      if (this.scrollBar) {
        this.scrollBar.scrollTop(0);
      }
    },

    stopBlocker: function () {
      this.unblockActions();
      return true;
    },

    //Make sure to only set the blocker once.
    setBlocker: function () {
      if (this.blockScroll) {
        this.blockScroll = false;
        this.blockActions();
      }
      return true;
    },

    addNextCollectionPage: function (event, args) {
      var collectionLength  = this.collection.length,
          scrollableHeight  = this.ui.list.height() - this.ui.listParent.height(),
          scrollRelativePos = this.ui.listParent.scrollTop() / scrollableHeight,
          nextJump          = (collectionLength - this.nextTriggerSetting) / collectionLength;

      if (collectionLength < this.collection.totalCount &&
          (scrollRelativePos >= nextJump)) {
        var self = this;
        if (this.notFetching) {
          this.notFetching = false;
          this.collection.setSkip(collectionLength, false);
          this.collection.fetch({
            reset: false,
            remove: false,
            merge: false
          }).done(function () {
            if (self.options.resolveShortcuts) {
              var nodesToResolve = self.collection.filter(function (node, index) {
                return (index >= collectionLength) && self.commandType.shouldResolveShortcut(node);
              });
              self.resolveShortcuts(nodesToResolve);
            }
          });
        }

        //Postpone progress blocker until user scrolls to the bottom. In the mean time
        //a request for more items has been made.
        if (scrollRelativePos > 0.98 && this.init) {
          this.setBlocker();
          this.init = false;
        }
      }
    },

    /**
     * Fetch original nodes of Shortcut to browse though and be able to select those items.
     */
    resolveShortcuts: function (collection) {
      var self              = this,
          shortcutDeferreds = [];
      if (!self.options.resolveShortcuts) {
        // No required to resolve shortcuts.
        return $.Deferred().resolve();
      }

      collection.filter(self.commandType.shouldResolveShortcut)
          .forEach(function (node) {
            // Original Node needs to be resolved.
            var originalId = node.original !== undefined ? node.original.get('id') :
                             node.original_id;
            var original = new NodeModel({id: originalId}, {
              connector: node.connector
            });
            shortcutDeferreds.push(original.fetch().done(function () {
              node.original = original;
              node.trigger('change', node);
            }));
          });
      return $.whenAll.apply($, shortcutDeferreds);
    },

    onDomRefresh: function () {
      if (!this.scrollBar) {
        this.scrollBar = this.ui.listParent;
        this.scrollBar.on('scroll', this.nextCollectionPage);
      }
    },

    onItemClick: function (child) {
      //Trigger action to close any binf-dropdown
      Backbone.trigger('closeToggleAction');
      if (child.$el.hasClass('csui-disabled')) {
        return;
      }
      if (this.options.searchView) {
        this.childView = ListItem;
        this._processClickedItem(child);
        if (child.getResolvedModel().get("container")) {
          this.jQuery(".csui-node-picker .binf-search-location-group").addClass('binf-hidden');
          this.jQuery(".csui-node-picker .csui-search-item-right-panel").addClass('binf-hidden');
        }
      } else {
        this._processClickedItem(child);
        this.options.searchView = false;
        child.options.searchView = false;
      }
      var clickedFocusables = this.$el.find('.binf-list-group-item.csui-acc-focusable');
      this.focusIndex = $(clickedFocusables).index(child.el);
      this.trigger('changed:focus');
      $(clickedFocusables[this.focusIndex]).focus();
    },

    _processClickedItem: function (child) {
      var browseable = this._isBrowsable(child.getResolvedModel());

      //ignore click item if still fetching collections.
      if (this.notFetching) {
        this.notFetching = false;

        if (!browseable) {
          this._targetSelection(child);
        } else {
          this._browseSelection(child);
        }
        child.$el.blur();
      }

      //In order set focus to the parent view after a 'enter/space' keycode event,
      //we  send a setCurrentTabFocus event. The parent will
      //then set focus to itself. This is needed for Dialog accessiblity.
      this.$el.trigger('setCurrentTabFocus');
      return true;
    },

    clearSelect: function () {
      var self = this;

      _.each(this.selectItems, function (item) {
        self.toggleSelectedChild(item);
      });
      this.selectItems = {};
      return true;
    },

    toggleSelectedChild: function (child) {
      if (this.commandType.isSelectable(child.getResolvedModel())) {
        child.toggleSelect();
      }
    },

    toggleBrowsedChild: function (child) {
      child && child.toggleBrowse();
    },

    confirmSelectionList: function () {
      _.each(this.selectItems, function (node, id) {
        var itemModel = _.find(this.collection.models, function (model) {
          return model.get('id').toString() === id;
        });
        //In multiSelect, don't delete the selected items even though search results does not have them
        if (!itemModel && !this.commandType.multiSelect) {
          delete this.selectItems[id];
          this.trigger('selection:change', {node: this._getNodeForSelection(node), add: false});
        }
      }, this);
    },

    _isBrowsable: function (node) {
      // FIXME: Use permitted commands as soon as the server sends browse
      //return node.actions.get('browse');
      if (this.options.resolveShortcuts &&
          node.get('type') === 1 && node.original !== undefined) {
        return this.commandType.browseAllowed(node.original);
      }
      return this.commandType.browseAllowed(node);
    },

    //Selection without browse
    _targetSelection: function (child) {
      var model        = this._getNodeForSelection(child),
          childId      = model.get('id'),
          prevSelected = child.isSelected();

      //remove selection
      if (prevSelected) {
        this.toggleSelectedChild(child);
        delete this.selectItems[childId];

      } else {
        if (!this.commandType.multiSelect) {
          this.clearSelect();
        }
        this.selectItems[childId] = child;
        this.toggleSelectedChild(child);
      }

      this.trigger('selection:change', {node: model, add: !prevSelected});
      this.notFetching = true;
    },

    _browseSelection: function (child) {
      var node            = child.getResolvedModel(),
          selectableType  = this.commandType.isSelectableType(node),
          browsable       = this.commandType.browseAllowed(node),
          selectable      = this.commandType.isSelectable(node),
          alreadyBrowsed  = child.isBrowsed(),
          alreadySelected = child.isSelected(),
          addToSelection  = false;

      if (alreadyBrowsed || alreadySelected) {
        selectable && this._targetSelection(child);
        this.notFetching = true;
      }
      else {
        if (selectable) {
          this._browseNSelect(child);
          addToSelection = true;
        } else {
          if (browsable || selectableType) {
            this.clearSelect();
            addToSelection = true;
          }
          this.toggleBrowsedChild(child);
        }

        this.options.searchView = false;
        child.options.searchView = false;
        this._browse(child, addToSelection);
        if (addToSelection) {
          this.trigger('selection:change',
              {node: this._getNodeForSelection(child), silent: true, add: addToSelection});
        }
      }
    },

    _browse: function (child, addToSelection) {
      var self = this;
      this.browsedChild && this.browsedChild.toggleBrowse();
      this.browsedChild = child;
      child.ui.link.attr('aria-expanded', 'true');

      this.trigger('browse:select', {node: child.getResolvedModel(), add: addToSelection});
    },

    _browseNSelect: function (child) {
      var childId = this._getNodeForSelection(child).get('id');
      if (!this.commandType.multiSelect) {
        this.clearSelect();
      }
      this.selectItems[childId] = child;
      child.assignedBrowseNSelect();
    },

    _getNodeForSelection: function (child) {
      var node = child.model;
      if (this.options.resultOriginalNode && child.model.original != null) {
        node = child.model.original;
      }
      return node;
    }

  });

  return NodeListView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/select.view/impl/header/header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-search-item-left-panel\">\r\n    <div class=\"csui-search-item-type\">\r\n      <span class=\"csui-type-label\"> "
    + this.escapeExpression(((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"type","hash":{}}) : helper)))
    + " </span>\r\n    </div>\r\n    <div class=\"csui-search-item\">\r\n      <div class=\"csui-search-item-name\">\r\n        "
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div class=\"csui-search-item-right-panel\">\r\n    <div class=\"csui-search-item-location\">\r\n      <div class=\"csui-search-toolbar-container\">\r\n        "
    + this.escapeExpression(((helper = (helper = helpers.location || (depth0 != null ? depth0.location : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"location","hash":{}}) : helper)))
    + "\r\n      </div>\r\n    </div>\r\n  </div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-folder-name\">\r\n    <h3 class=\"folder-name\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h3>\r\n    <span class=\"cs-icon icon-sv-search csui-acc-focusable\" tabindex=\"0\" data-cstabindex=\"-1\"\r\n          role=\"button\" aria-expanded=\"false\" aria-haspopup=\"true\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.searchInButtonAria || (depth0 != null ? depth0.searchInButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"searchInButtonAria","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.searchInButtonAria || (depth0 != null ? depth0.searchInButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"searchInButtonAria","hash":{}}) : helper)))
    + "\"></span>\r\n  </div>\r\n\r\n  <form class=\"cs-modal-filter\">\r\n    <div class=\"binf-form-group\">\r\n      <input class=\"binf-form-control cs-filter-input\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\"\r\n             tabindex=\"0\" data-cstabindex=\"-1\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\">\r\n      <span class=\"binf-form-control-feedback cs-icon icon-formfield-clear\" role=\"button\"\r\n            title=\""
    + this.escapeExpression(((helper = (helper = helpers.clearSearchButtonAria || (depth0 != null ? depth0.clearSearchButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"clearSearchButtonAria","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.clearSearchButtonAria || (depth0 != null ? depth0.clearSearchButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"clearSearchButtonAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\" data-cstabindex=\"-1\"></span>\r\n\r\n      <button class=\"binf-btn csui-form-control-search\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.collapseSearch || (depth0 != null ? depth0.collapseSearch : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"collapseSearch","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.collapseSearch || (depth0 != null ? depth0.collapseSearch : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"collapseSearch","hash":{}}) : helper)))
    + "\" aria-expanded=\"true\" aria-haspopup=\"true\"\r\n              tabindex=\"0\" data-cstabindex=\"-1\">\r\n        <span class=\"form-control-search cs-icon icon-sv-search-hide\"></span>\r\n      </button>\r\n    </div>\r\n  </form>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <div class=\"csui-targetbrowse-history\">\r\n      <span class=\"csui-targetbrowse-arrow-back\">\r\n        <span class=\"icon arrow_back cs-go-back\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.backButtonTooltip || (depth0 != null ? depth0.backButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"backButtonTooltip","hash":{}}) : helper)))
    + "\"\r\n              aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.backButtonAria || (depth0 != null ? depth0.backButtonAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"backButtonAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\" data-cstabindex=\"-1\"\r\n              role=\"link\"></span>\r\n      </span>\r\n  </div>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.searchView : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_select.view_impl_header_header', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/node.picker/impl/select.view/impl/header/header',[],function(){});
csui.define('csui/dialogs/node.picker/impl/select.view/impl/header/header.view',["csui/lib/underscore", "csui/lib/jquery", "csui/lib/marionette", 'csui/lib/backbone',
  "csui/behaviors/input/placeholder", "i18n!csui/controls/table/impl/nls/lang",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  "hbs!csui/dialogs/node.picker/impl/select.view/impl/header/header",
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  "css!csui/dialogs/node.picker/impl/select.view/impl/header/header",
  'csui/lib/jquery.ui/js/jquery-ui'
], function (_, $, Marionette, Backbone, PlaceholderBehavior, lang, TabableRegionBehavior, template,
    dialogLang) {

  var HeaderView = Marionette.ItemView.extend({

    template: template,
    tagName: 'div',

    templateHelpers: function () {
      return {
        search_icon_tooltip: _.str.sformat(lang.searchIconTooltip, this.options.columnTitle),
        search_placeholder: lang.searchByNamePlaceholder,
        search_clear_icon_tooltip: lang.searchClearIconTooltip,
        title: this.title,
        backButtonTooltip: dialogLang.backButtonTooltip,
        type: dialogLang.Type,
        name: dialogLang.Name,
        location: dialogLang.Location,
        searchView: this.options.searchView,
        searchInButtonAria: _.str.sformat(lang.searchPlaceholder, this.title),
        clearSearchButtonAria: dialogLang.clearSearchButtonAria,
        collapseSearch: dialogLang.collapseSearch,
        backButtonAria: dialogLang.backButtonTooltip
      };
    },

    ui: {
      searchBox: '> form.cs-modal-filter',
      closeSearchIcon: '> form .csui-form-control-search',
      openSearchIcon: '> .csui-folder-name .icon-sv-search',
      headerTitle: '> .csui-folder-name',
      searchInput: '> form .cs-filter-input',
      clearer: '> form .binf-form-control-feedback',
      tabElements: '> *[tabindex]',
      backBtn: '.csui-targetbrowse-history'
    },

    events: {
      'click .icon-sv-search': 'searchClicked',
      'click .csui-form-control-search': 'searchClicked',
      'paste @ui.searchInput': 'contentPasted',
      'change @ui.searchInput': 'filterChanged',
      'click @ui.clearer': 'searchFieldClearerClicked',
      'submit @ui.searchBox': 'filterChanged',
      'keydown': 'onKeyInView'
    },

    behaviors: {
      Placeholder: {
        behaviorClass: PlaceholderBehavior
      },

      TabableRegionBehavior: {
        behaviorClass: TabableRegionBehavior
      }
    },

    constructor: function HeaderView(options) {
      this.options = options || {};
      this.container = options.container;
      this.lastFilterValue = "";
      this.title = options.title;
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      if (this.container) {
        this.listenTo(this.container, 'change:name', function (node) {
          this.title = node.get('name');
          this.render();
        });
      }
    },

    currentlyFocusedElement: function (event) {
      //change the input and icons back to tabindex = 0. Tabable behavior sets all tabindex to -1, which doesn't work for
      //this scenario
      var focusables = this.$el.find('*[data-cstabindex=-1]');
      if (focusables.length) {
        focusables.prop('tabindex', 0);
      }
      if (focusables.length > 1) {
        if (this.$el.find('.cs-go-back:visible').length && !event.shiftKey) {
          return this.$el.find('.cs-go-back');
        } else if (this.$el.find('.csui-folder-name.binf-hidden').length && !event.shiftKey) {
          return this.$el.find('input');
        } else if (this.$el.find('.csui-folder-name.binf-hidden').length && event.shiftKey) {
          return this.$el.find('button');
        } else {
          return this.$el.find('.csui-folder-name .icon-sv-search');
        }
      } else {
        return focusables[0];
      }
      return true;
    },

    onLastTabElement: function (shiftTab) {
      var tabItems = this.$('[data-cstabindex=-1]'),
          lastItem = tabItems.length - 1;

      if (tabItems.length) {
        var focusElement = shiftTab ? tabItems[0] : tabItems[lastItem];
        this.$('.csui-focus').removeClass('csui-focus');
        return $(focusElement).hasClass(TabableRegionBehavior.accessibilityActiveElementClass) &&
               !shiftTab;
      }

      return true;
    },

    onKeyInView: function (event) {
      var bubbleEvent = false,
          target      = $(event.target);
      switch (event.keyCode) {
          //Enter
      case 13:
        target.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        $(event.target).trigger('click');
        break;

          //escape
      case 27:
        if (!$(event.target).hasClass('.icon-sv-search')) {
          this.$el.trigger('tabNextRegion');
        }
        break;
      default:
        return true;
      }
      return bubbleEvent;
    },

    onRender: function () {
      this.ui.clearer.toggle(false);
      this.ui.searchBox.toggleClass('binf-hidden');
      this.ui.closeSearchIcon.toggleClass('binf-hidden');
      this.ui.searchInput.hide();

      var self = this;
      this.ui.searchInput.keyup(function (e) {
        self.filterChanged(e);
      });
      this.$el.find('*[data-cstabindex]').on('focus', function () {
        var target = $(this);
        self.focusedElement &&
        self.focusedElement.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        target.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        self.focusedElement = target;
      });
    },

    searchClicked: function (event) {
      event.preventDefault();
      event.stopPropagation();
      //Trigger action to close any binf-dropdown
      Backbone.trigger('closeToggleAction');

      this.ui.headerTitle.toggleClass('binf-hidden');
      this.ui.searchInput.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);

      this.ui.clearer.toggle(false);
      if (this.getValue().length) {
        // If the filter has just been hidden, reset the filtering value to show all items again
        this.ui.searchInput.val('');
        this.filterChanged(event);
      }
      this.ui.searchInput.toggle(200, 'linear', _.bind(function () {
        this.ui.searchInput.focus();
        this.ui.closeSearchIcon.toggleClass('binf-hidden');
      }, this));

      this.ui.closeSearchIcon.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.ui.closeSearchIcon.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);

      this.ui.openSearchIcon.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.ui.searchBox.toggleClass('binf-hidden');

      if ($(event.target).hasClass('form-control-search')) {
        this.ui.searchInput.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        this.ui.openSearchIcon.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        this.$el.trigger('setCurrentTabFocus');
      }
      else {
        this.ui.searchInput.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        this.ui.openSearchIcon.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
      }
      this.trigger('changed:focus');
      this.focusElement && this.focusElement.focus();
    },

    searchFieldClearerClicked: function (e) {
      e.preventDefault();
      e.stopPropagation();
      this.ui.clearer.removeClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.ui.clearer.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
      this.ui.searchInput.val('');
      this.filterChanged(e);
      this.ui.searchInput.focus();
      this.ui.searchInput.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
    },

    getColumn: function () {
      return this.options.column;
    },

    getValue: function () {
      var filterValue;

      filterValue = this.ui.searchInput.val();
      if (filterValue === this.ui.searchInput.attr('placeholder')) {
        filterValue = '';
      }

      return filterValue;
    },

    setValue: function (val) {
      if (val && val.length) {
        this.ui.searchInput.val(val);
        this.lastFilterValue = val;
      }
    },

    getShown: function () {
      return this.ui.searchInput.hasClass('binf-show');
    },

    setShown: function (show) {
      if (show === true && this.ui.searchInput.hasClass('binf-hidden')) {
        this.ui.searchInput.toggleClass('show binf-hidden');
      } else if (show === false && this.ui.searchInput.hasClass('binf-show')) {
        this.ui.searchInput.toggleClass('show binf-hidden');
      }
    },

    setFocus: function () {
      var textLen = this.ui.searchInput.val().length;
      this.ui.searchInput.focus();
      this.ui.searchInput[0].setSelectionRange(textLen, textLen);
    },

    contentPasted: function (event) {
      this.applyFilter();
    },

    filterChanged: function (event) {
      this.applyFilter();

      return false;
    },

    applyFilter: function () {
      var filterValue = this.getValue();
      var filterHasValue = !!filterValue.length;
      this.ui.clearer.toggle(filterHasValue);

      if (filterHasValue) {
        this.ui.clearer.addClass(TabableRegionBehavior.accessibilityFocusableClass);
      }
      else {
        this.ui.clearer.removeClass(TabableRegionBehavior.accessibilityFocusableClass);
      }

      if (this.lastFilterValue != filterValue) {
        this.lastFilterValue = filterValue;
        var self = this;
        if (this.filterTimeout) {
          clearTimeout(this.filterTimeout);
        }
        this.filterTimeout = setTimeout(function () {
          self.filterTimeout = undefined;
          self.trigger('change:filterValue', {name: self.getValue()});
        }, 1000);
      }
    }

  });

  return HeaderView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/select.view/impl/select.view',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div>\r\n  <div class=\"csui-np-header cs-folder-name\"></div>\r\n</div>\r\n<div class=\"csui-np-content\"></div>\r\n\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_select.view_impl_select.view', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/node.picker/impl/select.view/impl/select.view',[],function(){});
csui.define(
    'csui/dialogs/node.picker/impl/select.view/select.view',["module", "csui/lib/jquery", "csui/lib/underscore", 'csui/lib/backbone', "csui/lib/marionette",
      "csui/utils/log", "csui/utils/base",
      'csui/dialogs/node.picker/impl/node.list/node.list.view',
      'csui/dialogs/node.picker/impl/select.view/impl/header/header.view',
      'hbs!csui/dialogs/node.picker/impl/select.view/impl/select.view',
      'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
      'csui/behaviors/keyboard.navigation/tabable.region.behavior',
      'i18n!csui/dialogs/node.picker/impl/nls/lang',
      'css!csui/controls/list/impl/list',
      'css!csui/dialogs/node.picker/impl/select.view/impl/select.view'
    ], function (module, $, _, Backbone, Marionette, log, base,
        NodeListView, HeaderView, template, LayoutViewEventsPropagationMixin,
        TabableRegionBehavior, lang) {

      var SelectView = Marionette.LayoutView.extend({

        template: template,
        templateHelpers: function () {
          var langtext,tooltiptext = '';
          if (this.options.targetBrowseHistory.length) {
            langtext = this.options.targetBrowseHistory[this.options.targetBrowseHistory.length-1];
            if (langtext[0] === 'search') {
              tooltiptext = lang.backToSearchAria;
            } else if (langtext[0] === 'location') {
              tooltiptext = lang.backToFolderView;
            }
            else if (langtext[0] === 'node') {
              tooltiptext = lang.backToFolderView;
            }
            else {
              tooltiptext = '';
            }

          }
          return {
            backButtonTooltip: lang.backButtonTooltip,
            backButtonAria: tooltiptext != '' ? tooltiptext : lang.backToFolderView
          };
        },
        regions: {
          viewHeaderRegion: '.csui-np-header',
          viewContentRegion: '.csui-np-content'
        },
        ui: {
          "backSearchButton": ".csui-targetbrowse-arrow-back"
        },

        events: {
          'tabNextRegion': 'tabNextRegion',
          'click @ui.backSearchButton': 'onClickFolderBack',
          'keydown @ui.backSearchButton': 'selectFolderBack'
        },

        behaviors: {
          TabableRegion: {
            behaviorClass: TabableRegionBehavior,
            recursiveNavigation: true,
            containTabFocus: true
          }
        },

        constructor: function SelectView(options) {
          options || (options = {});
          _.defaults(options, {pageSize: 30});

          Marionette.LayoutView.prototype.constructor.call(this, options);

          this.search = false;
          this.rendered = false;
          this.selectList = {};

          this.collection = options.collection;
          this.container = options.container;

          this.propagateEventsToRegions();

          this.listenTo(this.collection, "sync", this._handlePendingFilter);

          this.setHeader(options);
          this.setListView(options);
          this.onWinRefresh = _.bind(this.windowRefresh, this);
          $(window).bind("resize.app", this.onWinRefresh);
        },
        tabNextRegion: function (event) {
          if (this.listView.currentlyFocusedElement()) {
            event.preventDefault();
            event.stopPropagation();
            this.listView.setFocus();
          }
        },

        windowRefresh: function () {
          //due to chrome not recognizing parent height, dynamically set through css,
          //the select view height must be coded.
          var parentHeight = this.options.parentEl.height();
          if ((!!window.chrome || (navigator.userAgent.indexOf("Firefox") > 0) ) &&
              parentHeight > 0) {
            this.$el.css('height', parentHeight + 'px');
          }
        },
        onDestroy: function () {
          this.$el.off();
          $(window).unbind("resize.app", this.onWinRefresh);
        },

        onRender: function () {
          var self        = this,
              contentList = self.$el.find('.csui-np-content');

          this.viewHeaderRegion.show(this.headerView);
          this.viewContentRegion.show(this.listView);
          this.$el.hover(function () {
            contentList.addClass('binf-focus');
          }, function () {
            contentList.removeClass('binf-focus');
          });

       this.$el.find('*[data-cstabindex]').on('focus', function () {
            var target = $(this);
            self.focusedElement &&
            self.focusedElement.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
            target.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
            self.focusedElement = target;
          });

          this.rendered = true;
          this.trigger('dom:refresh');
        },

        onDomRefresh: function () {
          this.windowRefresh();
        },

        onShow: function () {
          if (!this.rendered) {
            this.render();
          }

          _.each(this.regionManager._regions, function (region) {
            if (region.currentView) {
              region.currentView.trigger('show');
            }
          });
        },

        getNumberOfSelectItems: function () {
          return _.size(this.selectList);
        },

        setNewSelect: function (node, silent) {
          this.clearSelect();
          this._setSelection({node: node, add: true, silent: silent});
        },

        isTabable: function () {
          return this.$('*[tabindex]').length > 0;
        },

        currentlyFocusedElement: function (event) {
          var focusables = this.$el.find('*[tabindex=-1]');
          if (focusables.length) {
            focusables.prop('tabindex', 0);
          }

        /* if (!!event && event.shiftKey && event.keyCode === 9) {
            return $(focusables[focusables.length - 1]);
          } else {
            return $(focusables[0]);
          }
          if (this.focusedElement) {
            return this.focusedElement;
          } */
          if (this.$el.find('.csui-folder-name.binf-hidden').length) {
            return this.$el.find('input');
          } else if (this.$el.find('.csui-targetbrowse-arrow-back .cs-go-back:visible').length && !event.shiftKey) {
            return this.$el.find('.csui-targetbrowse-arrow-back .cs-go-back');
          } else {
            return this.$el.find('.csui-folder-name .icon-sv-search');
          }
        },

        onLastTabElement: function (shiftTab) {
          var tabItems = this.$('[data-cstabindex=-1]'),
              lastItem = tabItems.length - 1;

          if (tabItems.length) {
            var focusElement = shiftTab ? tabItems[0] : tabItems[lastItem];
            this.$('.csui-focus').removeClass('csui-focus');
            return $(focusElement).hasClass(TabableRegionBehavior.accessibilityActiveElementClass);
          }

          return true;
        },

        clearSelect: function () {
          this.listView.clearSelect();
          this.selectList = {};
        },

        setListView: function (options) {
          options || (options = {});
          var self = this,
              args = {
                collection: this.collection,
                container: this.container,
                commandType: options.commandType,
                pageSize: options.pageSize,
                searchView: options.searchView,
                resolveShortcuts: options.resolveShortcuts,
                resultOriginalNode: options.resultOriginalNode,
                context: options.context
              };

          var listView = this.listView = new NodeListView(args);
          this.listenTo(listView, 'selection:change', this._setSelection)
              .listenTo(listView, 'click:location', this._clickLocation)
              .listenTo(listView, 'browse:select',
                  _.bind(this.trigger, this, 'browse:select', this))
              .listenTo(this, "browse:complete",
                  _.bind(listView.trigger, listView, 'browse:complete'));
        },

        selectFolderBack: function (event) {
          if (event.keyCode === 13 || event.keyCode === 32) {
            this.trigger("backbutton:click", this);
          }
        },

        onClickFolderBack: function (event) {
          this.trigger("backbutton:click", this);
        },

        setHeader: function (options) {
          var title = this.container && (this.container.get('name') || '');
          title = (title == null) ? this.options.locationName : title;

          this.headerView = new HeaderView({
            title: title,
            container: this.container,
            searchView: options.searchView
          });

          this.listenTo(this.headerView, 'change:filterValue', this.applyFilter);
        },

        applyFilter: function (searchInfo) {
          //add supported types
          _.extend(searchInfo, {type: this.options.listTypes});
          if (this.collection.fetching) {
            this.filterValuePending = searchInfo;
          }
          else {
            //reset the collections start position
            var self = this;
            this.collection.setLimit(0, this.options.pageSize, false);
            this.collection.setFilter(searchInfo, false);
            this.collection.fetch({reset: true})
                .fail(function (resp) {
                  self.listView.stopBlocker();
                  self.trigger('search:failed', {resp: resp, view: self});
                });
            this.listView.reset();
          }

        },

        refresh: function () {
          var self = this;
          this.collection.fetch({reset: true})
              .fail(function () {
                self.listView.stopBlocker();
              });
        },

        addFolderSelection: function (node) {
          this._setSelection({browse: true, add: true, node: node});
        },

        _handlePendingFilter: function () {

          //header search
          if (!_.isEmpty(this.filterValuePending)) {
            this.collection.setFilter(this.filterValuePending);
            this.filterValuePending = {};
          }
        },

        _setSelection: function (args) {
          var id          = args.node.get('id'),
              commandType = this.options.commandType;

          !commandType.multiSelect && (this.selectList = {});

          if (args.add && commandType.isSelectable(args.node)) {
            if(!!commandType.multiSelect) {
              var self = this;
              _.each(this.selectList, function (list) {
                var parentNode = args.node.parent;
                // resetting the selection, while switching selections in left and right sides.
                if (list.get("id") === parentNode.get("id")) {
                  self.selectList = {};
                }
              });
            }

            this.selectList[id] = args.node;
          }
          else {
            delete this.selectList[id];
            if(!commandType.multiSelect){
              this.trigger('clear:selectList', args, this);
            }

          }

          if (!args.silent) {
            this.trigger('selection:change', args, this);
          }
        },

        _clickLocation: function (args) {
          this.trigger('click:location', args, this);
        }

      });

      _.extend(SelectView.prototype, LayoutViewEventsPropagationMixin);

      return SelectView;

    });


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/select.views/selectviews',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_select.views_selectviews', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/node.picker/impl/search.list/search.results.model',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/node/node.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/browsable.mixin',
  'csui/models/browsable/v1.request.mixin', 'csui/models/browsable/v2.response.mixin',
  'csui/utils/deepClone/deepClone'
], function (_, $, Backbone, Url, NodeModel, ConnectableMixin, FetchableMixin, BrowsableMixin,
    BrowsableV1RequestMixin, BrowsableV2ResponseMixin) {
  'use strict';

  var SearchResultCollection = Backbone.Collection.extend({

    model: NodeModel,

    constructor: function SearchResultCollection(models, options) {
      this.options = options || (options = {});
      Backbone.Collection.prototype.constructor.call(this, models, options);

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeBrowsable(options)
          .makeBrowsableV1Request(options)
          .makeBrowsableV2Response(options);

    },

    clone: function () {
      return new this.constructor(this.models, {
        connector: this.connector,
        skip: this.skipCount,
        top: this.topCount,
        filter: _.deepClone(this.filters),
        orderBy: _.clone(this.orderBy)
      });
    }
  });

  BrowsableMixin.mixin(SearchResultCollection.prototype);
  BrowsableV1RequestMixin.mixin(SearchResultCollection.prototype);
  BrowsableV2ResponseMixin.mixin(SearchResultCollection.prototype);
  ConnectableMixin.mixin(SearchResultCollection.prototype);
  FetchableMixin.mixin(SearchResultCollection.prototype);
  _.extend(SearchResultCollection.prototype, {

    isFetchable: function () {
      return !!this.options.query.get('where');
    },

    cacheId: '',

    url: function () {
      var url   = this.connector.connection.url.replace('/v1', '/v2'),
          query = this.options.query.toJSON();
      query.where = "OTName:" + query.where;
      this.orderBy = "OTName";
      query = Url.combineQueryString(
          this.getBrowsableUrlQuery(),
          {
            actions: 'open',
            expand: 'properties{parent_id}'
          },
          query
      );
      return Url.combine(url, 'search?' + query);
    },

    parse: function (response, options) {
      this.parseBrowsedState(response.collection, options);
      response.results.sorting = response.collection.sorting;
      this.cacheId = (!!response.collection && !!response.collection.searching &&
                      !!response.collection.searching.cache_id) ?
                     response.collection.searching.cache_id : "";
      return this.parseBrowsedItems(response, options);
    }
  });
  return SearchResultCollection;
});

csui.define('css!csui/dialogs/node.picker/impl/select.views/selectviews',[],function(){});

csui.define('css!csui/dialogs/node.picker/impl/select.views/slider',[],function(){});
csui.define('csui/dialogs/node.picker/impl/select.views/select.views',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/marionette",
  "csui/utils/log", "csui/utils/base", "i18n!csui/dialogs/node.picker/impl/nls/lang",
  "csui/models/node/node.model", "csui/models/nodechildren",
  "csui/dialogs/node.picker/impl/select.view/select.view",
  "csui/dialogs/modal.alert/modal.alert", 'csui/utils/commands',
  "hbs!csui/dialogs/node.picker/impl/select.views/selectviews",
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/dialogs/node.picker/impl/search.list/search.results.model',
  'csui/lib/binf/js/binf', 'csui/lib/jquery.ui/js/jquery-ui',
  "css!csui/dialogs/node.picker/impl/select.views/selectviews",
  "css!csui/dialogs/node.picker/impl/select.views/slider"
], function (module, $, _, Marionette, log, base, lang,
    NodeModel, NodeChildrenCollection, SelectView, ModalAlert, commands,
    template, ViewEventsPropagationMixin, TabableRegionBehavior, SearchResultCollection) {
  'use strict';

  var SelectViews = Marionette.ItemView.extend({

    className: 'csui-select-lists',
    template: template,

    //No sense in providing the target browser with the current table collection, since the
    //collection will need start on the first page for infinite scrolling, and the table collection
    //may be of any page.
    constructor: function SelectViews(options) {
      options || (options = {});
      _.defaults(options, {pageSize: 30});

      Marionette.ItemView.prototype.constructor.call(this, options);

      this.commandType = options.commandType;
      this.selectableTypes = this.commandType.getSelectableNodeTypes();
      // If the selectable types are restricted, always add -1 to them, as -1 will provide all
      // folder types for browsing.  If all types are selectable, leave them empty.
      this.listTypes = _.isEmpty(this.selectableTypes) ? [] :
                       _.contains(this.selectableTypes, -1) ? this.selectableTypes :
                       _.union(this.selectableTypes, [-1]);
      this.leftView = this.rightView = null;
      this.invalidNodes = [];

      this.connector = options.connector;
    },

    onRender: function () {
      this.setLeftOnly();

      if (this.leftView) {
        this.leftView.render();
      }

      if (this.rightView) {
        this.rightView.render();
      }
    },

    onDomRefresh: function () {
      this.leftView.triggerMethod('dom:refresh', this.leftView);
      if (this.rightView) {
        this.rightView.triggerMethod('dom:refresh', this.rightView);
      }
    },

    onShow: function () {
      this.leftView.triggerMethod('show');

      if (this.rightView) {
        this.rightView.triggerMethod('show');
      }
    },

    setParentNodeAsTarget: function (node) {
      var selectable = this.commandType.isSelectable(node);
      this.rightView && this.rightView.clearSelect();
      //In multiSelect, Disable add button on explicitly selected bread crumbs
      if (!this.commandType.multiSelect) {
        this.leftView && this.leftView.setNewSelect(node, true);
      }
      return selectable;
    },
    getSelection: function () {
      var retVal         = {},
          rightSelection = this.rightView ? this.rightView.selectList : {},
          leftSelection  = this.leftView.selectList;
      _.extend(retVal, leftSelection, rightSelection);

      return retVal;
    },

    getNumberOfSelectItems: function () {
      var totalCount = this.leftView.getNumberOfSelectItems();

      if (this.rightView) {
        totalCount += this.rightView.getNumberOfSelectItems() || 0;
      }

      return totalCount;
    },

    //Public - used by breadcrumbs to get the ancestors for the latest container.
    leftNodeId: function () {
      var container = this.leftView.container;
      return container ? container.get('id') : -1;
    },

    setLeftOnly: function () {
      var left = this._setView(-1, 'cs-start-locations left-only', this.options.searchView, false,
          this.options),
          node = left.view.container,
          self = this;

      left.promise
          .done(function () {
            //in multiSelect, disable add button on bread crumbs change when there is no explicit selection - intial Container
            if (node && !self.commandType.multiSelect) {
              self.leftView.addFolderSelection(node);
            }
            if (self.options.searchView) {
              self.trigger("update:searchHeader", this);
            }
            if (self.options.targetBrowseHistory.length === 0 && self.options.searchView) {
              self.options.targetBrowseHistory.push(['location', self.options.previousLocation.id]);
            }
            if (self.options.targetBrowseHistory.length > 0) {
              self.showBackButton();
            } else if (self.options.targetBrowseHistory.length > 1 ||
                       (self.options.targetBrowseHistory.length === 1 &&
                        self.options.navigateFromHistory)) {
              self.showBackButton();
            }
          })
          .fail(function (resp) {
            self.forceClose(resp);
          });

      this.leftView = left.view;
      return left.promise;
    },

    forceClose: function (resp) {
      this
          ._displayAlert(resp)
          .always(this.trigger('close'));
    },

    //called during a breadcrumb change
    newLeftView: function (node, pageSize) {
      var newId = node.get('id'),
          self  = this;
      this.options.pageSize = pageSize;
      return this._drillUp(newId).done(function (view) {
        self.leftView = view;
        //In multiSelect, don't add button on bread crumbs change when there is no explicit selection
        if (!self.commandType.multiSelect) {
          self.leftView.addFolderSelection(node);
        }
        self.onDomRefresh();
        if (self.options.targetBrowseHistory.length === 0) {
          //maintain history
          var page     = Math.floor((self.leftView.collection.skipCount || 0) /
                                    self.leftView.collection.topCount) + 1,
              pageSize = parseInt(self.leftView.collection.topCount) * parseInt(page);
          var nodeObj = {
            "leftId": (self.leftView && self.leftView.container) ?
                      self.leftView.container.get("id") :
                      node.parent ? node.parent.get("id") : undefined,
            "rightId": (self.rightView && self.rightView.container) ?
                       self.rightView.container.get("id") : undefined,
            "pageSize": pageSize
          };
          self.options.targetBrowseHistory.push(['node', nodeObj]);
        }
      }).fail(function (resp) {
        self._displayAlert(resp);
      });
    },

    onSelectionChange: function (args, view) {
      var isRightView = view && this._isRightView(view);

      if (args && args.add) {
        if (isRightView) {
          this.leftView.clearSelect();
        }
        else {
          this.rightView && this.rightView.clearSelect();
        }
      }

      if (view.options.searchView) {
        if (args.node.get("container")) {
          this.trigger('update:searchHeader', args.node);
        } else {
          this.trigger('change:complete', args.node);
        }
      } else {
        //trigger to let node.picker release dialog blockingView and update
        //select button enable status.
        this.trigger('change:complete', args.node);
      }
      return true;
    },

    onBrowse: function (view, args) {
      var isRightView = this._isRightView(view),
          promise     = null;

      //trigger to let node picker know to block dialog from further action
      this.trigger('changing:selection');

      if (isRightView) {
        promise = this.selectRight(args);
      }
      else {
        promise = this.selectLeft(args);
      }

      promise
          .done(function () {
            view.trigger('browse:complete');
          })
          .fail(function () {
            view.clearSelect();
          });
      return promise;
    },

    onClickLocation: function (view, args) {
      this.trigger('click:location', view);
    },

    selectLeft: function (args, view) {
      var self        = this,
          replaceView = 'right';
      if (this.options.searchView) {
        this.options.targetBrowseHistory.push(['search', this.options.query.clone()]);
      }

      return this._runSelection(args, '.cs-pane-view', replaceView)
          .done(function (view) {
            if (view) {
              self.rightView = view;
              self.onDomRefresh();
            }
          });

    },

    selectRight: function (args, view) {
      var self        = this,
          replaceView = 'left';
      //maintain history
      if (this.options.targetBrowseHistory.length === 0) {
        this.options.targetBrowseHistory.push(['location', this.options.previousLocation.id]);
      } else {
        var page         = Math.floor((this.leftView.collection.skipCount || 0) /
                                      this.leftView.collection.topCount) + 1,
            pageSize     = parseInt(this.leftView.collection.topCount) * parseInt(page),
            browsedChild = this.leftView.listView.browsedChild,
            nodeObj      = {
              "leftId": browsedChild ? browsedChild.model.parent.get("id") : undefined,
              "rightId": browsedChild ? browsedChild.model.get('id') : undefined,
              "pageSize": pageSize
            };
        this.options.targetBrowseHistory.push(['node', nodeObj]);
      }
      return this._runSelection(args, '.csui-panel.cs-start-locations', replaceView).done(
          function (newView) {
            if (newView) {
              self.leftView = self.rightView;
              self.rightView = newView;
              self.onDomRefresh();
              self.showBackButton();
            }
          });
    },

    showBackButton: function () {
      if (this.leftView && this.options.targetBrowseHistory.length >= 1) {
        this.leftView.headerView && this.leftView.headerView.ui.backBtn.show();
      }
    },

    hideBackButton: function () {
      if (this.leftView && this.options.targetBrowseHistory.length < 1) {
        this.leftView.headerView && this.leftView.headerView.ui.backBtn.hide();
      }
    },

    _runSelection: function (args, shiftViewClass, replaceView) {
      var node     = args.node,
          self     = this,
          deferred = $.Deferred();

      //Drill down item
      var nodeId = node.get('id');
      this._drillDown(nodeId, shiftViewClass)
          .done(function (view) {
            if (replaceView === 'left') {
              self.onClearLeftViewSelectList();
            } else if (replaceView === 'right') {
              self.onClearRightViewSelectList();
            }
            // trigget to update breadcrumbs with Node selected (Shortcut or Original node)
            var browsedModel = (replaceView === 'left' ? self.rightView : self.leftView)
                .listView.browsedChild.model;
            self.trigger('changed', browsedModel.get('id'));

            //trigger to let node.picker release dialog blockingView and update
            //select button enable status.
            self.trigger('change:complete', node);
            deferred.resolve(view);
          })
          .fail(function (resp) {
            self._displayAlert(resp);
            //trigger to let node.picker release dialog blockingView and update
            //select button enable status.
            self.trigger('change:complete');
            deferred.reject();
          });

      return deferred;
    },

    _drillUp: function (nodeId, rightFlag) {
      this.trigger('drill:up', nodeId);
      var newView  = this._setView(nodeId, 'csui-new-view left-only binf-hidden',
          this.options.searchView, 'prepend'),
          view     = newView.view,
          self     = this,
          deferred = $.Deferred();

      view.$el.addClass('zeroWidth')
          .removeClass('binf-hidden');

      view.render();
      if (!rightFlag) {
        self._removeRightView(newView.promise).done(function () {
          deferred.resolve(newView.view);
        }).fail(function (resp) {
          deferred.reject(resp);
        });
      }
      return deferred;
    },

    _drillDown: function (nodeId, removeClass) {
      var newView      = this._setView(nodeId, 'csui-new-view', false),
          panelPromise = null,
          view         = newView.view;

      view.render();

      if (this.rightView == null) {
        view.options.searchView = false;
        $(".binf-list-group").removeClass("search-left-item");
        if ($(".csui-search-item-left-panel").is(":visible")) {
          $(".binf-list-group").addClass("search-left-folder-right");
        }
        panelPromise = this._addRightView(newView.promise, view);
      } else {
        panelPromise = this._replaceView(newView.promise, view, removeClass);
      }

      return panelPromise;
    },

    _showLeftOnly: function () {
      var leftView  = this.leftView,
          rightView = this.rightView,
          self      = this,
          width     = '100%';

      leftView.animate({width: width}, {
        duration: 200, complete: animateComplete
      });

      function animateComplete() {
        if (rightView != null) {
          var selectView = rightView[0].selectView;
          self.cancelEventsToViewsPropagation(selectView);
          selectView.destroy();   //selectView is the view object that was added to the DOM element
          rightView.remove();
          self.rightView = null;
        }
      }
    },

    _removeRightView: function (fetchPromise) {
      var newView   = this.$el.find('.csui-new-view'),
          leftView  = this.$el.find('.csui-panel.cs-start-locations'),
          rightView = this.$el.find('.cs-pane-view'),
          deferred  = $.Deferred(),
          self      = this;

      leftView.hide();
      rightView.hide();
      newView[0].className = 'csui-panel cs-start-locations left-only';

      fetchPromise.done(function () {
        self._finishRightRemove(newView, leftView, rightView);
        deferred.resolve();
      }).fail(function (resp) {
        self._removeNewView(newView, leftView, rightView);
        deferred.reject(resp);
      });

      return deferred;
    },

    _removeNewView: function (newView, leftView, rightView) {
      newView || (newView = this.$el.find('.csui-new-view'));
      var selectView = newView[0].selectView;
      this.cancelEventsToViewsPropagation(selectView);
      selectView.destroy();
      newView.remove();
      leftView && leftView.show();
      rightView && rightView.show();
    },

    _finishRightRemove: function (newView, leftView, rightView) {
      var selectView;
      if (rightView.length > 0) {
        selectView = rightView[0].selectView;
        this.cancelEventsToViewsPropagation(selectView);
        selectView.destroy();   //selectView is the view object that was added to the DOM element
        rightView.remove();
        this.rightView = null;
      }

      selectView = leftView[0].selectView;
      this.cancelEventsToViewsPropagation(selectView);
      selectView.destroy();
      leftView.remove();
      this.leftView = null;

      return true;
    },

    _addRightView: function (fetchPromise, selectView) {
      var leftView = this.$el.find('.csui-panel.cs-start-locations'),
          newView  = this.$el.find('.csui-new-view'),
          deferred = $.Deferred(),
          self     = this;

      leftView[0].className = 'csui-panel cs-start-locations';
      newView[0].className = 'csui-panel cs-pane-view csui-slideMidLeft';

      fetchPromise.done(function () {
        deferred.resolve(selectView);
      }).fail(function (resp) {
        self._removeNewView(newView);
        leftView.animate({width: '100%'}, {
          duration: 200,
          complete: function () {
            leftView.addClass('left-only').css('width', '');
          }
        });
        self.leftView.clearSelect();
        self.leftView.refresh();
        deferred.reject(resp);
      });

      return deferred;
    },

    _replaceView: function (fetchPromise, selectView, removeClass) {
      var view      = this.$el.find(removeClass),
          newView   = $('.csui-new-view'),
          rightView = $('.cs-pane-view'),
          deferred  = $.Deferred(),
          self      = this;

      view.hide();
      switch (removeClass) {
      case '.csui-panel.cs-start-locations':
        rightView[0].className = 'csui-panel cs-start-locations csui-slideLeft';
        newView[0].className = 'csui-panel cs-pane-view csui-slideMidLeft';
        break;
      case '.cs-pane-view':
        newView[0].className = 'csui-panel cs-pane-view csui-slideMidLeft';
      }
      this.$el.find('.left-only').removeClass('left-only');
      fetchPromise.done(function () {
        self._removeView(view);
        deferred.resolve(selectView);
      }).fail(function (resp) {
        self._reverseRemoveView(newView, removeClass, rightView);
        if (removeClass === '.csui-panel.cs-start-locations') {
          view.show();
        }
        deferred.reject(resp);
      });

      return deferred;
    },

    _reverseRemoveView: function (domView, className, rightView) {
      this._removeNewView(domView);
      switch (className) {
      case '.csui-panel.cs-start-locations':
        rightView[0].className = 'csui-panel cs-pane-view csui-slideRight';
        this.rightView.refresh();
        break;
      case '.cs-pane-view':
        this._removeView(rightView);
        this.leftView.$el[0].className = 'csui-panel cs-start-locations left-only';
        this.leftView.clearSelect();
        this.leftView.refresh();
      }
      return true;
    },

    _removeView: function (domView) {
      if (domView.length) {
        var selectView = domView[0].selectView;
        this.cancelEventsToViewsPropagation(selectView);
        selectView.destroy();   //selectView is the view object that was added to the DOM element
        domView.remove();
        return true;
      } else {
        return false;
      }
    },

    //NodeId - id of the node whose contents are to be displayed in a view
    //callBack - call back function for any item clicked in the node view
    //clasName - class name to give the new ('csui-new-view', 'cs-start-locations',
    //          'cs-pane-view')
    //appendAction - jquery action to either 'append' or 'prepend' the new view
    //               the list of views.
    //Returns: View and fetch promise.
    _setView: function (nodeId, className, searchView, appendAction, viewOptions) {
      viewOptions || (viewOptions = this._getViewOptions(nodeId, this.connector));
      this.options.searchView = searchView;
      _.defaults(viewOptions, this.options, {invalidNodes: this.invalidNodes});
      appendAction || (appendAction = 'append');

      var view    = this._newView(viewOptions, className),
          promise = this._fetchView(view);
      if (searchView) {
        this.options.fromSearch = true;
      } else {
        this.options.fromSearch = false;
      }

      //attach the view to its div so that we know which left/right view we are dealing with
      //when sliding in/out panels.
      view.el.selectView = view;
      this.$el[appendAction](view.el);

      return {view: view, promise: promise};
    },

    _fetchView: function (view) {

      this._fetchContainer(view);
      return this._fetchCollection(view);
    },

    _fetchContainer: function (view) {
      if (view.container && view.container.get("id")) {
        view.container.fetch();
      }
      return true;
    },

    _fetchCollection: function (view) {
      view.collection.setOrder(this.options.orderBy, false);
      view.collection.setFilter({type: this.listTypes}, false);
      view.collection.setLimit(0, this.options.pageSize || view.options.pageSize, false);

      var deferred = $.Deferred(), self = this;
      var promise = view.collection.fetch({reset: false, merge: false, remove: false});
      promise.done(function (result) {
        view.listView.resolveShortcuts(view.collection).always(function() {
          deferred.resolve(view.collection);
        });
      }).fail(function (resp) {
        deferred.reject(resp);
      });

      return deferred;
    },

    _newView: function (args, className) {
      var self    = this,
          options = _.extend({
            listTypes: this.listTypes,
            className: className + ' csui-panel',
            parentEl: this.$el
          }, args);

      var selectView = new SelectView(options);
      this.propagateEventsToViews(selectView);
      this.listenTo(selectView, 'selection:change', this.onSelectionChange);
      this.listenTo(selectView, 'search:failed', this._searchFailed);
      this.listenTo(selectView, 'backbutton:click', this._onClickBackButton);
      this.listenTo(selectView, 'clear:selectList', this.onClearLeftViewSelectList);
      this.listenTo(selectView, 'browse:select', _.bind(this.onBrowse, this));
      this.listenTo(selectView, 'click:location', _.bind(this.onClickLocation, this));
      return selectView;
    },

    onClearLeftViewSelectList: function () {
      if (!!this.leftView) {
        this.leftView.selectList = {};
      }
    },

    onClearRightViewSelectList: function () {
      if (!!this.rightView) {
        this.rightView.selectList = {};
      }
    },

    _onClickBackButton: function (args) {
      var self = this;
      var lastVisited = this.options.targetBrowseHistory.length > 0 ?
                        this.options.targetBrowseHistory.pop() : undefined;
      if (this.options.targetBrowseHistory.length === 1) {
        this.options.navigateFromHistory = true;
      } else {
        this.options.navigateFromHistory = false;
      }
      if (lastVisited && lastVisited[0] === "search") {
        this.requestedQueryModel = lastVisited[1];
        this.trigger("back:toSearch", this);
        if (this.options.targetBrowseHistory.length > 0) {
          this.showBackButton();
        }
      } else if (lastVisited && lastVisited[0] === "location") {
        this.onClearLeftViewSelectList();
        this.onClearRightViewSelectList();
        this.trigger("change:location", lastVisited);
      } else if ((this.options.searchView && lastVisited && lastVisited[0] === "node") ||
                 (lastVisited && lastVisited[0] === "node")) {
        this.options.searchView = false;
        var leftNode  = new NodeModel({id: lastVisited[1].leftId}, {connector: this.connector}),
            rightNode = new NodeModel({id: lastVisited[1].rightId}, {connector: this.connector});
        this.newLeftView(leftNode, lastVisited[1].pageSize).done(function (view) {
          self.setParentNodeAsTarget(leftNode);
          self.trigger('change:complete');

          self.trigger('toggle:breadcrumbs', self.leftNodeId());
          if (self.options.targetBrowseHistory) {
            self.hideBackButton();
          }

          if (self.options.targetBrowseHistory.length > 0 && rightNode && rightNode.get('id')) {
            if (self.$el.find('.cs-left-item-' + rightNode.get('id')).length > 0) {
              self.$el.find('.cs-left-item-' + rightNode.get('id')).trigger("click");
            }
            self.showBackButton();
          } else {
            self.hideBackButton();
          }
        });
      }
      this.options.backBtn = true;
    },

    _searchFailed: function (args) {
      var isRightView = this._isRightView(args.view);

      if (!isRightView) {
        this.forceClose(args.resp);
      }
      else {
        this._displayAlert(args.resp);
      }
    },

    _isRightView: function (view) {
      var viewClasses = view.$el[0].className.split(' ');
      return _.contains(viewClasses, 'cs-pane-view');
    },

    _addNewPanel: function (className, action) {
      var div = document.createElement('div');
      div.className = className;
      this.$el[action](div);

      return div;
    },

    _getViewOptions: function (nodeId, connector) {
      var node       = new NodeModel({id: nodeId}, {connector: connector}),
          collection = new NodeChildrenCollection(undefined, {
            node: node,
            autofetch: true,
            orderBy: this.options.orderBy,
            // TODO:  This will not be enough for the consumer.  How to work
            // around the skinflint in the REST API?
            expand: ['node'],
            commands: commands.getAllSignatures()
          });

      return {container: node, collection: collection};
    },

    _displayAlert: function (resp) {
      var msg = _.str.sformat(lang.serverError, 'unknown');
      if (resp) {
        if (resp instanceof SelectView) {
          msg = _.str.sformat(lang.ViewDenied, resp.node.get('name'));
        }
        else {
          if (resp.responseJSON) {
            msg = resp.responseJSON.error;
          }
        }
      }
      return ModalAlert.showInformation(msg);
    }

  });

  _.extend(SelectViews.prototype, ViewEventsPropagationMixin);

  return SelectViews;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/node.picker',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div id=\"csui-np-breadcrumbs\" class=\"cs-breadcrumb\">\r\n  <div class=\"breadcrumb-inner\" role=\"navigation\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.breadcrumbAria || (depth0 != null ? depth0.breadcrumbAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"breadcrumbAria","hash":{}}) : helper)))
    + "\"></div>\r\n  <div class=\"searchheader-inner\"></div>\r\n</div>\r\n<div id=\"csui-np-selectviews\"></div>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_node.picker', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/search.list/header/search.result.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-search-header\">\r\n    <span class=\"csui-search-header-title\">\r\n        <span class=\"results-title searchResultsTitle\">"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.searchResults : stack1), depth0))
    + "</span>\r\n        <span class=\"headerCount searchHeaderCount\" aria-live=\"polite\"></span>\r\n    </span>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_search.list_header_search.result.header', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/node.picker/impl/search.list/header/search.result.header.view',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/marionette',
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'hbs!csui/dialogs/node.picker/impl/search.list/header/search.result.header',
  'css!csui/dialogs/node.picker/impl/search.list/search.list'
], function (_, $, Marionette, lang, headerTemplate) {
  "use strict";

  var SearchResultHeaderView = Marionette.ItemView.extend({
    className: "csui-search-data-header",
    template: headerTemplate,
    templateHelpers: function () {
      var messages = {
        searchResults: lang.searchResults
      };
      return {
        messages: messages
      };
    },
    constructor: function SearchResultHeaderView(options) {
      options || (options = {});
      Marionette.View.prototype.constructor.apply(this, arguments); // apply (modified) options to this
    },
    onRender: function () {
      var collection = this.collection;
      this.rendered = true;
      this.$el.show();
      this._assignTotalItemElem(collection);
    },

    _assignTotalItemElem: function (collection) {
      this.totalCount = 0;
      if (collection && collection.length > 0) {
        this.totalCount = collection.totalCount;
      }
      var listElem = this.$el.find('.searchHeaderCount'),
          txt      = lang.searchFoundZero;
      if (this.totalCount !== null) {
        txt = _.str.sformat(lang.searchFoundAbout, this.totalCount);
      }
      listElem.empty();
      listElem.append(txt);
      return true;
    }
  });
  return SearchResultHeaderView;
});
csui.define('csui/dialogs/node.picker/impl/node.picker.view',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/marionette",
  "csui/utils/log", "csui/utils/base",
  "csui/models/node/node.model", "csui/models/nodechildren",
  "csui/dialogs/node.picker/impl/select.views/select.views",
  "csui/controls/breadcrumbs/breadcrumbs.view",
  "csui/utils/contexts/factories/ancestors", "csui/models/nodeancestors",
  "hbs!csui/dialogs/node.picker/impl/node.picker",
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  "csui/dialogs/node.picker/impl/search.list/header/search.result.header.view"
], function (module, $, _, Marionette, log, base,
    NodeModel, NodeChildrenCollection, SelectViews,
    BreadcrumbsView, AncestorCollectionFactory, NodeAncestorCollection, template,
    lang, LayoutViewEventsPropagationMixin, SearchResultsHeaderView) {

  var NodePicker = Marionette.LayoutView.extend({

    template: template,
    className: 'csui-node-picker',

    regions: {
      breadcrumbRegion: '#csui-np-breadcrumbs > div.breadcrumb-inner',
      searchHeaderRegion: '#csui-np-breadcrumbs > div.searchheader-inner',
      selectViewRegion: '#csui-np-selectviews'
    },

    ui: {
      breadcrumb: '#csui-np-breadcrumbs',
      breadcrumbContent: '.breadcrumb-inner',
      searchHeaderContent: '.searchheader-inner',
      selectViews: '#csui-np-selectviews'
    },

    templateHelpers: function () {
      return {
        breadcrumbAria: lang.breadcrumbAria,
        nodePickerChoices: lang.nodePickerChoices
      };
    },

    //No sense in providing the target browser with the current table collection, since the
    //collection will need start on the first page for infinite scrolling, and the table collection
    //may be of any page.
    constructor: function NodePicker(options) {
      options || (options = {});

      Marionette.LayoutView.prototype.constructor.call(this, options);

      this.propagateEventsToRegions();

      //Set left and right panel collection. Keep in mind that Enterprise has no parent node, so
      //the left parent will contain the current table node content, and the right will be blank.
      this.setViews(options);
      this.setBreadcrumbs(options);
      if (options.searchView) {
        this.updatedBreadcrumbId = options.locationID;
        this.setSearchResultsHeader(options);
      }
      this.onWinRefresh = _.bind(this.windowRefresh, this);
      $(window).bind("resize.app", this.onWinRefresh);
    },

    windowRefresh: function () {
      //due to chrome not recognizingg parent height, dynamically set through css,
      //the select view height must be coded.
      var breadCrumb       = $('.cs-breadcrumb'),
          breadCrumbHeight = breadCrumb.is(':visible') ? breadCrumb.height() : 0,
          viewHeight       = this.$el.height() - breadCrumbHeight;
      if (!!window.chrome && viewHeight > 0) {
        this.selectViews.$el.css('height', viewHeight + 'px');
      }
      this.selectViews.triggerMethod('dom:refresh', this.selectViews);
      if (this.breadcrumbs) {
        this.breadcrumbs.refresh();
      }
    },
    onBeforeDestroy: function () {
      if (this.selectViews) {
        if (this.selectViews.leftView) {
          this.selectViews.leftView.clearSelect();
        }
        if (this.selectViews.rightView) {
          this.selectViews.rightView.clearSelect();
        }
      }
    },
    onDestroy: function () {
      $(window).unbind("resize.app", this.onWinRefresh);
    },
    onRender: function () {
      if (this.options.searchView) {
        this.searchHeaderRegion.show(this.searchHeaderView);
      }
      if (this.breadcrumbs) {
        this.breadcrumbRegion.show(this.breadcrumbs);
      }
      this.selectViews.options.navigateFromHistory = this.options.navigateFromHistory;
      this.selectViewRegion.show(this.selectViews);
    },
    onDomRefresh: function () {
      this.windowRefresh();
    },

    onShow: function () {
      _.each(this.regionManager.regions, function (region) {
        if (region.currentView) {
          region.currentView.trigger('show');
        }
      });

      //If the container provided by startLocation is null, then hide
      //breadcrumbs
      if (!this.options.container && !this.options.searchView) {
        this.ui.breadcrumb.hide();
        this.ui.selectViews.addClass('csui-full-height');
      }
    },

    setViews: function (options) {
      var views = this.selectViews = new SelectViews(options);
      this.listenTo(views, 'changed', this.updateBreadcrumbs);
      this.listenTo(views, 'update:searchHeader', this.updateSearchResultHeader);
      this.listenTo(views, 'change:complete', _.bind(this.trigger, this, 'change:complete'));
      this.listenTo(views, 'click:location', _.bind(this.trigger, this, 'open:location'));
      this.listenTo(views, 'change:location', _.bind(this.trigger, this, 'change:location'));
      this.listenTo(views, 'back:toSearch', function (promise) {
        this.trigger('back:toSearch', promise);
      });
      this.listenTo(views, 'backto:folder', function (promise) {
        this.trigger('backto:folder', promise);
      });
      this.listenTo(views, 'close', this.close)
          .listenTo(views, 'toggle:breadcrumbs', this.updateBreadcrumbs);

    },

    getSelection: function () {
      return _.values(this.selectViews.getSelection());
    },

    getNumberOfSelectItems: function () {
      return this.selectViews.getNumberOfSelectItems();
    },

    close: function () {
      this.destroy();
      this.trigger('close');
    },

    updateBreadcrumbs: function (objId) {
      var ancestors;
      this.updatedBreadcrumbId = undefined;
      if (this.breadcrumbNode) {
        this.breadcrumbNode.set('id', objId);
      }

      if (objId) {
        var self = this;
        this.getAncestors(objId).fetch();
      }
      this.listenTo(this.breadcrumbs, 'after:synchronized', this.onAfterBreadcrumbsSynchronized);
      return true;
    },

    getAncestors: function (nodeId) {
      var node            = new NodeModel({id: nodeId}, {connector: this.options.connector}),
          ancestorOptions = {node: node, autofetch: true},
          newAncestors    = new NodeAncestorCollection(undefined, ancestorOptions);
      this.breadcrumbs = new BreadcrumbsView({
        node: node,
        collection: newAncestors
        // TODO: Use {fetchOnCollectionUpdate: false} to prevent
        // the control from an extra fetching of the collection.
      });
      this.breadcrumbs.synchronizeCollections();
      if (!this.breadcrumbNode) {
        this.breadcrumbNode = node;
      }
      return newAncestors;
    },

    setBreadcrumbs: function (options) {
      var container = options.container || options.initialContainer,
          id        = container ? container.get('id') : 0;

      if (!id || id === 0) {
        this.getAncestors(0);
        this.setBreadcrumbEvents();
        return;
      }

      if (options.container) {
        var self = this;
        this.getAncestors(id).fetch();
      } else {
        this.getAncestors(0);
        this.setBreadcrumbEvents();
      }

      this.setBreadcrumbEvents();

      return true;
    },

    showBackButton: function () {
      this.selectViews.showBackButton();
    },

    setBreadcrumbEvents: function () {
      this.listenTo(this.breadcrumbs, 'before:defaultAction', function (args) {
        var selectViews = this.selectViews,
            self        = this;
        selectViews.newLeftView(args.node).done(function (view) {
          selectViews.setParentNodeAsTarget(view.container);
          self.trigger('change:complete', view.container);
        });
      });
      this.listenTo(this.breadcrumbs, 'after:synchronized', this.onAfterBreadcrumbsSynchronized);
    },

    onAfterBreadcrumbsSynchronized: function () {
      if (this.ui.breadcrumb.hasClass('cs-breadcrumb')) {
        this.ui.breadcrumb.show();
        this.ui.breadcrumbContent.show();
        this.ui.searchHeaderContent.hide();
        this.ui.selectViews.removeClass('csui-full-height');
        if (this.breadcrumbs.collection.length === 1) {
          this.options.targetBrowseHistory = [];
        }
        this.windowRefresh();
      }
    },

    setSearchResultsHeader: function (options) {
      this.searchHeaderView = new SearchResultsHeaderView({
        collection: this.collection
      });
      return true;
    },

    updateSearchResultHeader: function () {
      if (this.options.searchView) {
        if (!this.options.container) {
          this.ui.searchHeaderContent.addClass('csui-non-container-padding');
        } else {
          this.ui.searchHeaderContent.removeClass('csui-non-container-padding');
        }
        this.ui.breadcrumbContent.hide();
        this.ui.searchHeaderContent.show();
        this.searchHeaderView._assignTotalItemElem(this.collection);
      }
    }
  });

  _.extend(NodePicker.prototype, LayoutViewEventsPropagationMixin);

  return NodePicker;

});

// Provides a list of starting locations for the node picker
csui.define('csui/dialogs/node.picker/start.locations/start.location.collection',['require', 'module', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone'
], function (require, module, _, $, Backbone) {
  'use strict';

  var config = module.config(),
      startLocations = config.startLocations || [],
      masks = config.masks || {};

  // Support either array of module IDs or a map with keys pointing
  // to arrays of module IDs; the latter can be used for decentralized
  // configuration (multiple calls to require.config, which merge maps,
  // but not arrays)
  if (!_.isArray(startLocations)) {
    startLocations = Array.prototype.concat.apply([], _.values(startLocations));
  }

  masks = _.reduce(_.values(masks), function (result, mask) {
    return {
      blacklist: result.blacklist.concat(mask.blacklist || []),
      whitelist: result.whitelist.concat(mask.whitelist || [])
    };
  }, {
    blacklist: [],
    whitelist: []
  });
  masks = {
    blacklist: _.unique(masks.blacklist),
    whitelist: _.unique(masks.whitelist)
  };

  function normalizeLocationName(location) {
    var lastSlash = location.lastIndexOf('/');
    // Enable start location names without the module path
    // for the core modules from historical reasons
    return lastSlash >= 0 ? location :
            'csui/dialogs/node.picker/start.locations/' +
            location;
  }

  function filterLocationByMask(location) {
    return !_.contains(masks.blacklist, location) &&
           (!masks.whitelist.length ||
            _.contains(masks.whitelist, location));
  }

  startLocations = _.chain(startLocations)
                    .map(normalizeLocationName)
                    .filter(filterLocationByMask)
                    .unique()
                    .value();

  var StartLocationModel = Backbone.Model.extend({
    defaults: {
      id: null,
      name: null,
      icon: null,
      invalid: false,
      factory: null,
      unselectable: true
    },

    constructor: function StartLocationModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);
    },

    sync: function (method, collection, options) {
      if (method !== 'read') {
        throw new Error('Only fetching the widget is supported.');
      }
      var self = this;
      options || (options = {});
      return this._resolveFactory(options)
          .then(function () {
            var factory = self.get('factory');
            return factory.updateLocationModel(self);
          })
          .then(function () {
            var response = self.toJSON();
            options.success && options.success(response, options);
            self.trigger('sync', self, response, options);
          }, function () {
            var error = self.get('error');
            options.error && options.error(error, options);
            self.trigger('error', self, error, options);
            return $.Deferred().reject(error);
          });
    },

    _resolveFactory: function (options) {
      var self = this,
          deferred = $.Deferred(),
          factoryData = this.getFactoryData(),
          factoryPath = this.getFactoryModulePath(factoryData);
      require([factoryPath],
          function (Factory) {
            self.set('factory', new Factory(options));
            deferred.resolve();
          }, function (error) {
            self.set('error', error);
            if (options.ignoreErrors) {
              deferred.resolve();
            } else {
              deferred.reject(error);
            }
          });
      return deferred.promise();
    },

    getFactoryData: function () {
      var name = this.get('id'),
          lastSlash = name.lastIndexOf('/'),
          path;
      // Enable start location names without the module path for the core modules
      if (lastSlash < 0) {
        path = 'csui/dialogs/node.picker/start.locations/' + name;
      } else {
        path = name;
        name = name.substring(lastSlash + 1);
      }
      return {
        name: name,
        path: path
      };
    },

    getFactoryModulePath: function (moduleData) {
      return moduleData.path + '/' + moduleData.name + '.factory';
    }
  });

  var StartLocationCollection = Backbone.Collection.extend({
    model: StartLocationModel,

    constructor: function StartLocationCollection(options) {
      options || (options = {});
      var locations = options.startLocations;
      if (locations) {
        locations = _.chain(locations)
                     .concat(['search.location', 'default.location'])
                     .map(normalizeLocationName)
                     .filter(filterLocationByMask)
                     .unique()
                     .value();
      } else {
        locations = startLocations;
      }
      var models = _.map(locations,
          function (id) {
            return {id: id};
          });
      Backbone.Collection.prototype.constructor.call(this, models, options);
    },

    sync: function (method, collection, options) {
      if (method !== 'read') {
        throw new Error('Only fetching the start locations is supported.');
      }
      var self = this;
      options || (options = {});
      return this._resolveFactories(options)
          .then(function () {
            if (options.removeInvalid !== false) {
              var invalidModels = self.where({invalid: true});
              self.remove(invalidModels);
            }
            var response = self.toJSON();
            options.success && options.success(response, options);
            self.trigger('sync', self, response, options);
          });
    },

    _resolveFactories: function (options) {
      var resolvableModels = this.filter(function (model) {
            // A resolvable factory must have an ID and it was already resolved
            // neither with a success nor with a failure
            return model.has('id') && !(model.has('factory') || model.has('error'));
          }),
          modelOptions = _.defaults({ignoreErrors: true},
              _.omit(options, 'success', 'error')),
          promises = _.invoke(resolvableModels, 'fetch', modelOptions);
      return $.when.apply($, promises);
    }
  });

  return StartLocationCollection;
});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/apply.properties.selector',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "    <li role=\"presentation\" data-optionid=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.id : depth0), depth0))
    + "\">\r\n      <a role=\"menuitem\" tabindex=\"-1\" href=\"#\">\r\n        <span class=\"cs-label\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.name : depth0), depth0))
    + "</span>\r\n      </a>\r\n    </li>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<button id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\" class=\"binf-btn binf-btn-default binf-dropdown-toggle csui-acc-focusable\" data-binf-toggle=\"dropdown\"\r\n        aria-haspopup=\"true\" aria-expanded=\"false\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.applyPropertiesAria || (depth0 != null ? depth0.applyPropertiesAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"applyPropertiesAria","hash":{}}) : helper)))
    + "\">\r\n  <span class=\"cs-label\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n  <span class=\"cs-icon icon-caret-down\"></span>\r\n</button>\r\n<ul class=\"binf-dropdown-menu\" role=\"menu\" aria-labelledby=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.applyPropertiesOptions : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <li class=\"binf-divider\"></li>\r\n  <li role=\"presentation\" class=\"open-selected-properties\">\r\n    <a role=\"menuitem\"  tabindex=\"-1\" href=\"#\">\r\n      <span class=\"cs-icon\"></span>\r\n      <span class=\"cs-label\">"
    + this.escapeExpression(((helper = (helper = helpers.openSelectedProperties || (depth0 != null ? depth0.openSelectedProperties : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"openSelectedProperties","hash":{}}) : helper)))
    + "</span>\r\n    </a>\r\n  </li>\r\n</ul>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_header_apply.properties.selector_impl_apply.properties.selector', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/nls/root/lang',{
  ApplyPropertiesAria: "Select properties handling",
  KeepOriginalProperties: "Keep original properties",
  ApplyDestinationProperties: "Apply destination properties",
  CombineAllProperties: "Combine all properties",
  OpenSelectedProperties: "Open selected properties"
});



csui.define('css!csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/apply.properties.selector',[],function(){});
csui.define('csui/dialogs/node.picker/impl/header/apply.properties.selector/apply.properties.selector.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/apply.properties.selector',
  'i18n!csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/nls/lang',
  'css!csui/dialogs/node.picker/impl/header/apply.properties.selector/impl/apply.properties.selector',
  'csui/lib/binf/js/binf'
], function (_,
    $,
    Backbone,
    Marionette,
    TabableRegion,
    selectorTemplate,
    lang) {
  "use strict";

  var ApplyPropertiesSelectorView = Marionette.ItemView.extend({
    _applyOptions: undefined,

    selected: undefined,

    openSelectedProperties: false,

    className: 'cs-apply-properties-selector binf-dropdown',

    template: selectorTemplate,

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegion
      }
    },

    ui: {
      toggle: '>.binf-dropdown-toggle',
      selectedLabel: '>.binf-dropdown-toggle >.cs-label',
      iconOpenSelectedProperties: 'li.open-selected-properties > a > span.cs-icon'
    },

    events: {
      'click li[data-optionid]': 'onClickPropertiesOption',
      'click li.open-selected-properties': 'onClickOpenSelectedProperties',
      'keydown': 'onKeyInView',
      'keyup': 'onKeyUpInView'
    },

    constructor: function ApplyPropertiesSelectorView(options) {
      options || (options = {});
      _.defaults(options, {startSelection: ApplyPropertiesSelectorView.KEEP_ORIGINAL_PROPERTIES});

      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    onKeyInView: function (event) {
      if (event.keyCode === 27 && this.$el.hasClass('binf-open')) {
        this.$el.removeClass('binf-open');
        this.$('*[tabindex = "0"]').focus();
        this.isKeydownClosedDropDown = true;
        return false;
      } else if (event.keyCode === 27 && !this.$el.hasClass('binf-open')) {
        this.isKeydownClosedDropDown = false;
      }
    },

    onKeyUpInView: function (event) {
      if (!this.isKeydownClosedDropDown && event.keyCode === 27) {
        return true;
      } else if (event.keyCode === 27) {
        return false;
      }
    },

    onClickPropertiesOption: function (e) {
      e.preventDefault();
      e.stopPropagation();

      this._setSelected(parseInt($(e.currentTarget).attr('data-optionid')));
      this._showSelected();
      this.ui.toggle.click();
      this.trigger('property:click:event');

      //let dialog know to set focus for the next tab request. For the modal dialog
      //focus is initially lost after each enter event.
      this.$el.trigger('setCurrentTabFocus');
    },

    onClickOpenSelectedProperties: function (e) {
      e.preventDefault();
      e.stopPropagation();

      this.openSelectedProperties = !this.openSelectedProperties;
      this._showOpenSelectedProperties();
      this.ui.toggle.click();
      //let dialog know to set focus for the next tab request. For the modal dialog
      //focus is initially lost after each enter event.
      this.$el.trigger('setCurrentTabFocus');
    },

    initialize: function () {
      this._setupApplyOptions();

      if (-1 !== _.indexOf(_.pluck(this._applyOptions, 'id'), this.options.selected)) {
        this._setSelected(this.options.selected);
      }
      else {
        this._setSelected(ApplyPropertiesSelectorView.KEEP_ORIGINAL_PROPERTIES);
      }

      this.listenTo(Backbone, 'closeToggleAction', this._closeToggle);
    },

    templateHelpers: function () {
      return {
        id: _.uniqueId('optionsDropdown'),
        applyPropertiesOptions: this._applyOptions,
        applyPropertiesAria: lang.ApplyPropertiesAria,
        openSelectedProperties: lang.OpenSelectedProperties
      };
    },

    currentlyFocusedElement: function () {
      return this.$el.find('button');
    },

    accDeactivateTabableRegion: function () {
      this._closeToggle();
    },

    onRender: function () {
      this.ui.toggle.binf_dropdown();
      this._showSelected();
      this._showOpenSelectedProperties();
    },

    _getOptionName: function (opt) {
      var i;
      var name;

      i = _.indexOf(_.pluck(this._applyOptions, 'id'), opt);
      name = (i === -1) ? '' : this._applyOptions[i].name;

      return name;
    },

    _setupApplyOptions: function () {
      this._applyOptions = [
        {
          id: ApplyPropertiesSelectorView.KEEP_ORIGINAL_PROPERTIES,
          name: lang.KeepOriginalProperties
        },
        {
          id: ApplyPropertiesSelectorView.APPLY_DESTINATION_PROPERTIES,
          name: lang.ApplyDestinationProperties
        }
      ];
      if (this.options.includeCombineProperties === true) {
        this._applyOptions.push({
          id: ApplyPropertiesSelectorView.COMBINE_ALL_PROPERTIES,
          name: lang.CombineAllProperties
        });
      }
    },

    _setSelected: function (applyPropertiesOption) {
      this.selected = applyPropertiesOption;
    },

    _showSelected: function () {
      this.ui.selectedLabel.text(this._getOptionName(this.selected));

      this.$el.find('li[data-optionid]').removeClass('binf-active');
      this.$el.find('li[data-optionid=' + this.selected + ']').addClass('binf-active');
    },

    _showOpenSelectedProperties: function () {
      if (this.openSelectedProperties === true) {
        this.ui.toggle.attr('aria-expanded', 'true');
        this.ui.iconOpenSelectedProperties
            .removeClass('icon-checkbox')
            .addClass('icon-checkbox-selected');
      }
      else {
        this.ui.toggle.attr('aria-expanded', 'false');
        this.ui.iconOpenSelectedProperties
            .removeClass('icon-checkbox-selected')
            .addClass('icon-checkbox');
      }
    },

    _closeToggle: function () {
      if (this.ui.toggle.parent && this.ui.toggle.parent().hasClass('binf-open')) {
        this.ui.toggle.binf_dropdown('toggle');
      }
    }
  });

  ApplyPropertiesSelectorView.KEEP_ORIGINAL_PROPERTIES = 1;
  ApplyPropertiesSelectorView.APPLY_DESTINATION_PROPERTIES = 2;
  ApplyPropertiesSelectorView.COMBINE_ALL_PROPERTIES = 3;

  return ApplyPropertiesSelectorView;

});

csui.define('csui/dialogs/node.picker/impl/search.list/search.query.model',['module', 'csui/lib/underscore', 'csui/lib/backbone'
], function (module, _, Backbone) {

  var SearchQueryTargetBrowseModel = Backbone.Model.extend({

    constructor: function SearchQueryTargetBrowseModel(attributes, options) {
      SearchQueryTargetBrowseModel.__super__.constructor.apply(this, arguments);
    },

    toJSON: function () {
      return SearchQueryTargetBrowseModel.__super__.toJSON.apply(this, arguments);
    }
  });
  return SearchQueryTargetBrowseModel;
});

csui.define('csui/dialogs/node.picker/impl/header/search.box/impl/search.box.model',['module', 'csui/lib/underscore', 'csui/lib/backbone'
], function (module, _, Backbone) {

  var SearchBoxModel = Backbone.Model.extend({

    constructor: function SearchBoxModel(attributes, options) {
      SearchBoxModel.__super__.constructor.apply(this, arguments);
    },

    toJSON: function () {
      return SearchBoxModel.__super__.toJSON.apply(this, arguments);
    }
  });

  return SearchBoxModel;
});
csui.define('csui/dialogs/node.picker/impl/header/search.box/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/dialogs/node.picker/impl/header/search.box/impl/nls/root/lang',{
  placeholder: 'Search',
  clearerTitle: 'Clear keywords',
  searchBoxTitle: 'Enter your search term',
  searchOptionsTitle: 'Show search options',
  searchFromHere: 'Search from here',
  searchFromHereAria: 'Select: search from here',
  searchIconTitle: 'Search',
  searchIconAria: 'Open searchbar',
  searchOptionsSelect: 'Select: ',
  startSearch: 'Start search'
});



/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/header/search.box/impl/search.box',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"search-bar\">\r\n  <div class=\"search-bar-content\">\r\n    <div class=\"csui-search-input-container\">\r\n      <input type=\"search\" class=\"csui-input csui-acc-focusable\"\r\n             placeholder=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.placeholder : stack1), depth0))
    + "\" title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.searchBoxTitle : stack1), depth0))
    + "\" tabindex=\"0\"\r\n             data-cstabindex=\"-1\" aria-label=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.searchBoxTitle : stack1), depth0))
    + "\">\r\n      <div class=\"csui-search-options-dropdown\"></div>\r\n    </div>\r\n    <span class=\"csui-clearer formfield_clear csui-acc-focusable\" title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.clearerTitle : stack1), depth0))
    + "\"\r\n          aria-label=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.clearerTitle : stack1), depth0))
    + "\" role=\"button\" tabindex=\"0\" data-cstabindex=\"-1\"></span>\r\n  </div>\r\n</div><a href=\"javascript:void(0);\"\r\n         class=\"icon icon-global-search csui-header-search-icon csui-acc-focusable\"\r\n         title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.searchIconTitle : stack1), depth0))
    + "\" aria-label=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.messages : depth0)) != null ? stack1.searchIconAria : stack1), depth0))
    + "\"\r\n         tabindex=\"0\" data-cstabindex=\"-1\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"></a>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_header_search.box_impl_search.box', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/header/search.box/impl/search.slice.dropdown',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-selected-checkbox csui-slice-checkbox csui-checkbox-primary\" tabindex=\"0\"\r\n     data-cstabindex=\"-1\" aria-label=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.searchFromHereAria : depth0), depth0))
    + "\">\r\n  <input type=\"checkbox\" class=\"csui-searchbox-option\" name=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.nodeId : depth0), depth0))
    + "\" id=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.nodeIdSO : depth0), depth0))
    + "\"\r\n         value=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.nodeId : depth0), depth0))
    + "\">\r\n  <label class=\"csui-search-slice-name csui-selectlabel\" for=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.nodeIdSO : depth0), depth0))
    + "\"\r\n         title=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.select : depth0), depth0))
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.fromHere : depth0), depth0))
    + "\">\r\n    <span class=\"cs-ellipsis\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.fromHere : depth0), depth0))
    + "</span>\r\n  </label>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_header_search.box_impl_search.slice.dropdown', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/node.picker/impl/header/search.box/impl/search.box',[],function(){});
csui.define('csui/dialogs/node.picker/impl/header/search.box/search.box.view',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/dialogs/node.picker/impl/search.list/search.query.model',
  'csui/dialogs/node.picker/impl/header/search.box/impl/search.box.model',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'i18n!csui/dialogs/node.picker/impl/header/search.box/impl/nls/lang',
  'hbs!csui/dialogs/node.picker/impl/header/search.box/impl/search.box',
  'hbs!csui/dialogs/node.picker/impl/header/search.box/impl/search.slice.dropdown', 'i18n',
  'css!csui/dialogs/node.picker/impl/header/search.box/impl/search.box',
  'csui/lib/jquery.ui/js/jquery-ui'
], function (module, _, $, Marionette,
    SearchQueryModel, SearchBoxModel, TabableRegionBehavior, lang,
    template, SliceDropDownTemplate, i18n) {
  "use strict";

  var config = _.defaults({}, module.config(), {
    showInput: false,
    inputValue: '',
    nodeName: '',
    searchFromHere: true
  });

  var SearchBoxView = Marionette.ItemView.extend({
    className: 'csui-search-box',
    template: template,
    templateHelpers: function () {
      var messages = {
        placeholder: lang.placeholder,
        clearerTitle: lang.clearerTitle,
        searchIconTitle: lang.searchIconTitle,
        searchBoxTitle: lang.searchBoxTitle,
        searchOptionsTitle: lang.searchOptionsTitle,
        searchOptionsSelect: lang.searchOptionsSelect,
        startSearch: lang.startSearch,
        searchIconAria: lang.searchIconAria
      };
      return {
        messages: messages
      };
    },
    sliceDropDownTemplate: SliceDropDownTemplate,
    ui: {
      input: '.csui-input',
      clearer: '.csui-clearer',
      searchIcon: '.csui-header-search-icon'
    },
    events: {
      'click .csui-header-search-icon': 'searchIconClicked',
      'focusin @ui.input': 'hideStartLocations',
      'click @ui.input': 'hidePopover',
      'keyup @ui.input': 'inputTyped',
      'paste @ui.input': 'inputChanged',
      'keydown @ui.clearer': 'clearerClicked',
      'change @ui.input': 'inputChanged',
      'click @ui.clearer': 'clearerClicked',
      'click .csui-searchbox-option': 'selectSearchOption',
      'keydown .csui-slice-checkbox': 'changeSearchOption',
      'focusout @ui.input': 'hideSearchOptionsDropDown',
      'focusout .csui-search-options-dropdown': 'hideSearchOptionsDropDown',
      'mouseleave .csui-search-options-dropdown': 'hideSearchOptionsDropDown'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    constructor: function SearchBoxView(options) {
      options || (options = {});
      options.data = _.defaults({}, options.data, config);
      this.direction = i18n.settings.rtl ? 'left' : 'right';

      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.model = new SearchQueryModel(undefined, options);
      this.searchboxModel = new SearchBoxModel(undefined, options);

      this.listenTo(this.searchboxModel, "change", this.prepareTargetBrowsedropdown);
      this.listenTo(this.searchboxModel, "change", this.searchIconToggle);
      this.listenTo(this.searchboxModel, "change", this.hideSearchBar);
      if (!!this.model.get("where")) {
        $(document).bind('click.' + this.cid + ' keydown.' + this.cid, this, this._hideSearchBar);
      }
    },

    isSearchbarVisible: function () {
      return this.$('.search-bar').is(':visible');
    },

    onRender: function () {
      var value = this.options.data.inputValue || this.model.get('where');
      if (value) {
        this._setInputValue(value);
        this.$el.find(".search-bar").show();
      }
      if (this.options.data.showInput || value) {
        this.triggerMethod('before:show:input', this);
        this.ui.input.show();
        this.triggerMethod('show:input', this);
      }
      this.ui.searchIcon.removeClass('icon-header-search_enabled').addClass('icon-header-search');
      var self = this;
      this.$el.find('*[data-cstabindex]').on('focus', function () {
        self._updateFocusables(this);
      });
    },

    _updateFocusables: function (ele) { 
      var target = $(ele);
      this.focusedElement &&
      this.focusedElement.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
      target.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
      this.focusedElement = target;

    },

    currentlyFocusedElement: function (arg) {
      if (this.$el) {
        var focusables = this.$el.find('*[data-cstabindex=-1]');
        if (focusables.length) {
          focusables.prop('tabindex', 0);
        }
        var shiftKey = !!arg && arg.shiftKey;
        if (!shiftKey && this.$el.find(".search-bar").length &&
            this.$el.find(".search-bar").is(":visible")) {
          this.focusElement = this.$el.find('.csui-input');
        } else if (this.$el.find('a.csui-acc-focusable').length) {
          this.focusElement = this.$el.find('a.csui-acc-focusable');
        }
      }
      return this.focusElement;
    },

    onLastTabElement: function (shiftTab) {

      var tabItems = this.$('[data-cstabindex=-1]'),
          lastItem = tabItems.length - 1,
          self     = this;
      //few elements are missing at time of render, so need to update tabable status here.
      this.$el.find('*[data-cstabindex]').on('focus', function () {
        self._updateFocusables(this);
      });
      if (tabItems.length) {
        var focusElement = shiftTab ? tabItems[0] : tabItems[lastItem];
        this.$('.csui-focus').removeClass('csui-focus');
        return $(focusElement).hasClass(TabableRegionBehavior.accessibilityActiveElementClass);
      }

      return true;
    },

    resetPageDefaults: function (event) {
      this.model.resetDefaults = true;
    },

    searchIconClicked: function (event) {
      $(document).bind('click.' + this.cid + ' keydown.' + this.cid, this, this._hideSearchBar);
      this.ui.input.toggleClass(TabableRegionBehavior.accessibilityFocusableClass);
      this.resetPageDefaults(event);
      if (!!this.searchboxModel.nodeId && this.$el.find('.csui-searchbox-option').length > 0) {
        this.$el.find('.csui-searchbox-option')[0].checked = this.options.data.searchFromHere;
      }
      if (this.$el.find(".search-bar").is(':visible')) {
        this.$el.find('a.icon-global-search').attr('aria-expanded', 'true');
        var value = this.ui.input.val().trim();
        if (!!value) {
          this._setInputValue(value);
          $(event.currentTarget).attr("title", lang.startSearch).attr("aria-label",
              lang.startSearch);
        }
        var searchOption = "",
            _selOption   = this.$el.find(".csui-searchbox-option:checked");
        if (!!_selOption) {
          searchOption = _selOption.val();
        }
        if (!!history.state && !!history.state.search) {
          this.previousState = history.state.search;
        }
        if (!!value) {
          this.model.clear({silent: true});
          var params = {};
          params['location_id1'] = searchOption;
          if (value) {
            params['where'] = value;
          }
          this.model.set(params);
          this.trigger("change:searchterm", this.model);
          this._updateInput(event);
        }
        if (!!this.previousState) {
          this.model["prevSearchState"] = this.previousState;
        }
      } else {
        if (this.$el && this.$el.parents()) {
          var eleLoadContainer = this.$el.parents(".target-browse ").find(
              "div[class='load-container']");
          if (eleLoadContainer && !eleLoadContainer.hasClass("binf-hidden")) {
            this.$el.find('a.icon-global-search').attr('aria-expanded', 'true');
            var that = this;
            this.hideStartLocations();
            this.$el.find('.search-bar').show('blind', {direction: this.direction}, '200',
                function () {
                  that.ui.input.focus();
                });
            //this._updateInput(event);
            if (this.model.attributes.where === "") {
              $(event.currentTarget).title = ""; // TODO What case is this? why empty the title?
              $(event.currentTarget).addClass("icon-header-search-nohover");
            }
          }
        }
      }
    },

    showStartLocations: function (event) {
      this.trigger("show:startLocation");
    },

    hideStartLocations: function (event) {
      this.trigger("hide:startLocation");
    },

    inputTyped: function (event) {
      var value = this.ui.input.val().trim();
      if (event.which === 13) {
        event.preventDefault();
        event.stopPropagation();
        this._setInputValue(value);
        if (!!value) {
          this.searchIconClicked(event);
        }
        if (this.previousValue != value) {
          this.previousValue = value;
        }
      } else if (event.keyCode == 27) {
        if (this.ui.searchIcon.is(":focus")) {
          event.preventDefault();
          event.stopImmediatePropagation();
        } else {
          this.hideSearchBar();
          this.ui.searchIcon.focus();
          event && event.stopPropagation();

        }
      } else {
        if (event.which === 40 && $('.csui-search-options-dropdown').is(':visible')) {
          this.$el.find('.csui-selected-checkbox').focus().focus();
        }
        else {
          this.inputChanged(event);
        }
      }
    },

    inputChanged: function (event) {
      var value = this.ui.input.val();
      this.searchIconToggle();
      this.ui.clearer.toggle(!!value.length);
      this.showOptionsDropdown(event);
    },

    showOptionsDropdown: function (event) {
      var _e = event || window.event;
      if (this.searchboxModel.nodeId && _e.which !== 27) {
        this.$el.find('.csui-search-options-dropdown').show();
        if (this.$el.find('.csui-searchbox-option').length > 0) {
          this.$el.find('.csui-searchbox-option')[0].checked = this.options.data.searchFromHere;
        }
      }
    },

    prepareTargetBrowsedropdown: function (e) {
      /*if (!this.searchboxModel.nodeId && this.model.get('location_id1')) {
        this.searchboxModel.nodeId = this.model.get('location_id1');
      }*/
      if (this.searchboxModel.nodeId) {
        this.searchOptions = {};
        this.searchOptions.nodeId = this.searchboxModel.nodeId;
        this.searchOptions.nodeIdSO = _.uniqueId('csui-so-' + this.searchboxModel.nodeId);
        this.searchOptions.select = lang.searchOptionsSelect;
        this.searchOptions.fromHere = lang.searchFromHere;
        this.searchOptions.selectFromHereAria = lang.searchFromHereAria;
        var content = this.sliceDropDownTemplate(this.searchOptions);
        this.$el.find('.csui-search-options-dropdown').html(content);
        this.hideSearchOptionsDropDown();
        this.ui.searchIcon.show();
        this.ui.searchIcon.removeClass('icon-header-search_enabled').addClass('icon-header-search');
      } else {
        //this.ui.searchIcon.hide();
        this.destroyOptionspopover();
      }
    },

    destroyOptionspopover: function (e) {
      // if node is not available destroy the search options dropdown
      this.$el.find('.csui-search-options-dropdown').html("");
      this.$el.find('.csui-search-options-dropdown').hide();
    },

    changeSearchOption: function (event) {
      //Enter key or Space will select search from here option
      if (event.keyCode === 13 || event.keyCode === 32) {
        var _selEle = this.$el.find(".csui-searchbox-option:checked");
        if (_selEle.length > 0) {
          this.$el.find('.csui-searchbox-option')[0].checked = false;
        } else {
          this.$el.find('.csui-searchbox-option')[0].checked = true;
        }
        this.selectSearchOption(event);
      }
    },

    selectSearchOption: function (e) {
      var _selEle = this.$el.find(".csui-searchbox-option:checked");
      if (_selEle.length > 0) {
        this.options.data.searchFromHere = true;
      } else {
        this.options.data.searchFromHere = false;
      }
    },

    hideSearchOptionsDropDown: function () {
      var that = this;
      var searchFromHereIcon = that.$el.find('.csui-searchbox-option');
      searchFromHereIcon.attr("tabindex", -1);
      setTimeout(function () {
        if (that.$el.find('.csui-selected-checkbox')[0] === document.activeElement) {
          return false;
        }
        else {
          var self = that;
          if (that.popoverTimer) {
            clearTimeout(that.popoverTimer);
          }
          that.popoverTimer = setTimeout(function () {
            self.showSearchOptionDropDown();
          }, 800);
          return true;
        }
      }, 100);
    },

    showSearchOptionDropDown: function () {
      if (!this.$el.find('.csui-search-options-dropdown').is(":hover")) {
        $('.csui-search-options-dropdown').hide();
      } else {
        if (this.popoverTimer) {
          clearTimeout(this.popoverTimer);
        }
      }
    },

    clearerClicked: function (event) {
      if (event.type === "click" || event.keyCode === 13) {
        event.preventDefault();
        event.stopPropagation();
        this._setInputValue('');
        this.ui.searchIcon.removeClass('icon-header-search_enabled').addClass('icon-header-search');
        this.hidePopover(event);
        this.ui.input.focus();
      }
    },

    setSlices: function (e) {
      e.preventDefault();
      e.stopPropagation();
      var sliceId           = $(e.target).data("sliceid"),
          _checkedEle       = this.$el.find(".csui-search-popover-checked"),
          _toggleCurrentEle = this.$el.find(".icon-listview-checkmark"),
          _isCurrentEle     = _toggleCurrentEle.length > 0 &&
                              _toggleCurrentEle.attr("id") === $(e.target).data("sliceid") + "";
      this.options.sliceString = "";
      $(_checkedEle).removeClass("icon-listview-checkmark");
      if (!_isCurrentEle) {
        $("#" + sliceId).addClass("icon-listview-checkmark");
        this.options.sliceString = "{" + sliceId + "}";
      }
      this.slice = this.options.sliceString;
    },

    hidePopover: function (event) {
      if ($('.csui-search-box-slice-popover').css("display") === "block") {
        $('.csui-search-box-slice-popover').binf_popover('hide');
      }
      this.showOptionsDropdown(event);
    },

    hideSearchBar: function (event) {
      var ele  = this.$el.find(".search-bar"),
          self = this;
      this.ui.input.val("");
      ele.hide('blind', {direction: this.direction}, '200', function () {
        self.showStartLocations();
      });
      this.$el.find('.csui-header-search-icon').removeClass(
          'icon-header-search_enabled').addClass('icon-header-search');
    },

    _hideSearchBar: function (event) {
      var _e   = event || window.event,
          ele  = $('.search-bar'),
          that = event.data;
      if (ele.is(':visible')) {
        if ((_e.type === 'keydown' && (_e.keyCode === 27 || _e.which === 27)) ||
            (!$(_e.target).closest(ele).length && _e.type === 'click') &&
            !$(_e.target).closest('.csui-header-search-icon').length &&
            !$(_e.target).closest('.esoc-activityfeed-invisiblebutton').length) {

          $(this).find(".icon-header-search-nohover").removeClass("icon-header-search-nohover");
          $(this).find('.csui-input').val('');
          that.$el.find(ele).hide('blind', {direction: event.data.direction}, '200', function () {
            that.showStartLocations();
            that.focusedElement = undefined;
            var fe = that.currentlyFocusedElement();
            fe.focus();
          });
          $(this).find('.csui-search-box-slice-popover').binf_popover('hide');
          $(this).find('.csui-search-box .csui-header-search-icon').attr('title',
              lang.searchIconTitle);
          $(this).find('.csui-search-box .csui-header-search-icon').attr('aria-label',
              lang.searchIconAria);
          $(this).find('.csui-search-box .csui-header-search-icon').attr('aria-expanded', 'false');
          event.data.slice = event.data.model.get('slice');
          event.data.options.data.searchFromHere = true;
          if (!!this.$el) {
            this.$el.parents(".csui-navbar").find(".binf-navbar-brand").addClass(
                "binf-navbar-collapse");
          }
          $(this).find('.csui-search-options-dropdown').hide();
          $(this).find('.csui-search-box .csui-header-search-icon').removeClass(
              'icon-header-search_enabled').addClass('icon-header-search');
          $(document).unbind('click.' + this.cid + ' keydown.' + this.cid);
        }
      }
    },
    _updateInput: function (event) {
      if (this._isRendered) {
        var value = this.model.get('where') || '';
        this._setInputValue(value);
      }
    },

    _setInputValue: function (value) {
      this.ui.input.val(value);
      this.ui.clearer.toggle(!!value.length);
      this.searchIconToggle();
    },

    searchIconToggle: function () {
      var value = this.ui.input.val().trim();
      if (!!value) {
        this.ui.searchIcon.removeClass("icon-header-search").addClass("icon-header-search_enabled");
        this.ui.input.addClass("csui-input-focus");
        $(this.ui.searchIcon).attr("title", lang.startSearch).attr("aria-label", lang.startSearch);
        $(this.ui.searchIcon).removeClass("icon-header-search-nohover");
      } else {
        this.ui.searchIcon.removeClass("icon-header-search_enabled").addClass("icon-header-search");
        this.ui.input.removeClass("csui-input-focus");
        if (this.$el.find('.search-bar').is(':visible')) {
          $(this.ui.searchIcon).addClass("icon-header-search-nohover");
          $(this.ui.searchIcon).attr("title", lang.searchBoxTitle).attr("aria-label",
              lang.searchBoxTitle);
        }
      }
    }

  });

  return SearchBoxView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/header/header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <h2 id=\"nodePickerHeader\" class=\"csui-title\">"
    + ((stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper))) != null ? stack1 : "")
    + "</h2>\r\n  <div class='csui-filtername-container'>\r\n    <span class=\"cs-icon-required category_required\" title=\"\"></span>\r\n    <input type='text' class='csui-filtername' placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.placeHolderName || (depth0 != null ? depth0.placeHolderName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"placeHolderName","hash":{}}) : helper)))
    + "\" tabindex=\"-1\"\r\n           data-cstabindex=\"-1\" />\r\n    <span class=\"csui-filtername-error binf-hidden\" title=\"\"></span>\r\n  </div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "  <h2 id=\"nodePickerHeader\" class=\"csui-title\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</h2><span class=\"csui-separator\"></span>\r\n";
},"5":function(depth0,helpers,partials,data) {
    return "csui-no-search";
},"7":function(depth0,helpers,partials,data) {
    return "    <div class=\"csui-start-locations binf-dropdown\" ></div>\r\n";
},"9":function(depth0,helpers,partials,data) {
    var stack1;

  return "      <div class=\"csui-global-search "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.saveFilter : depth0),{"name":"if","hash":{},"fn":this.program(10, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.propertiesSeletor : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0),"inverse":this.program(14, data, 0)})) != null ? stack1 : "")
    + "\"></div>\r\n";
},"10":function(depth0,helpers,partials,data) {
    return "csui-save-filter ";
},"12":function(depth0,helpers,partials,data) {
    return "";
},"14":function(depth0,helpers,partials,data) {
    return "csui-no-properties-selector for-shortcut";
},"16":function(depth0,helpers,partials,data) {
    return "      <div class=\"apply-properties-selector\"></div>\r\n";
},"18":function(depth0,helpers,partials,data) {
    return "csui-no-properties-selector";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.saveFilter : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "\r\n<div class=\"csui-target-controls "
    + ((stack1 = (helpers.xif || (depth0 && depth0.xif) || helpers.helperMissing).call(depth0,"this.globalSearch !== false",{"name":"xif","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.locationSelector : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n  <div class=\"csui-target-search-property-container\">\r\n"
    + ((stack1 = (helpers.xif || (depth0 && depth0.xif) || helpers.helperMissing).call(depth0,"this.globalSearch !== false",{"name":"xif","hash":{},"fn":this.program(9, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.propertiesSeletor : depth0),{"name":"if","hash":{},"fn":this.program(16, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "    <span class=\"csui-separator "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.propertiesSeletor : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0),"inverse":this.program(18, data, 0)})) != null ? stack1 : "")
    + "\"></span>\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_header_header', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/node.picker/impl/header/header',[],function(){});
csui.define('csui/dialogs/node.picker/impl/header/header.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/dialogs/node.picker/impl/header/apply.properties.selector/apply.properties.selector.view',
  'csui/dialogs/node.picker/impl/header/start.location.selector/start.location.selector.view',
  'csui/dialogs/node.picker/impl/header/search.box/search.box.view',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/dialogs/node.picker/impl/header/header',
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'csui/lib/handlebars.helpers.xif',
  'css!csui/dialogs/node.picker/impl/header/header'
], function (_,
    $,
    Marionette,
    ApplyPropertiesSelectorView,
    StartLocationCollectionView,
    SearchBoxView,
    TabableRegionBehavior,
    headerTemplate,
    lang) {

  var HeaderView = Marionette.LayoutView.extend({
    template: headerTemplate,
    className: 'cs-header-control',
    regions: {
      startLocations: '.csui-start-locations',
      globalSearch: '.csui-global-search',
      properties: '.apply-properties-selector'
    },

    ui: {
      saveFilter: '.csui-filtername',
      saveFilterError: '.csui-filtername-error',
      startlocations: '.csui-start-locations'
    },

    events: {
      'keyup @ui.saveFilter': 'onChangeFilterName',
      'keydown @ui.startlocations': 'onStartLoaction',
      'focusout @ui.saveFilter': 'onFocusoutFilterName'
    },

    templateHelpers: function () {
      var options = this.options;
      return {
        title: options.title,
        locationSelector: options.locationSelector,
        propertiesSeletor: options.propertiesSeletor,
        saveFilter: options.saveFilter,
        placeHolderName: lang.placeHolderName,
        globalSearch: options.globalSearch,
        backButtonTooltip: lang.backButtonTooltip
      };
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    initialize: function () {
      var options = this.options;
      var defaultApplyPropertiesOption = ApplyPropertiesSelectorView.KEEP_ORIGINAL_PROPERTIES;
      if (options.propertiesSeletor) {
        this.propertiesView = new ApplyPropertiesSelectorView({
          selected: defaultApplyPropertiesOption,
          includeCombineProperties: this.options.includeCombineProperties
        });
      }

      if (options.locationSelector) {
        this.startLocationView = new StartLocationCollectionView({
          collection: this.options.locations,
          title: this.options.dialogTitle,
          selected: this.options.initialLocation
        });
      }
      if (options.globalSearch !== false) {
        var initialLocationID, initialLocationName;
        if (this.options.initialLocation) {
          var initialLocationFactory = this.options.initialLocation.get("factory");
          initialLocationID = (!!initialLocationFactory &&
                               !!initialLocationFactory.options.container) ?
                              initialLocationFactory.options.container.get("id") : null;
          initialLocationName = (!!initialLocationFactory &&
                                 !!initialLocationFactory.options.container) ?
                                initialLocationFactory.options.container.get("name") : null;
        }
        this.searchBoxView = new SearchBoxView({
          targetBrowseSearch: true,
          locationID: initialLocationID,
          locationName: initialLocationName
        });
        this.searchboxModel = this.searchBoxView.searchboxModel;
        this.searchQueryModel = this.searchBoxView.model;
      }
    },

    onRender: function () {
      var options = this.options;
      if (this.startLocationView) {
        this.startLocations.show(this.startLocationView);
      }

      if (this.propertiesView) {
        this.properties.show(this.propertiesView);
      }

      if (this.searchBoxView) {
        this.globalSearch.show(this.searchBoxView);
      }

      this.searchBoxView.on('show:startLocation', this.showStartLocations, this);
      this.searchBoxView.on('hide:startLocation', this.hideStartLocations, this);
      this.searchBoxView.on('close:dialog', this.onApplyProperties, this);      

      var self = this;
      this.$el.find('*[data-cstabindex]').on('focus', function () {
        var target = $(this);
        self.focusedElement &&
        self.focusedElement.removeClass(TabableRegionBehavior.accessibilityActiveElementClass);
        target.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
        self.focusedElement = target;
      });
    },

    currentlyFocusedElement: function (arg) {
      if (this.$el) {
        var focusables = this.$('*[tabindex]');
        if (focusables.length) {
          focusables.prop('tabindex', 0);
        }
        var shiftKey = !!arg && arg.shiftKey;
        if (!shiftKey && this.$el.find(".csui-filtername").length) {
          return this.$el.find('.csui-filtername');
        } else {
          return !!focusables[0] && $(focusables[0]).focus();
        }
      }
    },

    onLastTabElement: function (shiftTab, event) {
      // return true if focus is on last tabable element else false.
      return (shiftTab && event.target === this.$('*[tabindex]')[0]);
    },

    onStartLoaction: function (event) {
      if (event.keyCode === 27) {
        !!this.ui.startlocations.is(':focus') ? '' : event.stopImmediatePropagation();
      }
    },

    onApplyProperties: function () {
      this.trigger('parent:destroydialog');
    },

    showStartLocations: function () {
      this.startLocationView.$el.removeClass("binf-hidden");
    },

    hideStartLocations: function () {
      this.startLocationView.$el.addClass("binf-hidden");
    },

    onDomRefresh: function () {
      if (this.startLocationView) {
        this.startLocationView.trigger('dom:refresh');
      }
      if (this.propertiesView) {
        this.propertiesView.trigger('dom:refresh');
      }
      if (this.searchBoxView) {
        this.searchBoxView.trigger('dom:refresh');
      }
    },

    hideStartLocationLabel: function (node) {
      this.startLocationView.hideDropDownLabel(node);
    },

    reset: function () {
      this.startLocationView.reset();
    },

    onChangeFilterName: function () {
      this.trigger('change:filterName');
    },

    onFocusoutFilterName: function () {
      this.trigger('focusout:filterName');
    },

    showErrorMessage: function (errorMessage) {
      this.$(this.ui.saveFilterError).html(errorMessage);
      this.ui.saveFilterError.removeClass("binf-hidden");
    },

    removeErrorMessage: function () {
      this.$(this.ui.saveFilterError).html("");
      this.ui.saveFilterError.addClass("binf-hidden");
    }
  });

  return HeaderView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/footer/footer',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-selected-items\"></div>\r\n<div class=\"csui-footer-buttons\"></div>";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_footer_footer', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/dialogs/node.picker/impl/footer/selectedItems.info',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return this.escapeExpression(((helper = (helper = helpers.selectedItemsMessage || (depth0 != null ? depth0.selectedItemsMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectedItemsMessage","hash":{}}) : helper)));
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<span>"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isMultiSelectEnabled : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</span>\r\n";
}});
Handlebars.registerPartial('csui_dialogs_node.picker_impl_footer_selectedItems.info', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/dialogs/node.picker/impl/footer/footer',[],function(){});
csui.define('csui/dialogs/node.picker/impl/footer/footer.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/lib/backbone',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/dialog/impl/footer.view',
  'hbs!csui/dialogs/node.picker/impl/footer/footer',
  'hbs!csui/dialogs/node.picker/impl/footer/selectedItems.info',
  'i18n!csui/dialogs/node.picker/impl/nls/lang',
  'csui/lib/handlebars.helpers.xif',
  'css!csui/dialogs/node.picker/impl/footer/footer'
], function (_,
    $,
    Marionette,
    Backbone,
    ViewEventsPropagationMixin,
    TabableRegionBehavior,
    DialogFooterView,
    footerTemplate,
    selectedItemsMessageTemplate,
    lang) {

  var NodePickerSelectedItemsMessageView = Marionette.ItemView.extend({
    template: selectedItemsMessageTemplate,
    className: 'csui-selectedItems-message',

    templateHelpers: function () {
      var selectedItemsCount   = this.selectedItemsCnt || this.options.selectedItemsCnt,
          selectedItemsMessage = "";
      if (selectedItemsCount === 1) {
        selectedItemsMessage = _.str.sformat(lang.SelectOneItemMessage, selectedItemsCount);
      } else {
        selectedItemsMessage = _.str.sformat(lang.SelectManyItemsMessage, selectedItemsCount);
      }
      var data = {
        isMultiSelectEnabled: this.options.isMultiSelectEnabled,
        selectedItemsMessage: selectedItemsMessage
      };
      return data;
    },

    constructor: function NodePickerSelectedItemsMessageView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.call(this, options);
    },

    onRender: function () {
      var selectedItemsCount = this.selectedItemsCnt || this.options.selectedItemsCnt;
      if (!selectedItemsCount) {
        this.$el.addClass('binf-hidden');
      } else {
        this.$el.removeClass('binf-hidden');
      }
    }
  });
  var NodePickerFooterView = Marionette.LayoutView.extend({

    template: footerTemplate,
    className: 'cs-footer-control',

    behaviors: {
      TabablesBehavior: {
        behaviorClass: TabableRegionBehavior,
        recursiveNavigation: true,
        containTabFocus: true
      }
    },

    regions: {
      selectedItemsInfoRegion: '.csui-selected-items',
      buttonsRegion: '.csui-footer-buttons'

    },
    isTabable: function () {
      return this.$('*[tabindex]').length > 0;
    },

    constructor: function NodePickerFooterView(options) {
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);
      this.propagateEventsToRegions();

    },

    initialize: function () {
      var options    = this.options,
          buttons    = options.buttons ? options.buttons : [],
          footerView = this.footerView = new DialogFooterView({
            collection: new Backbone.Collection(buttons)
          });
      this.messageView = new NodePickerSelectedItemsMessageView(_.extend({},
          {selectedItemsCnt: 0}));
      this.listenTo(footerView, 'childview:click', this.onClickButton);
      this.listenTo(this, 'selectedItems:updateCount', this.updateSelectedItems);
    },

    onRender: function () {
      this.buttonsRegion.show(this.footerView);
    },

    updateButton: function (id, options) {
      var footerView = this.footerView;
      footerView.updateButton(id, options);
    },

    onClickButton: function (view) {
      var attributes = view.model.attributes;
      if (attributes.click) {
        attributes.click({
          dialog: this,
          button: this.$el
        });
      }
      if (attributes.close) {
        this.destroy();
      }
    },

    updateSelectedItems: function (selectedItemsCnt) {
      this.messageView = new NodePickerSelectedItemsMessageView(_.extend({},
          {
            selectedItemsCnt: selectedItemsCnt,
            isMultiSelectEnabled: this.options.isMultiSelectEnabled
          }));
      this.selectedItemsInfoRegion.show(this.messageView);
    },

    onBeforeDestroy: function () {
      this.footerView.destroy();
      this.messageView.destroy();
    }

  });

  _.extend(NodePickerFooterView.prototype, ViewEventsPropagationMixin);
  return NodePickerFooterView;
});





csui.define('csui/dialogs/node.picker/impl/command.type',['module',
  'csui/lib/underscore', 'i18n!csui/dialogs/node.picker/impl/nls/lang'
], function (module, _, lang) {

  var config = module.config();
  _.defaults(config, {addable_types: {899: [899, 480, 146]}});

  var CommandTypes = function (options) {
    var node = options.initialContainer;

    this.actionNodes = options.initialSelection ?
                       (_.isArray(options.initialSelection) ? options.initialSelection :
                        options.initialSelection.models) : [];
    this.unselectableNodes = options.unselectableNodes;
    this.invalidNodes = options.invalidNodes;
    this.selectableTypes = options.selectableTypes || [];
    this.unselectableTypes = options.unselectableTypes || [];
    this.showAllTypes = options.showAllTypes || false;
    this.multiSelect = !!options.selectMultiple;
    this.action = options.command;
    this.parentId = node != null ? node.get('id') : -1;
    this.selectButtonLabel = options.selectButtonLabel || lang.selectButtonLabel;
    switch (this.action) {
    case 'copy':
      this.selectButtonLabel = options.selectButtonLabel || lang.copyButtonLabel;
      break;
    case 'move':
      this.selectButtonLabel = options.selectButtonLabel || lang.moveButtonLabel;
      break;
    case 'addCategories':
      this.selectableTypes = options.selectableTypes || [131];
      this.multiSelect = true;
      this.actionNodes = [];
      break;
    case 'savefilter':
      this.selectButtonLabel = options.selectButtonLabel || lang.saveFilterButtonLabel;
      this.actionNodes = [];
      break;
    case 'collect':
      this.selectableTypes = options.selectableTypes;
      this.multiSelect = true;
      this.actionNodes = [];
      break;
    default:
      // Only concrete actions like "copy" and "move" have an action node,
      // which they handle in a special way. General node picker does not.
      this.actionNodes = [];
    }

  };

  _.extend(CommandTypes.prototype, {

    getSelectableNodeTypes: function () {
      if (this.showAllTypes) {
        return [];
      }

      return this.selectableTypes;
    },

    //Validate that the target node is of select type, or allows requested addable types to complete the action.
    //Used by select.views to remove unselectable types that should not be part of the display list.
    //Used by select.view and its node.list to determine if an item should still be displayed, but marked as unselectable.
    validateTarget: function (targetNode) {
      var targetId     = targetNode.data ? targetNode.data.id : targetNode.get('id'),
          targetType   = targetNode.get('type'),
          addableTypes = config.addable_types[targetType],
          retVal       = _.every(this.unselectableNodes, function (id) {
            return (targetId !== id);
          });

      if (this.browseAllowed(targetNode)) {
        retVal = _.every(this.unselectableTypes, function (type) {
          return targetType !== type;
        });
      }

      //Check if selected node types can be added to targetNode
      if (addableTypes) {
        retVal = _.every(this.actionNodes, function (node) {
          return _.contains(addableTypes, node.get('type'));
        });
      }

      if (retVal) {
        switch (this.action) {
        case 'copy':
          retVal = this.isVirtualNode(targetNode) ? false : this.validateNode(targetNode);
          break;
        case 'move':
          retVal = this.isVirtualNode(targetNode) ? false : this.validId(targetNode);
          if (retVal) {
            retVal = this.validateAddableTypes(targetNode);
          }
          break;
        case 'savefilter':
          retVal = !(this.isVirtualNode(targetNode));
          break;
        }
      }
      return retVal;
    },

    //parent nodes and action Nodes (items to be moved or copied), are not valid target items.
    validId: function (targetNode) {
      var targetId = targetNode.data ? targetNode.data.id : targetNode.get('id');
      return (targetId !== this.parentId);
    },

    validateAddableTypes: function (targetNode) {

      var addable_types = targetNode.addable_types;

      if (!addable_types) {
        return true;
      }

      // Target's  addable types must include every node type,
      // which is going to be copied or moved.
      return _.every(this.actionNodes, function (actionNode) {
        return _.some(addable_types, function (type) {
          return (type.type === actionNode.get('type'));
        });
      });
    },

    isSelectableType: function (targetNode) {
      var targetType = targetNode.get('type');
      //Check against command provided unselectable types
      var retVal = _.every(this.unselectableTypes, function (type) {
        return (targetType !== type);
      });
      if (retVal && !_.isEmpty(this.selectableTypes)) {
        retVal = _.indexOf(this.selectableTypes, targetType) !== -1;
        if (!retVal && this.browseAllowed(targetNode) &&
            _.indexOf(this.selectableTypes, -1) > -1) {
          retVal = true;
        }
      }
      return retVal;
    },
    //returns if the node is selectable based on given action type
    isSelectable: function (targetNode) {
      var targetId     = targetNode.data ? targetNode.data.id : targetNode.get('id'),
          targetType   = targetNode.get('type'),
          addableTypes = config.addable_types[targetType];

      //Identify start location node that is not selectable.
      if (targetNode.get('unselectable')) {
        return false;
      }

      var retVal = this.isSelectableType(targetNode);

      //Check if selected node types can be added to targetNode
      if (retVal && addableTypes) {
        retVal = _.every(this.actionNodes, function (node) {
          return _.contains(addableTypes, node.get('type'));
        });
      }

      //Check against command provided unselectable node
      retVal && (retVal = _.every(this.unselectableNodes, function (id) {
        return (targetId !== id);
      }));

      //Check against the action items that had been chosen for example a copy/move
      retVal && (retVal = !this.isActionNode(targetNode));

      //If the targetNode made it through all the unselectables, then check it agains given commands..
      if (retVal) {
        switch (this.action) {
        case 'copy':
          retVal = this.isVirtualNode(targetNode) ? false : this.validateNode(targetNode);
          break;
        case 'move':
          retVal = this.isVirtualNode(targetNode) ? false : this.validId(targetNode);
          break;
        case 'addCategories':
          retVal = !this.browseAllowed(targetNode);
          break;
        case 'savefilter':
          retVal = !this.isVirtualNode(targetNode);
          break;
        }
      }

      return retVal;
    },

    //returns if the node can be opened for browsing.
    browseAllowed: function (node) {
      // FIXME: Use permitted commands as soon as the server sends browse
      //return node.actions.get('browse');
      var openAction = node.actions && _.find(node.actions.models, function (action) {
        return action.id === 'open';
      });
      return node.get('container') && (node.get('perm_see_contents') !== false || openAction);
    },

    //Called to find out if a node should be part of a list or not.
    validateNode: function (node) {
      var valid = this._hasValidId(node);
      if (valid && !this.showAllTypes) {
        if (!this.browseAllowed(node)) {
          if ((this.selectableTypes.length > 0) &&
              (this.selectableTypes.indexOf(node.get('type')) === -1)) {
            valid = false;
          }
        }
        else if ((this.action === 'move' || this.action === 'copy') &&
                 this.isActionNode(node)) {
          valid = false;
        }
      }
      return valid;
    },

    isActionNode: function (node) {
      var nodeId   = node.get('id'),
          parentId = node.get('parent_id');

      return _.any(this.actionNodes, function (actionNode) {
        var actionNodeId = actionNode.get('id');
        var retVal = actionNodeId === nodeId;
        return (!retVal) ? actionNodeId === parentId : retVal;
      });
    },

    isVirtualNode: function (node) {
      var nodeType = node.get('type'),
          retVal   = false;
      if (nodeType === 899) {
        retVal = true;
      }
      return retVal;
    },

    _hasValidId: function (node) {
      return _.every(this.invalidNodes, function (invalidNode) {
        return invalidNode.get('id') !== node.get('id');
      });
    },

    shouldResolveShortcut: function (node) {
      // Shortcut node and Original node is not available.
      return node.get('type') === 1 && (typeof node.get('original_id') === 'number');
    }

  });

  return CommandTypes;

});


csui.define('css!csui/dialogs/node.picker/impl/node.picker',[],function(){});
csui.define('csui/dialogs/node.picker/node.picker',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/controls/dialog/dialog.view',
  'csui/dialogs/node.picker/impl/node.picker.view',
  'csui/utils/contexts/factories/connector', 'csui/utils/contexts/factories/node',
  'csui/models/node/node.model',
  'csui/dialogs/node.picker/start.locations/start.location.collection',
  'csui/dialogs/node.picker/impl/header/header.view',
  'csui/dialogs/node.picker/impl/footer/footer.view',
  'csui/dialogs/node.picker/impl/command.type',
  'i18n!csui/dialogs/node.picker/impl/nls/lang', 'csui/utils/log',
  'csui/controls/progressblocker/blocker',
  'css!csui/dialogs/node.picker/impl/node.picker'
], function (module, _, $, Backbone, Marionette, DialogView, NodePickerView,
    ConnectorFactory, NodeModelFactory, NodeModel, StartLocationCollection,
    HeaderView, FooterView, CommandType, lang, log, BlockingView, dialogTemplate) {
  "use strict";

  var config = _.extend({
    initialLocationLookupOrder: [
      'csui/dialogs/node.picker/start.locations/recent.containers',
      'csui/dialogs/node.picker/start.locations/current.location',
      'csui/dialogs/node.picker/start.locations/favorites']
  }, module.config());

  var defaultOptions = {
    initialSelection: [],
    selectMultiple: false,
    unselectableNodes: [],
    dialogTitle: lang.dialogTitle,
    orderBy: 'name asc'
  };

  function NodePicker(options) {
    options || (options = {});
    this.options = _.defaults(options, defaultOptions, {pageSize: 30});
    this.options.connector || (this.options.connector = this._getConnector(this.options));

    if (!this.options.connector) {
      var msg = 'Node Picker: insufficient options';
      log.error(msg) && console.error(msg);
      throw new Error(msg);
    }

    //target browse history
    this.options.targetBrowseHistory = [];
    this.options.navigateFromHistory = false;

    //use initial container to distinguish between original container provided and the one returned from
    //startLocation.

    this.options.initialContainer = this._getInitalContainer(this.options);
    this.options.unselectableNodes = this._getArrayOfNodeIds(options.unselectableNodes);
    this.options.commandType = new CommandType(this.options);
  }

  _.extend(NodePicker.prototype, {

    show: function () {

      this._locations = new StartLocationCollection(this.options);

      this._locations
          .fetch({
            connector: this.options.connector,
            container: this.options.initialContainer,
            removeInvalid: false
          })
          .done(_.bind(this._showDialog, this));

      this._deferred = $.Deferred();
      return this._deferred.promise();
    },

    _showDialog: function () {
      this.recentLocations = this._locations.get(
          'csui/dialogs/node.picker/start.locations/recent.containers');

      var invalidLocations = this._locations.where({invalid: true});
      this._locations.remove(invalidLocations);

      var initialLocation = this._getInitialLocation();
      this.searchLocation = initialLocation;

      this._headerControl = this._createHeaderControl(initialLocation);
      this._view = this._createNodePickerView(initialLocation);
      this._footerView = this._createFooterViewControl();
      this._dialog = this._createDialog();

      this._dialog.show();
    },

    _createHeaderControl: function (initialLocation) {
      var options          = this.options,
          locationSelector = options.locationSelector == null ? true : options.locationSelector;
      this.options.previousLocation = initialLocation;
      var headerView = new HeaderView({
        locations: this._locations,
        title: options.dialogTitle,
        initialLocation: initialLocation,
        includeCombineProperties: options.includeCombineProperties,
        propertiesSeletor: options.propertiesSeletor,
        saveFilter: options.saveFilter,
        locationSelector: locationSelector,
        initialSelection: options.initialSelection,
        globalSearch: options.globalSearch
      });

      headerView.startLocationView.on('change:location', this.onChangeLocation, this);
      headerView.on('change:filterName', this.onChangeFilterName, this);
      headerView.on('focusout:filterName', this.onFocusOutFilterName, this);
      if (headerView.searchBoxView) {
        headerView.searchBoxView.on('change:searchterm', this.onChangeSearchTerm, this);
      }

      return headerView;
    },

    _createNodePickerView: function (location) {
      this.options.searchView = false;
      var locationFactory    = location.get('factory'),
          locationParameters = locationFactory.getLocationParameters(this.options);

      _.defaults(locationParameters, this.options);
      var view = new NodePickerView(locationParameters);

      view
          .on('change:complete', this.onSelectionChange, this)
          .on('changing:selection', this._blockDialog, this)
          .on('back:toSearch', this.onClickBackFromFolderToSearch, this)
          .on('change:location', this.onChangeLocationFromBack, this)
          .on('backto:folder', this.onClickBackFromSearch, this)
          .on('close', this.forceClosed, this);
      view.selectViews.on('drill:up', this.onDrillUp, this);

      return view;
    },

    _createFooterViewControl: function () {
      var options    = this.options,
          footerView = new FooterView({
            isMultiSelectEnabled: this.options.commandType.multiSelect,
            buttons: [
              {
                id: 'select',
                label: options.selectButtonLabel || options.commandType.selectButtonLabel,
                'default': true,
                disabled: true,
                click: _.bind(this.onClickSelectButton, this)
              },
              {
                id: 'cancel',
                label: lang.cancelButtonLabel,
                close: true,
                click: _.bind(this.onClickCancelButton, this)
              }
            ]
          });
      return footerView;
    },

    _blockDialog: function () {
      this._dialog.blockWithoutIndicator();
      return true;
    },

    dialogClassName: function () {
      var className = 'target-browse';
      if (this.options && this.options.view && this.options.view.options &&
          this.options.view.options.saveFilter) {
        className = className + ' csui-save-filter-browse';
      }
      return className;
    },

    _createDialog: function () {
      var options = this.options,
          dialog  = new DialogView({
            title: options.dialogTitle,
            headerView: this._headerControl,
            view: this._view,
            className: this.dialogClassName,
            attributes: {
              'aria-label': options.dialogTitle
            },
            largeSize: true,
            footerView: this._footerView
          });

      dialog.listenTo(dialog, 'hide', _.bind(this.onHideDialog, this));
      BlockingView.imbue(dialog);
      return dialog;
    },

    onChangeLocation: function (location) {
      this.options.targetBrowseHistory = [];
      this._view.destroy();
      this.updateFooterSelectedList();
      this._dialog.updateButton('select', {disabled: true});
      this.options.previousLocation = location;
      this._view = this._createNodePickerView(location);
      var node = location.get("factory").container;
      this.updateSearch(node);
      this._dialog.showView(this._view);
    },

    onChangeSearchTerm: function (args) {
      this._headerControl.searchQueryModel = args;
      this._view.destroy();
      this.updateFooterSelectedList();
      this._dialog.updateButton('select', {disabled: true});
      if (this.options.targetBrowseHistory.length === 0) {
        this.options.targetBrowseHistory.push(['location', this.options.previousLocation.id]);
      }
      if (!this._view.options.navigateFromHistory && !this.options.searchView) {
        var leftView  = this._view.selectViews.leftView,
            rightView = this._view.selectViews.rightView,
            page      = Math.floor((leftView.collection.skipCount || 0) /
                                   leftView.collection.topCount) + 1,
            pageSize  = parseInt(leftView.collection.topCount) *
                        parseInt(page);
        if (leftView.container && rightView) {
          var nodeObj = {
            "leftId": (rightView && rightView.container && rightView.container.parent) ?
                      rightView.container.parent.get("id") : undefined,
            "rightId": rightView && rightView.container ? rightView.container.get("id") : undefined,
            "pageSize": pageSize
          };
          this.options.targetBrowseHistory.push(['node', nodeObj]);
        } else if (leftView.container && rightView === null &&
                   (["csui/dialogs/node.picker/start.locations/current.location",
                      "csui/dialogs/node.picker/start.locations/enterprise.volume"].indexOf(
                       this.options.previousLocation.get('id')) < 0)) {
          var nodeObj1 = {
            "leftId": leftView.container.get("id"),
            "rightId": undefined,
            "pageSize": pageSize
          };
          this.options.targetBrowseHistory.push(['node', nodeObj1]);
        }
      }
      this.options.locationID = !!this._view.breadcrumbNode ? this._view.breadcrumbNode.get("id") :
                                this.options.locationID;
      this.searchLocation = this.options.previousLocation;
      var location = this._locations.get(
          'csui/dialogs/node.picker/start.locations/search.location');
      this._view = this._createSearchResultsView(location);
      this._dialog.showView(this._view);
    },

    _createSearchResultsView: function (location, isBackClick) {
      if (this._headerControl.searchQueryModel) {
        this.options.query = this._headerControl.searchQueryModel;
      }
      this.options.searchView = true;
      var locationFactory    = location.get('factory'),
          locationParameters = locationFactory.getLocationParameters(this.options);

      _.defaults(locationParameters, this.options);
      var view = new NodePickerView(locationParameters);

      view
          .on('change:complete', this.onSelectionChange, this)
          .on('changing:selection', this._blockDialog, this)
          .on('open:location', this.onClickLocationFromSearch, this)
          .on('change:location', this.onChangeLocationFromBack, this)
          .on('back:toSearch', this.onClickBackFromFolderToSearch, this)
          .on('backto:folder', this.onClickBackFromSearch, this)
          .on('close', this.forceClosed, this);

      return view;
    },

    onChangeLocationFromBack: function (args) {
      this.options.targetBrowseHistory = [];
      var location = this._locations.get(args[1]);
      this._view.destroy();
      this.updateFooterSelectedList();
      this._dialog.updateButton('select', {disabled: true});
      this.options.previousLocation = location;
      this._view = this._createNodePickerView(location);
      var node = location.get("factory").container;
      this.updateSearch(node);
      this._dialog.showView(this._view);
      this._view.selectViews.options.backBtn = true;
    },

    onClickBackFromSearch: function () {
      this._view.destroy();
      this.updateFooterSelectedList();
      this._dialog.updateButton('select', {disabled: true});
      var locationID = !!this.options.locationID ? this.options.locationID :
                       this.options.container ? this.options.container.get("id") :
                       this.options.nodes.models.length > 0 ?
                       this.options.nodes.models[0].get("id") : null;
      var nodeModel = new NodeModel({id: locationID}, {connector: this.options.connector});
      this.updateSearch(nodeModel, undefined, true);
      var location = this._locations.get(
          'csui/dialogs/node.picker/start.locations/search.location');
      if (this.options.locationID === 0) {
        location = this.options.previousLocation;
      }
      if (!!location) {
        var locationFactory = location.get("factory");
        locationFactory.options.container = nodeModel;
        this._view = this._createNodePickerView(location);
        if (this._view) {
          this._dialog.showView(this._view);
        }
      }
      this._view.selectViews.options.backBtn = true;
    },

    onClickLocationFromSearch: function (nodeModel) {
      this._view.destroy();
      this.updateFooterSelectedList();
      this._dialog.updateButton('select', {disabled: true});
      var location        = this._locations.get(
          'csui/dialogs/node.picker/start.locations/default.location'),
          locationFactory = location.get("factory");
      locationFactory.options.container = nodeModel;
      this.options.targetBrowseHistory.push(['search', this.options.query.clone()]);
      this._view = this._createNodePickerView(location);
      if (this._view) {
        this._dialog.showView(this._view);
        this._view.showBackButton();
      }
    },

    onClickBackFromFolderToSearch: function (view) {
      this._view.destroy();
      //update search query model
      this._headerControl.searchQueryModel = view.requestedQueryModel;
      this.updateSearch(view.options.container, view.requestedQueryModel, true);
      this.updateFooterSelectedList();
      this._dialog.updateButton('select', {disabled: true});
      var location = this._locations.get(
          'csui/dialogs/node.picker/start.locations/search.location');
      this._view = this._createSearchResultsView(location, true);
      this._view.options.navigateFromHistory = view.options.navigateFromHistory;
      this._dialog.showView(this._view);
      this._view.selectViews.options.backBtn = true;
    },

    onSelectionChange: function (node) {
      var disable = this._view.getNumberOfSelectItems() > 0, hasFilterName;
      if (node && node.get("id") && node.get("name")) {
        this.options.locationID = node.get("id");
        this.updateSearch(node);
        this.updateHeaderStartLocation(node);
      }
      this.updateFooterSelectedList();
      this._dialog.destroyBlockingView();
      if (this.options.saveFilter && this._headerControl && this._headerControl.ui.saveFilter) {
        hasFilterName = this._headerControl.ui.saveFilter.val().trim() ? true : false;
        if (hasFilterName && disable) {
          this._dialog.updateButton('select', {disabled: false});
        } else {
          this._dialog.updateButton('select', {disabled: true});
        }
      } else {
        this._dialog.updateButton('select', {disabled: !disable});
      }
      //set focus to first element in list, when press back-botton.
      if (!!this._view.selectViews.options.backBtn) {
        this._view.selectViews.options.backBtn = false;
        this._view.$el.find('.list-content li:first-child').focus();
      }
    },

    onChangeFilterName: function () {
      var eleLoadContainer = this._dialog.$el.find("div[class='load-container']");
      if (this.options.saveFilter && eleLoadContainer && eleLoadContainer.length === 0) {
        var hasFilterName, disable, isEmpty = true;
        if (this._headerControl.ui.saveFilter) {
          isEmpty = this._headerControl.ui.saveFilter.val().trim().length < 1 ? true : false;
        }
        disable = this._view.getNumberOfSelectItems() > 0;
        this.updateFooterSelectedList();
        if (this._headerControl && this._headerControl.ui.saveFilter) {
          hasFilterName = !isEmpty;
        }
        if (hasFilterName && disable) {
          this._dialog.updateButton('select', {disabled: false});
        } else {
          this._dialog.updateButton('select', {disabled: true});
        }
      }
    },

    onFocusOutFilterName: function () {
      this.isValidVirtualFolderName();
    },

    isValidVirtualFolderName: function () {
      var isEmpty       = false,
          isColonExists = false;
      if (this._headerControl.ui.saveFilter && this._headerControl.ui.saveFilter.length === 1 &&
          this._headerControl.ui.saveFilter.val() !== undefined &&
          this._headerControl.ui.saveFilter.val() !== null) {
        isEmpty = this._headerControl.ui.saveFilter.val().trim().length < 1 ? true : false;
        isColonExists = this._headerControl.ui.saveFilter.val().indexOf(":") >= 0 ? true :
                        false;
      }

      if (isEmpty) {
        this._headerControl.showErrorMessage(lang.nameCannotBeEmpty);
      } else if (isColonExists) {
        this._headerControl.showErrorMessage(lang.nameCannotContainColon);
      } else {
        this._headerControl.removeErrorMessage();
      }
      return !isEmpty && !isColonExists;
    },

    updateHeaderStartLocation: function (node) {
      if (this.options.commandType.browseAllowed(node)) {
        this._headerControl.hideStartLocationLabel(node);
      }
    },

    updateSearch: function (node, queryModel, flag) {
      var locationID   = !!node ? node.get("id") : undefined,
          locationName = !!node ? node.get("name") : "";
      if (this._headerControl.searchBoxView && this._headerControl.searchboxModel) {
        if (flag) {
          var prevLocation = queryModel ? queryModel.get("location_id1") :
                             this._headerControl.searchBoxView.model.get("location_id1");
          this._headerControl.searchboxModel.nodeId = prevLocation;
        } else {
          this._headerControl.searchboxModel.nodeId = locationID;
        }
        this._headerControl.searchboxModel.nodeName = locationName;
        this._headerControl.searchboxModel.trigger("change");
      }
    },

    updateFooterSelectedList: function () {
      var selectedItemsCnt = this._view.getNumberOfSelectItems();
      this._footerView.trigger("selectedItems:updateCount", selectedItemsCnt);
    },

    onClickSelectButton: function () {
      if (this && this._view && (this._view.getSelection().length > 0)) {
        var nodes      = this._view.getSelection(),
            properties = this._headerControl.propertiesView,
            filterName;
        if (this._headerControl.searchQueryModel) {
          this._headerControl.searchQueryModel.clear({silent: true});
        }
        if (this._headerControl.ui && this._headerControl.ui.saveFilter &&
            this.isValidVirtualFolderName()) {
          filterName = this._headerControl.ui.saveFilter.val();
        } else {
          return;
        }
        this._result = {
          nodes: nodes,
          applyProperties: properties && properties.selected,
          openSelectedProperties: properties && properties.openSelectedProperties,
          filterName: filterName
        };
        this._dialog.destroy();
      } else {
        this._dialog.updateButton('select', {disabled: true});
      }
    },

    onHideDialog: function () {
      if (this._deferred) {
        if (this._result) {
          this._deferred.resolve(this._result);
        } else if (this._deferred.state() === 'pending') {
          // When the dialog is cancelled, reject the promise without error
          this._deferred.reject({cancelled: true});
        }
      }
      if (this._headerControl.searchQueryModel) {
        this._headerControl.searchQueryModel.clear({silent: true});
      }
    },

    onDrillUp: function (nodeId) {
      this.options.container = new NodeModel({id: nodeId}, {connector: this.options.connector});
      this._locations.get('csui/dialogs/node.picker/start.locations/search.location').get(
          'factory').options.container = this.options.container;
    },

    //Private function with assumes either container or nodes exists.
    _getConnector: function (options) {
      var connector;

      if (options.context) {
        connector = options.context.getObject(ConnectorFactory);
      } else if (options.initialSelection || options.initialContainer) {
        var initalSelection = options.initialSelection,
            nodes           = initalSelection ? (_.isArray(initalSelection) ? initalSelection :
                                                 initalSelection.models) : undefined,
            node            = options.initialContainer || nodes[0];
        connector = node && node.connector;
      }

      return connector;
    },

    _getInitalContainer: function (options) {
      var container = this.options.initialContainer;

      if (container == null || _.isEmpty(container)) {
        var node = options.context && options.context.getModel(NodeModelFactory);
        if (node != null && node.parent != null && node.parent.isFetchable()) {
          if (node.parent.get("id") === 1 || node.get("container")) {
            //RestApi Team confirmed that Enterprise Workspaces and personal workspaces does not
            // have parent, So node it self consider as container
            container = node.clone();
          } else {
            container = node.parent.clone();
          }
        } else {
          container = null;
        }
      } else if (!(container instanceof Backbone.Model)) {
        container = new NodeModel(container, {connector: this.options.connector});
      }

      return container;
    },

    _getArrayOfNodeIds: function (unselectableNodes) {

      if (unselectableNodes && !_.isEmpty(unselectableNodes)) {
        if (unselectableNodes[0] instanceof Backbone.Model) {
          return _.map(unselectableNodes, function (node) {
            return node.get('id');
          });
        }
      }

      return unselectableNodes;
    },

    _getInitialLocation: function () {
      var locationId = this.options.startLocation,
          initialLocation;
      if (locationId) {
        // Enable start location names without the module path for the core modules
        var lastSlash = locationId.lastIndexOf('/');
        if (lastSlash < 0) {
          locationId = 'csui/dialogs/node.picker/start.locations/' + locationId;
        }
        initialLocation = this._locations.get(locationId);
      }
      if (!initialLocation) {
        initialLocation = !_.isEmpty(this.options.initialContainer) &&
                          this._locations.get(
                              'csui/dialogs/node.picker/start.locations/current.location');
        if (!initialLocation) {
          _.find(config.initialLocationLookupOrder,
              function (locationId) {
                initialLocation = this._locations.get(locationId);
                return initialLocation;
              }, this);
          initialLocation || (initialLocation = this._locations.first());
        }
      }
      return initialLocation;
    },

    onClickCancelButton: function () {
      this._dialog.destroy();
    }
  });

  NodePicker.defaults = {

    containers: {
      selectableTypes: [-1],
      dialogTitle: lang.dialogTitleForContainers
    },

    documents: {
      selectableTypes: [144],
      dialogTitle: lang.dialogTitleForDocuments
    },

    categories: {
      initialContainer: {
        id: 'volume',
        type: 133
      },
      selectableTypes: [131],
      dialogTitle: lang.dialogTitleForCategories
    }

  };

  return NodePicker;

});

csui.define('csui/dialogs/members.picker/members.picker.wizard',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/dialogs/members.picker/impl/members.picker.view',
  'csui/utils/contexts/factories/connector',
  'csui/utils/contexts/factories/member',
  'csui/models/member/member.model',
  'csui/models/member/membercollection',
  'csui/models/permission/nodepermission.model',
  'csui/dialogs/members.picker/start.locations/start.location.collection',
  'csui/dialogs/members.picker/impl/command.type',
  'csui/dialogs/members.picker/impl/header/members.picker.header.view',
  'i18n!csui/dialogs/members.picker/impl/nls/lang',
  'csui/utils/log',
  'csui/controls/progressblocker/blocker',
  'csui/controls/wizard/wizard.view',
  'csui/widgets/permissions/impl/edit/permission.level.selector/permission.level.selector.view',
  'csui/widgets/permissions/impl/edit/permission.attributes/permission.attributes.view',
  'csui/widgets/permissions/impl/edit/apply.permission/apply.permission.view',
  'csui/utils/taskqueue',
  'csui/controls/globalmessage/globalmessage', 'i18n',
  'css!csui/dialogs/members.picker/impl/members.picker',
  'csui/dialogs/node.picker/node.picker'
], function (module, _, $, Backbone, Marionette, MembersPickerView, ConnectorFactory,
    MemberModelFactory, MemberModel, MemberCollectionModel, NodePermissionModel,
    StartLocationCollection, CommandType, HeaderView, lang, log, BlockingView, WizardView,
    PermissionLevelSelectorView, PermissionAttributesView, ApplyPermissionView, TaskQueue,
    GlobalMessage, i18n) {
  "use strict";

  var config = _.extend({
    initialLocationLookupOrder: [
      'csui/dialogs/members.picker/start.locations/recent.groups',
      'csui/dialogs/members.picker/start.locations/member.groups',
      'csui/dialogs/members.picker/start.locations/acl.groups',
      'csui/dialogs/members.picker/start.locations/all.members']
  }, module.config());

  _.defaults(config, {
    parallelism: 3
  });

  var defaultOptions = {
    initialSelection: [],
    dialogTitle: lang.dialogTitle,
    orderBy: 'name asc'
  };

  function MembersPickerWizard(options) {
    options || (options = {});
    this.options = _.defaults(options, defaultOptions, {pageSize: 30});
    this.options.connector || (this.options.connector = this._getConnector(this.options));

    if (!this.options.connector) {
      //TODO: provide proper message here.
      var msg = lang.missingConnector;
      log.error(msg) && console.error(msg);
      throw new Error(msg);
    }

    //target browse history
    this.options.targetBrowseHistory = [];
    this.options.navigateFromHistory = false;

    this.options.initialContainer = this._getInitalContainer(this.options);
    this.options.unselectableMembers = this._getArrayOfNodeIds(options.unselectableMembers);
    this.options.selectableMembers = this._getArrayOfNodeIds(options.selectableMembers);
    this.options.commandType = new CommandType(this.options);
  }

  _.extend(MembersPickerWizard.prototype, {

    show: function () {
      this._locations = new StartLocationCollection(this.options);
      this._locations
          .fetch({
            connector: this.options.connector,
            container: this.options.initialContainer,
            nodeId: this.options.nodeModel ? this.options.nodeModel.get("id") : undefined,
            removeInvalid: false
          })
          .done(_.bind(this._showWizard, this));

      this._deferred = $.Deferred();
      return this._deferred.promise();
    },

    _showWizard: function () {
      this._steps = this._createWizardSteps();
      this._wizard = new WizardView({steps: this._steps});
      BlockingView.imbue(this._wizard);
      this._wizard.options.editpermission = this.membersPickerView.options.edit_permission;
      this._wizard.options.groupId = this.membersPickerView.options.groupId;
      this._wizard.options.id = this.membersPickerView.options.groupId;
      this._wizard.options.add = this.membersPickerView.options.add;
      this._wizard.show(this._wizard.options);
      this._wizard.on('save:result', this.onClickFinishButton, this);
      this._wizard.on('add:member', this.onClickAddButton, this);
      this._wizard.currentView.headerView.on('show:selectItem', this.selectUsers, this);
      this._wizard.currentView.headerView.on('enable:add', this.enableAdd, this);
      if (this.options.selectedMember) {
        this.selectUsers(this.options.selectedMember);
      }
    },

    _createHeaderControl: function (initialLocation) {
      var options              = this.options,
          locationSelector     = options.locationSelector == null ? true : options.locationSelector,
          displayStartLocation = options.displayStartLocation == null ? false :
                                 options.displayStartLocation;
      var headerView = new HeaderView({
        locations: this._locations,
        headerViewoptions: this.options,
        title: options.dialogTitle,
        context: options.context,
        authUser: this.options.authUser,
        initialLocation: initialLocation,
        displayStartLocation: displayStartLocation,
        adduserorgroup: options.adduserorgroup ? options.adduserorgroup : false,
        showUserPicker: options.showUserPicker,
        locationSelector: locationSelector,
        selectedMember: options.selectedMember,
        initialSelection: options.initialSelection
      });

      options.adduserorgroup &&
      headerView.startLocationView.on('change:location', this.onChangeLocation, this);
      headerView.on('hide:parentDialog', this.parentdialogdestroy, this);
      return headerView;
    },

    parentdialogdestroy: function (e) {
      this._wizard.destroy();
    },

    _createPickerView: function (location) {
      if (!this.options.startLocation) {
        this.options.startLocation = this._locations.at(0);
      }
      var options            = this.options,
          locationFactory    = location.get('factory'),
          locationParameters = locationFactory.getLocationParameters(this.options);

      _.defaults(locationParameters, this.options);
      var membersPickerView = new MembersPickerView(locationParameters);
      membersPickerView.on('update:button', this.updateButton, this);
      membersPickerView.on('changing:selection', this._blockDialog, this)
          .on('change:location', this.onChangeLocation, this);
      if (!!options.adduserorgroup) {
        membersPickerView.on('change:complete', this.onSelectionChange, this);
      }
      this.membersPickerView = membersPickerView;
      return membersPickerView;
    },

    _createPermissionLevelSelectorView: function () {
      var permissionLevelView = new PermissionLevelSelectorView({
        selected: 1,
        isContainer: this.options.nodeModel ? this.options.nodeModel.get('container') : true
      });
      permissionLevelView.on('permission:level:selected', this.onPermissionLevelSelection, this);
      return permissionLevelView;
    },

    _createPermissionLevelSubItemsView: function () {
      var applyPermissionView = new ApplyPermissionView({
        selected: 2,
        context: this.options.context,
        model: this.options.nodeModel,
        applyTo: this.options.applyTo
      });
      applyPermissionView.on('permission:level:selected', this.onPermissionLevelSelection, this);
      return applyPermissionView;
    },

    dialogClassName: function () {
      var className = 'target-browse';
      if (this.options && this.options.userClassName) {
        className = className + " " + this.options.userClassName;
      }
      return className;
    },

    _createWizardSteps: function () {
      var options               = this.options,
          initialLocation       = this._getInitialLocation(),

          step1header           = this._createHeaderControl(initialLocation),
          step1view             = this._createPickerView(initialLocation),
          isContainer           = (options.nodeModel && options.nodeModel.get("container") &&
                                   options.nodeModel.get("permissions_model") === "advanced") ?
                                  true : false,
          memberPickerTitleId   = 'memberPickerHeader',
          permissionLevelDescId = _.uniqueId('permissionLevel'),
          step1, step2, step3;
      if (options.adduserorgroup && !options.showUserPicker && isContainer) {
        step1 = {
          title: options.dialogTitle,
          adduserorgroup: options.adduserorgroup ? options.adduserorgroup : false,
          headerView: step1header,
          view: step1view,
          className: this.dialogClassName,
          nextButton: true,
          userClassName: this.options.dialogClass,
          attributes: {'aria-labelledby': memberPickerTitleId},
          largeSize: true
        };
        step2 = {
          title: options.dialogTitle,
          headers: [{
            label: lang.selectPermissionLevel,
            class: 'csui-permission-level-select',
            id: permissionLevelDescId
          }],
          nextButtonLabel: lang.nextButtonLabel,
          nextButton: true,
          disableNext: false,
          view: this._createPermissionLevelSelectorView(),
          className: this.dialogClassName() + ' csui-permissions-level',
          attributes: {
            'aria-labelledby': memberPickerTitleId,
            'aria-describedby': permissionLevelDescId
          }
        };
        step3 = {
          title: options.dialogTitle,
          doneButtonLabel: lang.doneButtonLabel,
          disableDone: false,
          doneButton: true,
          view: this._createPermissionLevelSubItemsView(),
          className: this.dialogClassName() + ' csui-permissions-apply-dialog',
          attributes: {'aria-labelledby': memberPickerTitleId}
        };
        return [step1, step2, step3];
      } else if (options.adduserorgroup && !options.showUserPicker && !isContainer) {
        step1 = {
          title: options.dialogTitle,
          adduserorgroup: options.adduserorgroup ? options.adduserorgroup : false,
          headerView: step1header,
          view: step1view,
          className: this.dialogClassName,
          nextButton: true,
          userClassName: this.options.dialogClass,
          attributes: {'aria-labelledby': memberPickerTitleId},
          largeSize: true
        };
        step2 = {
          title: options.dialogTitle,
          headers: [{
            label: lang.selectPermissionLevel,
            class: 'csui-permission-level-select',
            id: permissionLevelDescId
          }],
          doneButtonLabel: lang.doneButtonLabel,
          disableDone: false,
          doneButton: true,
          view: this._createPermissionLevelSelectorView(),
          className: this.dialogClassName() + ' csui-permissions-level',
          attributes: {
            'aria-labelledby': memberPickerTitleId,
            'aria-describedby': permissionLevelDescId
          }
        };
        return [step1, step2];
      } else {
        var memberBrowseStep = {
          title: options.dialogTitle,
          adduserorgroup: options.adduserorgroup ? options.adduserorgroup : false,
          showUserPicker: options.showUserPicker,
          headerView: step1header,
          view: step1view,
          className: this.dialogClassName,
          userClassName: this.options.dialogClass,
          attributes: {'aria-labelledby': 'memberPickerHeader'},
          largeSize: true,
          buttons: options.buttons
        };

        return [memberBrowseStep];
      }
    },

    _blockDialog: function () {
      this._wizard.blockWithoutIndicator();
      return true;
    },

    onHideDialog: function () {
      if (this._deferred) {
        if (this._result) {
          this._deferred.resolve(this._result);
        } else if (this._deferred.state() === 'pending') {
          // When the dialog is cancelled, reject the promise without error
          this._deferred.reject({cancelled: true});
        }
      }
    },

    onChangeLocation: function (location) {
      if (!location.get) {
        location = this._locations.get('csui/dialogs/members.picker/start.locations/' + location);
      }
      this.options.targetBrowseHistory = [];
      var selectedMembers = this.membersPickerView && this.membersPickerView.selectedMemberList &&
                            this.membersPickerView.selectedMemberList.collection.models;
      this._steps[0].view.destroy();
      this.membersPickerView.trigger('change:complete');
      this.options.previousLocation = location;
      this._steps[0].view = this._createPickerView(location);
      var node = location.get("factory").container;
      this._wizard.currentView.showView(this._steps[0].view);
      if (selectedMembers) {
        this.selectUsers(selectedMembers);
      }
    },

    selectUsers: function (selectedMember) {
      this.membersPickerView && this.membersPickerView.selectedMemberList &&
      this.membersPickerView.selectedMemberList.trigger("show:selectItem", selectedMember);
    },

    enableAdd: function () {
      var buttonView = this._wizard.currentView.footerView.children._views;
      _.each(buttonView, function (add) {
        if (add.model.get('id') === 'Add') {
          add.$el.removeClass("binf-hidden");
        }
      }, this);
    },

    updateButton: function (selectedMemberCollection) {
      this._wizard.currentView.footerView &&
      this._wizard.currentView.footerView.trigger("update:button", selectedMemberCollection);
      this.locationId = !!this._wizard.currentView.headerView.options &&
                        !!this._wizard.currentView.headerView.options.headerViewoptions &&
                        this._wizard.currentView.headerView.options.headerViewoptions.locationID;
      var buttonView = this._wizard.currentView.footerView.children._views;
      _.each(buttonView, function (add) {
        if (add.model.get('id') === 'Add') {
          if (selectedMemberCollection.models.length > 0 && this._wizard.options.add) {
            if (this.options.selectedMember && !this.locationId) {
              add.$el.attr("disabled", "disabled");
            } else {
              add.$el.removeAttr("disabled");
            }
          } else {
            add.$el.attr("disabled", "disabled");
          }
        }
      }, this);
      var memberExists = selectedMemberCollection.models.length > 0 ? true : false;
      this._wizard.currentView.headerView && this._wizard.currentView.headerView.userSearchView &&
      this._wizard.currentView.headerView.userSearchView.updatePlaceHolder(memberExists);
    },

    onClickFinishButton: function () {
      var members, permissions, applyToSubFolders, isContainer;
      if (this && this.getMemberPickerView() && this.getMemberPickerView().getSelection()) {
        members = this.getMemberPickerView().getSelection();
        permissions = this.getPermissionLevelView().getSelectedPermissions();
        isContainer = (this.options.nodeModel.get("container") &&
                       this.options.nodeModel.get("permissions_model") === "advanced") ? true :
                      false;
        if (isContainer) {
          applyToSubFolders = this.getPermissionsApplyView().getApplyToFlag();
        }
        this._result = {
          members: members,
          permissions: permissions,
          apply_to: isContainer ? (applyToSubFolders ? 2 : 3) : 0
        };
        this._wizard.destroy();
        this.onHideDialog();
      }
      /* else if (this.options.showUserPicker) {
         members = this.getMemberPickerView().getSelection();
         permissions = this.getPermissionLevelView().getSelectedPermissions();
         applyToSubFolders = this.getPermissionsApplyView().getApplyToFlag();
         isContainer = (this.options.nodeModel.attributes.type === 0) ? true : false;
         this._result = {
           members: members,
           permissions: permissions,
           apply_to: isContainer ? (applyToSubFolders ? 2 : 3) : 0
         };
         this._wizard.destroy();
         this.onHideDialog();

       }*/ else {
        this._wizard.currentView.updateButton('next', {disabled: true});
      }
    },

    onClickAddButton: function () {
      var id  = this._wizard.options.groupId,
          url = this.options.connector.connection.url;
      url = url.replace('v1', 'v2');
      var self             = this,
          groupName        = this.getMemberPickerView().getSelection() &&
                             this.getMemberPickerView().getSelection().get("name_formatted") ||
                             this.membersPickerView.options.displayName,
          formData         = {},
          ajaxOptions      = {},
          connector        = this.options.connector,
          selecetedGroupId = !!this._wizard.currentView.headerView.options &&
                             !!this._wizard.currentView.headerView.options.headerViewoptions &&
                             this._wizard.currentView.headerView.options.headerViewoptions.locationID;
      id = selecetedGroupId ? selecetedGroupId : id;
      self.groupName = groupName;
      self.failedUsers = [];
      self.passcount = 0;
      self.failcount = 0;
      var queue          = new TaskQueue({
            parallelism: config.parallelism
          }),
          count          = 0,
          selectedModels = this.membersPickerView && this.membersPickerView.selectedMemberList &&
                           this.membersPickerView &&
                           this.membersPickerView.selectedMemberList.collection.models,
          promises       = _.map(selectedModels, function (model) {
            var deferred = $.Deferred();
            queue.pending.add({
              worker: function () {
                formData = {
                  member_id: model.id
                };
                ajaxOptions = connector.extendAjaxOptions({
                  type: 'POST',
                  id: id,
                  url: url + '/members/' + id + '/members',
                  data: formData
                });
                self.userName = model.get('name_formatted') || model.get('name');
                $.ajax(ajaxOptions).done(function (resp) {
                  self.passcount += 1;
                  deferred.resolve(model);
                }, self).fail(function (resp) {
                  self.failcount += 1;
                  self.failedUsers.push(self.userName);
                  deferred.resolve(model);
                }, self);
                return deferred.promise();
              }
            });
            count++;
            return deferred.promise(promises);  // return promises
          });

      $.whenAll.apply($, promises).then(function (promises) {
        if (self.passcount === 1 && self.failcount === 0) {
          GlobalMessage.showMessage('success',
              _.str.sformat(lang.singleUserText, self.userName, self.groupName));
        } else if (self.passcount === 0 && self.failcount === 1) {
          GlobalMessage.showMessage('error',
              _.str.sformat(lang.singleUserFailureText, self.userName, self.groupName));
        } else if (self.passcount === 1 && self.failcount > 0) {
          GlobalMessage.showMessage('success',
              _.str.sformat(lang.SinglePassMoreThanOneFail, self.userName, self.groupName,
                  self.failcount));
        } else if (self.passcount > 0 && self.failcount > 0) {
          GlobalMessage.showMessage('success',
              _.str.sformat(lang.manyUserText, self.passcount, self.failcount, self.groupName));
        } else if (self.passcount > 0 && self.failcount === 0) {
          GlobalMessage.showMessage('success',
              _.str.sformat(lang.onlyAllSuccessText, self.passcount, self.groupName));
        } else if (self.passcount === 0 && self.failcount > 0) {
          GlobalMessage.showMessage('error',
              _.str.sformat(lang.onlyAllFailureText, self.failcount, self.groupName));
        }
        self._wizard.destroy();
      });
    },

    _getArrayOfNodeIds: function (unselectableNodes) {
      if (unselectableNodes && !_.isEmpty(unselectableNodes)) {
        if (unselectableNodes[0] instanceof Backbone.Model) {
          return _.map(unselectableNodes, function (node) {
            return node.get('right_id');
          });
        }
      }

      return unselectableNodes;
    },

    _getInitalContainer: function (options) {
      var container = this.options.initialContainer;

      if (container == null || _.isEmpty(container) || !(container instanceof Backbone.Model)) {
        container = new MemberModel(
            {
              groupId: options.groupId,
              displayName: options.displayName
            },
            {connector: options.connector});
      } else {
        container == null;
      }
      return container;
    },

    //Private function with assumes either container or nodes exists.
    _getConnector: function (options) {
      var connector;

      if (options.context) {
        connector = options.context.getObject(ConnectorFactory);
      } else if (options.initialSelection || options.initialContainer) {
        var initalSelection = options.initialSelection,
            nodes           = initalSelection ? (_.isArray(initalSelection) ? initalSelection :
                                                 initalSelection.models) : undefined,
            node            = options.initialContainer || nodes[0];
        connector = node && node.connector;
      }

      return connector;
    },

    _getInitialLocation: function () {
      var locationId = this.options.startLocation,
          initialLocation;
      if (locationId) {
        // Enable start location names without the module path for the core modules
        var lastSlash = locationId.lastIndexOf('/');
        if (lastSlash < 0) {
          locationId = 'csui/dialogs/members.picker/start.locations/' + locationId;
        }
        initialLocation = this._locations.get(locationId);
      }
      if (!locationId && this.options.groupId) {
        initialLocation = this._locations.get(
            'csui/dialogs/members.picker/start.locations/current.group');
      }
      return initialLocation;
    },

    onSelectionChange: function (member) {
      var disable = this.getMemberPickerView().getNumberOfSelectItems() > 0, hasFilterName;
      if (member && member.get("id")) {
        this.options.locationID = member.get("id");
        //this.updateSearch(member);
        //this.updateHeaderStartLocation(node);
      }
      this._wizard.options.add = member && member.add;
      //this.updateFooterSelectedList();
      this._wizard.destroyBlockingView();
      var header = this.getMemberPickerHeader();
      if (this.options.saveFilter && header && header.ui.saveFilter) {
        hasFilterName = header.ui.saveFilter.val().trim() ? true : false;
        if (hasFilterName && disable) {
          this._wizard.updateButton('next', {disabled: false});
        } else {
          this._wizard.updateButton('next', {disabled: true});
        }
      } else {
        this._wizard.updateButton('next', {disabled: !disable});
        if (this.membersPickerView &&
            this.membersPickerView.selectedMemberList.collection.models.length > 0 &&
            member && member.get("id") && member.add && !member.get("deleted")) {
          this._wizard.updateButton('Add', {disabled: false});
        } else {
          this._wizard.updateButton('Add', {disabled: true});
        }
      }

      if (this.isCustom) {
        this._steps[1].view = this._createPermissionLevelSelectorView();
        var permissionLevelStep = this._wizard.getStepViewByStepNumber(1);
        //Update it with newly created permissionLevelSelectorView
        permissionLevelStep.showView(this._steps[1].view);
        this.isCustom = false;
      }
    },

    onPermissionLevelSelection: function () {
      var view = this.getPermissionLevelView();
      if (view.selected === NodePermissionModel.PERMISSION_LEVEL_CUSTOM) {
        //Replace current view with custom permission view
        var customPermissionView = new PermissionAttributesView({
          permissions: [],
          readonly: false,
          showButtons: false,
          node: this.options.nodeModel
        });

        this._steps[1].view = customPermissionView;
        this._wizard.currentView.showView(this._steps[1].view);
        this.isCustom = true;

        // adjusting split bar and separator positions
        var $treeViewDiv = customPermissionView.$el.find('.csui-permission-attribute-tree'),
            adjustSplitsHeight,
            adjustSplitsRight,
            adjustSplitsSeparator,
            adjustSplits = $treeViewDiv.find(".csui-tree-split");

        for (var i = adjustSplits.length - 1, j = 0; i >= 0, j < adjustSplits.length; i--, j++) {
          adjustSplitsRight = $(adjustSplits[i]).width() * j;
          adjustSplitsSeparator = $(adjustSplits[i]).closest(".csui-tree-child").find(
              '.csui-separator');
          if (adjustSplits[i] === adjustSplits[adjustSplits.length - 1]) {
            adjustSplitsHeight = $treeViewDiv.outerHeight();
          } else {
            adjustSplitsHeight = Math.round(($(adjustSplits[i]).closest("li").position().top) +
                                            $(adjustSplits[i]).closest(
                                                ".csui-tree-child").outerHeight());
            adjustSplitsRight = adjustSplitsRight + j;
          }
          if (i18n && i18n.settings.rtl) {
            $(adjustSplits[i]).css({'height': adjustSplitsHeight, 'left': adjustSplitsRight});
            adjustSplitsSeparator.css({
              'width': ($treeViewDiv.find('.csui-tree-container').width()),
              'left': adjustSplitsRight
            });
            $(adjustSplits[i]).closest('.csui-tree-child').css(
                {'padding-left': adjustSplitsRight + $(adjustSplits[i]).width()});
          } else {
            $(adjustSplits[i]).css({'height': adjustSplitsHeight, 'right': adjustSplitsRight});
            adjustSplitsSeparator.css({
              'width': ($treeViewDiv.find('.csui-tree-container').width()),
              'right': adjustSplitsRight
            });
            $(adjustSplits[i]).closest('.csui-tree-child').css(
                {'padding-right': adjustSplitsRight + $(adjustSplits[i]).width()});
          }
        }
      }
      this._wizard.updateButton('next', {disabled: false});
    },

    getMemberPickerView: function () {
      return this._steps[0].view;
    },

    getMemberPickerHeader: function () {
      return this._steps[0].headerView;
    },

    getPermissionLevelView: function () {
      return this._steps[1].view;
    },

    getPermissionsApplyView: function () {
      return this._steps[2].view;
    }

  });

  return MembersPickerWizard;

});

csui.define('csui/controls/table/cells/user/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/user/impl/nls/root/localized.strings',{
  publicAccess: 'Public Access',
  noOwnerAssigned: 'No owner assigned',
  noGroupAssigned: 'No group assigned',
  addOwnerOrGroup: 'Add owner or owner group',
  ownerAccessTitle: 'Owner access',
  groupOwnerAccessTitle: 'Group owner access',
  addButtonLabel: 'Add',
  cancelButtonLabel: 'Cancel',
  addButtonTooltip: 'Add member to group',
  cancelButtonTooltip: "Close dialog"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/user/impl/user',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <div class=\"csui-profileimg\">\r\n    <span class=\"csui-icon-paceholder csui-icon icon_permmision_public\"></span>\r\n  </div>\r\n  <div class=\"member-info csui-fadeout"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disabled : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + " \">\r\n    <div class=\"\">\r\n      <span class=\"csui-user-display-name csui-public\"\r\n            aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.ariaUserLabel || (depth0 != null ? depth0.ariaUserLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"ariaUserLabel","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.publicAccesslabel || (depth0 != null ? depth0.publicAccesslabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"publicAccesslabel","hash":{}}) : helper)))
    + "</span>\r\n    </div>\r\n  </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    return " binf-disabled";
},"4":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.showProfileImg : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <div class=\"member-info csui-fadeout \">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.addOwnerOrGroup : depth0),{"name":"if","hash":{},"fn":this.program(22, data, 0),"inverse":this.program(24, data, 0)})) != null ? stack1 : "")
    + "  </div>\r\n";
},"5":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"csui-profileimg"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disabled : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + " binf-pull-left\">\r\n    <span class=\"csui-icon "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isOwner : depth0),{"name":"if","hash":{},"fn":this.program(6, data, 0),"inverse":this.program(8, data, 0)})) != null ? stack1 : "")
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "\"\r\n          aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.ariaUserType || (depth0 != null ? depth0.ariaUserType : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"ariaUserType","hash":{}}) : helper)))
    + "\">"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isUser : depth0),{"name":"if","hash":{},"fn":this.program(16, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</span>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isOwner : depth0),{"name":"if","hash":{},"fn":this.program(18, data, 0),"inverse":this.program(20, data, 0)})) != null ? stack1 : "")
    + "    </div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    return " icon_permmision_owner ";
},"8":function(depth0,helpers,partials,data) {
    var stack1;

  return "\r\n      "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isOwnerGroup : depth0),{"name":"if","hash":{},"fn":this.program(9, data, 0),"inverse":this.program(11, data, 0)})) != null ? stack1 : "");
},"9":function(depth0,helpers,partials,data) {
    return " icon_permmision_owner_group ";
},"11":function(depth0,helpers,partials,data) {
    var stack1;

  return " csui-icon-paceholder\r\n      "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isGroup : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0),"inverse":this.program(14, data, 0)})) != null ? stack1 : "");
},"12":function(depth0,helpers,partials,data) {
    return " image_group_placeholder_permission\r\n      ";
},"14":function(depth0,helpers,partials,data) {
    return " image_user_placeholder_permission";
},"16":function(depth0,helpers,partials,data) {
    var helper;

  return " "
    + this.escapeExpression(((helper = (helper = helpers.initials || (depth0 != null ? depth0.initials : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"initials","hash":{}}) : helper)));
},"18":function(depth0,helpers,partials,data) {
    return "";
},"20":function(depth0,helpers,partials,data) {
    var helper;

  return "        <img class=\"csui-icon-user csui-icon binf-img-circle binf-hidden\" src=\""
    + this.escapeExpression(((helper = (helper = helpers.usrImgSrc || (depth0 != null ? depth0.usrImgSrc : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"usrImgSrc","hash":{}}) : helper)))
    + "\"\r\n             alt=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.ariaUserType || (depth0 != null ? depth0.ariaUserType : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"ariaUserType","hash":{}}) : helper)))
    + "\">\r\n";
},"22":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-add-owner-or-group\">\r\n        <span class=\"csui-user-display-name binf-disabled\"\r\n              aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.ariaUserLabel || (depth0 != null ? depth0.ariaUserLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"ariaUserLabel","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n        <span class=\"csui-icon\"></span>\r\n      </div>\r\n";
},"24":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <div class=\"\">\r\n        <span class=\"csui-user-display-name  "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disabled : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\"\r\n              aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.ariaUserLabel || (depth0 != null ? depth0.ariaUserLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"ariaUserLabel","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n      </div>\r\n";
},"26":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isOwnerOrOwnerGroup : depth0),{"name":"if","hash":{},"fn":this.program(27, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers.unless.call(depth0,(depth0 != null ? depth0.addOwnerOrGroup : depth0),{"name":"unless","hash":{},"fn":this.program(29, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"27":function(depth0,helpers,partials,data) {
    return "    <div class=\"csui-inline-owner-change\"></div>\r\n";
},"29":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\""
    + this.escapeExpression(((helper = (helper = helpers.inlineToolBarPlaceholderClass || (depth0 != null ? depth0.inlineToolBarPlaceholderClass : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"inlineToolBarPlaceholderClass","hash":{}}) : helper)))
    + " binf-hidden\"></div>\r\n";
},"31":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-selected-user-ingroup\">\r\n    <span class=\"icon icon-toolbar-more\"></span>\r\n    <span class=\"csui-selected-username\">"
    + this.escapeExpression(((helper = (helper = helpers.selectedUsername || (depth0 != null ? depth0.selectedUsername : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectedUsername","hash":{}}) : helper)))
    + "</span>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-user-container\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isPublicPermission : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.includeInlineToolBarPlaceholder : depth0),{"name":"if","hash":{},"fn":this.program(26, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</div>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selectedUsername : depth0),{"name":"if","hash":{},"fn":this.program(31, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_user_impl_user', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/user/user.view',['require',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'csui/utils/base',
  'csui/utils/commands',
  'csui/utils/url',
  'csui/dialogs/members.picker/members.picker.wizard',
  'csui/utils/contexts/factories/connector',
  'csui/utils/user.avatar.color',
  'i18n!csui/controls/table/cells/user/impl/nls/localized.strings',
  'hbs!csui/controls/table/cells/user/impl/user'
], function (require, $, _, Backbone, Marionette, TemplatedCellView, cellViewRegistry, base,
    commands, Url, MembersPickerDialog, ConnectorFactory, UserAvatarColor, lang, template) {
  var UserCellView = TemplatedCellView.extend({

    template: template,
    ui: {
      personalizedImage: '.csui-icon-user',
      defaultImage: '.csui-icon-paceholder',
      userDisplayName: '.csui-user-display-name',
      addOwnerOrGroup: '.csui-add-owner-or-group',
      addOwnerOrGroupIcon: '.csui-add-owner-or-group .icon-edit',
      userPlaceHolder: '.image_user_placeholder_permission'
    },

    events: function () {
      var ret = base.isTouchBrowser() ? {
        'click @ui.addOwnerOrGroup': 'addOwnerOrGroupIconClicked'
      } : {
        'mouseover @ui.personalizedImage': 'showMiniProfilePopup',
        'mouseover @ui.defaultImage': 'showMiniProfilePopup',
        'mouseover @ui.userDisplayName': 'showMiniProfilePopup',
        'mouseover @ui.addOwnerOrGroup': 'showAddOwnerOrGroupIcon',
        'mouseleave @ui.personalizedImage': 'removeUnderline',
        'mouseleave @ui.defaultImage': 'removeUnderline',
        'mouseleave @ui.userDisplayName': 'removeUnderline',
        'mouseleave @ui.addOwnerOrGroup': 'removeAddOwnerOrGroupIcon',
        'click @ui.addOwnerOrGroupIcon': 'addOwnerOrGroupIconClicked',
        'keydown': 'onKeyInView'
      };

      _.extend(ret, {
        'click @ui.userDisplayName': 'showUserProfileDialog',
        'click @ui.personalizedImage': 'showUserProfileDialog',
        'click @ui.defaultImage': 'showUserProfileDialog'
      });

      return ret;
    },

    //Method is used by TemplatedCellView to pass data to template
    getValueData: function () {
      var userType        = this.model.get("type"),
          right_id_expand = this.model.get("right_id_expand");
      return {
        includeInlineToolBarPlaceholder: this.options.includeInlineToolBarPlaceholder,
        inlineToolBarPlaceholderClass: this.options.inlineToolBarPlaceholderClass,
        name: this.getDispalyName(),
        disabled: this.hasPermissions(),
        showProfileImg: !this.options.showOnlyUserName,
        isPublicPermission: userType === "public",
        publicAccesslabel: lang.publicAccess,
        isOwner: userType === "owner",
        ariaUserLabel: this.prepareUserName(),
        ariaUserType: this.prepareUserType(),
        isOwnerGroup: userType === "group",
        isOwnerOrOwnerGroup: userType === "owner" || userType === "group",
        initials: !!right_id_expand ? right_id_expand.initials : '',
        isUser: userType !== "owner" && userType !== "group" &&
                right_id_expand && right_id_expand.type === 0,
        title: userType === "owner" ? lang.ownerAccessTitle :
               userType === "group" ? lang.groupOwnerAccessTitle : "",
        isGroup: this.model.get("right_id_expand") && this.model.get("right_id_expand").type === 1,
        addOwnerOrGroup: this.addOwnerOrGroup,
        // a 1x1 transparent gif, to avoid an empty src tag
        usrImgSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=",
        selectedUsername: this.model.selectedUser && this.model.selectedUser.get("name")
      };
    },

    constructor: function UserCellView(options) {
      UserCellView.__super__.constructor.apply(this, arguments);
      var columnAttributes = this.options.column.attributes;
      this.options.connector = this.options.context.getModel(ConnectorFactory);
      if (this.options.includeInlineToolBarPlaceholder === undefined) {
        this.options.includeInlineToolBarPlaceholder = (columnAttributes &&
                                                        columnAttributes.containsInlineActions);
      }
      this.options.inlineToolBarPlaceholderClass ||
      (this.options.inlineToolBarPlaceholderClass = 'csui-inlinetoolbar');
      this.noOwnerOrGroup = this.model.get("type") === "owner" && this.hasPermissions();
      if (this.noOwnerOrGroup) {
        this.commands = commands;
        this.addOwnerOrGroupCommand = this.commands.findWhere({signature: 'addownerorgroup'});
        this.status = {
          context: this.options.context,
          permissionCollection: this.model.collection,
          connector: this.options.connector,
          applyTo: this.options.applyTo,
          nodeId: this.model.collection.options.nodeId,
          nodeModel: this.model.collection.options.node
        };
        this.addOwnerOrGroup = this.noOwnerOrGroup && this.addOwnerOrGroupCommand &&
                               this.addOwnerOrGroupCommand.enabled(this.status);
      }
      this.listenTo(this, 'render', this._assignUserColor);
    },

    onRender: function () {
      var userData = this.model.get("right_id_expand");
      if (!!userData) {
        this.isGroup = (userData.type === 1);
        this.userId = userData.id;
      } else {
        this.isGroup = true;
        this.userId = -1; //Public group
      }
      var renderOnlyName    = this.options.showOnlyUserName,
          isOwnerOfDocument = this.model.get("type") === "owner" ||
                              this.model.get("type") === "group";
      if (!renderOnlyName && !isOwnerOfDocument) {
        // render profile image
        this._displayProfileImage();
      }
    },

    onDestroy: function () {
      this._releasePhotoUrl();
    },

    prepareUserName: function () {
      var text         = !!this.model.attributes && !!this.model.attributes.right_id_expand &&
                         this.model.attributes.right_id_expand.name,
          preparedText = !!text && text;
      return preparedText;
    },

    prepareUserType: function () {
      return !!this.model && this.model.get('type');
    },

    hasPermissions: function () {
      var hasPermission = false;
      if (!this.model.get("permissions")) {
        hasPermission = true;
      }
      return hasPermission;
    },
    getDispalyName: function () {
      var displayName;
      if (this.model.get("right_id_expand")) {
        displayName = base.formatMemberName(this.model.get("right_id_expand"));
      } else if (this.model.get("type") === "owner" && this.hasPermissions()) {
        displayName = this.addOwnerOrGroup ? lang.addOwnerOrGroup :
                      lang.noOwnerAssigned;
      } else if (this.model.get("type") === "group" && this.hasPermissions()) {
        displayName = lang.noGroupAssigned;
      }
      return displayName;
    },

    _displayProfileImage: function () {
      var photoUrl = this._getUserPhotoUrl();
      // esoc-userprofile-img-{userid} - the common class for all profile pictures of given userid
      this.ui.personalizedImage.addClass("esoc-userprofile-img-" + this.userId);
      this.ui.defaultImage.addClass("esoc-user-default-avatar-" + this.userId);
      if (photoUrl) {
        var getPhotoOptions = this.options.connector.extendAjaxOptions({
          url: photoUrl,
          dataType: 'binary'
        });
        this._releasePhotoUrl();
        $.ajax(getPhotoOptions)
            .always(_.bind(function (response, statusText, jqxhr) {
              if (jqxhr.status === 200) {
                this._showPersonalizedImage(response);
              } else {
                this._showDefaultImage();
              }
            }, this));
      } else {
        this._showDefaultImage();
      }
    },

    _getUserPhotoUrl: function () {
      var connection = this.options.connector.connection,
          cgiUrl     = new Url(connection.url).getCgiScript(),
          photoPath  = this.model.get("right_id_expand") ?
                       this.model.get("right_id_expand").photo_url : null;
      // If the URL does not contain the cache-busting parameter derived from
      // the picture's latest change, there was a problem retrieving it.  It
      // does not make sense to try it once more from the client side, waste
      // time and server resources and litter the log by 404 errors.
      if (photoPath && photoPath.indexOf('?') > 0) {
        return Url.combine(cgiUrl, photoPath);
      }
    },

    _showPersonalizedImage: function (imageContent) {
      this._releasePhotoUrl();
      this._photoUrl = URL.createObjectURL(imageContent);
      if (typeof this.ui.personalizedImage === "object") {
        this.ui.personalizedImage.attr("src", this._photoUrl);
        this.ui.personalizedImage.removeClass('binf-hidden');
      }
      if (typeof this.ui.defaultImage === "object") {
        this.ui.defaultImage.addClass('binf-hidden');
      }

    },

    _showDefaultImage: function (imageContent) {
      this._releasePhotoUrl();
      if (typeof this.ui.personalizedImage === "object") {
        this.ui.personalizedImage.addClass('binf-hidden');
      }
      if (typeof this.ui.defaultImage === "object") {
        this.ui.defaultImage.removeClass('binf-hidden');
      }
    },

    showAddOwnerOrGroupIcon: function () {
      if (this.addOwnerOrGroupCommand && this.addOwnerOrGroupCommand.enabled(this.status)) {
        this.ui.addOwnerOrGroup.find('.csui-icon').addClass("icon-edit");
      }
    },

    removeAddOwnerOrGroupIcon: function () {
      this.ui.addOwnerOrGroup.find('.csui-icon').removeClass("icon-edit");
    },

    addOwnerOrGroupIconClicked: function () {
      var self = this;
      if (this.addOwnerOrGroupCommand && this.addOwnerOrGroupCommand.enabled(this.status)) {
        this.addOwnerOrGroupCommand.execute(this.status).done(_.bind(function (resp) {
          if (resp.get("addOwnerGroup")) {
            self.model && self.model.collection && self.model.collection.addOwnerOrGroup(resp);
          }
        }));
      }
    },

    _releasePhotoUrl: function () {
      if (this._photoUrl) {
        URL.revokeObjectURL(this._photoUrl);
        this._photoUrl = undefined;
      }
    },

    removeUnderline: function (e) {
      if (!!this.isGroup || this.userId === -3) {
        return;
      }
      this.ui.personalizedImage.removeClass("cs-user-photo-hover");
      this.ui.defaultImage.removeClass("cs-user-photo-hover");
      this.ui.userDisplayName.removeClass("cs-user-container-hover").addClass(
          "cs-user-container-no-hover");
    },

    onKeyInView: function (e) {
      if (e.keyCode === 32 || e.keyCode === 13) {
        // space key or enter key
        this.showUserProfileDialog(e);
      }
    },

    showUserProfileDialog: function (e) {
      if (this.userId < 0) {
      } else if (!!this.isGroup) {
        var self = this;
        var membersPickerDialog = new MembersPickerDialog({
          context: self.options.context,
          connector: self.options.connector,
          groupId: self.model.attributes.right_id,
          edit_permission: self.options.column.attributes.containsInlineActions,
          dialogClass: 'cs-permission-group-picker',
          startLocations: ['current.group'],
          authUser: self.options.originatingView.user,
          selectedGroup: self.model,
          displayName: base.formatMemberName(this.model.get("right_id_expand")),
          unselectableTypes: [0, 1],
          add: true,
          buttons: [
            {
              id: 'Add',
              label: lang.addButtonLabel,
              default: true,
              hidden: true,
              disabled: true,
              toolTip: lang.addButtonTooltip
            },
            {
              id: 'Cancel',
              label: lang.cancelButtonLabel,
              disabled: false,
              close: true,
              toolTip: lang.cancelButtonTooltip
            }
          ]
        });
        var that = this;
        membersPickerDialog
            .show()
            .always(function () {
              that.$el.focus();
            }).done();

        return;
      } else {
        e.preventDefault();
        e.stopPropagation();
        if (this.userWidgetView) {
          this.dialogOpen = true;
          this.ui.personalizedImage.addClass("cs-user-photo-hover");
          this.ui.defaultImage.addClass("cs-user-photo-hover");
          this.ui.userDisplayName.removeClass("cs-user-container-no-hover").addClass(
              "cs-user-container-hover");
          // hide mini profile
          $('.popover.esoc-mini-profile-popover').hide();
          this.userWidgetView.showUserProfileDialog(e);
        } else {
          this.setUserWidget('showUserProfileDialog', e);
        }
      }

    },

    showMiniProfilePopup: function (e) {
      if (!!this.isGroup || this.userId === -3) {
        return;
      } else {
        if (this.userWidgetView) {

          this.ui.personalizedImage.addClass("cs-user-photo-hover");
          this.ui.defaultImage.addClass("cs-user-photo-hover");
          this.ui.userDisplayName.removeClass("cs-user-container-no-hover").addClass(
              "cs-user-container-hover");
          this.userWidgetView.showMiniProfilePopup(e);

        } else {
          this.setUserWidget('showMiniProfilePopup', e);
        }
      }
    },

    setUserWidget: function (methodName, e) {
      var that = this;
      csui.require(['esoc/controls/userwidget/userwidget.view'], function (UserWidgetView) {
        that.userWidgetView = new UserWidgetView({
          userid: that.userId,
          context: that.options.context,
          baseElement: that.ui.userDisplayName,
          showUserProfileLink: true,
          showMiniProfile: true,
          loggedUserId: that.userId,
          connector: that.options.connector
        });
        that[methodName](e);
      });
    },

    _assignUserColor: function () {
      var user                = this.model.get("right_id_expand"),
          userbackgroundcolor = UserAvatarColor.getUserAvatarColor(user);
      this.ui.userPlaceHolder.css("background", userbackgroundcolor);
    }
  }, {
    hasFixedWidth: false,
    widthFactor: 2
  });
  cellViewRegistry.registerByColumnKey('right_id', UserCellView);
  return UserCellView;
});

csui.define('csui/controls/table/cells/permission/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/permission/impl/nls/root/localized.strings',{
  FullControl: "Full control",
  Write: "Write",
  Read: "Read",
  Custom: "Custom",
  None: "None",
  see: "See",
  see_contents: "See contents",
  modify: "Modify",
  edit_attributes: "Edit attributes",
  add_items: "Add items",
  reserve: "Reserve",
  delete_versions: "Delete version",
  delete: "Delete",
  permissionfor:'{0} Permission for {1}',
  publicaccess:'Public Access',
  edit_permissions: "Edit permissions"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/permission/impl/permission.level',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-permission-level-container csui-fadeout\">\r\n    <span class=\"csui-permission-level\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.permissionLevelAria || (depth0 != null ? depth0.permissionLevelAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"permissionLevelAria","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "</span>\r\n    <div class=\"csui-tree\"></div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.value : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_permission_impl_permission.level', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/permission/permission.level.view',['csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'i18n!csui/controls/table/cells/permission/impl/nls/localized.strings',
  'hbs!csui/controls/table/cells/permission/impl/permission.level'
], function ($, _, Backbone, Marionette, TemplatedCellView, cellViewRegistry,
    lang, template) {
  'use strict';

  var PermissionLevelCellView = TemplatedCellView.extend({

    template: template,

    ui: {
      permissionLevel: '.csui-permission-level',
      permissionTree: '.csui-tree'
    },

    events: {
      'click @ui.permissionLevel': 'onClickPermissionLevel',
      'keydown': 'onKeyInView'
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        // space key or enter key
        this.$el.find('.csui-permission-level').click();
      }
    },

    getValueData: function () {
      var permissions_level_array = this.model.get("permissions"),
          value                   = this.getPermissionLevel(permissions_level_array), ownername;
      if (this.model.get("type") === "public") {
        ownername = lang.publicaccess;
      } else {
        ownername = (!!this.model && !!this.model.get('right_id_expand')) ?
                    this.model.get('right_id_expand').name : '';
      }

      if (value === null) {
        return TemplatedCellView.prototype.getValueData.apply(this, arguments);
      }
      return {
        value: value,
        permissionLevelAria: _.str.sformat(lang.permissionfor, value, ownername),
        formattedValue: value
      };
    },

    getPermissionLevel: function (permissions_level_array) {
      var value = null;
      if (permissions_level_array && permissions_level_array.length > 0) {
        if (permissions_level_array.indexOf("edit_permissions") >= 0 &&
            permissions_level_array.length === (this.model.collection.isContainer ? 10 : 9)) {
          value = lang.FullControl;
        } else if (permissions_level_array.indexOf("edit_permissions") < 0 &&
                   permissions_level_array.indexOf("delete") >= 0 &&
                   permissions_level_array.length === (this.model.collection.isContainer ? 9 : 8)) {
          value = lang.Write;
        } else if (permissions_level_array.indexOf("see_contents") >= 0 &&
                   permissions_level_array.length === 2) {
          value = lang.Read;
        } else {
          value = lang.Custom;
        }
      } else if (this.model.get("type") === "public" || !!this.model.get("right_id")) {
        value = lang.None;
      }
      return value;
    },

    constructor: function PermissionLevelCellView(options) {
      PermissionLevelCellView.__super__.constructor.apply(this, arguments);

      this.$ = $;
    },

    onClickPermissionLevel: function (e) {
      var membersTypeSupport = [0, 1];
      if (membersTypeSupport.indexOf(
              this.options.model.get("right_id_expand") &&
              this.options.model.get("right_id_expand").type) < 0 &&
          this.options.model.get("type") === "custom") {
        //TODO: Once REST API supports we will provide action for project members and Guests actions
        if (this.options.originatingView) {
          this.options.originatingView.trigger("permission:level:focus",
              {cellView: this});
        }
      } else {
        if (this.options.originatingView) {
          this.options.originatingView.trigger("permission:level:clicked",
              {cellView: this});
        }
        this.trigger("cell:content:clicked", this);
      }
    }

  }, {
    hasFixedWidth: false,
    columnClassName: 'csui-permission-level',
    widthFactor: 1
  });

  cellViewRegistry.registerByColumnKey('permissions', PermissionLevelCellView);

  return PermissionLevelCellView;
});
csui.define('csui/controls/table/cells/add.permission/add.permission.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry'
], function ($, _, Backbone, Marionette, TemplatedCellView, cellViewRegistry) {
  'use strict';

  var AddPermissionCellView = TemplatedCellView.extend({

    className: 'csui-row-inlinetoolbar',

    events: {
      'keydown': 'onKeyInView'
    },
    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        // space key or enter key
        if(document.activeElement === this.el) {
          if(this.options.originatingView){
            this.options.originatingView.trigger("permission:inlineaction:clicked", {cellView: this});
          }
          this.$el.find('a.binf-dropdown-toggle').click();
          event.preventDefault();
          event.stopPropagation();
        }
      }
    },

    renderValue: function () {
      var classes = _.result(this, 'className');
      if (classes) {
        this.$el.addClass(classes);
      }
    },

    constructor: function AddPermissionCellView(options) {
      AddPermissionCellView.__super__.constructor.apply(this, arguments);
    }

  }, {
    hasFixedWidth: true,
    noTitleInHeader: true,
    isToolbar: true,
    columnClassName: 'csui-add-permission',
    widthFactor: 1 / 3.0,
  });

  cellViewRegistry.registerByColumnKey('addpermissions', AddPermissionCellView);

  return AddPermissionCellView;
});

csui.define('css!csui/controls/table/cells/versionnumber/impl/versionnumber',[],function(){});
csui.define('csui/controls/table/cells/versionnumber/versionnumber.view',[
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/cell.registry',
  'csui/utils/base',
  'css!csui/controls/table/cells/versionnumber/impl/versionnumber'
], function (TemplatedCellView, cellViewRegistry, base) {
  'use strict';

  var VersionNumberCellView = TemplatedCellView.extend({
      className: 'csui-nowrap',
      needsAriaLabel: true
    }, {
      hasFixedWidth: true,
      columnClassName: 'csui-table-cell-version_number_name'
    }
  );

  cellViewRegistry.registerByColumnKey('version_number_name', VersionNumberCellView);

  return VersionNumberCellView;
});


csui.define('csui/controls/table/cells/cell.factory',['csui/lib/underscore', 'csui/controls/table/cells/cell.registry',
  'csui/controls/table/cells/text/text.view',
  'csui/controls/table/cells/name/name.view',
  // The cell view module registers the view to the factory automatically
  'csui/controls/table/cells/date/date.view',
  'csui/controls/table/cells/datetime/datetime.view',
  'csui/controls/table/cells/duedate/duedate.view',
  'csui/controls/table/cells/member/member.view',
  'csui/controls/table/cells/node.state/node.state.view',
  'csui/controls/table/cells/parent/parent.view',
  'csui/controls/table/cells/priority/priority.view',
  'csui/controls/table/cells/select/select.view',
  'csui/controls/table/cells/toggledetails/toggledetails.view',
  'csui/controls/table/cells/size/size.view',
  'csui/controls/table/cells/status/status.view',
  'csui/controls/table/cells/favorite/favorite.view',
  'csui/controls/table/cells/favorite/favorite.name.view',
  'csui/controls/table/cells/type.icon/type.icon.view',
  'csui/controls/table/cells/user/user.view',
  'csui/controls/table/cells/permission/permission.level.view',
  'csui/controls/table/cells/add.permission/add.permission.view',
  'csui/controls/table/cells/versionnumber/versionnumber.view',
  // Load and register external cell views
  'csui-ext!csui/controls/table/cells/cell.factory'
], function (_, cellViewRegistry, TextCellView, NameCellView) {

  function CellViewFactory() {}

  _.extend(CellViewFactory.prototype, {

    hasCellViewByOtherKey: function (columnKey) {
      return cellViewRegistry.hasCellViewByOtherKey(columnKey);
    },

    getCellView: function (columnDefinition) {
      if (columnDefinition.get('isNaming') === true) {
        return NameCellView;
      }
      var CellView = cellViewRegistry.getCellView(columnDefinition);
      // Render unrecognized column types as text; if it is not satisfactory,
      // a custom column should be created
      return CellView || TextCellView;
    }

  });

  return new CellViewFactory();

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/searchbox/searchbox',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "class=\"search-box csui-table-searchbox\" ";
},"3":function(depth0,helpers,partials,data) {
    return "class=\"search-box csui-table-searchbox\r\nbinf-hidden\"";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.show_input : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + ">\r\n  <input type=\"search\" class=\"csui-table-search-input\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\"\r\n         title=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.search_value || (depth0 != null ? depth0.search_value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_value","hash":{}}) : helper)))
    + "\">\r\n         <span class=\"fadeout csui-icon\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.search_placeholder || (depth0 != null ? depth0.search_placeholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_placeholder","hash":{}}) : helper)))
    + "\" style=\"display: inline-block;\"></span>\r\n  <span class=\"sbclearer formfield_clear\" role=\"button\" aria-expanded=\"false\"\r\n        title=\""
    + this.escapeExpression(((helper = (helper = helpers.search_clear_icon_tooltip || (depth0 != null ? depth0.search_clear_icon_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_clear_icon_tooltip","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.search_clear_icon_tooltip || (depth0 != null ? depth0.search_clear_icon_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_clear_icon_tooltip","hash":{}}) : helper)))
    + "\"></span>\r\n</div>\r\n<div class=\"csui-table-search-icon\" role=\"button\" aria-expanded=\"false\"\r\n     aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.search_icon_tooltip || (depth0 != null ? depth0.search_icon_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_icon_tooltip","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.search_icon_tooltip || (depth0 != null ? depth0.search_icon_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"search_icon_tooltip","hash":{}}) : helper)))
    + "\">\r\n  <span class=\"icon icon-search\"></span>\r\n</div>\r\n\r\n";
}});
Handlebars.registerPartial('csui_controls_table_cells_searchbox_searchbox', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/searchbox/searchbox',[],function(){});
csui.define('csui/controls/table/cells/searchbox/searchbox.view',["csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/marionette",
  "i18n!csui/controls/table/impl/nls/lang",
  "hbs!csui/controls/table/cells/searchbox/searchbox",
  "css!csui/controls/table/cells/searchbox/searchbox"
], function ($, _, Marionette, lang, template) {

  var SearchBoxView = Marionette.ItemView.extend({

    className: "csui-table-column-search",

    template: template,

    templateHelpers: function () {
      return {
        search_value: this.lastFilterValue,
        show_input: this.lastFilterValue !== undefined,
        search_icon_tooltip: _.str.sformat(lang.searchIconTooltip,
            this.options.columnTitle.toLowerCase()),
        search_placeholder: _.str.sformat(lang.searchPlaceholder,
            this.options.columnTitle.toLowerCase()),
        search_clear_icon_tooltip: lang.searchClearIconTooltip
      };
    },

    ui: {
      searchBox: '.csui-table-searchbox',
      searchInput: '.csui-table-search-input',
      clearer: '.sbclearer',
      searchGlass: '.icon-search',
      searchGlassContainer: '.csui-table-search-icon'
    },

    events: {
      'keyup @ui.searchInput': 'filterChanged',
      'keydown': 'onKeyInView',
      'paste @ui.searchInput': 'filterChanged',
      'change @ui.searchInput': 'filterChanged',
      'click @ui.searchInput': '_searchFieldInputClicked',
      'click @ui.clearer': '_searchFieldClearerClicked',
      'click @ui.searchGlassContainer': '_searchFieldGlassClicked',
      'click': '_searchBoxClicked'
    },

    constructor: function SearchBoxView(filterValue, options) {
      this.options = options || {};
      Marionette.ItemView.prototype.constructor.apply(this, arguments);

      this.lastFilterValue = filterValue;
      this.lastFocused = "I";
    },

    onRender: function () {
      if (!this.ui.searchBox.hasClass('binf-hidden')) {
        this.showClearerIfFilterHasValue();
        this.triggerMethod('opened');
        this.triggerMethod('changed:focus', this.lastFocused);
        this.setIconAndState();
      }
    },

    onDestroy: function () {
      if (this.filterTimeout) {
        clearTimeout(this.filterTimeout);
        this.filterTimeout = undefined;
      }
    },

    onKeyInView: function (event) {
      if (this.getShown()) {
        if (event.keyCode === 27) {
          // esc
          this.hideAndClear();
          return;
        }

        switch (this.lastFocused) {
        case "I":
          // input field
          var caretPos = this.ui.searchInput[0].selectionStart;
          var val = this.ui.searchInput.val();
          switch (event.keyCode) {
          case 13:
            // Enter key -> submit filter if there is one
            event.stopPropagation();
            event.preventDefault();
            if (val.length > 0) {
              this.triggerMethod('change:filterValue',
                  {column: this.options.column, keywords: val});
            }
            break;
          case 37:
            // don't propagate left key unless cursor is at the very left pos in the input field
            if (caretPos > 0) {
              event.stopPropagation();
            }
            break;
          case 39:
            // don't propagate right key unless cursor is at the very right pos in the input field
            // (if the keypress propagates to the table for example the keyboard handling
            // there will move the currently focused element to the next header column)
            if (val.length > 0 && caretPos < val.length) {
              event.stopPropagation();
            } else {
              this._moveFocusRight();
              event.stopPropagation();
              event.preventDefault();
            }
            break;
          case 35:
            // END key -> move to rightmost position in input field
            this.ui.searchInput[0].selectionStart = val.length;
            this.ui.searchInput[0].selectionEnd = val.length;
            event.stopPropagation();
            event.preventDefault();
            break;
          case 36:
            // POS1 key -> move to leftmost position in input field
            this.ui.searchInput[0].selectionStart = 0;
            this.ui.searchInput[0].selectionEnd = 0;
            event.stopPropagation();
            event.preventDefault();
            break;
          }
          break;
        case "C":
          // clearer icon
          switch (event.keyCode) {
          case 13:
          case 32:
            // Enter and space key activate clearer
            this._searchFieldClearerClicked(event);
            break;
          case 37:
            this.lastFocused = "I";
            this.triggerMethod('changed:focus', this.lastFocused);
            event.stopPropagation();
            event.preventDefault();
            break;
          case 39:
            this.lastFocused = "G";
            this.triggerMethod('changed:focus', this.lastFocused);
            event.stopPropagation();
            event.preventDefault();
            break;
          }
          break;
        case "G":
          // search glass
          switch (event.keyCode) {
          case 13:
          case 32:
            this.hideAndClear();
            event.stopPropagation();
            event.preventDefault();
            break;
          case 37:
            // left arrow
            this._moveFocusLeft();
            event.stopPropagation();
            event.preventDefault();
            break;
          case 39:
            // right arrow key
            event.preventDefault();
            // let it propagate to table
            break;
          }
          break;
        }
      } else {
        // searchbox is hidden -> only allow toggle visibility by enter or space
        if (event.keyCode === 13 || event.keyCode === 32) {
          event.preventDefault();
          event.stopPropagation();
          this.showSearchInput();
        }
      }
    },

    currentlyFocusedElement: function () {
      if (this.getShown()) {
        switch (this.lastFocused) {
        case "I":
          return this.ui.searchInput;
        case "C":
          return this.ui.clearer;
        case "G":
          return this.ui.searchGlassContainer;
        default:
          return $();
        }
      } else {
        return this.ui.searchGlassContainer;
      }
    },

    setFocusToInput: function () {
      this.lastFocused = "I";
      this.triggerMethod('changed:focus', this.lastFocused);
      this.ui.searchInput.focus();
    },

    setFocusToGlass: function () {
      this.lastFocused = "G";
      this.triggerMethod('changed:focus', this.lastFocused);
    },

    showSearchInput: function () {
      this.ui.searchBox.removeClass('binf-hidden');
      this.$el.addClass('csui-searchbox-shown');
      this.setIconAndState();
      this.setFocusToInput();
      this.triggerMethod('opened');
    },

    setIconAndState: function () {
      this.ui.searchGlassContainer.attr('title', lang.collapseSearch);
      this.ui.searchGlassContainer.attr('aria-label', lang.collapseSearch);
      this.ui.searchGlassContainer.attr('aria-expanded', 'true');
      this.ui.searchGlass.addClass('icon-search-hide');
    },

    hideAndClear: function (silent) {
      this.ui.searchBox.addClass('binf-hidden');
      this.$el.removeClass('csui-searchbox-shown');
      this.ui.searchGlassContainer.attr('title', this.templateHelpers().search_icon_tooltip);
      this.ui.searchGlassContainer.attr('aria-label', this.templateHelpers().search_icon_tooltip);
      this.ui.searchGlassContainer.attr('aria-expanded', 'false');
      this.ui.searchGlass.removeClass('icon-search-hide');
      this.lastFocused = "I";

      if (this.filterTimeout) {
        clearTimeout(this.filterTimeout);
        this.filterTimeout = undefined;
      }

      // search glass was clicked to close the input field. if there was a search value set,
      // remove it and clear the filter value
      if (this.ui.searchInput.val().length && !silent) {
        // If the search field has just been hidden, reset the filtering value to show all items
        // again

        this.ui.searchInput.val('');
        this.triggerMethod('change:filterValue', {column: this.options.column, keywords: ''});
      }
      this.lastFilterValue = undefined;
      this.triggerMethod('closed');
    },

    toggleSearch: function () {
      if (this.ui.searchBox.hasClass('binf-hidden')) {
        this.showSearchInput();
      } else {
        this.hideAndClear();
      }
    },

    showClearerIfFilterHasValue: function () {
      var filterValue = this.ui.searchInput.val();
      var filterHasValue = !!filterValue.length;
      this.ui.clearer.toggle(filterHasValue);
      return filterValue;
    },

    getColumn: function () {
      return this.options.column;
    },

    getValue: function () {
      return this.ui.searchInput.val();
    },

    setValue: function (val) {
      if (val && val.length) {
        this.ui.searchInput.val(val);
        this.lastFilterValue = val;
      }
    },

    getShown: function () {
      return !this.ui.searchBox.hasClass('binf-hidden');
    },

    setFocus: function () {
      var textLen = this.ui.searchInput.val().length;
      this.lastFocused = "I";
      // The table header seems to be rendering multiple times.
      // IE11 throws an error with setSelectionRange.
      // Delay and call setSelectionRange when it is available.
      setTimeout(_.bind(function () {
        if (this.ui.searchInput[0].setSelectionRange) {
          this.ui.searchInput.focus();
          this.ui.searchInput[0].setSelectionRange(textLen, textLen);
        }
      }, this), 200);
    },

    filterChanged: function () {
      var filterValue = this.showClearerIfFilterHasValue();

      if (this.lastFilterValue != filterValue) {
        this.lastFilterValue = filterValue;
        var self = this;
        if (this.filterTimeout) {
          clearTimeout(this.filterTimeout);
        }
        this.filterTimeout = setTimeout(function () {
          self.filterTimeout = undefined;
          self.triggerMethod('change:filterValue',
              {column: self.options.column, keywords: self.ui.searchInput.val()});
        }, 1000);
      }
    },

    _hasFilterValue: function () {
      var filterValue = this.ui.searchInput.val();
      var filterHasValue = !!filterValue.length;
      return filterHasValue;
    },

    _moveFocusLeft: function () {
      var filterHasValue = this._hasFilterValue();
      if (filterHasValue) {
        this.lastFocused = "C";
        this.triggerMethod('changed:focus', this.lastFocused);
      } else {
        this.lastFocused = "I";
        this.triggerMethod('changed:focus', this.lastFocused);
      }
    },

    _moveFocusRight: function () {
      var filterHasValue = this._hasFilterValue();
      if (filterHasValue) {
        this.lastFocused = "C";
        this.triggerMethod('changed:focus', this.lastFocused);
      } else {
        this.lastFocused = "G";
        this.triggerMethod('changed:focus', this.lastFocused);
      }
    },

    _searchFieldInputClicked: function (event) {
      // don't propagate click event into search box to table header, because it would cause sorting
      event.stopPropagation();
      this.setFocusToInput();
    },

    _searchFieldClearerClicked: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.ui.searchInput.val('');
      this.ui.clearer.hide();
      this.lastFilterValue = ''; // show empty input field on re-render
      this.setFocusToInput();
      this.triggerMethod('change:filterValue', {column: this.options.column, keywords: ''});
    },

    _searchFieldGlassClicked: function (event) {
      event.stopPropagation();
      this.toggleSearch();
    },

    _searchBoxClicked: function (event) {
      event.stopPropagation();
      if (!this.getShown()) {
        this.toggleSearch();
      }
    }
  });

  return SearchBoxView;

});

csui.define('csui/controls/table/inlineforms/inlineform.registry',['csui/lib/underscore'], function (_) {

  function InlineFormViewRegistry() {
    this._addableTypes = {};
  }

  _.extend(InlineFormViewRegistry.prototype, {

    getInlineFormView: function(addableType){
      return this._addableTypes[addableType];
    },

    registerByAddableType: function (addableType, InlineFormViewClass) {
      if (!(_.isNumber(addableType))) {
        throw new Error('addableType key must be a number');
      }
      this._addableTypes[addableType] = InlineFormViewClass;
    }
  });

  return new InlineFormViewRegistry();
});

csui.define('csui/controls/table/inlineforms/folder/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/inlineforms/folder/impl/nls/root/lang',{
  CancelButtonLabel: "Cancel",
  NewNamePlaceholder: 'Enter name'
});


csui.define('csui/controls/table/inlineforms/inlineform/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/inlineforms/inlineform/impl/nls/root/lang',{
  EditCancelTooltip: "Cancel",
  CancelButtonLabel: "Cancel",
  SaveButtonLabel: "Save",
  AddButtonLabel: "Add",
  ExtendedAdd: "Extended add dialog",
  ExtendedAddAria: "Open extended add dialog",
  ActionFailedMessage: "Action failed"
});



csui.define('css!csui/controls/table/inlineforms/inlineform/impl/inlineform',[],function(){});
csui.define('csui/controls/table/inlineforms/inlineform/impl/inlineform.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/utils/base',
  'csui/utils/log',
  'i18n!csui/controls/table/inlineforms/inlineform/impl/nls/lang',
  "csui/lib/marionette",
  'csui/models/nodechildren',
  'csui/utils/commands/add.item.metadata',
  'csui/utils/commands/properties',
  'csui/models/nodes',
  'csui/utils/commandhelper',
  'csui/behaviors/keyboard.navigation/tabkey.behavior',
  'csui/lib/jsonpath',
  'css!csui/controls/table/inlineforms/inlineform/impl/inlineform'
], function ($,
    _,
    base,
    log,
    lang,
    Marionette,
    NodeChildrenCollection,
    AddItemMetadataCommand,
    PropertiesCommand,
    NodeCollection,
    CommandHelper,
    TabKeyBehavior, jsonPath) {

  var InlineFormView = Marionette.ItemView.extend({

        className: "csui-inlineform",

        ui: {
          inputFieldName: '.csui-inlineform-input-name',
          cancelButton: '.csui-btn-cancel',
          editCancelButton: '.csui-btn-edit-cancel',
          saveButton: '.csui-btn-save',
          metadataButton: '.csui-btn-metadata'
        },

        events: {
          'keyup @ui.inputFieldName': 'keyReleased',
          'paste @ui.inputFieldName': 'mouseRightCicked',
          'cut @ui.inputFieldName': 'mouseRightCicked',
          'focusin @ui.inputFieldName': 'onFocusInWrite',
          'keydown @ui.editCancelButton': 'cancelEditKeyPressed',
          'submit form': "saveClicked",
          'click @ui.saveButton': 'saveClicked',
          'click @ui.cancelButton': 'cancelClicked',
          'click @ui.editCancelButton': 'cancelClicked',
          'click @ui.metadataButton': _.debounce(function (event) {
            this.metadataIconClicked(event);
          }, 500),
          'keydown': 'onKeyInView'
        },

        behaviors: {
          TabKeyBehavior: {
            behaviorClass: TabKeyBehavior
          }
        },

        _templateHelpers: function () {
          var errorMessage   = this.model.get('csuiInlineFormErrorMessage'),
              disableSavebtn = false,
              objType        = this.model.get("type");
          disableSavebtn = !(!!this.model.get("name"));

          disableSavebtn = disableSavebtn || this.checkCustomFieldsModel();

          var data = {
            name: this.model.get('name'),
            EditCancelTooltip: lang.EditCancelTooltip,
            CancelButtonLabel: lang.CancelButtonLabel,
            disableSavebtn: disableSavebtn,
            SaveButtonLabel: this._isEditMode() ? lang.SaveButtonLabel :
                             lang.AddButtonLabel,
            formModeIsEdit: this._isEditMode(),
            haveErrorMessage: errorMessage ? true : false,
            extendedAdd: lang.ExtendedAdd,
            extendedAddAria: lang.ExtendedAddAria
          };
          if (data.haveErrorMessage) {
            data.errorMessage = errorMessage;
          }
          return data;
        },

        constructor: function InlineFormView(options) {
          this.options = options || {};
          Marionette.ItemView.prototype.constructor.apply(this, arguments);
        },

        onDomRefresh: function () {
          //Instead of using jquery select, focus was used. The reason:
          //When select is used it acts like a "select-All", which causes the table to
          //scroll when mouse focus is outside the table scrollable area.
          this.refershTabableElements();
          var errorMessage = this.model.get('csuiInlineFormErrorMessage');
          !!this.tabableElements && !!this.tabableElements[0] && this.tabableElements[0].focus();
          if (this.ui.metadataButton.length) {
            // set title, aria-label and aria-haspopup attributes.
            // check if these are exists in options, otherwise get them from lang bundles.
            this.ui.metadataButton.attr('title', this.options.ExtendedAdd || lang.ExtendedAdd);
            this.ui.metadataButton.attr('aria-label',
                this.options.ExtendedAddAria || lang.ExtendedAddAria);
            if (this.options.AriaHasPopUp === undefined) {
              this.ui.metadataButton.attr('aria-haspopup', true);
            } else {
              this.ui.metadataButton.attr('aria-haspopup', this.options.AriaHasPopUp);
            }
          }
          !!errorMessage && this.addInlineRole(errorMessage);
          //Remove transition to add item for thumbnail view
          /*if (this.options.originatingView && this.options.originatingView.thumbnailView && this.options.originatingView.thumbnail) {
            if (!!errorMessage) {
              this.options.originatingView.thumbnail.trigger("remove:transition", this.options.model);
            }
          }*/
        },

        cancelClicked: function (event) {
          event.preventDefault();
          event.stopPropagation();
          this.cancel();
        },

        onKeyInView: function (event) {
          this.clearInlineRole();
          if (event.keyCode === 9) {
            this._moveTab(event);
            return true;
          }
        },

        refershTabableElements: function () {
          this.tabableElements = this.$el.find('input:not([disabled]),  button:not([disabled])').filter(
              ':visible').toArray();
        },

        _moveTab: function (event) {
          this.currentlyFocusedElementIndex = this.tabableElements.indexOf(event.target);
          if (event.shiftKey) {
            if (this.currentlyFocusedElementIndex > 0) {
              this.currentlyFocusedElementIndex -= 1;
              $(this.tabableElements[this.currentlyFocusedElementIndex]).focus();
            } else {
              this.currentlyFocusedElementIndex = this.tabableElements.length - 1;
              $(this.tabableElements[this.currentlyFocusedElementIndex]).focus();
            }
          } else {
            if (this.currentlyFocusedElementIndex < this.tabableElements.length - 1) {
              this.currentlyFocusedElementIndex += 1;
              $(this.tabableElements[this.currentlyFocusedElementIndex]).focus();
            } else {
              this.currentlyFocusedElementIndex = 0;
              $(this.tabableElements[this.currentlyFocusedElementIndex]).focus();
            }
          }
          event.stopPropagation();
          event.preventDefault();
        },

        saveClicked: function (event) {
          event.preventDefault();
          event.stopPropagation();
          //Add transition to add item for thumbnail view
          /*if (this.options.originatingView && this.options.originatingView.thumbnailView && this.options.originatingView.thumbnail) {
            this.options.originatingView.thumbnail.trigger("apply:transition", this.options.model);
          }*/
          this.clearInlineRole();
          if (!!this.model.get('id')) { // in edit mode
            this._saveIfOk();
          } else { // in create mode
            var self = this;
            self.required = false;
            self._getCategoryID().done(function () { // return true if required fields found in container
              if (self.required) {
                self._openMetadataPage();
              } else {
                self._saveIfOk();
              }
            });
          }
        },

        _getCategoryID: function () {
          var self           = this,
              nId            = self.options.model.collection.node.get('id'),
              type           = this.model.get('type'),
              connector      = self.options.model.connector,
              fullUrl        = connector.connection.url + '/forms/nodes/create?parent_id=' + nId +
                               '&type=' +
                               type,
              deferredObject = $.Deferred(),
              ajaxOptions    = {
                type: 'GET',
                url: fullUrl
              },
              that           = this;
          connector.extendAjaxOptions(ajaxOptions);
          var xhr = $.ajax(ajaxOptions).done(_.bind(function (resp) {

            _.any(resp["forms"], function (form) {
              if (form.role_name == 'categories') {
                var requiredFilled = self._checkForAlpacaRequiredFields(form),
                    reqFields      = jsonPath(form.schema.properties, "$..[?(@.required===true)]");
                if (_.isArray(reqFields) && reqFields.length > 0 && !requiredFilled) {
                  self.required = true;

                }

              }
            });

            self.model.attributes.forms = resp;
            self.model.attributes.xhr = xhr;

            deferredObject.resolve();
          })).fail(function (resp) {
            //TODO show error message
            deferredObject.reject();
          });
          return deferredObject.promise();
        },

        // private
        //TO DO Same Method exists at several places ,must move to centralized place to get rid of
        // code redundancy
        _checkForAlpacaRequiredFields: function (form) {
          var valid             = true,
              data              = form.data || form.get('data'),
              options           = form.options || form.get('options'),
              schema            = form.schema || form.get('schema'),
              reqArray          = [],
              requiredFields    = jsonPath(schema, "$..[?(@.required===true)]", {resultType: "PATH"}),
              nonValidateFields = jsonPath(options, "$..[?(@.validate===false)]", {resultType: "PATH"});
          // getting field id for non validate fields
          var nonValidateFieldsIds = [];
          _.each(nonValidateFields, function (nvField) {
            var matches = nvField.toString().match(/(\'[\w]*\')/g);
            if (!!matches) {
              nonValidateFieldsIds.push(matches[matches.length - 1].replace(/'/g, ""));
            }
          });

          // getting field id for Required Fields
          var reqFieldId = [];
          _.each(requiredFields, function (reqField) {
            var matches = reqField.toString().match(/(\'[\w]*\')/g);
            if (!!matches) {
              reqFieldId.push(matches[matches.length - 1].replace(/'/g, ""));
            }
          });

          // eliminating non validating fields from required field ids.
          var removeNonValidateFields = function (nvFields, rFields) {
            var rFields_ = nvFields.filter(function (n) {
              return rFields.indexOf(n) != -1;
            });
            return rFields_.length > 0 ? rFields_ : rFields;
          };

          var filteredRequiredFieldsIds = removeNonValidateFields(nonValidateFieldsIds, reqFieldId);

          if (!!filteredRequiredFieldsIds) {
            var nullCount = false;
            _.each(filteredRequiredFieldsIds, function (arrayElement) {
              reqArray = jsonPath(data, "$.." + arrayElement.toString(), {resultType: "PATH"}.toArray);
              _.each(reqArray, function (arrayElement) {
                var checkNull = function (element) {
                  if (element instanceof Array && (element !== null || element !== "")) {
                    _.each(element, function (childElement) {
                      checkNull(childElement);
                    });
                  } else if (element === null || element === "") {
                    nullCount = true;
                    return;
                  }
                };
                if (!nullCount) {
                  checkNull(arrayElement);
                } else {
                  valid = false;
                  return;
                }
              });
              if (nullCount) {
                valid = false;
                return;
              }
            });
          }

          return valid;
        },
        // private
        _openMetadataPage: function () {

          var MN = '{0}:metadataIconClicked {1}';
          // don't propagate click event into name cell, because it would cause selecting the row

          var self = this;

          // set input data to the model ready for the Properties command
          self.viewToModelData();
          var nodes = new NodeCollection();
          nodes.push(self.options.model);

          var status = {
            nodes: nodes,
            container: self.options.model.collection.node,
            collection: self.options.model.collection
          };

          var options = {context: self.options.context};

          // new item to be added

          options = _.extend(options, {
            addableType: self.constructor.CSSubType // get subtype from static property
          });
          var addItemMetadataCmd = new AddItemMetadataCommand();
          addItemMetadataCmd.execute(status, options)
              .then(function (args) {
                delete self.model.inlineFormView;
                self.model.unset('csuiInlineFormErrorMessage', {silent: true});
                self.trigger('editEnded', this);
                if (args.name) {
                  return self.model.fetch();
                }
              }).fail(function (err) {
            self.cancel();
          });

        },

        cancelEditKeyPressed: function (event) {
          // Automatically save if user uses keyboard to tabs forward (to the right) over the cancel
          // edit button. Don't save if user tabbed backwards and the focus is in the input field.
          this.clearInlineRole();
          if (event.keyCode === 9) {  // tab key
            if (!event.shiftKey) {
              event.preventDefault();
              event.stopPropagation();
              this._saveIfOk();
            }
          }
        },

        onFocusInWrite: function (event) {
          // Begin - highlight the complete text.
          var currentInputElement    = $(event.target)[0],
              currentInputElementVal = currentInputElement.value,
              selEnd                 = !!currentInputElementVal ? currentInputElementVal.length : 0;

          // for documents, highlight text till last dot.
          if (this.model.get("type") === 144 && currentInputElementVal.lastIndexOf('.') > 0 &&
              currentInputElementVal.lastIndexOf('.') < currentInputElementVal.length - 1) {
            selEnd = currentInputElementVal.lastIndexOf('.');
          }
          currentInputElement.selectionEnd = selEnd;
          // End - highlight the complete text.
        },

        toggleButton: function (event) {
          if (this.ui.saveButton.length) {
            var currentInputElementVal = this.ui.inputFieldName.val().trim(),
                enableAddButton        = false;

            // check the name field.
            enableAddButton = currentInputElementVal.length !== 0;

            enableAddButton = enableAddButton && this.checkCustomFieldsInputVal();

            if (enableAddButton) {
              this.ui.saveButton.removeAttr("disabled").addClass("binf-btn-default");
            } else {
              this.ui.saveButton.attr("disabled", "disabled").removeClass("binf-btn-default");
            }
          }
          this.refershTabableElements();
        },

        /**
         * override in views which extends this, for example, url.view.js
         * functionality: returns false if custom model values are not available.
         * @return boolean
         */
        checkCustomFieldsModel: function () {
          return false;
        },

        /**
         * override in views which extends this, for example, url.view.js
         * functionality: returns true if custom input fields contains any value.
         * @return boolean
         */
        checkCustomFieldsInputVal: function () {
          return true;
        },

        mouseRightCicked: function (event) {
          this.clearInlineRole();
          var that = this;
          setTimeout(function () {
            that.toggleButton(event);
          }, 100);
        },

        keyReleased: function (event) {
          // clear the timeout if after leaving the input field the user types again in the input field
          if (this.leftInputFieldTimer) {
            clearTimeout(this.leftInputFieldTimer);
          }

          if (event.keyCode === 27) {  // escape key
            this.cancel();
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          this.toggleButton(event);
        },

        cancel: function (options) {
          options || (options = {});
          this.destroy();
          // delete the model if it was not already saved
          if (this.model.get('id') === undefined) {
            this.model.destroy();
          } else {
            // remove all editing related attributes from the model and trigger change to let it
            // re-render in the table
            delete this.model.inlineFormView;
            this.model.set('csuiInlineFormErrorMessage', 'dummy', {silent: true});
            this.model.unset('csuiInlineFormErrorMessage', {silent: options.silent});
          }
        },

        _isEditMode: function () {
          return this.model.get('id') !== undefined;
        },

        // Base class method.  Don't override.
        viewToModelData: function () {
          // calling base class method to set basic attribute(s)
          this._viewToModelData();

          // calling overridable method to set additional attribute(s)
          this._viewToModelDataExtended();
        },

        // Base class method.  Don't override.
        _viewToModelData: function () {
          this.model.set('name', this._getInputName(), {silent: true});
        },

        // Override this method to set additional model attribute(s)
        _viewToModelDataExtended: function () {
          // implementation in derived class
        },

        _getInputName: function () {
          var elInput = this.ui.inputFieldName;
          var name = elInput.val();
          name = name.trim();
          return name;
        },

        _saveIfOk: function () {
          // implementation in derived class
        },

        _save: function (attributes) {
          // Extra blocking here, because when saving of the model ends,
          // we load it once more from the server, because CS REST API
          // does not return anything from the create/modify calls.  This
          // second call is made on other temporary model, which the parent
          // collection does not contain and cannot take care of the blocking
          // on its own thus.
          var blockableView = this.options.originatingView;
          if (blockableView && blockableView.blockActions) {
            blockableView.blockActions();
          }
          var method  = this.model.get('id') === undefined ?
                        '_saveNewModel' : '_updateModel',
              promise = this[method](attributes);
          if (blockableView && blockableView.unblockActions) {
            promise.always(_.bind(blockableView.unblockActions, blockableView));
          }
          promise.done(_.bind(this.destroy, this));
          return promise;
        },

        _updateModel: function (attributes) {
          var MN = '{0}:_updateModel {1}';
          var inlineForm = this.model.inlineFormView; // save in case the sync fails
          delete this.model.inlineFormView; // let row render normally when model changes after save

          // note: not all models have mustRefreshAfterPut set. Because of this also assume on
          // undefined the model must be refreshed after update or save and only if set to false
          // the refresh is not needed
          var data = this.model.mustRefreshAfterPut !== false ? attributes : undefined;
          var saveAttr = this.model.mustRefreshAfterPut !== false ? undefined : attributes;

          var self = this,
              isThumbnailView = self.options.originatingView && self.options.originatingView.thumbnailView;
          // update attributes on existing nodes
          return this.model
              .save(saveAttr, {
                data: data,
                patch: true,  // let form data be 'body:{"name":"Pictures"}' and uploadable
                // mixin makes it a PUT again (backbone would use PATCH)
                wait: true,
                silent: true,
                skipSetValue: isThumbnailView // to stop re-rendering entire thumbnail item
                // before setting values to model
              })
              .then(function () {
                self.model.set(attributes, {silent: true});
                if (self.model.mustRefreshAfterPut !== false) {
                  return self.model.fetch();
                }
                self.model.set('csuiInlineFormErrorMessage', 'dummy', {silent: true});
                self.model.unset('csuiInlineFormErrorMessage'); // this lets the model be
                // re-rendered in the table (but without inline form open)
              })
              .fail(function (err) {
                self.model.inlineFormView = inlineForm; // use the form again

                // temporarily set attributes so that the UI elements would show the entered values
                var attributeKeys = _.keys(attributes);
                var cloneAttributes = _.pick(_.clone(self.model.attributes), attributeKeys);
                self.model.set(attributes, {silent: true});

                // renders the row again with the error message
                var errorMessage = self._getErrorMessageFromResponse(err);
                self.model.set('csuiInlineFormErrorMessage', errorMessage);
                log.error('Saving failed. ', errorMessage) && console.error(log.last);

                // reset the model's attributes back to previous
                self.model.set(cloneAttributes, {silent: true});
              });
        },

        _saveNewModel: function (attributes) {
          var MN = '{0}:_saveNewModel {1}';
          var inlineForm = this.model.inlineFormView; // save in case the save fails
          delete this.model.inlineFormView; // let row render normally when model changes after save

          this.model.set(attributes, {silent: true});
          var data = _.clone(this.model.attributes);
          delete data.hasMetadataRow;
          delete data.csuiInlineFormErrorMessage;
          var self = this;
          return this.model
              .save(undefined, {
                data: data,
                wait: true,
                silent: true
              })
              .then(function () {
                // todo remove code when server returns all node attributes after put/push
                if (self.model.mustRefreshAfterPut !== false) {
                   //Remove transition to add item for thumbnail view
                  /*if (self.options.originatingView && self.options.originatingView.thumbnailView && self.options.originatingView.thumbnail) {
                    self.options.originatingView.thumbnail.trigger("remove:transition", self.options.model);
                  }*/
                  return self.model.fetch();
                }
                self.model.set('csuiInlineFormErrorMessage', 'dummy', {silent: true});
                self.model.unset('csuiInlineFormErrorMessage'); // this lets the model be
                // re-rendered in the table (but without inline form open)
              })
              .fail(function (err) {
                self.model.inlineFormView = inlineForm; // use the form again
                self.model.trigger('error', self.model); // need sync for blocking view

                // renders the row again with the error message
                var errorMessage = self._getErrorMessageFromResponse(err);
                self.model.set('csuiInlineFormErrorMessage', errorMessage);
                log.error('Saving failed. ', errorMessage) && console.error(log.last);
              });
        },

        _getErrorMessageFromResponse: function (err) {
          var errorMessage;
          if (err && err.responseJSON && err.responseJSON.error) {
            errorMessage = err.responseJSON.error;
          } else {
            var errorHtml = base.MessageHelper.toHtml();
            base.MessageHelper.reset();
            errorMessage = $(errorHtml).text();
          }
          return errorMessage;
        },

        metadataIconClicked: function (event) {
          var MN = '{0}:metadataIconClicked {1}';
          // don't propagate click event into name cell, because it would cause selecting the row
          event.preventDefault();
          event.stopPropagation();
          this.clearInlineRole();
          // set input data to the model ready for the Properties command
          this.viewToModelData();

          var self = this;
          var nodes = new NodeCollection();
          nodes.push(this.model);
          var status = {
            nodes: nodes,
            container: this.model.collection.node,
            collection: this.model.collection
          };
          var options = {context: this.options.context};

          // new item to be added
          if (this.model.get('id') === undefined) {
            options = _.extend(options, {
              addableType: this.constructor.CSSubType // get subtype from static property
            });

            var addItemMetadataCmd = new AddItemMetadataCommand();
            addItemMetadataCmd.execute(status, options)
                .then(function (args) {
                  delete self.model.inlineFormView;
                  self.model.unset('csuiInlineFormErrorMessage', {silent: true});
                  self.trigger('editEnded', this);
                  if (args.name) {
                    return self.model.fetch();
                  }
                }).done(function () {
                  self.options.originatingView.$el.find(
                      '.csui-nodetable .csui-new-item a.csui-table-cell-name-value').first().focus();
                })
                .fail(function (err) {
                  self.cancel();
                  self.options.originatingView.$el.find(
                      '.csui-addToolbar .binf-dropdown-toggle').focus();
                });

          } else {
            status = _.extend(status, {originatingView: this.options.originatingView});
            // view properties of an existing item
            var propertiesCmd = new PropertiesCommand();
            propertiesCmd.execute(status, options)
                .always(function (args) {
                  self.cancel();
                });
          }
        },

        addInlineRole: function (errorMessage) {
          this.ui.inputFieldName.attr('title', lang.ActionFailedMessage + errorMessage);
          this.ui.inputFieldName.attr('role', 'alert');
        },

        clearInlineRole: function () {
          var errorMessage = !!this.model.get('csuiInlineFormErrorMessage');
          if (errorMessage) {
            this.ui.inputFieldName.attr('title', '');
            this.ui.inputFieldName.removeAttr('role');
          }
        },

      },
      {
        CSSubType: undefined  // Content Server Subtype of this base class is undefined
      }
  );

  return InlineFormView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/inlineforms/folder/impl/folder',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "csui-inlineform-error";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\r\n  ";
},"5":function(depth0,helpers,partials,data) {
    var helper;

  return this.escapeExpression(((helper = (helper = helpers.namePlaceholder || (depth0 != null ? depth0.namePlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"namePlaceholder","hash":{}}) : helper)));
},"7":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" class=\"csui-btn-edit-cancel binf-btn\">\r\n      <span class=\"icon edit-cancel\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.EditCancelTooltip || (depth0 != null ? depth0.EditCancelTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditCancelTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n    </button>\r\n";
},"9":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" class=\"csui-btn-metadata binf-btn\"><span\r\n        class=\"icon icon-toolbar-metadata\"></span></button>\r\n    <div class=\"csui-inline-action-container\">\r\n      <button type=\"submit\" class=\"csui-btn-save csui-btn binf-btn\"\r\n              disabled>"
    + this.escapeExpression(((helper = (helper = helpers.SaveButtonLabel || (depth0 != null ? depth0.SaveButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"SaveButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n      <button type=\"button\" class=\"csui-btn-cancel csui-btn binf-btn\">"
    + this.escapeExpression(((helper = (helper = helpers.CancelButtonLabel || (depth0 != null ? depth0.CancelButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"CancelButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n    </div>\r\n";
},"11":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-inlineform-group csui-inlineform-group-error\" role=\"alert\">\r\n    <div class=\"binf-text-danger\">"
    + this.escapeExpression(((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"errorMessage","hash":{}}) : helper)))
    + "</div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<form class=\"csui-inlineform-group csui-inlineform-group-folder-name\">\r\n  <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.namePlaceholder || (depth0 != null ? depth0.namePlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"namePlaceholder","hash":{}}) : helper)))
    + "\"\r\n         class=\"binf-form-control csui-inlineform-input-name "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\"\r\n         aria-label=\""
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.name : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(5, data, 0)})) != null ? stack1 : "")
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.formModeIsEdit : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "")
    + "</form>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_inlineforms_folder_impl_folder', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/inlineforms/folder/impl/folder',[],function(){});
csui.define('csui/controls/table/inlineforms/generic/generic.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  "csui/lib/marionette",
  'i18n!csui/controls/table/inlineforms/folder/impl/nls/lang',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/inlineform/impl/inlineform.view',
  "hbs!csui/controls/table/inlineforms/folder/impl/folder",
  "css!csui/controls/table/inlineforms/folder/impl/folder"
], function ($, _, Marionette, lang, inlineFormViewRegistry, InlineFormView, template) {

  var InlineFormGenericView = InlineFormView.extend({

        className: function () {
          var className = "csui-inlineform-generic";
          if (InlineFormView.prototype.className) {
            className += ' ' + _.result(InlineFormView.prototype, 'className');
          }
          return className;
        },

        template: template,

        templateHelpers: function () {
          var dataFromInlineFormView = this._templateHelpers();
          var data = _.extend(dataFromInlineFormView, {
            namePlaceholder: lang.NewNamePlaceholder
          });
          return data;
        },

        ui: {},

        events: {},

        constructor: function InlineFormGenericView(options) {
          this.options = options || {};

          // extend the base class ui and events hashes
          this.ui = _.extend({}, this.ui, InlineFormView.prototype.ui);
          this.events = _.extend({}, this.events, InlineFormView.prototype.events);

          Marionette.ItemView.prototype.constructor.apply(this, arguments);
        },

        _saveIfOk: function () {
          var inputName = this._getInputName();
          var name = this.model.get('name');
          if (inputName.length > 0 && inputName === name) {
            this.cancel();
          } else {
            if (inputName.length > 0) {
              this._save({name: inputName});
            }
          }
        }

      },
      {
        CSSubType: -1  // -1 is not a content server subtype. it's a marker for this generic impl.
      }
  );

  inlineFormViewRegistry.registerByAddableType(
      InlineFormGenericView.CSSubType,
      InlineFormGenericView);

  return InlineFormGenericView;
});

csui.define('csui/controls/table/inlineforms/folder/folder.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  "csui/lib/marionette",
  'i18n!csui/controls/table/inlineforms/folder/impl/nls/lang',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/inlineform/impl/inlineform.view',
  "hbs!csui/controls/table/inlineforms/folder/impl/folder",
  "css!csui/controls/table/inlineforms/folder/impl/folder"
], function ($, _, Marionette, lang, inlineFormViewRegistry, InlineFormView, template) {

  var InlineFormFolderView = InlineFormView.extend({

        className: function () {
          var className = "csui-inlineform-folder";
          if (InlineFormView.prototype.className) {
            className += ' ' + _.result(InlineFormView.prototype, 'className');
          }
          return className;
        },

        template: template,

        templateHelpers: function () {
          var dataFromInlineFormView = this._templateHelpers();
          var data = _.extend(dataFromInlineFormView, {
            namePlaceholder: lang.NewNamePlaceholder
          });
          return data;
        },

        ui: {},

        constructor: function InlineFormFolderView(options) {
          this.options = options || {};

          // extend the base class ui and events hashes
          this.ui = _.extend({}, this.ui, InlineFormView.prototype.ui);
          this.events = _.extend({}, this.events, InlineFormView.prototype.events);

          Marionette.ItemView.prototype.constructor.apply(this, arguments);
        },

        _saveIfOk: function () {
          var inputName = this._getInputName();
          var name = this.model.get('name');
          if (inputName.length > 0 && inputName === name) {
            this.cancel();
          } else {
            if (inputName.length > 0) {
              this._save({name: inputName}).fail(function (resp) {
                // Failed to save. So, revert model updates
                this.model.set({name: name}, {silent: true});
              }.bind(this));
            }
          }
        }

      },
      {
        CSSubType: 0  // Content Server Subtype of Folder is 0
      }
  );

  inlineFormViewRegistry.registerByAddableType(
      InlineFormFolderView.CSSubType,
      InlineFormFolderView);

  return InlineFormFolderView;
});

csui.define('csui/controls/table/inlineforms/shortcut/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/inlineforms/shortcut/impl/nls/root/lang',{
  ShortcutPickerTitle: 'Shortcut',
  ShortcutNamePlaceholder: 'Enter a new Shortcut name',
  NameMustNotBeEmpty: 'Shortcut name cannot be empty.',
  NoShortcutSelected: 'No Shortcut target selected.'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/inlineforms/shortcut/impl/shortcut',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" class=\"csui-btn-edit-cancel binf-btn\">\r\n      <span class=\"icon edit-cancel\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.EditCancelTooltip || (depth0 != null ? depth0.EditCancelTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditCancelTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n    </button>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" class=\"csui-btn-metadata binf-btn\"><span\r\n        class=\"icon icon-toolbar-metadata\"></span></button>\r\n    <div class=\"csui-inline-action-container\">\r\n      <button type=\"submit\" class=\"csui-btn-save csui-btn binf-btn\r\n    binf-btn-default\">"
    + this.escapeExpression(((helper = (helper = helpers.SaveButtonLabel || (depth0 != null ? depth0.SaveButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"SaveButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n      <button type=\"button\" class=\"csui-btn-cancel csui-btn binf-btn\">"
    + this.escapeExpression(((helper = (helper = helpers.CancelButtonLabel || (depth0 != null ? depth0.CancelButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"CancelButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n    </div>\r\n";
},"5":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-inlineform-group csui-inlineform-group-error\" role=\"alert\">\r\n    <div class=\"binf-text-danger\">"
    + this.escapeExpression(((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"errorMessage","hash":{}}) : helper)))
    + "</div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<form class=\"csui-inlineform-group csui-inlineform-group-url-name\">\r\n  <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.namePlaceholder || (depth0 != null ? depth0.namePlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"namePlaceholder","hash":{}}) : helper)))
    + "\"\r\n         class=\"binf-form-control csui-inlineform-input-name\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.formModeIsEdit : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "</form>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_inlineforms_shortcut_impl_shortcut', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/inlineforms/shortcut/impl/shortcut',[],function(){});
csui.define('csui/controls/table/inlineforms/shortcut/shortcut.view',[
  'csui/lib/underscore',
  'csui/lib/marionette',
  'i18n!csui/controls/table/inlineforms/shortcut/impl/nls/lang',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/inlineform/impl/inlineform.view',
  'hbs!csui/controls/table/inlineforms/shortcut/impl/shortcut',
  'css!csui/controls/table/inlineforms/shortcut/impl/shortcut'
], function (_, Marionette, lang, inlineFormViewRegistry, InlineFormView, template) {

  var InlineFormShortcutView = InlineFormView.extend({

        className: function () {
          var className = "csui-inlineform-shortcut";
          if (InlineFormView.prototype.className) {
            className += ' ' + _.result(InlineFormView.prototype, 'className');
          }
          return className;
        },

        template: template,

        templateHelpers: function () {
          var dataFromInlineFormView = this._templateHelpers();
          var data = _.extend(dataFromInlineFormView, {
            namePlaceholder: lang.ShortcutNamePlaceholder
          });
          return data;
        },

        ui: {
          inputFieldName: '.csui-inlineform-input-name'
        },

        events: {},

        constructor: function InlineFormShortcutView(options) {
          this.options = options || {};

          // extend the base class ui and events hashes
          this.ui = _.extend({}, this.ui, InlineFormView.prototype.ui);
          this.events = _.extend({}, this.events, InlineFormView.prototype.events);

          Marionette.ItemView.prototype.constructor.apply(this, arguments);
        },

        _saveIfOk: function () {
          var inputName = this._getInputName();
          if (inputName && inputName.length > 0) {
            if (this.model.get('original_id') === undefined) {
              this.model.set('csuiInlineFormErrorMessage', lang.NoShortcutSelected);
            } else {
              var attributes;
              if (this.model.get('id') === undefined) {
                // save new
                attributes = {name: inputName, original_id: this.model.get('original_id')};
              } else {
                // when updating, save only the name for now, because there is no UI to change
                // the original node
                attributes = {name: inputName};
              }
              this._save(attributes);
            }
          } else {
            this.model.set('csuiInlineFormErrorMessage', lang.NameMustNotBeEmpty);
          }
        }

      },
      {
        CSSubType: 1  // Content Server Subtype of Shortcut is 1
      }
  );

  inlineFormViewRegistry.registerByAddableType(
      InlineFormShortcutView.CSSubType,
      InlineFormShortcutView);

  return InlineFormShortcutView;
});

csui.define('csui/controls/table/inlineforms/url/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/inlineforms/url/impl/nls/root/lang',{
  UrlNamePlaceholder: 'Enter website name',
  UrlAddressPlaceholder: 'Web address',

  UrlInvalidFormat: 'The format of the Web address is invalid.'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/inlineforms/url/impl/url',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "hasError";
},"3":function(depth0,helpers,partials,data) {
    return "csui-inlineform-error";
},"5":function(depth0,helpers,partials,data) {
    return "      <span class=\"formfield_error csui-inlineform-input-error\"></span>\r\n";
},"7":function(depth0,helpers,partials,data) {
    return " ";
},"9":function(depth0,helpers,partials,data) {
    return "binf-btn-default ";
},"11":function(depth0,helpers,partials,data) {
    return " disabled ";
},"13":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-inlineform-group csui-inlineform-group-error\" role=\"alert\">\r\n    <div class=\"binf-text-danger\">"
    + this.escapeExpression(((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"errorMessage","hash":{}}) : helper)))
    + "</div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<form>\r\n  <div class=\"binf-hidden-md binf-hidden-lg hidden-xl hidden-xxl\r\n       csui-inlineform-vertical-spacer\"></div>\r\n  <div class=\"csui-inlineform-group csui-inlineform-group-url\">\r\n    <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.namePlaceholder || (depth0 != null ? depth0.namePlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"namePlaceholder","hash":{}}) : helper)))
    + "\"\r\n           class=\"binf-form-control csui-inlineform-input-name "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.validationFailed_Name : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n    <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"url","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.urlPlaceholder || (depth0 != null ? depth0.urlPlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"urlPlaceholder","hash":{}}) : helper)))
    + "\"\r\n           class=\"binf-hidden-xs binf-hidden-sm binf-form-control csui-inlineform-input-url "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "    <button type=\"button\" class=\"binf-hidden-xs\r\n    binf-hidden-sm csui-btn-metadata binf-btn\">\r\n      <span class=\"icon icon-toolbar-metadata\"></span></button>\r\n    <div class=\"csui-inline-action-container\">\r\n      <button type=\"submit\" class=\"binf-hidden-xs\r\n    binf-hidden-sm csui-btn-save csui-btn binf-btn\r\n            "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disableSavebtn : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "")
    + "\"\r\n        "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disableSavebtn : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ">"
    + this.escapeExpression(((helper = (helper = helpers.SaveButtonLabel || (depth0 != null ? depth0.SaveButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"SaveButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n      <button type=\"button\" class=\"binf-hidden-xs binf-hidden-sm csui-btn-cancel csui-btn binf-btn\r\n            binf-btn-default\">"
    + this.escapeExpression(((helper = (helper = helpers.CancelButtonLabel || (depth0 != null ? depth0.CancelButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"CancelButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n    </div>\r\n\r\n  </div>\r\n  <div class=\"binf-hidden-md binf-hidden-lg hidden-xl hidden-xxl\r\n       csui-inlineform-vertical-spacer\"></div>\r\n  <div class=\"binf-hidden-md binf-hidden-lg hidden-xl hidden-xxl csui-inlineform-group\r\ncsui-inlineform-group-url-wrapped\">\r\n    <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"url","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.urlPlaceholder || (depth0 != null ? depth0.urlPlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"urlPlaceholder","hash":{}}) : helper)))
    + "\"\r\n           class=\"binf-form-control csui-inlineform-input-url "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n    <button type=\"button\" class=\"csui-btn-metadata binf-btn\">\r\n      <span class=\"icon icon-toolbar-metadata\"></span></button>\r\n    <div class=\"csui-inline-action-container\">\r\n      <button type=\"submit\" class=\"csui-btn-save csui-btn binf-btn\r\n            "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disableSavebtn : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "")
    + "\"\r\n        "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.disableSavebtn : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ">"
    + this.escapeExpression(((helper = (helper = helpers.SaveButtonLabel || (depth0 != null ? depth0.SaveButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"SaveButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n      <button type=\"button\"\r\n              class=\"csui-btn-cancel csui-btn binf-btn binf-btn-default\">"
    + this.escapeExpression(((helper = (helper = helpers.CancelButtonLabel || (depth0 != null ? depth0.CancelButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"CancelButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n    </div>\r\n  </div>\r\n  <div class=\"binf-hidden-md binf-hidden-lg hidden-xl hidden-xxl\r\n       csui-inlineform-vertical-spacer\"></div>\r\n</form>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(13, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_inlineforms_url_impl_url', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/inlineforms/url/impl/url',[],function(){});
csui.define('csui/controls/table/inlineforms/url/url.view',[
  'require',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'i18n!csui/controls/table/inlineforms/url/impl/nls/lang',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/inlineform/impl/inlineform.view',
  "hbs!csui/controls/table/inlineforms/url/impl/url",
  "css!csui/controls/table/inlineforms/url/impl/url"
], function (require, $, _, Marionette, lang, inlineFormViewRegistry, InlineFormView, template) {

  var InlineFormUrlView = InlineFormView.extend({

        className: function () {
          var className = "csui-inlineform-url";
          if (InlineFormView.prototype.className) {
            className += ' ' + _.result(InlineFormView.prototype, 'className');
          }
          return className;
        },

        template: template,

        templateHelpers: function () {
          var dataFromInlineFormView = this._templateHelpers();
          // FIXME: Either the server returns the URL or we have to fetch
          // the single node info here and supply the value asynchronously,
          // or we fetch the specific form
          var url = this.model.get('url');
          var data = _.extend(dataFromInlineFormView, {
            url: url,
            namePlaceholder: lang.UrlNamePlaceholder,
            urlPlaceholder: lang.UrlAddressPlaceholder
          });
          return data;
        },

        ui: {
          urlFieldName: '.csui-inlineform-input-url'
        },

        events: {
          'keyup @ui.urlFieldName': 'keyReleased'
        },

        constructor: function InlineFormUrlView(options) {
          this.options = options || {};

          // extend the base class ui and events hashes
          this.ui = _.extend({}, this.ui, InlineFormView.prototype.ui);
          this.events = _.extend({}, this.events, InlineFormView.prototype.events);

          this.relativeUrlRegexp = this.options.relativeUrlRegexp || /^\?func=[a-z0-9]/i;

          Marionette.ItemView.prototype.constructor.apply(this, arguments);
        },

        // overriding this method to include url input value check.
        checkCustomFieldsInputVal: function () {
          return this._getInputUrl().trim().length !== 0;
        },

        // overriding this method to check model has url value or not.
        checkCustomFieldsModel: function () {
          return !(!!this.model.get("url"));
        },

        // Override base method to set additional model attribute(s)
        _viewToModelDataExtended: function () {
          // setting additional attribute(s)
          this.model.set('url', this._getInputUrl(), {silent: true});
        },

        _getInputUrl: function () {
          var url      = '',
              elInputs = this.ui.urlFieldName;

          elInputs.each(_.bind(function (idx, elInput) {
            var h = elInput.offsetHeight;
            if (h > 0) {
              url = $(elInput).val().trim();
              if (!url.match(this.relativeUrlRegexp)) {
                // add default protocol silently when the url field is non-empty and doesn't contains any protocol.
                // else if url contains CS specific relative, then let it as it is.
                url = (!!url.match(/^[a-zA-Z]+:\/\//)) ? url : 'http://' + url;
              }
            }
          }, this));

          return url;
        },

        _saveIfOk: function () {
          var urlName    = this._getInputName(),
              urlAddress = this._getInputUrl();
          if (urlName.length > 0 && urlAddress.length > 0) {
            if (urlAddress.match(this.relativeUrlRegexp)) {
              this._save({name: urlName, url: urlAddress});
            } else {
              var self = this;
              csui.require(['csui/lib/alpaca/js/alpaca'
              ], function (Alpaca) {
                var regexpUrl = Alpaca.regexps.url;
                if (urlAddress.match(regexpUrl)) {
                  self._save({name: urlName, url: urlAddress});
                } else {
                  self.model.set({'name': urlName, 'url': urlAddress}, {silent: true});
                  self.model.set('csuiInlineFormErrorMessage', lang.UrlInvalidFormat);
                }
              }, function (error) {
                self.model.set('csuiInlineFormErrorMessage', error.message);
              });
            }
          }
        }

      },
      {
        CSSubType: 140 // Content Server Subtype of Url is 140
      }
  );

  inlineFormViewRegistry.registerByAddableType(InlineFormUrlView.CSSubType, InlineFormUrlView);
  return InlineFormUrlView;
});

/**
 * collection inline form is more or less same as folder except icon and sub-typ, hence
 * extending from FolderFormView and overriding classname to get collection specific item and
 * overriding CSSubType to register `Collection` sub-type.
 */

csui.define('csui/controls/table/inlineforms/collection/collection.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  "csui/lib/marionette",
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/folder/folder.view'
], function ($, _, Marionette, inlineFormViewRegistry, FolderFormView) {

  var InlineFormCollectionView = FolderFormView.extend({
        className: function () {
          var className = "csui-inlineform-collection";
          if (FolderFormView.prototype.className) {
            className += ' ' + _.result(FolderFormView.prototype, 'className');
          }
          return className;
        }
      },
      {
        CSSubType: 298 // Content Server Subtype of Collection is 298
      }
  );

  inlineFormViewRegistry.registerByAddableType(
      InlineFormCollectionView.CSSubType,
      InlineFormCollectionView);

  return InlineFormCollectionView;
});


csui.define('csui/controls/table/inlineforms/inlineform.factory',['csui/lib/underscore',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/generic/generic.view',
  'csui/controls/table/inlineforms/folder/folder.view',
  'csui/controls/table/inlineforms/shortcut/shortcut.view',
  'csui/controls/table/inlineforms/url/url.view',
  'csui/controls/table/inlineforms/collection/collection.view',
  'csui-ext!csui/controls/table/inlineforms/inlineform.factory'
], function (_, inlineFormViewRegistry,
    InlineFormGenericView,
    InlineFormFolderView,
    InlineFormShortcutView,
    InlineFormUrlView,
    InlineFormCollectionView) {

  function InlineFormViewFactory() {}

  _.extend(InlineFormViewFactory.prototype, {

    getInlineFormView: function (addableType) {
      var InlineFormView = inlineFormViewRegistry.getInlineFormView(addableType);
      return InlineFormView;
    }

  });

  return new InlineFormViewFactory();

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/rows/metadata/impl/metadatarow',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <div class=\"binf-form-group binf-col-xs-12\"\r\n           data-csui-attribute=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isRegion : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "      </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    return "              <div title=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.label : depth0), depth0))
    + "\" id=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.regionLabelId : depth0), depth0))
    + "\"\r\n                     class=\"binf-col-xs-4 binf-col-sm-3 binf-col-md-2 binf-control-label\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.label : depth0), depth0))
    + "</div>\r\n\r\n              <div id=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.id : depth0), depth0))
    + "\" class=\"binf-col-xs-8 binf-col-sm-9 binf-col-md-10\r\n              binf-form-control-static csui-content-view\" aria-labelledby=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.regionLabelId : depth0), depth0))
    + "\"></div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    var stack1;

  return "              <label for=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.id : depth0), depth0))
    + "\" title=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.label : depth0), depth0))
    + "\"\r\n                     class=\"binf-col-xs-4 binf-col-sm-3 binf-col-md-2 binf-control-label\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.label : depth0), depth0))
    + "</label>\r\n              <input id=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.id : depth0), depth0))
    + "\" type=\"text\" readonly value=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.value : depth0), depth0))
    + "\"\r\n                     "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.tooltip : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n                     class=\"binf-col-xs-8 binf-col-sm-9 binf-col-md-10 binf-form-control-static\">\r\n";
},"5":function(depth0,helpers,partials,data) {
    return "title=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.tooltip : depth0), depth0))
    + "\"";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"binf-row\">\r\n  <div class=\"cs-form binf-form-horizontal\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.meta : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_table_rows_metadata_impl_metadatarow', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/rows/metadata/impl/metadatarow',[],function(){});
csui.define('csui/controls/table/rows/metadata/metadatarow.view',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/marionette',
  'hbs!csui/controls/table/rows/metadata/impl/metadatarow',
  'css!csui/controls/table/rows/metadata/impl/metadatarow',
  // FIXME: This is not possible.  Forms are in other bundle and impl
  // is not included in its index; it is not a public interface.
  'css!csui/controls/form/impl/form'
], function ($, _, Marionette, template) {
  'use strict';

  var MetadataRowView = Marionette.ItemView.extend({
    className: "csui-table-metadata-view binf-container-fluid",

    template: template,

    templateHelpers: function () {
      var self = this;
      var meta = [];
      var cellView;

      _.each(this.options.columns, function (column) {
        cellView = new column.CellView({
          context: this.options.context,
          column: column,
          model: this.options.model,
          nameEdit: false
        });

        meta = meta.concat(this._getColumnAttributes(column, cellView));
      }, this);

      // generate attribute id and setup contentViews
      this._contentViews = [];
      _.each(meta, function (attribute) {
        attribute.id = _.uniqueId(attribute.name);
        if (attribute.contentView) {
          attribute.id = _.uniqueId(attribute.name);
          attribute.isRegion = true;
          attribute.regionLabelId = _.uniqueId("rl_" + attribute.id);
          self._contentViews.push({
            view: attribute.contentView,
            regionElementId: attribute.id
          });
        }
      });

      return {meta: meta};
    },

    _getColumnAttributes: function (column, cellView) {
      var attributes = [];

      if (_.isFunction(cellView.getAttributes)) {
        attributes = cellView.getAttributes();
      } else {
        var textValue        = cellView.getValueText(),
            tooltipTextValue = _.isFunction(cellView.getTooltipValueText) ?
                               cellView.getTooltipValueText() : textValue;
        attributes.push({
          label: column.title,
          value: textValue,
          tooltip: tooltipTextValue,
          name: column.name,
          contentView: _.isFunction(cellView.getContentView) ? cellView.getContentView() : undefined
        });
      }

      return attributes;
    },

    constructor: function MetadataRowView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    onRender: function () {
      _.each(this._contentViews, function (contentView) {
        var $el = this.$el.find('#' + contentView.regionElementId);
        var contentRegion = new Marionette.Region({el: $el});
        contentRegion.show(contentView.view);
      }, this);
    },

    currentlyFocusedElement: function () {
      // there is currently noting to focus in the metadata row view
      return $();
    }
  });

  return MetadataRowView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/rows/error/impl/errorrow',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"binf-text-danger\">"
    + this.escapeExpression(((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"errorMessage","hash":{}}) : helper)))
    + "</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_table_rows_error_impl_errorrow', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/rows/error/impl/errorrow',[],function(){});
csui.define('csui/controls/table/rows/error/errorrow.view',[
  'csui/lib/underscore',
  "csui/lib/marionette",
  "hbs!csui/controls/table/rows/error/impl/errorrow",
  "css!csui/controls/table/rows/error/impl/errorrow"
], function (_, Marionette, template) {

  var ErrorRowView = Marionette.ItemView.extend({

    className: "csui-table-error-view binf-container-fluid",

    template: template,

    templateHelpers: function () {
      return {errorMessage: this.options.errorMessage ? this.options.errorMessage : '' };
    },

    ui: {},

    events: {},

    constructor: function ErrorRowView(options) {
      this.options = options || {};
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }

  });

  return ErrorRowView;

});

csui.define('csui/controls/table/impl/table.header.view',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/marionette',
  'csui/utils/base'
], function ($, _, Marionette, base) {
  'use strict';

  var TableHeaderView = Marionette.View.extend({
    constructor: function TableHeaderView(options) {
      TableHeaderView.__super__.constructor.apply(this, arguments);
      this._getActiveInlineForm = options._getActiveInlineForm;
      this.searchBoxes = options.searchBoxes;
      this.alternativeHeaderView = options.alternativeHeaderView;
      this.displayedColumns = options.displayedColumns;

      this.accFocusedColumn = options.accFocusedColumn || 0;
      this.accSearchFocused = options.accSearchFocused || false;

      if (this.alternativeHeaderView) {
        this.listenTo(this.alternativeHeaderView, 'focusout', function (args) {
          var thElements = this.$('>tr>th:not(.csui-alternative-table-header)');
          var thNextToAlternativeHeaderIndex = -1;
          var i, thEl;
          if (args.direction === "left") {
            // find th left from alternativeHeader
            for (i = 0; i < thElements.length; i++) {
              thEl = $(thElements[i]);
              if (thEl.hasClass(TableHeaderView.ClassNameColumnForAlternativeHeader)) {
                thNextToAlternativeHeaderIndex = i - 1;
                break;
              }
            }
          } else {
            // find th that follows alternativeHeader
            for (i = thElements.length - 1; i > 0; i--) {
              thEl = $(thElements[i]);
              if (thEl.hasClass(TableHeaderView.ClassNameColumnForAlternativeHeader)) {
                if (i + 1 < thElements.length) {
                  thNextToAlternativeHeaderIndex = i + 1;
                  break;
                }
              }
            }
          }
          if (thNextToAlternativeHeaderIndex >= 0) {
            this.accFocusedColumn = thNextToAlternativeHeaderIndex;
          }
          this._accSetFocusToCurrentlyFocusedElement();
        });

        this.listenTo(this.alternativeHeaderView, 'changed:focus',
            this._accSetFocusToCurrentlyFocusedElement);
      }
    },

    events: {"keydown": "onKeyInView"},

    render: function () {
      this.triggerMethod('before:render', this);

      // not rendering, but calculating the column count from the already rendered table
      var headerCells = this.$('>tr>th');
      var searchBoxCells = this.$('>tr>th>.csui-table-column-search');
      this._columnCount = headerCells.length;
      this._searchBoxCount = searchBoxCells.length;

      this.triggerMethod('render', this);
    },

    remove: function () {
      this.stopListening();
      this.undelegateEvents();
      return this;
    },

    currentlyFocusedElement: function () {
      _limitAccFocusedColumnToDisplayed.call(this);

      var columnSelector = this._getColumnSelector(this.displayedColumns[this.accFocusedColumn]);
      var focusedElement = this.$(columnSelector);
      if (focusedElement.is(":visible")) {
        if (this.accSearchFocused) {
          var sbView = this._findActiveSearchBoxView();
          if (sbView) {
            focusedElement = sbView.currentlyFocusedElement();
          } else {
            focusedElement = $(); // should never happen
          }
        } else {

          var elText = $(focusedElement[0]).find('.csui-focusable-table-column-header');
          if (elText.length > 0) {
            focusedElement = elText;
          }
        }
      }
      return focusedElement;

    },

    _getColumnSelector: function (column) {
      var columnAttributeName = column.attributes.column_key;
      var columnSelector = 'tr>th[data-csui-attribute="' + columnAttributeName + '"]';
      return columnSelector;
    },

    // this test is used when user navigates right with keyboard and returns true if the
    // move-right operation would end up in the next column. If false is returned, focus should
    // stay in the same column but move from the column title to the search glass instead
    _rightIsNextColumn: function () {
      var column = this.displayedColumns[this.accFocusedColumn];
      var columnSelector = this._getColumnSelector(column);
      var searchboxSelector = columnSelector + " .csui-table-column-search";
      var searchBox = this.$(searchboxSelector);
      return this.accSearchFocused || searchBox.length === 0;
    },

    onKeyInView: function (event) {
      var columnSelector, thEl;

      function moveFocusedElementLeft() {
        newFocusedColumn = this.accFocusedColumn - 1;
        while (newFocusedColumn >= 0) {
          columnSelector = this._getColumnSelector(this.displayedColumns[newFocusedColumn]);
          thEl = this.$(columnSelector);
          if (thEl.is(":visible") &&
              thEl.find('.csui-focusable-table-column-header').length > 0) {
            this.accFocusedColumn = newFocusedColumn;
            searchBox = thEl.find('.csui-table-column-search');
            this.accSearchFocused = searchBox.length > 0;
            // if searchbox is open then we tell it to focus to the rightmost element
            // (the searchglass)
            if (this.accSearchFocused) {
              sbView = this._findActiveSearchBoxView();
              if (sbView && sbView.getShown()) {
                sbView.setFocusToGlass();
              }
            }
            break;
          } else {
            // try next column to the left
            newFocusedColumn--;
          }
        }
      }

      var n, searchBox, newFocusedColumn, sbView;

      // if there is an inline form opened, don't handle keystrokes here
      if (this._getActiveInlineForm()) {
        return;
      }

      switch (event.keyCode) {
      case 32:
      case 13:
        // enter and space key (without ctrl or command)
        if (!(event.ctrlKey || event.metaKey)) {
          if (!this.accSearchFocused) {
            if (this.options.displayedColumns[this.accFocusedColumn].bSortable) {
              event.preventDefault();
              event.stopPropagation();

              this.trigger('sorting:toggle', this.accFocusedColumn);
            }
          }
        }
        break;
      case 37:
        // left arrow
        if (this.accSearchFocused) {
          sbView = this._findActiveSearchBoxView();
          if (sbView && sbView.getShown()) {
            // search is shown - left means moving to the previous column
            moveFocusedElementLeft.call(this);
          } else {
            // search is not shown - left means moving from the search glass to column title
            this.accSearchFocused = false;
          }
        } else {
          moveFocusedElementLeft.call(this);
        }
        event.preventDefault();
        event.stopPropagation();
        this.trigger('closeOtherControls'); // force inline bar to close
        this._accSetFocusAfterTabableRegionActivated();
        break;
      case 39:
        // right arrow:

        // focus on Name: this.accSearchFocused = false, searchbox is there (searchBox.length === 1)
        // -> stay in this th, but move focus from Name to search glass by setting
        // this.accSearchFocused to true
        //      -> this.accSearchFocused = true
        //      -> if searchbox shown -> set focus to input field
        //                  otherwise -> set focus to search glass
        //           (currentlyFocusedElement knows what to focus in searchbox)

        if (this._rightIsNextColumn()) {
          // find next column

          n = this.accFocusedColumn + 1;
          while (n < this.displayedColumns.length) {
            columnSelector = this._getColumnSelector(this.displayedColumns[n]);
            thEl = this.$(columnSelector);
            if (this._isHeaderCellFocusable(thEl)) {
              this.accFocusedColumn = n;
              this.accSearchFocused = false;
              break;  // stop loop, because we have found the next column
            } else {
              // try next column
              n = n + 1;
            }
          }
          sbView = this._findActiveSearchBoxView();
          if (sbView && sbView.getShown()) {
            this.accSearchFocused = true;
            sbView.setFocusToInput();
          }

        } else {
          // stay in this column, but move the focus to the searchbox
          this.accSearchFocused = true;
          sbView = this._findActiveSearchBoxView();
          if (sbView && sbView.getShown()) {
            sbView.setFocusToInput();
          }
        }

        event.preventDefault();
        event.stopPropagation();
        this.trigger('closeOtherControls'); // force inline bar to close
        this._accSetFocusAfterTabableRegionActivated();

        break;
      case 35:
        // END key > goto rightmost column
        this.accFocusedColumn = this.displayedColumns.length - 1;
        n = this.accFocusedColumn + 1;
        searchBox = this.$('>tr>th:nth-child(' + n + ') .csui-table-column-search');
        this.accSearchFocused = searchBox.length > 0;
        if (this.accSearchFocused) {
          sbView = this._findActiveSearchBoxView();
          if (sbView && sbView.getShown()) {
            sbView.setFocusToInput();
          }
        }
        event.preventDefault();
        event.stopPropagation();
        this.trigger('closeOtherControls'); // force inline bar to close
        this._accSetFocusAfterTabableRegionActivated();
        break;
      case 36:
        // POS1 key > goto first column
        this.accFocusedColumn = 0;
        this.accSearchFocused = false;
        event.preventDefault();
        event.stopPropagation();
        this.trigger('closeOtherControls'); // force inline bar to close
        this._accSetFocusAfterTabableRegionActivated();
        break;
      case 121:
        if (event.shiftKey) {
          // F10
          if (this.searchBoxes && this.searchBoxes.length > 0) {
            sbView = this.searchBoxes[0];
            sbView.showSearchInput();
            this.listenToOnce(sbView, 'closed', this._accSetFocusAfterTabableRegionActivated);
          }
          event.stopPropagation();
          event.preventDefault();
        }
        break;
      }

    },

    _accSetFocusToCurrentlyFocusedElement: function () {
      var el = this.currentlyFocusedElement();
      if (el.length > 0) {
        el = $(el[0]);
        this.trigger('changed:focus', this);
        if (base.isVisibleInWindowViewport(el)) {
          el.focus();
        }
      }
    },

    _accSetFocusAfterTabableRegionActivated: function () {
      if (this._getActiveInlineForm()) {
        // don't set focus when inline form is active
        return;
      }
      var sbView = this._findActiveSearchBoxView();
      if (sbView && sbView.getShown()) {
        // don't set focus if searchbox input field is open
        return;
      }
      this._accSetFocusToCurrentlyFocusedElement();
    },

    _accSearchBoxFocused: function (options) {
      this.accFocusedColumn = options.columnIndex;
      this.accSearchFocused = true;
      // this.trigger('changed:focus', this);
      this._accSetFocusToCurrentlyFocusedElement();
    },

    _findActiveSearchBoxView: function () {
      var searchBoxViews = this.searchBoxes;
      var displayedColumns = this.displayedColumns;
      var columnName = displayedColumns[this.accFocusedColumn].name.toLowerCase();
      var sbView = _.find(searchBoxViews, function (searchBoxView) {
        return searchBoxView.options.column === columnName;
      });
      return sbView;
    },

    _isHeaderCellFocusable: function (thEl) {
      return thEl.is(":visible") &&
             thEl.find('.csui-focusable-table-column-header').length > 0;
    }
  }, {
    // FIXME: Fix or remove this
    ClassNameColumnForAlternativeHeader: 'csui-undefined'
  });

  function _limitAccFocusedColumnToDisplayed() {
    if (this.accFocusedColumn >= this.displayedColumns.length) {
      if (this.displayedColumns > 0) {
        this.accFocusedColumn = this.displayedColumns.length - 1;
      } else {
        this.accFocusedColumn = 0;
      }
    }
  }

  return TableHeaderView;
})
;

csui.define('csui/controls/table/impl/table.body.view',[
  'csui/lib/jquery', 'csui/lib/marionette', 'csui/utils/focusable'
], function ($, Marionette, focusable) {
  'use strict';

  var TableBodyView = Marionette.View.extend({
    constructor: function TableBodyView(options) {
      TableBodyView.__super__.constructor.apply(this, arguments);
      this._getActiveInlineForm = options._getActiveInlineForm;
      this.startInlineFormForEdit = options.startInlineFormForEdit;
      this.collection = options.collection;
      this.displayedColumns = options.displayedColumns;
      this.nameColumnIndex = TableBodyView.getNameColumnIndex(options.displayedColumns) || 0;

      this.accFocusedCell = options.accFocusedCell || {column: this.nameColumnIndex, row: 0};
      this.tableView = options.tableView;
    },

    ui: {
      description: '.csui-details-row-description'
    },

    events: {
      "keydown": "onKeyInView",
      "focus @ui.description": "descriptionRowFocus"
    },

    render: function () {
      this.triggerMethod('before:render', this);

      // not rendering, but calculating the column count from the already rendered table
      var headerCells = this.$el.parent().find('thead>tr>th');
      this._columnCount = headerCells.length;

      this.triggerMethod('render', this);
    },

    remove: function () {
      this.stopListening();
      this.undelegateEvents();
      return this;
    },

    currentlyFocusedElement: function () {
      // Guard against call from outside, when rendering has not been
      // finished yet. Another try should be made on dom:refresh.
      if (!this.tableView.table) {
        return $();
      }
      if (this.accFocusedCell) {
        var model = this.collection.at(this.accFocusedCell.row);
        var detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);

        if (detailRowsInfo.accFocusedViewIndex !== undefined) {
          // focus is in detail row -> delegate this call to it if it is visible

          var view = detailRowsInfo.views[detailRowsInfo.accFocusedViewIndex];
          if (view.$el.is(':visible')) {
            return view.currentlyFocusedElement();
          } else {
            return $(); // can't focus it, because it is not visible
          }
        } else {
          // focus is in main row
          var tableRowEl = $(this.tableView.table.row(this.accFocusedCell.row).node());
          var tableCellEl = tableRowEl.children()[this.accFocusedCell.column];
          // If there is only one focusable element, focus it right away.
          // Otherwise focus the cell and it is up to it, how to handle focus.
          var focusables = focusable.findFocusables(tableCellEl);
          return focusables.length === 1 ? $(focusables[0]) : $(tableCellEl);
        }
      } else {
        return $();
      }
    },

    onClickedCell: function (args) {
      // console.log("### CELL CLICKED", args);
      this.accFocusedCell.row = args.rowIndex;
      this.accFocusedCell.column = args.colIndex;
      this._accSetFocusAfterTabableRegionActivated();
    },

    _findDetailRowFromEnd: function () {
      var model = this.collection.at(this.accFocusedCell.row);
      var detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);

      if (detailRowsInfo.views.length > 0) {
        // if there is no index in detail rows set but detail rows are available set it to the last
        if (detailRowsInfo.accFocusedViewIndex === undefined) {
          detailRowsInfo.accFocusedViewIndex = detailRowsInfo.views.length - 1;
        }

        while (true) {
          var view = detailRowsInfo.views[detailRowsInfo.accFocusedViewIndex];
          if (view.$el.is(':visible')) {
            // current detail row is visible
            var currentlyFocusedElement = view.currentlyFocusedElement();
            // current detail row is visible AND has an element to focus
            if (currentlyFocusedElement.length > 0) {
              break;  // stop loop
            }
          }

          if (detailRowsInfo.accFocusedViewIndex > 0) {
            // there is still a detail row above the current: -> set focus to detail row above
            detailRowsInfo.accFocusedViewIndex--;
          } else {
            // current detail row is already to first: -> delete index, which means to use main row
            delete detailRowsInfo.accFocusedViewIndex;
            break;  // stop loop
          }
        }
      }
    },

    onKeyInView: function (event) {
      var model, detailRowsInfo;
      var focusedElement = $();

      // if there is an inline form opened, don't handle keystrokes here
      if (this._getActiveInlineForm()) {
        return;
      }
      if (event.keyCode === 37) {
        // left arrow
        while (this.accFocusedCell.column > 0) {
          this.accFocusedCell.column--;
          if (this._isCurrentBodyCellFocusable()) {
            break;
          }
        }
        event.preventDefault();
        event.stopPropagation();
        this.trigger('closeOtherControls'); // force inline bar to close
        this._accSetFocusAfterTabableRegionActivated();
      } else {
        if (event.keyCode === 38) {
          // up arrow

          event.preventDefault();
          event.stopPropagation();
          this.trigger('closeOtherControls'); // force inline bar to close

          model = this.collection.at(this.accFocusedCell.row);
          detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);
          if (detailRowsInfo.accFocusedViewIndex === undefined) {
            // main row is currently focused

            if (this.accFocusedCell.row > 0) {
              this.accFocusedCell.row--;  // move focus into previous main row or it's detail rows
              // try to find a detail row that that belongs to the current main row to set the focus
              this._findDetailRowFromEnd();
            } else {
              return; // can't move focus upwards anymore -> ignore the key
            }
          } else {
            if (detailRowsInfo.accFocusedViewIndex > 0) {
              detailRowsInfo.accFocusedViewIndex--;
              // try to find a detail row that that belongs to the current main row to set the focus
              this._findDetailRowFromEnd();
            } else {
              // current detail row is already the first: delete index, which means to use main row
              delete detailRowsInfo.accFocusedViewIndex;
            }
          }

          this._accSetFocusAfterTabableRegionActivated();
        } else {
          if (event.keyCode === 39) {
            // right arrow
            while (this.accFocusedCell.column < this.displayedColumns.length - 1) {
              this.accFocusedCell.column++;
              if (this._isCurrentBodyCellFocusable()) {
                break;
              }
            }
            event.preventDefault();
            event.stopPropagation();
            this.trigger('closeOtherControls'); // force inline bar to close
            this._accSetFocusAfterTabableRegionActivated();
          } else {
            if (event.keyCode === 40) {
              // down arrow

              model = this.collection.at(this.accFocusedCell.row);
              detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);
              var detailLastFocusedView = detailRowsInfo.accFocusedViewIndex;
              if (detailRowsInfo.accFocusedViewIndex === undefined &&
                  detailRowsInfo.views.length > 0) {
                // there are detail rows, but none had the focus

                // start at top detail row view (will be incremented to 0 later)
                detailRowsInfo.accFocusedViewIndex = -1;
              }
              while (focusedElement.length === 0) {
                if (detailRowsInfo.accFocusedViewIndex !== undefined &&
                    (detailRowsInfo.accFocusedViewIndex + 1) < detailRowsInfo.views.length) {
                  // already have focus in one detail row -> try to move to next

                  detailRowsInfo.accFocusedViewIndex = detailRowsInfo.accFocusedViewIndex + 1;
                } else {
                  // it's no more possible to move down inside the detail rows -> move to next
                  // main row
                  if ((this.accFocusedCell.row + 1) < this.collection.length) {  // still more rows downwards
                    delete detailRowsInfo.accFocusedViewIndex;
                    this.accFocusedCell.row++;
                    model = this.collection.at(this.accFocusedCell.row);
                    if (model) {
                      detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);
                    }
                  } else {
                    // leave it as it is, because it's not possible to move more downwards
                    detailRowsInfo.accFocusedViewIndex = detailLastFocusedView;
                    break;
                  }
                }
                focusedElement = this.currentlyFocusedElement();
              }

              event.preventDefault();
              event.stopPropagation();
              this.trigger('closeOtherControls'); // force inline bar to close
              this._accSetFocusAfterTabableRegionActivated();
            } else {
              if (event.keyCode === 33) {
                // Page Up Key > goto first row
                this.accFocusedCell.row = 0;
                model = this.collection.at(this.accFocusedCell.row);
                detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);
                delete detailRowsInfo.accFocusedViewIndex;  // main row in every case

                event.preventDefault();
                event.stopPropagation();
                this.trigger('closeOtherControls'); // force inline bar to close
                this._accSetFocusAfterTabableRegionActivated();
              } else {
                if (event.keyCode === 34) {
                  // Page Down Key > goto last row
                  if (this.collection.length > 0) {
                    this.accFocusedCell.row = this.collection.length - 1;
                    model = this.collection.at(this.accFocusedCell.row);
                    detailRowsInfo = _accGetDetailRowInfo.call(this.tableView, model);
                    delete detailRowsInfo.accFocusedViewIndex;
                    this._findDetailRowFromEnd(); // goto lowest detail row if possible
                  } else {
                    this.accFocusedCell.row = 0;
                  }
                  event.preventDefault();
                  event.stopPropagation();
                  this.trigger('closeOtherControls'); // force inline bar to close
                  this._accSetFocusAfterTabableRegionActivated();
                } else {
                  if (event.keyCode === 35) {
                    // END key > goto rightmost column
                    this.accFocusedCell.column = this.displayedColumns.length - 1;
                    event.preventDefault();
                    event.stopPropagation();
                    this.trigger('closeOtherControls'); // force inline bar to close
                    this._accSetFocusAfterTabableRegionActivated();
                  } else {
                    if (event.keyCode === 36) {
                      // POS1 key > goto first column
                      this.accFocusedCell.column = 0;
                      event.preventDefault();
                      event.stopPropagation();
                      this.trigger('closeOtherControls'); // force inline bar to close
                      this._accSetFocusAfterTabableRegionActivated();
                    } else {
                      if (event.keyCode === 113) {
                        // F2
                        model = this.collection.at(this.accFocusedCell.row);
                        if (model) {
                          this.startInlineFormForEdit(model);
                        }
                        event.preventDefault();
                        event.stopPropagation();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },

    descriptionRowFocus: function (event) {
      $(event.target).find(".description-readmore, .description-showless").focus();
    },

    _accSetFocusAfterTabableRegionActivated: function () {
      if (this._getActiveInlineForm()) {
        // don't set focus when inline form is active
        return;
      }
      var tdEl = this.currentlyFocusedElement();
      if (tdEl.length > 0) {
        var el = $(tdEl);
        this.trigger('changed:focus', this);
        if (this._isVisible(el)) {
          el.focus();
        }
      }
    },

    _isVisible: function (el) {
      return $(el).is(':visible');
    },

    _isCurrentBodyCellFocusable: function() {
      var column = this.displayedColumns[this.accFocusedCell.column];
      return !(column.name === 'description' && !this.hasCustomDescriptionColumn);
    }
  }, {
    getNameColumnIndex: function (displayedColumns) {
      if (!displayedColumns) {
        // skip rest of function if no columns are displayed
        return undefined;
      }

      for (var colIdx = 0; colIdx < displayedColumns.length; colIdx++) {
        var column = displayedColumns[colIdx];
        if (column.isNaming) {
          return colIdx;
        }
      }
      return undefined;
    }
  });

  function _accGetDetailRowInfo(model) {
    var detailRowInfo;
    if (model) {
      detailRowInfo = this._detailRowViewsByModelId[model.id || model.get('id')];
    }
    if (!detailRowInfo) {
      return {views: []}; // return always a valid object
    } else {
      return detailRowInfo;
    }
  }

  return TableBodyView;
});


csui.define('css!csui/controls/table/impl/table',[],function(){});
csui.define('csui/controls/table/table.view',[
  "csui/lib/jquery", "csui/lib/underscore", "csui/lib/backbone", "csui/lib/marionette",
  "csui/lib/jquery.dataTables.bootstrap/js/dataTables.bootstrap",
  "csui/lib/jquery.dataTables.tableTools/js/dataTables.tableTools",
  'i18n!csui/controls/table/impl/nls/lang', "csui/utils/log", "csui/utils/base",
  'csui/utils/focusable',
  "csui/controls/tile/behaviors/perfect.scrolling.behavior",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  "csui/controls/table/cells/cell.factory",
  "csui/models/nodechildrencolumn",
  "csui/controls/progressblocker/blocker",
  'csui/utils/contexts/factories/connector',
  'csui/behaviors/default.action/impl/defaultaction',
  'csui/controls/checkbox/checkbox.view',
  'csui/controls/table/cells/select/select.view',
  'csui/controls/table/cells/searchbox/searchbox.view',
  'csui/controls/table/inlineforms/inlineform.factory',
  'csui/controls/table/rows/metadata/metadatarow.view',
  'csui/controls/table/rows/error/errorrow.view',
  'csui/controls/table/impl/table.header.view',
  'csui/controls/table/impl/table.body.view',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/controls/toolbar/toolitems.filtered.model',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/controls/mixins/global.alert/global.alert.mixin',
  'csui/models/mixins/v2.fields/v2.fields.mixin',
  'i18n!csui/controls/table/cells/toggledetails/impl/nls/lang',
  "css!csui/controls/table/impl/table",
  'csui/lib/perfect-scrollbar', 'csui/lib/jquery.mousehover',
  'csui/lib/jquery.scrollbarwidth', 'csui/lib/jquery.renametag'
], function ($, _, Backbone, Marionette, DataTables, TableTools,
    lang, log, base,
    focusable,
    PerfectScrollingBehavior,
    TabableRegionBehavior,
    cellViewFactory,
    NodeChildrenColumnModel,
    BlockingView,
    ConnectorFactory,
    DefaultActionController,
    CheckboxView,
    SelectCellView,
    SearchBoxView,
    inlineFormViewFactory,
    MetadataRowView,
    ErrorRowView,
    TableHeaderView,
    TableBodyView,
    ViewEventsPropagationMixin,
    FilteredToolItemsCollection,
    ToolbarCommandController,
    GlobalAlertMixin,
    FieldsV2Mixin,
    toggleDetailsLang) {
  'use strict';

  var accessibleTable = /\baccessibleTable\b(?:=([^&]*)?)?/i.exec(location.search);
  accessibleTable = accessibleTable && accessibleTable[1] !== 'false';

  var TableView = Marionette.View.extend({

    constructor: function TableView(options) {
      this.accFocusedState = {focusView: 'tableBody', headerColumn: 0, body: {column: 0, row: 0}};
      options || (options = {});
      this.context = options.context;

      this.expandedDetailRows = {};
      this._showEmptyViewText = true;

      this.columnHeadersVisible = true;
      this.columnsWithSearch = options.columnsWithSearch || [];
      _.each(this.columnsWithSearch, _.bind(function (c, i) {
        this.columnsWithSearch[i] = this.columnsWithSearch[i].toLowerCase();
      }, this));
      this.searchBoxes = [];
      if (options.filterBy) {
        _.each(options.filterBy, _.bind(function (val, key) {
          if (options.collection.filters) {
            options.collection.filters[key] = val;
          }
        }, this));
      }
      if (options.actionItems && options.commands) {
        this.defaultActionController = new DefaultActionController({
          actionItems: options.actionItems,
          commands: options.commands
        });
        this.checkModelHasAction = this.defaultActionController.hasAction.bind(
            this.defaultActionController);
      } else {
        // this is the fallback for TableView usages where no commands and actionItems are
        // passed in the options to the table.view -> never set table row items inactive
        this.checkModelHasAction = function () {
          return true;
        };
      }

      this.additionalColumns = options.additionalColumns || [];

      // The collection should be passed to the parent constructor because events
      // may be attached to it by some views
      if (!options.collection) {
        throw new Error("table.view options require a collection to be set");
      }

      Marionette.View.prototype.constructor.apply(this, arguments); // apply (modified) options to this

      _.defaults(this.options, {
        orderBy: "name asc",
        enableSorting: true,
        selectColumn: true,
        haveToggleAllDetailsRows: true,
        haveDetailsRowExpandCollapseColumn: true,
        selectRows: "multiple",
        selectAllColumnHeader: true,
        nameEdit: true,
        maxColumnsDisplayed: 25
      });

      if (accessibleTable) {
        this.options.haveToggleAllDetailsRows = false;
        this.options.haveDetailsRowExpandCollapseColumn = false;
      }

      // must set order before collection is initially fetched to prevent fetching again
      this.collection.setOrder(this.options.orderBy, false);
      delete this.options.orderBy;  // from now on, use the order stored with the collection

      if (this.options.blockingParentView) {
        BlockingView.delegate(this, this.options.blockingParentView);
      } else {
        BlockingView.imbue(this);
      }

      this.connector = this.options.connector;
      if (!this.connector) {
        this.connector = this.context.getObject(ConnectorFactory);
      }

      this.columns = this.options.columns;
      if (!this.columns) {
        this.columns = this.collection.columns;
        if (!this.columns) {
          throw new Error("table.view options require columns or collection.columns to be set");
        }
      }

      this._ViewCollection = Backbone.Collection.extend({
        model: this.collection.model
      });

      this.selectedChildren = new this._ViewCollection();

      // @deprecated
      this.listenTo(this.selectedChildren, 'reset', function () {
        this._showOrHideAlternativeHeaderView();
      });

      this.listenTo(this.collection, "reset", this._handleModelsReset)
          .listenTo(this.collection, "update", this._handleModelsUpdate)
          .listenTo(this.collection, "remove", this._handleModelRemove)
          .listenTo(this.collection, "change", this.updateRow)
          .listenTo(this.collection, "request", this.blockActions)
          .listenTo(this.collection, "sync", this.unblockActions)
          .listenTo(this.collection, "sync", this._handlePendingFilter)
          .listenTo(this.collection, 'new:page', this.resetScrollToTop)
          .listenTo(this.collection, "reset", this._updateSelectedChildren)
          .listenTo(this.collection, "remove", this._updateSelectedChildren)
          // Destroying a node does not send sync, but destroy event
          .listenTo(this.collection, "destroy", this.unblockActions)
          .listenTo(this.collection, "error", this.unblockActions)
          .listenTo(this.columns, 'reset', this._handleColumnsReset);

      if (this.options.tableColumns) {
        this.listenTo(this.options.tableColumns, 'reset update', this._handleTableColumnsReset);
      }

      if (this.context) {
        this.listenTo(this.context, 'request', this._handleContextRequest)
            .listenTo(this.context, 'sync error', this._handleContextFinish)
            .listenTo(this.context, 'sync', this._handleContextSync);
      }

      this.listenTo(this.collection, "reset", function () {
        if (!this._isRendered) {
          return;
        }
        // This event handler can be triggered from outside. Guard it against the
        // case, when the table was not rendered, because there were no columns.
        if (!this.table) {
          return;
        }
        updateSelectAllCheckbox.call(this);
      });

      this.listenTo(this.collection, "reset", this.setFocusToFirstRow)
          .listenTo(this.collection, "add", this.setFocusToFirstRow)
          .listenTo(this.collection, "remove", this.setFocusToFirstRow)
          .listenTo(this.collection, "destroy", this.setFocusToFirstRow);

      // If the collection has been fetched before passing it to the view
      // and the operation is still ongoing, turn on the blocking view right
      // away and wait for the finishing event to turn it off
      if (this.collection.fetching) {
        this.blockActions();
        this.disableEmptyViewText();
      }

      this.disableEmptyViewText();  // switch empty text off initially

      this.listenTo(this, 'dom:refresh', this._onDomRefresh);

      this.listenTo(this, "clickDefaultPreAction", function (event) {
        this.triggerMethod('execute:defaultAction', event.node);
      });
      if (this.collection.node) {
        this.listenTo(this.collection.node, "change:id", this.setFocusToFirstRow);
        this.listenTo(this.collection.node, "change:id", this._clearSearchBoxes);
        this.listenTo(this.collection.node, "change:id", this._clearExpandedRows);
        this.listenTo(this.collection.node, "change:id", function () {
          //  this.selectedChildren.reset([]);  // todo check if needed (drilldown resets collection?
        });
      }

      var tableView = this;
      $(window).bind("resize.tableview", _.debounce(function () {
        tableView.triggerMethod('dom:refresh');
      }, 200));

      if (this.options.inlineBar) {
        this._setInlineBarEvents();
      }
      this.prepareForGlobalAlert();
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: 'tbody',
        suppressScrollX: true
      },
      TabableRegion: {
        behaviorClass: TabableRegionBehavior,
        initialActivationWeight: 100
      }
    },

    events: {"keydown": "onKeyInView"},

    destroy: function () {
      $(window).unbind("resize.tableview");
      destroyTable.call(this);
      return Marionette.View.prototype.destroy.apply(this, arguments);
    },

    enableEmptyViewText: function () {
      this._showEmptyViewText = true;
    },

    disableEmptyViewText: function () {
      this._showEmptyViewText = false;
    },

    _updateSelectedChildren: function (model) {
      if (!this._isRendered) {
        return;
      }
      if (this.deletingNodes) {
        return;
      }
      // This event handler can be triggered from outside. Guard it against the
      // case, when the table was not rendered, because there were no columns.
      if (!this.table) {
        return;
      }
      var tt = getTableTools.call(this);
      var selectedChildren = this.getSelectedChildren();
      this.selectedChildren.reset(selectedChildren);
      _.each(this.selectedChildren.models, function (model) {
        var idx    = this.collection.indexOf(model),
            trNode = this.table.row(idx).node();
        if (trNode && model.get(SelectCellView.isSelectedModelAttributeName) &&
            tt.fnIsSelected(trNode) === false) {
          tt.fnSelect(trNode); // trigger the 'tableRowSelected' to refresh toolbars
        }
      }, this);
    },

    _setInlineBarEvents: function () {
      this.listenTo(this, 'closeOther', this._inlineBarShouldDestroy);
      if (this.options.inlineBar.options.forceInlineBarOnClick) {
        this.listenTo(this, 'row:clicked', function (args) {
          if (this.inlineBarView) {
            var oldModelId = this.inlineBarView.model.get('id');
            var newModelId = args.node.get('id');
            if (oldModelId === newModelId) {
              return;
            }
          }
          if (this.options.inlineBar.viewClass) {
            this._destroyOldAndCreateNewInlineBarWithoutDelay(args);
          }
        });
      } else {
        if (this.options.inlineBar.options.showInlineBarOnHover) {
          this.listenTo(this, 'enterTableRow', this._destroyOldAndCreateNewInlineBarWithDelay);
          this.listenTo(this, 'leaveTableRow', this._inlineBarShouldDestroy);
        }
      }
      this.listenTo(this.collection, "reset", this._destroyInlineBar);
      if (this.collection.node) {
        this.listenTo(this.collection.node, 'change:id', this._destroyInlineBar);
      }
    },

    _showInlineBar: function (args) {
      var selectedItems = this.getSelectedChildren();
      if (selectedItems.length > 0) {
        // no inline bar if items are selected by checkbox
        return;
      }
      if (this.inlineBarView) {
        this._savedHoverEnterArgs = args;
        // ignore until inline bar removed itself
      } else {
        this._savedHoverEnterArgs = null;

        this.inlineBarView = new this.options.inlineBar.viewClass(_.extend({
              context: this.options.context,
              originatingView: this.options.originatingView,
              commands: this.defaultActionController.commands,
              model: args.node
            }, this.options.inlineBar.options)
        );
        this.listenToOnce(this.inlineBarView, 'destroy', function () {
          //Even though we are listening to tableActionBar 'destroy' even once, that event listener is not
          //being removed after the fact. To ensure memory cleanup, the event listener if forcibly removed.
          if (this.inlineBarView) {
            this.stopListening(this.inlineBarView);
          }
          if (this._savedHoverEnterArgs) {
            this._destroyOldAndCreateNewInlineBarWithDelay(this._savedHoverEnterArgs);
          }
        }, this);

        var nameCell = this.getNameCell(args.target);
        if (nameCell && nameCell.length === 1) {
          var inlineBarDiv = nameCell.find('.csui-table-cell-name-appendix');
          var inlineBarRegion = new Marionette.Region({el: inlineBarDiv});
          inlineBarRegion.show(this.inlineBarView);

          if (this.inlineBarView.$el.parent().length > 0) { // action bar has no actions to show
            inlineBarDiv.addClass('csui-table-cell-name-appendix-full');
          }
          nameCell.addClass('csui-table-actionbar-shown');
        }
      }
    },

    _destroyOldAndCreateNewInlineBarWithDelay: function (args) {
      this._inlineBarShouldDestroy();
      if (this._showInlineBarTimeout) {
        clearTimeout(this._showInlineBarTimeout);
      }
      var self = this;
      this._showInlineBarTimeout = setTimeout(function () {
        self._showInlineBarTimeout = null;
        if (!self.lockedForOtherContols) {
          // don't show the inline bar control if the table view is locked because a different
          // control is already open
          self._showInlineBar.call(self, args);
        }
      }, 200);
    },

    _inlineBarShouldDestroy: function () {
      if (this._showInlineBarTimeout) {
        clearTimeout(this._showInlineBarTimeout);
        this._showInlineBarTimeout = null;
      }
      this._destroyInlineBar();
    },

    _destroyOldAndCreateNewInlineBarWithoutDelay: function (args) {
      this._inlineBarShouldDestroy();
      if (!this.lockedForOtherContols) {
        // don't show the inline bar control if the table view is locked because a different
        // control is already open
        this._showInlineBar.call(this, args);
      }
    },

    _destroyInlineBar: function () {
      if (this.inlineBarView) {
        var inlineBarEl = this.inlineBarView.$el.parent();
        inlineBarEl.removeClass('csui-table-cell-name-appendix-full');
        inlineBarEl.closest('.csui-table-actionbar-shown').removeClass(
            'csui-table-actionbar-shown');
        this.inlineBarView.destroy();
        this.inlineBarView = null;
      }
    },

    _clearExpandedRows: function () {
      if (!this._isRendered) {
        return;
      }
      this.expandedDetailRows = {};
    },

    _adjustColumnsAfterWindowResize: function () {
      if (accessibleTable) {
        return;
      }

      if (!this.columns.length) {
        // prevent column width computations if there are no columns
        return;
      }
      var doAdjustColumns = true;
      if (this.$el.is(':visible')) {
        var maxColumns = calculateMaxColumnsDisplayed.call(this);
        // console.log("this.maxColumnsDisplayed: " + this.maxColumnsDisplayed + ", maxcolumns: " +
        //             maxColumns);
        if (maxColumns && maxColumns !== this.maxColumnsDisplayed) {
          // DataTables trigger the callbacks before the DataTables()
          // initializer returns.  During the rendering, the column
          // width computation may trigger another table re-creation,
          // because some columns need to be wrapped.  This another
          // re-creation should happen first after the current one is
          // finished.  Switch the context here to allow it.
          this.maxColumnsDisplayed = maxColumns;
          if (!this._rebuildingTable) {
            doAdjustColumns = false;
            return setTimeout(_.bind(this.rebuild, this));
          }
        }
      }
      if (doAdjustColumns) {
        this._adjustColumns();
      }

      // If column widths were adjusted without wrapping,
      // make the table visible
      this.$el.removeClass('csui-not-ready');
    },

    onKeyInView: function (event) {
      if (event.keyCode === 9) {
        if (this.activeInlineForm) {
          event.preventDefault();
          event.stopPropagation();
          // don't set focus to other elements when inline form is active
          return;
        }

        if (event.shiftKey) {
          // shift tab -> put focus into table header view if in body
          if (this.accFocusedState.focusView === 'tableBody') {
            event.preventDefault();
            event.stopPropagation();

            this.accFocusedState.focusView = 'tableHeader';
            this.trigger('changed:focus');
            this.currentlyFocusedElement().focus();
          }
        } else {
          // TAB (NO shift) -> put focus into table body view if in header
          if (this.accFocusedState.focusView === 'tableHeader') {
            event.preventDefault();
            event.stopPropagation();

            this.accFocusedState.focusView = 'tableBody';
            this.trigger('changed:focus');
            this.currentlyFocusedElement().focus();
          }
        }
      }
    },

    currentlyFocusedElement: function () {
      // delegate the call either to the table header or table body view
      if (this.accFocusedState.focusView === 'tableHeader') {
        if (this.tableCaptionView) {
          return this.tableCaptionView.currentlyFocusedElement();
        }
      } else {
        if (this.tableBodyView) {
          return this.tableBodyView.currentlyFocusedElement();
        }
      }
    },

    setFocusToFirstRow: function () {
      if (!this._isRendered) {
        return;
      }
      this.accFocusedState.body.row = 0;
      this.accFocusedState.body.column = TableBodyView.getNameColumnIndex(this.displayedColumns) ||
                                         0;
    },

    renderError: function () {
      // If the error came very early and there is no table rendered
      // yet, show the error message at the place of the widget.
      // If the table is there, the error came from an additional
      // operation and the dialog shown by the caller should be enough;
      // we will let the user to use the table again.
      if (!this.table) {
        cleanPlaceholder.call(this);
        $("<div></div>", {id: "message"}).html(base.MessageHelper.toHtml()).appendTo(this.$el);
      }
    },

    rebuild: function () {
      if (this._rebuildingTable) {
        throw new Error("Rebuild called recursively");
      }
      this._rebuildingTable = true;

      this.$el.addClass("csui-nodetable");
      if (this.table) {
        // State saving method in DataTables works only if it is
        // turned on as a feature storing the state in a cookie.
        saveStateBeforeRebuild.call(this);
        destroyTable.call(this);
      }

      this.triggerMethod('before:render', this);
      createTable.call(this);

      // If there are no columns available, there will be no table.
      if (this.table) {
        this.accFocusedState.body.row = 0;
        this.accFocusedState.body.column = TableBodyView.getNameColumnIndex(
            this.displayedColumns) || 0;
      } else {
        this.accFocusedState.body.row = this.accFocusedState.body.column = 0;
      }

      this.showOrHideZeroRecordsMessage();

      this.triggerMethod('render', this);
      this._rebuildingTable = false;
    },

    _plugHeaderBodyViews: function () {
      // log.debug("############### _plugHeaderBodyViews") && console.log(log.last);
      var self = this;

      this.tableCaptionView = new TableHeaderView({
        el: this.$('thead'),
        displayedColumns: this.displayedColumns,
        searchBoxes: this.searchBoxes,
        _getActiveInlineForm: _.bind(function () {
          return this.activeInlineForm;
        }, this),
        accFocusedColumn: this.accFocusedState.headerColumn,
        accSearchFocused: this.accFocusedState.accSearchFocused
      });

      this.propagateEventsToViews(this.tableCaptionView);

      this.tableCaptionView.listenTo(this.tableCaptionView, 'closeOtherControls', function () {
        self.trigger('closeOther');
      });
      this.tableCaptionView.listenTo(this.tableCaptionView, 'sorting:toggle',
          function (columnIndex) {
            if (self.displayedColumns[columnIndex].bSortable) {

              // toggle search direction if column already sorted before or set to asc sorting otherwise
              var direction = 'asc';
              var currentOrder = self.table.order();
              if (_.isArray(currentOrder) && currentOrder.length > 0) {
                var sortedColumnIndex = currentOrder[0][0];
                var sortedColumnSortDirection = currentOrder[0][1];
                if (sortedColumnIndex === columnIndex &&
                    sortedColumnSortDirection === direction) {
                  direction = 'desc';
                }
              }
              self.table.order([columnIndex, direction]).draw();
            }
          });
      this.tableCaptionView.listenTo(this.tableCaptionView, 'changed:focus', function () {
        self.accFocusedState.focusView = 'tableHeader';
        self.trigger('changed:focus');
      });
      this.tableCaptionView.render();
      Marionette.triggerMethodOn(this.tableCaptionView, 'before:show');
      Marionette.triggerMethodOn(this.tableCaptionView, 'show');

      this.tableBodyView = new TableBodyView({
        el: this.$('tbody'),
        collection: this.collection,
        displayedColumns: this.displayedColumns,
        _getActiveInlineForm: _.bind(function () {
          return this.activeInlineForm;
        }, this),
        startInlineFormForEdit: _.bind(this.startInlineFormForEdit, this),
        accFocusedCell: this.accFocusedState.body,
        tableView: this
      });
      this.propagateEventsToViews(this.tableBodyView);

      this.tableBodyView.listenTo(this.tableBodyView, 'closeOtherControls', function () {
        self.trigger('closeOther');
      });
      this.tableBodyView.listenTo(this.tableBodyView, 'changed:focus', function () {
        self.accFocusedState.focusView = 'tableBody';
        self.trigger('changed:focus');
      });

      this.tableBodyView.render();
      Marionette.triggerMethodOn(this.tableBodyView, 'before:show');
      this.tableBodyView.triggerMethod('show');
    },

    _destroyTableHeaderAndBodyViews: function () {
      // log.debug("########## _destroyTableHeaderAndBodyViews") && console.log(log.last);
      if (this.tableCaptionView) {
        // log.debug("_destroyTableHeaderAndBodyViews destroying table header view") &&
        // console.log(log.last);
        this.accFocusedState.headerColumn = this.tableCaptionView.accFocusedColumn;
        this.accFocusedState.accSearchFocused = this.tableCaptionView.accSearchFocused;
        this.tableCaptionView.destroy();
        this.tableCaptionView = null;
      }
      if (this.tableBodyView) {
        // log.debug("_destroyTableHeaderAndBodyViews destroying table body view") &&
        // console.log(log.last);

        // no need to copy back the body object - objects are passed by reference
        // this.accFocusedState.body = this.tableBodyView.accFocusedCell;
        this.tableBodyView.destroy();
        this.tableBodyView = null;
      }
    },

    render: function () {
      this._ensureViewIsIntact();

      this.$el.addClass("csui-nodetable");

      this.triggerMethod('before:render', this);

      cleanUpTableEventListeners.call(this);
      if (!this.table) {
        createTable.call(this);
      } else {
        this.table.draw();
      }

      this.showOrHideZeroRecordsMessage();

      this.triggerMethod('render', this);

      return this;
    },

    // params:
    // - state <boolean> : true/false
    setDeletingNodesState: function (state) {
      this.deletingNodes = state;
    },

    _handleContextRequest: function () {
      this._fetchingContext = true;
      this._columnsReset = false;
      this._collectionReset = false;
    },

    _handleContextSync: function () {
      if (!this._isRendered) {
        return;
      }
      if (this._columnsReset) {
        this.rebuild();
      } else if (this._collectionReset) {
        this.render();
      }
    },

    _handleContextFinish: function () {
      this._fetchingContext = false;
    },

    _handleTableColumnsReset: function () {
      if (!this._isRendered) {
        return;
      }
      if (this._fetchingContext) {
        this._columnsReset = true;
      } else {
        this.rebuild();
      }
    },

    _handleColumnsReset: function () {
      if (!this._isRendered) {
        return;
      }
      if (this._fetchingContext) {
        this._columnsReset = true;
      } else {
        this.rebuild();
      }
    },

    _handleModelsReset: function () {
      if (!this._isRendered) {
        return;
      }
      this.enableEmptyViewText();
      if (this._fetchingContext) {
        this._collectionReset = true;
      } else {
        this.render();
      }
    },

    _handleModelsUpdate: function (collection, options) {
      if (!this._isRendered) {
        return;
      }
      var models = options.changes.added;
      if (models.length > 0 && this.table) {

        _.each(models, function (model) {
          model.unset(SelectCellView.isSelectedModelAttributeName);
        });
        // todo: try to replace the call to render() by adding the additional rows directly to
        // the table and to call draw afterwards. Note, that view events must be triggered in
        // this case too.

        // _.each(models, function (model) {
        //   this.table.row.add(model);
        // }, this);
      }
      this.render();  // this calls rebuild, which then restores the scroll position
    },

    _handleModelRemove: function (model) {
      if (!this._isRendered) {
        return;
      }
      // For performance: hide the deleted row during deletion of many nodes to show progress.
      // It is the most optimal way to show UI progress without calling expensive TableView and
      // DataTables methods that would do many table cells construction and rows rendering to end
      // up with the same UI behavior that is seen by the user.
      // Note: at the end of the Delete command, the collection will be refetched and the TableView
      // will be re-rendered to reflect the actual collection.
      if (this.deletingNodes === true) {
        if (model) {
          var targetIdx;
          this.table.rows(function (idx, data, node) {
            if (data.get('id') === model.get('id')) {
              targetIdx = idx;
              return true;
            } else {
              return false;
            }
          }).data();

          if (targetIdx !== undefined) {
            $(this.$el.find(this.table.row(targetIdx).node())).hide();
          }
        }
      } else {
        // Original code that renders the table on each collection's model 'remove' event.
        // If any other code places remove model(s) from the collection, the TableView behaves
        // correctly as before.
        this.render();
      }
    },

    // set the updated model in the table and let it redraw
    updateRow: function (model) {
      if (!this._isRendered) {
        return;
      }
      var idx = this.collection.indexOf(model);
      if (this.childWithBlockingView) {
        this.childWithBlockingView.updateRowIndex = idx;
      }
      if (idx === undefined) {
        return; // don't update if model can't be found in the collection (caller mistake)
      }

      if (this.table) {
        var $row = $(this.table.row(idx).node());
        var detailRows = this.table.row(idx).child();

        if (_.keys(model.changed).length === 1 &&
            model.changed[SelectCellView.isSelectedModelAttributeName] != null) {
          var isSelected = model.get(SelectCellView.isSelectedModelAttributeName);
          if (isSelected) {
            $row.addClass('binf-active');
            _.each(detailRows, function (detailRow) {
              $(detailRow).addClass('binf-active');
            });
          } else {
            $row.removeClass('binf-active');
            _.each(detailRows, function (detailRow) {
              $(detailRow).removeClass('binf-active');
            });
          }
        }

        // for D2 Smart UI, fade out when the model is Cut
        if (model.get('isCut') === true) {
          $row && $row.addClass('csui-cut-row');
          detailRows && detailRows.addClass('csui-cut-row');
        } else {
          $row && $row.removeClass('csui-cut-row');
          detailRows && detailRows.removeClass('csui-cut-row');
        }
      }

      if (_.keys(model.changed).length === 1 &&
          (model.changed[SelectCellView.isSelectedModelAttributeName] != null ||
           model.changed.csuiDelayedActionsRetrieved != null)) {
        return;
      }
      //account for a new attribute being added or changed for node before the
      //table is drawn.
      if (this.table) {

        if (this.activeInlineForm && this.activeInlineForm.model !== model) {
          this.cancelAnyExistingInlineForm({silent: true});
        }

        // save scroll position for restoring it after render
        var currentScollPosition = this.$('tbody').scrollTop();

        this.triggerMethod('before:render');
        this.table.row(idx).invalidate();
        // this.render(); // redraw table
        this.table.draw();

        // restore scroll position after render
        this.$('tbody').scrollTop(currentScollPosition);
        this.triggerMethod('render');

        // if someone listens for the render event (which is triggered by table.draw from above)
        // and calls destroy to the table.view then this.table is no more valid
        if (!this.table) {
          return;
        }

        // re-select the row if the model still has the marker but table tools lost the selection

        getTableTools.call(this);

        this._updateSelectedChildren(model);

        if (this.activeInlineForm) {
          this.activeInlineForm.triggerMethod('dom:refresh', this.activeInlineForm);
        }

        // when the row is newly drawn the widths of the tds in this row must be set again to
        // have it the same as the th elements
        this._adjustColumns();  // recalculate column widths after redrawing table
      }
    },

    _onDomRefresh: function () {
      if (this.$el.parent().length > 0) {
        var displayStyle = this.$el.parent().css('display');
        if (displayStyle.indexOf('flex') < 0) {
          this.$el.addClass("csui-not-in-flex-container");
        }
      }
      if (this.$el.is(':visible')) {
        // inline from lost focus on name field if this dom:refresh is triggered too early
        // triggers dom:refresh on activeInlineForm after the table rebuild() above
        if (this.activeInlineForm) {
          this.activeInlineForm.triggerMethod('dom:refresh', this.activeInlineForm);
        }

        this._adjustColumnsAfterWindowResize();
      }
    },

    // Note: this is not a marionette.js event. It's triggered by the csui dialog view only.
    onAfterShow: function () {
      this._adjustColumnsAfterWindowResize();
    },

    getNameCell: function (nRow) {
      var nameColumnIdx = TableBodyView.getNameColumnIndex(this.displayedColumns);
      if (nameColumnIdx === undefined) {
        // skip rest of function if no columns are displayed
        return undefined;
      }
      var nameCell = $(nRow).children()[nameColumnIdx];
      return $(nameCell);
    },

    // Let cell views influence how much information the collection will fetch
    updateCollectionParameters: function () {
      var collection     = this.collection,
          context        = this.context,
          // Update only collections supporting v2 fields and expands
          supportsFields = collection.makeFieldsV2,
          supportsExpand = collection.makeExpandableV2,
          fields         = {},
          expands        = {};

      if (!this.collection.setFields) {
        // don't do anything for the expands if the collection is "old"
        return;
      }

      // Reset the collection to the original state
      if ((supportsFields || supportsExpand) &&
          collection.getResourceScope && collection.setResourceScope) {
        // Very first rendering meets the collection still with the default scope
        if (this._originalCollectionScope) {
          collection.setResourceScope(this._originalCollectionScope);
        } else {
          this._originalCollectionScope = collection.getResourceScope();
        }
      }
      // Gather fields and expands and perform other custom setup
      _.each(this.allColumns, function (column) {
        var CellView = column.CellView;
        if (CellView) {
          if (supportsFields && CellView.getModelFields) {
            var field = CellView.getModelFields({
              collection: collection,
              context: context,
              column: column
            });
            if (field) {
              FieldsV2Mixin.mergePropertyParameters(fields, field);
            }
          }
          if (supportsExpand && CellView.getModelExpand) {
            var expand = CellView.getModelExpand({
              collection: collection,
              context: context,
              column: column
            });
            if (expand) {
              FieldsV2Mixin.mergePropertyParameters(expands, expand);
            }
          }
          if (CellView.updateCollectionParameters) {
            CellView.updateCollectionParameters({
              collection: collection,
              context: context,
              column: column
            });
          }
        }
      }, this);
      // Apply gathered fields and expands
      if (!_.isEmpty(fields)) {
        collection.setFields(fields);
      }
      if (!_.isEmpty(expands)) {
        collection.setExpand(expands);
      }
    },

    // Is it worth creating a model for the DataTables UI elements so
    // that we could listen to them and modify them? DataTables handles
    // them on its own and calls ajax whenever necessary.

    clearFilter: function (refresh, filter) {
      if (this.table) {
        if (filter && !$.isEmptyObject(this.options.filter)) {
          this.options.filter = _.omit(this.options.filter,
              filter.split(","));
        }
        // TODO: Think up a better integration for name filter placed outside.
        if (this.options.filter) {
          delete this.options.filter.name;
        }

        this.table.search('').columns().search('').draw();
      }
      return this;
    },

    setFilter: function (filter) {
      if (this.table) {
        if ($.isEmptyObject(this.options.filter)) {
          this.options.filter = filter;
        } else {
          this.options.filter = _.extend(this.options.filter, filter);
        }
        this.table.draw();
      }
    },

    resetOrder: function (refresh) {
      this.collection.resetOrder();
      return this;
    },

    //Returns the number of rows that can be seen at once on the screen, not the
    //number of rows scrollable.
    getScreenRowCount: function (filter) {
      var tableTools = this.table && getTableTools.call(this);

      if (tableTools) {
        var jqTable = $('#' + tableTools.dom.table.id);
        var tbodyH = jqTable && jqTable[0].childNodes[1] &&
                     jqTable[0].childNodes[1].clientHeight ||
                     0;
        var rows = jqTable && jqTable.dataTable().$('tbody tr');
        var rowH = rows[0] && rows[0].clientHeight || 0; //make sure at least one so you don't divide by 0'
        return (rowH > 0) ? Math.floor(tbodyH / rowH) : 0;
      }
      return 0;
    },

    getSelectedChildren: function () {
      var crit = {};
      crit[SelectCellView.isSelectedModelAttributeName] = true;
      return this.collection.where(crit);
    },

    clearChildrenSelection: function () {
      var tableTools = this.table && getTableTools.call(this);
      tableTools && tableTools.fnSelectNone();
    },

    getFocusedChild: function () {
      if (this.accFocusedState.body.row) {
        return this.collection.at(this.accFocusedState.body.row);
      } else {
        return undefined;
      }
    },

    cancelFetch: function () {
      if (this.table) {
        this.table.clear();
      }
    },

    showDetailRowDescriptions: function (show) {
      if (this.options.descriptionRowView) {
        // put the new description show/hide state into the descriptionRowViewOptions, which
        // are shared between all descriptionRowView instances
        this.options.descriptionRowViewOptions.showDescriptions = show;
        _.each(this._detailRowsDescriptionTRs, function (description) {
          if (show) {
            description.rowEl.removeClass("binf-hidden");
          } else {
            description.rowEl.addClass("binf-hidden");
          }
          description.view.trigger('dom:refresh');  // let the view adjust due to visibility change
        });
        this.trigger('dom:refresh');  // let the table refresh keyboard navigation
      }
    },

    enableLocationColumn: function (enable) {
      if (this.options.locationColumn !== enable) {
        this.options.locationColumn = enable;
      }
    },

    enableRefresh: function (enabled) {
      this.refreshEnabled = enabled;
    },

    applyFilter: function (data) {
      if (this.options.clientSideDataOperation) {
        // TODO: Deprecate and remove this.  The client-side mixin does not need this.
        // client side filtering
        this.clientSideSearch(data.column);
      } else {
        // server side filtering
        var filterObj = {};
        filterObj[data.column] = data.keywords;
        if (this.collection.fetching) {
          this.filterValuePending = filterObj;
        } else {
          this.collection.resetLimit(false);
          this.collection.setFilter(filterObj);
        }
      }
    },

    cancelAnyExistingInlineForm: function (options) {
      if (this.activeInlineForm) {
        this.activeInlineForm.cancel(options);
      }
    },

    startCreateNewModel: function (newNode, inlineFormView) {
      // cancel any active inline form before starting with a new one
      this.cancelAnyExistingInlineForm();
      if (this.collection && this.collection.node) {
        newNode.set("parent_id", this.collection.node.get('id'));
        newNode.isLocallyCreated = true;
        newNode.inlineFormView = inlineFormView;
        this.collection.add(newNode, {at: 0});
      }
    },

    startInlineFormForEdit: function (model) {
      if (this.collection.contains(model)) {
        // cancel any active inline form before starting with a new one
        this.cancelAnyExistingInlineForm();

        var inlineFormView = inlineFormViewFactory.getInlineFormView(model.get('type'));
        if (!inlineFormView) {
          // fallback to generic for rename action
          inlineFormView = inlineFormViewFactory.getInlineFormView(-1);
        }
        if (inlineFormView) {
          model.inlineFormView = inlineFormView;
          model.set('csuiInlineFormErrorMessage', 'dummy', {silent: true});
          model.unset('csuiInlineFormErrorMessage');
        }
      }
    },

    showOrHideZeroRecordsMessage: function () {
      this.$el.find('div.csui-table-empty').remove();
      if (this.collection.length === 0) {
        // make tbody empty in case our own empty text div is displayed
        this.$el.find('tbody').empty();

        this.$el.addClass("csui-table-empty");
        var emptyTableText = "";
        if (this._showEmptyViewText) {
          emptyTableText = (!!this.collection.filters && this.collection.filters.name ?
                            this.localizableLabels.emptyTable :
                            this.localizableLabels.zeroRecords);
        }
        var emptyEl = $("<div class='csui-table-empty'><p class='csui-no-result-message' title='" +
                        emptyTableText + "'>" + emptyTableText + "</p></div>");
        this.$el.append(emptyEl);
      } else {
        this.$el.removeClass("csui-table-empty");
      }
    },

    setCustomLabels: function (otherLabels) {
      // Support tableTexts for compatibility
      var customLabels = this.getOption('customLabels') ||
                         this.getOption('tableTexts') || {};
      if (_.isFunction(customLabels)) {
        customLabels = customLabels.call(this);
      }
      // Remember the latest custom labels in case the table will be re-rendered
      this.options.customLabels = this._fillDefaultLocalizableLabels(otherLabels, customLabels);

      function mergeCustomLabels(customLabels, oLanguage) {
        return _.reduce(_.keys(customLabels), function (result, labelKey) {
          var customLabel = customLabels[labelKey];
          if (_.isObject(customLabel)) {
            var originalLabels = oLanguage[labelKey] || (oLanguage[labelKey] = {});
            return result || mergeCustomLabels(customLabel, originalLabels);
          }
          var differs = oLanguage[labelKey] != customLabel;
          oLanguage[labelKey] = customLabel;
          return result || differs;
        }, false);
      }

      // If the table has been already rendered, merge the latest
      // custom labels to the object used by the table
      if (this.table) {
        var hungarianLabels = _.deepClone(this.options.customLabels);
        DataTables.camelToHungarian(DataTables.defaults.oLanguage, hungarianLabels);
        var differs = mergeCustomLabels(hungarianLabels, this.table.settings()[0].oLanguage);
        if (differs) {
          this.table.draw();
        }
      }
    },

    _fillDefaultLocalizableLabels: function () {
      var customLabels   = Array.prototype.slice.call(arguments),
          completeLabels = {
            paginate: {},
            aria: {}
          };

      // Merge all objects with custom labels, which were passed in their priority
      _.each(customLabels, function (customLabels) {
        // Support zeroRecordsMsg for compatibility
        if (customLabels.zeroRecordsMsg != null && customLabels.zeroRecords == null) {
          customLabels.zeroRecords = customLabels.zeroRecordsMsg;
          delete customLabels.zeroRecordsMsg;
        }
        _.defaults(completeLabels, customLabels);
        _.defaults(completeLabels.paginate, customLabels.paginate);
        _.defaults(completeLabels.aria, customLabels.aria);
      });

      function removeDefaultingLabels(completeLabels) {
        _.each(_.keys(completeLabels), function (labelKey) {
          var label = completeLabels[labelKey];
          if (_.isObject(label)) {
            removeDefaultingLabels(label);
          } else {
            if (label === false || label === null) {
              delete completeLabels[labelKey];
            }
          }
        });
      }

      // If the default message was requested to remove by `false` or
      // `null`, delete it, so that it gets filled from defaults below
      removeDefaultingLabels(completeLabels);

      // Finally, merge the defaults
      _.defaults(completeLabels, {
        emptyTable: lang.NodeTableNoItems,
        zeroRecords: lang.NodeTableNoItems,
        loadingRecords: lang.NodeTableLoadingItems,
        processing: lang.NodeTableProcessingItems,
        info: lang.NodeTablePageInfo,
        infoEmpty: lang.NodeTableEmptyPageInfo,
        infoFiltered: lang.NodeTableFilteredPageInfo,
        infoThousands: lang.NodeTablePageThousandsSeparator,
        infoPostFix: lang.NodeTablePageInfoSuffix,
        lengthMenu: lang.NodeTablePageSizeSelector,
        search: lang.NodeTablePageFilterLabel
      });
      _.defaults(completeLabels.paginate, {
        first: lang.NodeTablePagingFirst,
        last: lang.NodeTablePagingLast,
        previous: lang.NodeTablePagingPrevious,
        next: lang.NodeTablePagingNext
      });
      _.defaults(completeLabels.aria, {
        sortAscending: lang.NodeTableSortAscending,
        sortDescending: lang.NodeTableSortDescending
      });
      return completeLabels;
    },

    _handlePendingFilter: function () {
      if (!this._isRendered) {
        return;
      }
      if (!_.isEmpty(this.filterValuePending)) {
        this.collection.resetLimit(false);
        this.collection.setFilter(this.filterValuePending);
        this.filterValuePending = {};
      }
    },

    // TODO: Deprecate and remove this.  The client-side mixin does not need this.
    clientSideSearch: function (column) {
      var filterObj = {};
      _.each(this.searchBoxes, function (sb) {
        var col = sb.getColumn();
        var keywords = sb.getValue();
        if (keywords.length) {
          filterObj[col] = keywords;
        }
      });
      this.collection.resetLimit(false);
      this.collection.setFilter(filterObj);
    },

    resetScrollToTop: function () {
      if (!this._isRendered) {
        return;
      }
      var scrollContainer = this.$('tbody');
      scrollContainer.scrollTop(0);
      // if needed: triggerMethod(this, "update:scrollbar");
    },

    _clearSearchBoxes: function () {
      if (!this._isRendered) {
        return;
      }
      _.each(this.searchBoxes, function (sb) {
        sb.hideAndClear();
      });
    },

    _adjustColumns: function () {
      if (accessibleTable) {
        return;
      }

      if (!this.displayedColumns || !this.$el.is(':visible')) {
        // skip rest of function if no columns are displayed or the view is hidden
        // (the width computation does not work if the HTML element is not visible)
        return;
      }

      var tableWidth = this.$el.width();
      if (!PerfectScrollingBehavior.usePerfectScrollbar()) {
        if (this.$el.find('.csui-normal-scrolling').hasScroll()) {
          tableWidth -= $.scrollbarWidth();
        }
      }
      var numberColumnsWithFixedWidth = 0;
      var sumFixedWidth = 0;
      var columnCells;
      var headerCells = this.$el.find('table>thead>tr>th');
      if (this.collection.length > 0 && !this.activeInlineForm) {
        columnCells = this.$el.find('table>tbody>tr:first-child').children();
      } else {
        columnCells = headerCells;
      }

      var widerCellIndexes = {};
      var normalCellIndexes = [];
      var displayedColumns = this.displayedColumns;
      var widthFactorSum                 = 0,
          widestColumnIndex,
          largestWidthFactor             = 0,
          flexibleColumnWidth            = 0,
          numberColumnsWithFlexibleWidth = 0;
      columnCells.each(function (index) {
        if (index < displayedColumns.length) {
          var el          = $(this),
              columnWidth = Math.max(el.outerWidth(), $(headerCells[index]).outerWidth());
          //var classes = getClassesFromElement(el);
          //console.log("Classes: ", classes);

          var column = displayedColumns[index];
          if (column.CellView.hasFixedWidth) {
            // Consider max width between conent and header to consider accommodating search, sort icons
            sumFixedWidth += columnWidth;
            numberColumnsWithFixedWidth++;
          } else {
            var widthFactor = (column.attributes && column.attributes.widthFactor) || 1.0;
            if (widthFactor && widthFactor !== 1.0) {
              widerCellIndexes[index] = widthFactor;
              widthFactorSum += widthFactor;
            } else {
              if (column.CellView && column.CellView.flexibleWidth) {
                // Consider max width between conent and header to consider accommodating search, sort icons
                flexibleColumnWidth += columnWidth;
                numberColumnsWithFlexibleWidth++;
              } else {
                normalCellIndexes.push(index);
                widthFactorSum += 1;
              }

            }
            if (widthFactor > largestWidthFactor) {
              largestWidthFactor = widthFactor;
              widestColumnIndex = index;
            }
          }
        }
      });
      var remainingWidth             = tableWidth - sumFixedWidth - flexibleColumnWidth,
          numberColumnsNonFixedWidth = displayedColumns.length - numberColumnsWithFixedWidth -
                                       numberColumnsWithFlexibleWidth,
          remainingWidthPerCell      = numberColumnsNonFixedWidth > 0 ?
                                       remainingWidth / numberColumnsNonFixedWidth : 0,
          sumWidthOfWideCells        = 0,
          averageWidthFactor         = widthFactorSum / numberColumnsNonFixedWidth;
      _.each(widerCellIndexes, function (widthFactor, columnIndex) {
        var // scale width factors so sum of width factors equals number of columns and the
            // average width factor is 1 again.
            wf = widthFactor / averageWidthFactor,
            w  = remainingWidthPerCell * wf;
        if (sumWidthOfWideCells + w > remainingWidth) {
          w = remainingWidth - sumWidthOfWideCells;
          if (w < 0) {
            w = 0;
          }
        }
        w = Math.floor(w);
        widerCellIndexes[columnIndex] = w;
        sumWidthOfWideCells += w;
      });
      // subtract the sum of wide cells widths and distribute the rest for the remaining cells
      // and as we use full pixels, compute a correction width to apply on the widest element.
      var correctionWidth;
      if (normalCellIndexes.length > 0) {
        remainingWidthPerCell = (remainingWidth - sumWidthOfWideCells) /
                                normalCellIndexes.length / averageWidthFactor;
        remainingWidthPerCell = Math.floor(remainingWidthPerCell);
        correctionWidth = remainingWidth - sumWidthOfWideCells -
                          remainingWidthPerCell * normalCellIndexes.length;
      } else {
        remainingWidthPerCell = 0;
        correctionWidth = remainingWidth - sumWidthOfWideCells;
      }
      correctionWidth = Math.floor(correctionWidth);

      var tbodyEl = this.$el.find('table>tbody');
      var cachedColumnWidths = {};
      columnCells.each(function (index) {
        if (index < displayedColumns.length) {
          var el              = $(this),
              column          = displayedColumns[index],
              colContentWidth = Math.max(el.outerWidth(), $(headerCells[index]).outerWidth());
          var widthStyle = {"width": colContentWidth + "px"};
          if (!column.CellView.hasFixedWidth) {
            var columnWidth;
            if (widerCellIndexes[index] && widerCellIndexes[index] > 0) {
              columnWidth = widerCellIndexes[index];
            } else {
              columnWidth = remainingWidthPerCell;
            }
            if (index === widestColumnIndex && correctionWidth) {
              columnWidth += correctionWidth;
            }
            var px = columnWidth + 'px';

            if (column.CellView.flexibleWidth) {
              $(headerCells[index]).css(widthStyle);
            } else {
              // set width of table header and body cells of the current column
              widthStyle = {"min-width": px, "max-width": px};
              $(headerCells[index]).css(widthStyle);
            }
          }
          var tdCells = tbodyEl.find(
              'tr:not(.csui-details-row)>:not(.csui-inlineform-parent):nth-child(' +
              (index + 1) + ')');
          tdCells.css(widthStyle);
          cachedColumnWidths[column.className] = widthStyle;
        }
      });
      this.cachedColumnWidths = cachedColumnWidths;
      // adjust focused cell if it would be outside
      if (this.accFocusedState.body.column > displayedColumns.length - 1) {
        this.accFocusedState.body.column = displayedColumns.length - 1;
      }

      // @deprecated
      this._showOrHideAlternativeHeaderView();
    },

    // @deprecated
    _showOrHideAlternativeHeaderView: function () {
      if (this._alternativeHeaderRegion) {
        if (this.selectedChildren.length > 0) {
          this._alternativeHeaderRegion.$el.addClass('csui-table-alternative-header-visible');
        } else {
          this._alternativeHeaderRegion.$el.removeClass('csui-table-alternative-header-visible');
        }
      }
    },

    // @deprecated
    _createAlternativeHeaderView: function () {
      var alternativeHeaderOptions = this.options.alternativeHeader.options;

      var toolItemFactoryOptions;
      var filteredCollection;

      if (alternativeHeaderOptions && alternativeHeaderOptions.toolbarItems &&
          alternativeHeaderOptions.toolbarItems.tableHeaderToolbar) {
        var toolItemFactory = alternativeHeaderOptions.toolbarItems.tableHeaderToolbar;
        toolItemFactoryOptions = toolItemFactory ? toolItemFactory.options : undefined;

        var status = {
          nodes: this.selectedChildren,
          container: this.collection.node,
          context: this.context,
          collection: this.collection
        };

        this._alternativeHeaderCommandController = alternativeHeaderOptions.toolbarCommandController ||
                                                   new ToolbarCommandController({
                                                     commands: alternativeHeaderOptions.commands
                                                   });

        // actions on the 'other' toolbar can be loaded later
        // make filtered collection of toolbar items
        filteredCollection = new FilteredToolItemsCollection(
            toolItemFactory, {
              status: status,
              commands: this._alternativeHeaderCommandController.commands,
              delayedActions: this.collection.delayedActions,
              mask: alternativeHeaderOptions.toolbarItemsMask
            });

      }

      // create toolbar view
      var alternativeHeaderView = new this.options.alternativeHeader.viewClass(_.extend({
        collection: filteredCollection,
        toolbarName: 'tableHeader',
        originatingView: this.options.parentView,
        keyboardNavigationEnabled: true,
        selectedNodes: this.selectedChildren
      }, toolItemFactoryOptions));

      if (this._alternativeHeaderCommandController) {
        this.listenTo(this._alternativeHeaderCommandController, 'before:execute:command',
            function (eventArgs) {
              log.debug("command " + eventArgs.commandSignature + " is starting") &&
              console.log(log.last);
              this.lockedForOtherContols = true;
              this._destroyInlineBar();

              alternativeHeaderView.trigger('before:execute:command', eventArgs);
            });
        this.listenTo(this._alternativeHeaderCommandController, 'after:execute:command',
            function (eventArgs) {
              log.debug("command is finished") && console.log(log.last);
              this.lockedForOtherContols = false;

              alternativeHeaderView.trigger('after:execute:command', eventArgs);
            });
      }

      return alternativeHeaderView;
    },

    // This method is triggered as a nested 'childview:...' event; such
    // events always get the childView as the first argument.
    _toolbarItemClicked: function (toolItemView, args) {
      var selectedNodes = this.getSelectedChildren();
      var executionContext = {
        context: this.context,
        nodes: new this._ViewCollection(selectedNodes),
        container: this.collection.node,
        collection: this.collection,
        originatingView: this.options.originatingView,
        toolItemView: toolItemView
      };
      this._alternativeHeaderCommandController.toolitemClicked(args.toolItem, executionContext);
    }
  });

  TableView.version = '1.0';

  function getClassesFromElement(el) {
    var ca = el.attr('class');
    var rval = [];
    if (ca && ca.length && ca.split) {
      ca = $.trim(ca);
      /* strip leading and trailing spaces */
      ca = ca.replace(/\s+/g, ' ');
      /* remove double spaces */
      rval = ca.split(' ');
    }
    return rval;
  }

  function _resolveDetailRowColspan(masterRow, detailsRow, options) {

    var colspan = 0;
    var allTh = this.$el.find('thead th');
    var allThLength = allTh.length;
    if (this.wrappedColumns.length === 0 &&
        allTh.last().hasClass('csui-table-cell-_toggledetails')) {
      allThLength = allThLength - 1;  // the toggledetails column will be removed later
    }

    if (options && options.firstColumnIndex >= 0) {
      if (allThLength > 0 && options.firstColumnIndex < allThLength) {
        var detailTableCell = $(detailsRow.children()[0]);
        if (options.lastColumnIndex && options.lastColumnIndex >= options.firstColumnIndex) {
          colspan = options.lastColumnIndex - options.firstColumnIndex + 1;
          if (colspan > 1) {
            detailTableCell.attr('colspan', colspan);
          }
          detailsRow.attr('style', '');
        }
        for (var i = 0; i < options.firstColumnIndex; i++) {
          detailsRow.prepend('<td></td>');
        }
        var remainingTdCount = allThLength - options.firstColumnIndex - colspan;
        if (remainingTdCount > 0) {
          for (var j = 0; j < remainingTdCount; j++) {
            detailsRow.append('<td></td>');
          }
        }
      }
    } else {
      var masterRowCells = $(masterRow).children();
      var detailsRowCells = detailsRow.children();
      if (detailsRowCells.length === 1 && masterRowCells.length > 1) {
        colspan = masterRowCells.length;
        if (this.wrappedColumns.length === 0 && colspan > 0) {
          colspan = colspan - 1;  // the toggledetails column will be removed later
        }
        detailsRowCells.attr('colspan', colspan);
      }
    }
  }

  function _rememberDetailRowViewByModel(model, view) {
    var id = model.id || model.get('id');
    var detailRowViews = this._detailRowViewsByModelId[id];
    if (!detailRowViews) {
      detailRowViews = {views: []};
      this._detailRowViewsByModelId[id] = detailRowViews;
    }
    detailRowViews.views.push(view);
  }

  function addDetailRow(table, iDataIndex, nRow, aData) {
    var childRows;
    // display either the error message in a single detail row or metadata or description row
    var errorMessage = aData.get('csuiErrorMessage');
    if (errorMessage) {
      //var fgColor = $(nRow).css("color");
      //var bgColor = $(nRow).css("background-color");
      var errorRowView = new ErrorRowView({errorMessage: errorMessage});
      errorRowView.render();
      table.row(iDataIndex).child(errorRowView.el, "csui-details-row").show();
      $(nRow).addClass("csui-has-details-row");

      childRows = table.row(iDataIndex).child();
      if (aData.isLocallyCreated) {
        // the row is a newly inserted model - not saved or already saved
        childRows.addClass("csui-new-item");
      }
      if (aData.get('id') !== undefined) {
        // the row is a model that is already saved
        childRows.addClass("csui-saved-item");
      }

      // make the background color and forground color in the error row the same as in the
      // main row
      //childRow.css('background-color', bgColor);
      //childRow.css('color', fgColor);
    } else {

      var detailRows = [];
      var trEl, tdEl;

      if (accessibleTable) {
        childRows = $();
      } else {
        // no error to be displayed -> look for other detail rows
        if (this.options.descriptionRowView) {
          if (aData.get('description') && aData.get('description').length > 0) {
            var collapsedHeightIsOneLine = false;
            if (this.options.descriptionRowViewOptions &&
                this.options.descriptionRowViewOptions.collapsedHeightIsOneLine) {
              collapsedHeightIsOneLine = true;
            }
            var descriptionRowView = new this.options.descriptionRowView(
                {
                  model: aData,
                  collapsedHeightIsOneLine: collapsedHeightIsOneLine,
                  tableView: this
                });
            descriptionRowView.render();

            tdEl = $('<td class="csui-details-row"></td>');
            trEl = $('<tr class="csui-details-row csui-details-row-description"></tr>');
            tdEl.appendTo(trEl);

            descriptionRowView.triggerMethod('before:show');
            descriptionRowView.$el.appendTo(tdEl);  // insert into td of tr
            descriptionRowView.triggerMethod('show');

            _resolveDetailRowColspan.call(this, nRow, trEl, this.options.descriptionRowViewOptions);

            if (this.options.descriptionRowViewOptions) {
              if (!this.options.descriptionRowViewOptions.showDescriptions) {
                trEl.addClass('binf-hidden');
              }
            }

            // need to store in table for "hide/show all description rows"
            this._detailRowsDescriptionTRs.push({rowEl: trEl, view: descriptionRowView});
            _rememberDetailRowViewByModel.call(this, aData, descriptionRowView);

            detailRows.push(trEl[0]);
          }
        }

        if (this.wrappedColumns.length > 0) {
          var metadataRowView = new MetadataRowView({
            context: this.context,
            model: aData,
            columns: this.wrappedColumns
          });
          metadataRowView.render();
          tdEl = $('<td class="csui-details-row"></td>');
          trEl = $('<tr class="csui-details-row csui-details-row-metadata"></tr>');
          tdEl.appendTo(trEl);

          if (this.options.haveDetailsRowExpandCollapseColumn &&
              this.options.haveToggleAllDetailsRows) {
            if (this.detailsRowsAreExpanded ||
                this.expandedDetailRows[aData.id || aData.get('id')]) {
              trEl.addClass("binf-collapse binf-in"); // show the row expanded
            } else {
              trEl.addClass("binf-collapse"); //binf-show it collapsed
            }
          } else {
            trEl.addClass("binf-collapse binf-in"); // show it initially expanded
          }
          // add a row specific id, used in the expand/collapse toggle of this row
          trEl.attr('id', "csui-details-row-" + aData.cid);

          metadataRowView.triggerMethod('before:show');
          metadataRowView.$el.appendTo(tdEl);  // insert into td of tr
          metadataRowView.triggerMethod('show');

          _resolveDetailRowColspan.call(this, nRow, trEl);

          // mark model and main row with a flag that shows that a metadata detail row is there
          aData.set('hasMetadataRow', true, {silent: true});

          _rememberDetailRowViewByModel.call(this, aData, metadataRowView);
          detailRows.push(trEl[0]);
        } else {
          // remove mark for metadata details row
          aData.set('hasMetadataRow', false, {silent: true});
        }

        // Note: must add all detail rows at once, because datatable removes existing ones before
        // adding a new one
        table.row(iDataIndex).child(detailRows, "csui-details-row").show();

        // take all added description/metadata rows for returning it
        childRows = table.row(iDataIndex).child();
      }
    }

    if (childRows.length > 0) {
      $(nRow).addClass("csui-has-details-row");
    }
    return childRows;
  }

  function createTable() {
    initializeLocalizableLabels.call(this);

    getColumns.call(this);
    if (!this.allColumns.length) {
      return;
    }

    this.trigger("creatingTable", {
      sender: this
    });
    var self = this;
    self.hoveredRowDataId = undefined;
    this._detailRowsDescriptionTRs = [];
    this._detailRowViewsByModelId = {};

    // Collection must support methods from browesable mixin, which means that table.view
    // always thinks the collection is sorted/fetched/filtered at server side. We never use
    // datatables client side processing.
    var useServerSideProcessing = true;

    // DataTables initialization must take place on an element which has
    // been already appended to DOM; it fails otherwise.
    cleanPlaceholder.call(this);

    // Let cell views influence how much information the collection will fetch
    this.updateCollectionParameters();

    var originUrl = new base.Url(this.connector.connection.url).getOrigin(true);
    var supportUrl = base.Url.combine(originUrl, this.connector.connection.supportPath);
    var additionalCreationOptions = getCreationOptions.call(this);

    this.csuiDestroyRowCallbacks = [];

    var creationOptions = _.extend({
      columns: _.map(this.displayedColumns, function (column) {
        if (column.attributes.initialSortingDescending) {
          column.asSorting = ['desc', 'asc'];   // apply sorting ranking
        }
        return column;
      }),
      jQueryUI: false,
      autoWidth: false,
      deferRender: useServerSideProcessing,
      serverSide: useServerSideProcessing,
      language: self.localizableLabels,

      ajax: function (aoData, fnCallback, oSettings) {
        // The container can disable fetching the data, if the collection
        // doesn't have the full information available yet, but the
        // container has already rendered this view.
        if (this.refreshEnabled === false) {
          return;
        }

        // TODO: Deprecate and remove this.  The client-side mixin does not need this.
        //If API is not linked to any datatable then ignore the fect. Could be the
        //'before:render' event triggers another rebuild causing this API's context
        //to be disconnected by the time it returns from the trigger event'
        var api = this.api();
        if (api.context.length > 0) {
          if (self.options.clientSideDataOperation) {
            clientSideUpdateData.call(self, api, aoData, oSettings, fnCallback);
          } else {
            fetchData.call(self, api, aoData, oSettings, fnCallback);
          }
        }
      },

      initComplete: function (oSettings, json) {
        self.trigger("tableFrameRendered", {
          sender: self, target: this[0]
        });
      },

      drawCallback: function (oSettings) {
        var $table = $(this);
        // add style to table if table is empty
        if (self.collection) {
          if (self.collection.length === 0 ||
              self.collection.length === 1 && self.collection.at(0).inlineFormView) {
            $table.addClass('csui-table-empty');
          } else {
            $table.removeClass('csui-table-empty');
          }
        }

        if (accessibleTable) {
          $table.css('display', 'table');
          $table.find('thead')
              .css('display', 'table-header-group');
          $table.find('tbody')
              .css('display', 'table-row-group');
          $table.find('tr')
              .css('display', 'table-row');
          $table.find('td,th')
              .css('display', 'table-cell');
          $table.find('thead > tr')
              .children()
              .each(function () {
                var header = $(this);
                if (header.find('.csui-table-column-search').length) {
                  var wrapper = $('<div>', {style: 'display: flex'});
                  header.wrapInner(wrapper);
                }
              });
          $table.parent()
              .css({
                display: 'block',
                width: '100%',
                'overflow-x': 'auto'
              });
        }

        self.hoveredRowDataId = undefined;
        self.hoveredRow = undefined;
        if (self.options.haveDetailsRowExpandCollapseColumn &&
            self.options.haveToggleAllDetailsRows) {
          // If no row is expandable, remove the expand all arrow.
          // The arrow is always added when the header is rendered,
          // because first after rendering the body we know if some
          // row needs expanding or not.  It would be better to add
          // the arrow to the header in this event handler, if it
          // starts flicker.
          if (!$table.find('td.csui-table-cell-_toggledetails >' +
                           ' .expand-details-row-toggle').length &&
              self.collection.length) {
            self.displayedColumns = _.filter(self.displayedColumns, function (col) {
              return col.sName !== '_toggledetails';
            });

            var toggleDetailEls = $table.find('.csui-table-cell-_toggledetails');
            toggleDetailEls.remove();
          }
        }

        // copy the aria-label, which has the localized text depending on actual sorting of
        // the columns to the title attribute to have the same text also in the tooltip of
        // the column header
        // Note, this can't be done in the headerCallback, because datatables sets the
        // aria-label value after the headerCallback is called.
        $table.find('thead th').each(function () {
          var sortTitle = $(this).attr('aria-label');
          if (!sortTitle) {
            sortTitle = $(this).text();
          }
          if (sortTitle) {
            $(this).attr({title: sortTitle});
          }

          var tmpAriaLabel = $(this).find("> div").attr("aria-label");
          if (!$(this).attr("aria-label") && tmpAriaLabel) {
            $(this).attr("aria-label", tmpAriaLabel);
          }
        });

        // remove the aria-sort from some th, which causes a validity error
        $table.find('th[aria-sort]').each(function () {
          $(this).removeAttr('aria-sort');
        });

        $table.find('tr:not(.csui-details-row)').each(function () {
          $(this).find('> *').last().addClass('csui-table-cell-last-visible');
        });

        self.trigger("tableBodyRendered", {
          sender: self, target: $("tbody", this)[0]
        });

        self._plugHeaderBodyViews();

        // Avoid updating the scrollbar, before the table is fully rendered.
        // Perfect scrollbar elements are added in the render event handler.
        if (self.table) {
          // TODO: Find some way how to trigger the render or update:scrollbar
          // events, when the new table body is in DOM. The drawCallback is
          // called earlier.
          setTimeout(function () {
            self.trigger('update:scrollbar');
          });
        }
      },

      headerCallback: function (nHead, aData, iStart, iEnd, aiDisplay) {

        var excludeTableHeaderCellsWithClass = [
          SelectCellView.columnClassName,
          'csui-table-cell-_toggledetails'
        ];

        var trEl = $(nHead);
        var headerCells = trEl.find('>th');
        headerCells.each(function (index) {
          var thEl = $(this);

          // remove the th content and add the title embedded in a div

          if (self.displayedColumns.length > index) {
            var column              = self.displayedColumns[index],
                originalColumnTitle = column.title,
                columnTitle         = originalColumnTitle;
            if (column.noTitleInHeader === true) {
              columnTitle = '';
            }

            thEl.attr('data-csui-attribute', column.name);
            if (_.find(excludeTableHeaderCellsWithClass, function (classToCheck) {
              return thEl.hasClass(classToCheck);
            }) === undefined) {
              // start from scratch every time the table header is rebuild
              $(this).empty();
              // th has none of the exclude classes: wrap the title text into a div
              var $wrapperEl, $textEl;
              if (columnTitle === '') {
                $wrapperEl = $('<div class="csui-focusable-table-column-header csui-empty"></div>')
                    .attr('aria-label', originalColumnTitle);
                $textEl = $('<div class="csui-table-column-text"></div>');
                $wrapperEl.append($textEl);
                $(this).append($wrapperEl);
              } else {
                var ariaLabel = columnTitle;
                if (self.displayedColumns[index].bSortable) {
                  // TODO get the prepared label from the parent which mentions ascending / descending
                  ariaLabel = _.str.sformat(lang.NodeTableSortByAria, columnTitle);
                }
                $wrapperEl = $('<div class="csui-focusable-table-column-header"></div>')
                    .attr('aria-label', ariaLabel);
                if (column.attributes.sort) {
                  $wrapperEl.attr('role', 'button');
                }
                $textEl = $('<div class="csui-table-column-text"></div>')
                    .text(columnTitle);
                $wrapperEl.append($textEl);
                $(this).append($wrapperEl);
              }
            }
          }
        });

        ensureExpandAllDetailRowsColumn.call(self, nHead);
        ensureSelectAllCheckbox.call(self, nHead);

        var order = this.api().order();

        if (order && order.length > 0 && order[0].length > 1) {
          var sortDefCol0 = order[0];
          var columnIndexForSorting = sortDefCol0[0];
          var sortDirection = sortDefCol0[1];
          var cssClass = 'icon-sortArrowUnknown';
          var found = self.displayedColumns.some(function (cellValue) {
            return (cellValue === self.allColumns[columnIndexForSorting]);
          });

          if (sortDirection === 'asc') {
            cssClass = 'icon-sortArrowUp';
          } else {
            if (sortDirection === 'desc') {
              cssClass = 'icon-sortArrowDown';
            }
          }
          var spanEl = '<span class="csui-sort-arrow ' + cssClass + '"></span>';
          var thEl = self.$(
              'th:eq(' + columnIndexForSorting + ')>.csui-focusable-table-column-header');
          if (found) {
            thEl.append(spanEl);
          }
        }
        // Moved the following block into drawCallback, because aria-label is not set by
        // datatables when this callback is called.
        //$(nHead).find('th').each(function () {
        //  var sortTitle = $(this).attr('aria-label');
        //  $(this).attr({title: sortTitle});
        //});

        ensureAllSearchBox.call(self);

        self.trigger("tableHeaderRendered", {
          sender: self, target: nHead
        });
      },

      footerCallback: function (nFoot, aData, iStart, iEnd, aiDisplay) {
        self.trigger("tableFooterRendered", {
          sender: self, target: nFoot
        });
      },

      rowCallback: function (nRow, aData, iDataIndex) {
        var $row = $(nRow);
        // Fill content of cells, which column handlers are Backbone.Views; must be
        // called before rendering the cells, because it sets a hasMetadataRow in the
        // model with silent:true for performance reasons
        var detailRows = addDetailRow.call(self, this.api(), iDataIndex, nRow, aData);
        var isSelected = aData.get(SelectCellView.isSelectedModelAttributeName);
        if (isSelected) {
          $row.addClass('binf-active');
          _.each(detailRows, function (detailRow) {
            $(detailRow).addClass('binf-active');
          });
        } else {
          $row.removeClass('binf-active');
          _.each(detailRows, function (detailRow) {
            $(detailRow).removeClass('binf-active');
          });
        }
        if (aData.isLocallyCreated) {
          // the row is a newly inserted model - not saved or already saved
          $row.addClass("csui-new-item");
          detailRows.addClass("csui-new-item");
        }
        if (aData.get('id') !== undefined) {
          // the row is a model that is already saved
          $row.addClass("csui-saved-item");
          detailRows.addClass("csui-saved-item");

          // Gray out list items which have no default action
          aData.set('inactive', !self.checkModelHasAction(aData), {silent: true});
        } else {
          aData.set('inactive', true, {silent: true});
        }

        // for D2 Smart UI, fade out when the model is Cut
        if (aData.get('isCut') === true) {
          $row && $row.addClass('csui-cut-row');
          detailRows && detailRows.addClass('csui-cut-row');
        }

        var cellViews = [];
        var displayInlineForm = aData.inlineFormView !== undefined;
        if (displayInlineForm) {
          $row.addClass("csui-table-row-shows-inlineform");
        }
        var inlineFormColspan = 0;
        var tdForInlineForm;
        var tdForDeletion = [];
        //Since we add event listeners to newly created  cellViews, and new cellViews are created for each window resize
        //and node browse, we need to retain the cellVies, and destroy them, else memory leaks will occur.
        self.csuiDestroyRowCallbacks.push(destroyCellViews, destroyRowViews);
        _.each(self.displayedColumns, function (column, index) {
          if (column.CellView) {
            var $td = $($row.children()[index]);
            if (self.cachedColumnWidths && self.cachedColumnWidths[column.className]) {
              var widthStyle = self.cachedColumnWidths[column.className];
              $td.css(widthStyle);
            }
            var cellViewOptions = {
              el: $td,
              tableView: self,
              column: column,
              model: aData,
              context: self.context,
              originUrl: originUrl,
              supportUrl: supportUrl,
              nameEdit: self.options.nameEdit,
              favoritesTableOptions: self.options.favoritesTableOptions,
              rowIndex: iDataIndex
            };
            if (column.name === '_toggledetails') {
              cellViewOptions.rowIsExpanded =
                  self.detailsRowsAreExpanded ||
                  self.expandedDetailRows[aData.id || aData.get('id')];
            }
            var cellView = new column.CellView(cellViewOptions);

            if (column.name === '_toggledetails') {
              self.listenTo(cellView, 'toggle:detailsrow', function (args) {
                // setting detailsRowsAreExpanded to undefined will let the code in render to
                // skip expanding or collapsing all rows
                delete self.detailsRowsAreExpanded;
                _updateToggleButton.call(self);

                self.expandedDetailRows[args.model.id ||
                                        args.model.get('id')] = args.detailsRowIsExpanded;
                self.trigger('update:scrollbar');
              });
            }

            // skip rendering of columns int this row - except for type and name - if
            // the model was created locally (through user input) and is not already saved
            if (displayInlineForm) {
              // in case the model is locally created render only type and name column
              if (column.name === 'type') {
                cellView.render();
                self.listenTo(cellView, 'type:clicked', function () {
                  self.triggerMethod('type:clicked');
                });
              } else {
                if ((column.isNaming || column.name === 'name') && !tdForInlineForm) {
                  inlineFormColspan = 1;
                  tdForInlineForm = $td;
                } else {
                  if (column.name !== '_select') {  // skip select column
                    inlineFormColspan++; // count remaining td name and all td that come after it
                    tdForDeletion.push($td);
                  }
                }
              }
            } else {
              cellView.render();
            }
            // propagate cellView events to table.view events to let others listen to it
            self.listenTo(cellView, 'cellCloseOther', function () {
              self.cancelAnyExistingInlineForm();
              self.trigger('closeOther', cellView);
              self.lockedForOtherContols = true;
              _.each(cellViews, function (otherCellView) {
                if (otherCellView !== cellView) {
                  otherCellView.triggerMethod('closeOther');
                }
              });
            });
            self.listenTo(cellView, 'cellAllowOther', function () {
              self.trigger('allowOther', cellView);
              self.lockedForOtherContols = false;
              _.each(cellViews, function (otherCellView) {
                if (otherCellView !== cellView) {
                  otherCellView.triggerMethod('allowOther');
                }
              });
            });
            self.listenTo(cellView, 'cancelEdit', function () {
              // cell editor was canceled - remove unsaved model if there is one at the
              // first position in the collection
              var unsavedModel = self.collection.at(0);
              if (unsavedModel && unsavedModel.get('id') === undefined) {
                unsavedModel.csuiIsRemoved = true;
                self.collection.remove(unsavedModel);
              }
            });
            // event from the favorite cellview
            self.listenTo(cellView, 'show:add:favorite:form', function () {
              self._destroyInlineBar();
              self.lockedForOtherContols = true;
            });
            self.listenTo(cellView, 'close:add:favorite:form', function () {
              self.lockedForOtherContols = false;
            });

            if (iDataIndex >= 0) {
              self.listenTo(cellView, 'clicked:cell', function (event) {
                self.trigger('clicked:cell', {
                  cellView: cellView,
                  rowIndex: iDataIndex,
                  colIndex: index,
                  model: aData
                });
              });
              self.listenTo(cellView, 'clicked:checkbox', function (event) {
                if (aData.get('selectable') !== false) {
                  var tt = getTableTools.call(self);
                  if (event.checked === 'false') {
                    tt.fnSelect(nRow);
                  } else {
                    tt.fnDeselect(nRow);
                  }
                }
              });
            }
            cellViews.push(cellView);
          }
        });

        function destroyRowViews() {
          var allRowViews = self._detailRowViewsByModelId || {};
          Object
              .keys(allRowViews)
              .forEach(function (rowViewId) {
                var itemRowViews = allRowViews[rowViewId].views;
                itemRowViews.forEach(function (rowView) {
                  self.stopListening(rowView);
                  rowView.destroy();
                });
              });
          self._detailRowsDescriptionTRs = [];
          self._detailRowViewsByModelId = {};
          self.hoveredRowDataId = undefined;
        }

        function destroyCellViews() {
          _.each(cellViews, function (cellView) {
            self.stopListening(cellView);
            cellView.destroy();
          });
          cellViews = null;
        }

        function handleRowHover(dtRow, detailRows) {
          if (detailRows === undefined) {
            detailRows = $();
          }

          // check whether hovered tr differs from previously hovered tr
          // this is necessary to for detail rows, which are additional TRs but the same
          // node is behind

          var hoveredNodeChanged = true;
          var rowDataId = dtRow._DT_RowIndex;

          if (self.hoveredRowDataId && self.hoveredRowDataId === rowDataId) {
            hoveredNodeChanged = false;
          }
          self.hoveredRowDataId = rowDataId;

          if (hoveredNodeChanged) {
            if (self.hoveredRow) {
              $(self.hoveredRow).removeClass("csui-state-hover");
              var prevDetailRows = self.table.row(self.hoveredRow).child();
              prevDetailRows.removeClass("csui-state-hover");
            }

            // allow hovering the row only if it was fetched from or saved to the server
            // to prevent actions on the node when cell editor is open
            var node = self.table.row(dtRow).data();
            if (node) {
              var nodeId = node.id || node.get('id');
              if (nodeId !== undefined) {
                var args = {
                  sender: self,
                  targets: [dtRow],
                  nodes: getNodes.call(self, [dtRow])
                };
                self.trigger("selectingTableRow", args);
                if (!args.cancel) {
                  self.hoveredRow = dtRow;
                  $(dtRow).addClass("csui-state-hover");
                  detailRows.addClass("csui-state-hover");
                }
              }
            }
          }
        }

        function handleRowHoverLeave(dtRow, detailRows) {
          if (detailRows === undefined) {
            detailRows = $();
          }
          $(dtRow).removeClass("csui-state-hover");
          detailRows.removeClass("csui-state-hover");
          self.hoveredRowDataId = undefined;
          self.hoveredRow = undefined;
        }

        // if this row is used as a inline form, apply colspan as needed
        if (displayInlineForm && tdForInlineForm && inlineFormColspan > 1) {
          // make the td for inline form wider with colspan and remove remaining td
          _.each(tdForDeletion, function (el) {
            el.remove();
          });
          tdForInlineForm.attr('colspan', inlineFormColspan);
          tdForInlineForm.addClass('csui-inlineform-parent');

          self.trigger('closeOther'); // force inline bar to close

          // render inline form
          if (aData.inlineFormView) {
            if (self.activeInlineForm) {
              self.activeInlineForm.destroy();
            }
            self.activeInlineForm = new aData.inlineFormView({
              model: aData,
              originatingView: self.options.originatingView,
              context: self.context
            });
          }

          self.activeInlineForm.listenTo(self.activeInlineForm, 'destroy', function () {
            self.lockedForOtherContols = false;
            if (!!self.activeInlineForm.model.get('id')) {
              setTimeout(function () {
                self.accFocusedState.focusView = 'tableBody';
                self.trigger('changed:focus');
                self.currentlyFocusedElement().focus();
              }, 1);
            }
            delete self.activeInlineForm;
          });

          var inlineFormRegion = new Marionette.Region({el: tdForInlineForm});
          inlineFormRegion.show(self.activeInlineForm);
        } else {

          // listen for hover events only if no inline form is displayed

          $row.mousehover(function () {
            var args = {
              sender: self,
              target: nRow,
              node: self.table.row(nRow).data()
            };
            self.trigger("enterTableRow", args);
          }, function () {
            var args = {
              sender: self,
              target: nRow,
              node: self.table.row(nRow).data()
            };
            self.trigger("leaveTableRow", args);
          }, {
            namespace: self.cid
          });

          // add event handler for main row and if there is one also for the details row
          $row.mousehover(
              function () { handleRowHover.call(self, nRow, detailRows); },
              function () { handleRowHoverLeave.call(self, nRow, detailRows); },
              {namespace: self.cid});
          detailRows.mousehover(
              function () { handleRowHover.call(self, nRow, detailRows); },
              function () { },
              {namespace: self.cid});
        }

        self.trigger("tableRowRendered", {
          sender: self, target: nRow, node: aData
        });

      } // end rowCallback
    }, additionalCreationOptions);

    if (!!this.collection.state) {
      _.extend(creationOptions, {
        order: saveSortOrderState.call(this),
        ordering: true
      });
    }

    function saveSortOrderState() {
      this.res = this.collection.state.split("_");
      this.order = this.order || [[]];
      self.foundcolumn = false;
      var stateValue = this.collection.state.substring(this.collection.state.indexOf("_") + 1,
          this.collection.state.length).trim();
      var found = this.displayedColumns.some(function (cellValue, index) {
        if (cellValue.name == stateValue) {
          self.index = index;
          return true;
        }
      }, this);
      if (found) {
        this.order[0].push(this.index);
        this.order[0].push(this.res[0]);
        this.foundcolumn = true;
      } else {
        this.foundcolumn = false;
      }
      return this.order;
    }

    if (!useServerSideProcessing) {
      creationOptions.data = this.collection.models;
    }

    // bootstrap, don't use table-hover - hover classes are set in script
    var tableEl = $("<table></table>").addClass("binf-table");

    // Prevent the table from being rendered with column widths not adjusted;
    // the columns will be finalized during dom:refresh
    if (!accessibleTable) {
      this.$el.addClass('csui-not-ready');
    }

    tableEl.appendTo(this.el);
    this.table = tableEl.DataTable(creationOptions);

    // TODO: Remove TabableRegion and Tabables behaviours.
    // Prevent TabableRegion behaviour from focusing the table wrapper div.
    // Screen reader would introduce the table again and confuse the user.
    // Crazy, adding the behaviour and disabling it like this again.
    $(this.$el.children()[0]).attr('tabindex', '-1');

    // re-select rows that were selected before the table was rebuilt
    selectRowsByNodeIds.call(this, additionalCreationOptions.selectedNodesById);

    // restore scroll position after rebuild finished, but only if there are rows
    if (this.collection.length > 0 && additionalCreationOptions.currentScollPosition !==
        undefined) {
      this.$('tbody').scrollTop(additionalCreationOptions.currentScollPosition);
    }

    // perfect scrollbar stops 'scroll' event propagation, trigger it for elements to listen to
    this.$('tbody').on('scroll', function () {
      self.trigger('scroll');
    });

    this.table.on("click", ".csui-table-cell-default-action", function (event) {
      delegateClickAction.call(self, event, "DefaultPre");
    }).on("click", "a#parentAction", function (event) {
      delegateClickAction.call(self, event, "Parent");
    }).on("click", "a#menuAction", function (event) {
      delegateClickAction.call(self, event, "Menu");
    }).on("click", "input[id^='selectAction']", function (event) {
      event.stopPropagation();
      var target = $(event.target);
      var td = target.closest("td,th");
      td.click();
    }).on("processing", function (event, oSettings, shown) {
      ensureProcessingPanel.call(self, oSettings, shown);
    }).on("destroy", function (event, oSettings) {
      destroyProcessingPanel.call(self, oSettings);
      cleanUpTableEventListeners.call(self);
      self._destroyTableHeaderAndBodyViews();
    }).on("preDraw", function (event, oSettings) {
      // If the collection is fetched by an AJAX call, this event is triggered
      // twice.  Once immediately when the fnDraw is called, but fnDraw does
      // nothing but triggering the server call.  When the data come back, fnDraw
      // is called for the second time, which triggers this event again.
      // We should clear the table first, when the data are back.  It looks bad
      // to make it white for a longer time and if the operation failed, the
      // current content would be lost.

      if (!oSettings.oFeatures.bServerSide || oSettings.bDrawing) {
        cleanUpTableEventListeners.call(self);
        if (self.activeInlineForm) {
          self.activeInlineForm.destroy();
        }
        self._destroyTableHeaderAndBodyViews();
      }
    });

    // Make the children filtering by name as you type a little
    // less demanding on the server resources. Refresh the content
    // not after every key hit, but first after a little delay.
    // A.S.: the new parameter is searchDelay (http://datatables.net/reference/option/searchDelay) and
    // because the default is 400ms when server side processing is active we don't need that parameter anymore.
    // this.table.fnSetFilteringDelay(250);

    tableEl.on('order.dt', function () {
      var order = self.table.order();

      if (self.displayedColumns) {
        var orderBy = [];
        _.each(self.table.order(), function (orderinfo) {
          var sortColumnIndex = orderinfo[0];
          var sortColumnKey = self.displayedColumns[sortColumnIndex].data(undefined, 'orderBy');
          if (sortColumnKey) {
            if (orderinfo[1]) {
              orderBy.push(sortColumnKey + " " + orderinfo[1]);
            } else {
              orderBy.push(sortColumnKey);
            }
          }
        });

        if (orderBy.length) {
          // set order at collection and fetch immediately
          self.collection.setOrder(orderBy.join());
        } else {
          self.collection.resetOrder();
        }
      }
    });

    // @deprecated
    // create alternativeHeader only if it's in the options
    if (this.options.alternativeHeader) {
      log.warn("Using of options.alternativeHeader with table.view is deprecated. Please use" +
               " csui/controls/table.rowselection.toolbar/table.rowselection.toolbar.view" +
               " instead and render this view ouside of table.view. The behavior" +
               " csui/behaviors/table.rowselection.toolbar/table.rowselection.toolbar.behavior" +
               " might help using it.") && console.log(log.last);

      this.$el.find('.csui-table-alternative-header').remove();
      var alternativeHeaderRegionEl = $('<div class="csui-table-alternative-header"></div>');
      this.$el.prepend(alternativeHeaderRegionEl);
      this._alternativeHeaderRegion = new Marionette.Region({el: alternativeHeaderRegionEl});
      var alternativeHeaderView = this._createAlternativeHeaderView();
      this._alternativeHeaderRegion.show(alternativeHeaderView);
      this.triggerMethod('alternativeHeader:show', alternativeHeaderView);

      // attach event listener for clicked toolbar items
      this.listenTo(alternativeHeaderView, 'childview:toolitem:action', this._toolbarItemClicked);
    }

    this.trigger("tableCreated", {
      sender: this
    });
  }

  function initializeLocalizableLabels() {
    // Support tableTexts for compatibility
    var customLabels = this.getOption('customLabels') ||
                       this.getOption('tableTexts') || {};
    if (_.isFunction(customLabels)) {
      customLabels = customLabels.call(this);
    }
    this.localizableLabels = this._fillDefaultLocalizableLabels(customLabels);
  }

  function ensureProcessingPanel(oSettings, shown) {
    if (!this.disablingOverlay) {
      this.disablingOverlay = $("<div id='disabling_overlay'></div>")
          .hide().prependTo(this.table);
    }
    if (shown) {
      this.disablingOverlay.show();
    } else {
      this.disablingOverlay.hide();
    }
  }

  function destroyProcessingPanel(oSettings) {
    if (this.disablingOverlay) {
      this.disablingOverlay.remove();
      this.disablingOverlay = undefined;
    }
  }

  function getTableTools() {
    return this.tableTools ||
           (this.tableTools = TableTools.fnGetInstance(this.table.table().node()));
  }

  function getCreationOptions() {
    var options;
    switch (this.options.paginationStyle) {
    case "all_buttons":
      options = {
        pagingType: "full_numbers"
      };
      break;
    case "two_buttons":
      options = {
        pagingType: "two_button"
      };
      break;
    case "infinite_scrolling":
      // TODO: infinite scrolling is implemented differently in DataTables 1.10
      // it might be an option to remove the paging and scrolling completely because it is not used in Carbon Fiber
      options = {
        //        bScrollInfinite: true, // removed in DataTable 1.10
        scrollCollapse: true, // 260 would be better but with scrollCollapse on the scrollbar
        // does not show up; maybe because it is the height of 10 rows...
        // TODO: fix the scrollbar showing in DataTables so that we don't
        // need to set the Y-size
        scrollY: this.options.pageSize ?
                 (this.options.pageSize * 25 - 1) + "px" : "249px"
        // This is removed in DataTables 1.10: iScrollLoadGap: this.options.pageSize ? this.options.pageSize * 10 : 100
      };
      break;
    default:
      options = {
        paging: false
        //scrollCollapse: false,
        //scrollY: 200,
        //scrollX: '100%'
        //scrollY: this.options.pageSize ? (this.options.pageSize * 25 - 1) + "px" : "249px"
      };
    }

    // Parameters which can be changed in the DataTables UI should be preferred
    // from there; the initial options should be used only for the initial table
    // creation.
    if (!this.recreated) {
      // The actual initial table creation is complete only when we have the
      // columns sent from the server.  The table can be rendered empty before
      // that.
      this.recreated = this.columns.length || this.columns.fetched;
    }

    options.order = getOrderFromOrderBy.call(this, this.collection.orderBy);

    // The rest of parameters cannot be changed on the UI and the initial
    // options have to be used again to ensure consistent UI look on container
    // changes.  (A container change re-creates the table is the columns
    // change.)

    // enable sorting only if there is at least one sortable displayed column
    options.ordering = getTableOrderingOption.call(this);

    var selectRows;
    switch (this.options.selectRows) {
    case "single":
      selectRows = "single";
      break;
    case "multiple":
      selectRows = "multi";
      break;
    default:
      selectRows = "none";
      this.options.selectAllColumnHeader = false;
      this.options.selectColumn = false;
    }

    if (selectRows === "none") {
      options.dom = '<"H"lfr>t<"F"ip>';
    } else {
      options.dom = '<"H"lTfr>t<"F"ip>';

      var self = this;
      options.tableTools = {
        aButtons: [],

        sRowSelect: selectRows,

        fnPreRowSelect: function (ev, rows, selecting) {
          if (self._rebuildingTable) {
            return; // don't handle row selection event while in table rebuild/render
          }

          function triggerRowClickedEvent() {
            var node = self.table.row(rows[0]).data();
            // trigger the event only if no inline form is displayed in this row
            if (!node.inlineFormView) {
              var rowClickedEventArgs = {sender: self, target: rows[0], node: node};
              self.triggerMethod('row:clicked', rowClickedEventArgs);
              return !rowClickedEventArgs.cancel;
            }
          }

          function triggerRowSelectingEvent() {
            var nodes = getNodes.call(self, rows);
            var args = {sender: self, targets: rows, nodes: nodes};
            self.trigger(selecting ? "selectingTableRow" : "unselectingTableRow", args);
            return !args.cancel;
          }

          Marionette.triggerMethodOn(self.tableBodyView, 'before:render');

          if (rows && rows.length > 0) {
            var ok = triggerRowClickedEvent();
            if (ok) {
              if (self.options.selectColumn && self.options.selectAllColumnHeader) {
                // allow the row selection only in the select cell
                // (event is not set if fnSelect is called from table.view code)
                var selectByClick = ev && ev.target;
                var canSel = !selectByClick ||
                             $(ev.target).hasClass(SelectCellView.columnClassName);
                if (canSel) {
                  return triggerRowSelectingEvent();
                } else {
                  return false;
                }
              } else {
                // select column not configured - allow selecting the row in every column by clicking it
                return triggerRowSelectingEvent();
              }
            } else {
              return false;
            }
          } else {
            return true;
          }
        },

        fnRowSelected: function (rows) {
          if (self._rebuildingTable) {
            return; // don't handle row selection event while in table rebuild/render
          }
          if (_.isArray(rows) && rows.length > 0) {

            _.each(rows, function (r) {
              var node       = self.table.row(r).data(),
                  currentRow = $(r);
              // detailRowsInfo = _accGetDetailRowInfo.call(self, node);

              node.set(SelectCellView.isSelectedModelAttributeName, true);
              // $(r).addClass('binf-active');
              // var childRows = self.table.row(r).child();
              // childRows.addClass('binf-active');
              // _.each(detailRowsInfo.views, function (detailRowInfo) {
              //   detailRowInfo.$el.addClass('binf-active');
              // }, self);
            });
            updateSelectAllCheckbox.call(self);
            Marionette.triggerMethodOn(self.tableBodyView, 'render');

            self.trigger('closeOther'); // force inline bar to close (updateRow rendered row
            // with inline action bar again if there was one displayed)
            self.selectedChildren.reset(self.getSelectedChildren());

            self.trigger("tableRowSelected", {
              sender: self, targets: rows, nodes: getNodes.call(self, rows)
            });
          }
        },

        fnRowDeselected: function (rows) {
          if (self._rebuildingTable) {
            return; // don't handle row deselection event while in table rebuild/render
          }
          if (_.isArray(rows) && rows.length > 0) {
            _.each(rows, function (r) {
              var node       = self.table.row(r).data(),
                  currentRow = $(r);
              // detailRowsInfo = _accGetDetailRowInfo.call(self, node);

              node.set(SelectCellView.isSelectedModelAttributeName, false);
              // $(r).removeClass('binf-active');
              // var childRows = self.table.row(r).child();
              // childRows.removeClass('binf-active');

              // _.each(detailRowsInfo.views, function (detailRowInfo) {
              //   detailRowInfo.$el.removeClass('binf-active');
              // }, self);
            });
            updateSelectAllCheckbox.call(self);
            Marionette.triggerMethodOn(self.tableBodyView, 'render');

            self.selectedChildren.reset(self.getSelectedChildren());
            self.trigger("tableRowUnselected", {
              sender: self, targets: rows, nodes: getNodes.call(self, rows)
            });
          }
        }
      };
    }
    options.searching || options.lengthChange ||
    (options.dom = options.dom.replace('"H"', '').replace('l',
        '').replace('f', ''));
    options.info || options.pagingType ||
    (options.dom = options.dom.replace('"F"', '').replace('i',
        '').replace('p', ''));

    tryApplyingStateSavedBeforeRebuild.call(this, options);

    return options;
  }

  function getOrderFromOrderBy(orderBy) {
    var orders = [];
    if (orderBy) {
      orders = _.map(orderBy.split(","),
          function (orderBy) {
            orderBy = orderBy.split(" ");
            var columnKey    = orderBy[0],
                columnNumber = getSortableColumnNumber.call(this, columnKey);
            if (columnNumber !== undefined) {
              columnKey = this.displayedColumns[columnNumber].attributes.column_key;
              //var c = _.findWhere(this.columns)
              if (this.columns.findWhere({column_key: columnKey}).get('sort')) {
                return [columnNumber, orderBy[1] || "asc"];
              }
            }
          }, this);
    }

    var definedOrders = _.filter(orders, function (orderBy) {return !!orderBy; });
    return definedOrders;
  }

  function getTableOrderingOption() {
    if (this.options.enableSorting !== true) {
      return false;
    }
    // enable DataTables ordering option only if there is at least one sortable displayed column
    var sortableColumn = _.find(this.displayedColumns, function (col) {
      return col.attributes && col.attributes.sort === true;
    });
    return !!sortableColumn;
  }

  function _updateToggleButton() {
    if (this.toggleExpandDetailsRowEl) {
      if (this.detailsRowsAreExpanded) {
        this.toggleExpandDetailsRowEl.removeClass('icon-expandArrowDown');
        this.toggleExpandDetailsRowEl.addClass('icon-expandArrowUp');
        this.toggleExpandDetailsRowEl.attr('title', toggleDetailsLang.collapseAllTooltip);
        this.toggleExpandDetailsRowEl.attr('aria-label', toggleDetailsLang.collapseAllAria);

      } else {
        this.toggleExpandDetailsRowEl.removeClass('icon-expandArrowUp');
        this.toggleExpandDetailsRowEl.addClass('icon-expandArrowDown');
        this.toggleExpandDetailsRowEl.attr('title', toggleDetailsLang.expandAllTooltip);
        this.toggleExpandDetailsRowEl.attr('aria-label', toggleDetailsLang.expandAllAria);
      }
    }
  }

  function ensureExpandAllDetailRowsColumn(nHead) {
    var expandDetailRowColumn;
    var self = this;

    function toggleDetailsRow(event) {
      // Do not let it bubble; the table cell catches the click on its own.
      event.stopPropagation();
      event.preventDefault();

      this.detailsRowsAreExpanded = !this.detailsRowsAreExpanded;
      this._clearExpandedRows();  // collapse or expand all clears single toggle states
      this._detailRowsDescriptionTRs = [];   // clear the row description trs else the array will be populated with the same elems after 'draw()'.
      _updateToggleButton.call(this);

      this.table.draw();
      if (this.options.descriptionRowViewOptions &&
          this.options.descriptionRowViewOptions.showDescriptions) { // call show detail row description only if show description is already set to true before 'draw()'.
        this.showDetailRowDescriptions(true);
      } else {
        this.trigger('dom:refresh');      // let the table refresh keyboard navigation
      }
      this._adjustColumns();
    }

    var anchor;
    if (this.options.haveDetailsRowExpandCollapseColumn &&
        this.options.haveToggleAllDetailsRows) {
      expandDetailRowColumn = $("th.csui-table-cell-_toggledetails", nHead);
      if (expandDetailRowColumn.length > 0) {
        //      expandDetailRowColumn = $("th:last-child", nHead);
        anchor = $("a", expandDetailRowColumn);
        if (anchor.length) {
          this.toggleExpandDetailsRowEl = anchor.find('.csui-button-icon');
          _updateToggleButton.call(this);
        } else {
          if (this.collection.length) {
            expandDetailRowColumn.addClass("csui-table-cell-_toggledetails");
            // don't set data-binf-toggle because the click event will be handled directly here
            anchor = $('<a class="csui-focusable-table-column-header expand-details-row-toggle"' +
                       ' title="' + toggleDetailsLang.expandAllTooltip + '" aria-label="' +
                       toggleDetailsLang.expandAllAria +
                       '" href="#" aria-expanded="false">' +
                       '<span class="csui-button-icon icon-expandArrowDown"></span></a>');
            this.toggleExpandDetailsRowEl = anchor.find('.csui-button-icon');
            _updateToggleButton.call(this);
            anchor.prependTo(expandDetailRowColumn);
            expandDetailRowColumn.click(_.bind(toggleDetailsRow, this));
            anchor.click(_.bind(toggleDetailsRow, this));
            expandDetailRowColumn.keypress(function (event) {
              var keyCode = event.keyCode || event.charCode;  // note: not all browser give
              // event.keyCode if it's a printable char
              if (!(event.ctrlKey || event.metaKey) && (keyCode === 32 || keyCode === 13)) {
                // space or enter key (without ctrl or command)
                toggleDetailsRow.call(self, event);
              }
            });
          } else {
            // If no item is displayed, expand all does not make sense.
            anchor.remove();
          }
        }
      }
    }
  }

  function ensureSelectAllCheckbox(nHead) {
    var self = this;
    var selectColumn = $("th:first-child", nHead);
    if (selectColumn.length === 0) {
      return;
    }

    function toggleSelection() {
      // Do not let it bubble; the table cell catches the click on its own.
      // event.stopPropagation();
      // event.preventDefault();

      var selectedRows = [];
      var selectedModels = [];
      var deselectedRows = [];
      var deselectedModels = [];
      var index, row;

      if (self._selectAllCheckboxRegion && self._selectAllCheckboxRegion.currentView) {
        Backbone.trigger('closeToggleAction');

        var cbView = self._selectAllCheckboxRegion.currentView;
        var checked = cbView.model.get("checked");

        switch (checked) {
        case 'true':
          // all rows are selected -> deselect all
          self.collection.each(function (model) {
            if (model.get(SelectCellView.isSelectedModelAttributeName)) {
              // row was selected before -> add it to the deselected list
              index = self.collection.indexOf(model);
              row = self.table.row(index);
              deselectedModels.push(model);
              deselectedRows.push(row.node());
            }
            model.set(SelectCellView.isSelectedModelAttributeName, false);
          });
          break;
        default:
          // no or some rows are selected -> select all, except those that are not selectable
          self.collection.each(function (model) {
            if (model.get('selectable') !== false) {
              if (!model.get(SelectCellView.isSelectedModelAttributeName)) {
                // row was not selected before -> add it to the selected list
                index = self.collection.indexOf(model);
                row = self.table.row(index);
                selectedModels.push(model);
                selectedRows.push(row.node());
              }
              model.set(SelectCellView.isSelectedModelAttributeName, true);
            } else {
              if (model.get(SelectCellView.isSelectedModelAttributeName)) {
                // row was selected before -> add it to the deselected list
                index = self.collection.indexOf(model);
                row = self.table.row(index);
                deselectedModels.push(model);
                deselectedRows.push(row.node());
              }
              model.set(SelectCellView.isSelectedModelAttributeName, false);
            }
          });
        }

        // update the selectedChildren collection and the select-all-checkbox
        self.selectedChildren.reset(self.getSelectedChildren());
        updateSelectAllCheckbox.call(this);

        if (deselectedRows.length > 0) {
          self.trigger("tableRowUnselected", {
            sender: self, targets: deselectedRows, nodes: deselectedModels
          });
        }
        if (selectedRows.length > 0) {
          self.trigger("tableRowSelected", {
            sender: self, targets: selectedRows, nodes: selectedModels
          });
        }

        self.trigger('dom:refresh');
        /* let tabables behavior re-set the tabindex values after the selection was toggled and
         rows were re-rendered*/
      }
    }

    function _markSelectAllCheckboxFocusable() {
      var checkboxFocusableElement = focusable.findFocusables(checkboxView.el);
      $(checkboxFocusableElement).addClass('csui-focusable-table-column-header');
    }

    if (this.options.selectColumn && this.options.selectAllColumnHeader) {


      // create the checkbox only once if it is not already there
      if (!this._selectAllCheckboxRegion) {
        var checkboxView = new CheckboxView({
          checked: false,
          disabled: false,
          ariaLabel: lang.selectAllAria,
          title: lang.selectAll
        });

        this.listenTo(checkboxView, 'clicked', function (e) {
          e.cancel = true;
          toggleSelection.call(self);
        });

        // after every render, set the csui-focusable-table-column-header again to the checkbox
        this.listenTo(checkboxView, 'render', function () {
          _markSelectAllCheckboxFocusable();
        });

        this._selectAllCheckboxRegion = new Marionette.Region({el: selectColumn});
        this._selectAllCheckboxRegion.show(checkboxView);
        _markSelectAllCheckboxFocusable();
      }

      if (this.collection.length) {
        this._selectAllCheckboxRegion.currentView.setDisabled(false); // todo remove hide
        var selected = this.collection.where({csuiIsSelected: true}).length;
        if (selected > 0) {
          updateSelectAllCheckbox.call(this);
        }
      } else {
        // hide checkbox when table has no rows and therefore nothing to select
        this._selectAllCheckboxRegion.currentView.setDisabled(true);  // todo hide instead
      }
    }
  }

  function ensureAllSearchBox() {
    var self = this;
    self.searchBoxes = [];
    this.$('thead th').each(function (index) {
      if ($(this).find('.csui-table-column-search').length === 0) {
        if (self.displayedColumns.length > index) {
          var columnName = self.displayedColumns[index].name.toLowerCase();
          var columnTitle = self.displayedColumns[index].title;
          if (self.displayedColumns[index].noTitleInHeader === true) {
            columnTitle = '';
          }
          var searchOn = _.indexOf(self.columnsWithSearch, columnName);
          if (searchOn > -1 || self.displayedColumns[index].filterable === true) {
            var filterKey = self.displayedColumns[index].data &&
                            self.displayedColumns[index].data(undefined, 'filterBy');
            var searchbox = new SearchBoxView(self.collection.filters &&
                                              self.collection.filters[columnName], {
              column: filterKey,
              columnTitle: columnTitle
            });
            self.searchBoxes.push(searchbox);
            searchbox.on('change:filterValue', function (data) {
              self.applyFilter(data);
            });
            var searchWrapper = $(this).find('.csui-table-column-search');
            var textDiv = $(this).find('.csui-table-column-text');
            var sortEl = $(this).find('.csui-sort-arrow');
            searchbox.on('opened', function () {
              // remove the column header text and sort arrow to make room for the search box
              textDiv.addClass('binf-hidden');
              sortEl.addClass('binf-hidden');
              self.searchColumn = columnName;
            });
            searchbox.on('closed', function () {
              textDiv.removeClass('binf-hidden');
              sortEl.removeClass('binf-hidden');
              self.collection.filters[columnName] = undefined;
              /* if undefined, searchbox is closed */
            });
            searchbox.on('changed:focus', function () {
              if (self.tableCaptionView) {
                self.tableCaptionView._accSearchBoxFocused(
                    {columnName: columnName, columnIndex: index});
              }
            });
            searchbox.render();
            $(this).append(searchbox.el);
            if (columnName === self.searchColumn) {
              searchbox.setFocus();
            }

            searchWrapper = $(this).find('.csui-table-column-search');
            if (searchWrapper) {
              searchWrapper.attr('aria-label',
                  _.str.sformat(lang.searchIconTooltip, columnTitle.toLowerCase()));
            }
          }
        }
      }
    });
  }

  function selectRowsByNodeIds(selectedNodesById) {
    if (this.table && selectedNodesById) {
      _.each(this.table.rows(), function (rows) {
        _.each(rows, function (position) {
          var node = this.table.row(position).data();
          var id = node.id || node.get('id');
          if (selectedNodesById[id]) {
            var tt = getTableTools.call(this);
            var trNode = this.table.row(position).node();
            tt.fnSelect(trNode);
          }
        }, this);
      }, this);
    }
  }

  function updateSelectAllCheckbox() {
    if (this._selectAllCheckboxRegion && this._selectAllCheckboxRegion.currentView) {
      var checkboxView = this._selectAllCheckboxRegion.currentView;

      var selection = this.collection.filter(function (model) {
        return model.get(SelectCellView.isSelectedModelAttributeName);
      });
      var page = this.table ? this.table.rows().nodes() : this.collection;
      var all = selection.length === page.length;

      if (selection.length > 0 && !all) {
        checkboxView.setChecked('mixed');
      } else {
        checkboxView.setChecked(selection.length > 0);
      }
    }
  }

  function getNodes(rows) {
    return _.map(rows, function (row) {
      var position = this.table.row(row).index();
      return this.table.row(position).data();
    }, this);
  }

  function getSortableColumnNumber(name) {
    name = name.toLowerCase();
    var number;
    _.find(this.displayedColumns, function (column, index) {
      if (column.attributes.sort_key === name || column.name.toLowerCase() === name ||
          column.attributes.column_key === name) {
        number = index;
        return true;
      }
    });
    return number;
  }

  var averageWidth = 120; // assume an average of 120px width per column
  function calculateMaxColumnsDisplayed() {
    var maxColumnsDisplayed = 0, usedWidth = 0, widthFactor, width;
    var tableElements = this.$el.find('table.binf-table');
    if (tableElements.length > 0 && this.collection.length > 0) {
      var tableEl = $(tableElements[0]);
      var tw = tableEl.width();
      _.each(this.allColumns, function (column) {
        if (column.attributes) {
          if (column.attributes.permanentColumn === true) {
            widthFactor = column.attributes && column.attributes.widthFactor;
            width = widthFactor ? averageWidth * widthFactor : averageWidth;
            usedWidth += width;
            maxColumnsDisplayed++;
          }
        }
      }, this);
      for (var colno = 0; colno < this.allColumns.length; colno++) {
        var column = this.allColumns[colno], selectorWidth, childrenInNthColumn;
        if (column.attributes) {
          if (!column.attributes.permanentColumn) {
            widthFactor = column.attributes && column.attributes.widthFactor;
            selectorWidth = averageWidth;
            if (column.CellView.flexibleWidth) {
              childrenInNthColumn = tableEl.find('>tbody>tr>:nth-child(' + (colno + 1) + ')>*');
              if (childrenInNthColumn.length > 0) {
                selectorWidth = averageWidth;
              } else {
                selectorWidth = 0;
              }
            }
            width = widthFactor ? selectorWidth * widthFactor : selectorWidth;
            usedWidth += width;
            if (usedWidth > tw) {
              break;
            }
            maxColumnsDisplayed++;
          }
        }
      }
      if (maxColumnsDisplayed > this.options.maxColumnsDisplayed) {
        maxColumnsDisplayed = this.options.maxColumnsDisplayed;
      }
      if (maxColumnsDisplayed < 1) {
        maxColumnsDisplayed = 1;
      }
    } else {
      maxColumnsDisplayed = undefined;
    }
    return maxColumnsDisplayed;
  }

  function getColumns() {
    this.trigger("buildingColumnDefinitions", {
      sender: this
    });

    var cols = [];
    if (this.options.tableColumns) {
      var tableColumns = this.options.tableColumns.deepClone(); // use fresh collection every time
      var columnModelsByKey = {};
      var clientNamingKey, serverNamingKey;

      // add the columns that come from the server to the columns collection, which automatically
      // sort the items by sequence
      this.columns.each(function (nodeColumnModel) {
        // The server used to send columns without type.  It probably included also
        // those not ready for display yet.
        var key = nodeColumnModel.get("column_key");
        var order = nodeColumnModel.get("definitions_order");
        if (nodeColumnModel.get("isNaming") === true) {
          serverNamingKey = key;
          nodeColumnModel.unset('isNaming', {silent: true});
        }
        columnModelsByKey[key] = nodeColumnModel;
        if (nodeColumnModel.get("type") && order) {

          // search server defined column in client side defined columns
          var tableColumnToMergeWithServerColumn = tableColumns.findWhere({key: key});
          if (tableColumnToMergeWithServerColumn) {
            // column is defined on server and client side
            if (tableColumnToMergeWithServerColumn.get('isNaming') === true) {
              clientNamingKey = tableColumnToMergeWithServerColumn.get("key");
            }
            // use server side defined attributes, except for sequence
            var sequence = tableColumnToMergeWithServerColumn.get('sequence');
            var mergedColumnAttributes = _.extend({sequence: sequence}, nodeColumnModel.attributes);
            tableColumnToMergeWithServerColumn.set(mergedColumnAttributes);
          } else {
            // search cellViewRegistry to see if it is already registered in cellView other key(s)
            var keyRegistedInCellView = cellViewFactory.hasCellViewByOtherKey(key);
            if (!keyRegistedInCellView) {  // key not registered
              tableColumns.add({
                key: key,
                sequence: order,
                permanentColumn: false
              });
            }
          }
        }
      }, this);

      //Order of Preference for Naming Column. Client --> Server --> 'name'
      var namingKey = clientNamingKey || serverNamingKey || 'name';
      var sortedColumns = [];
      tableColumns.each(function (tableColumn) {
        var column_key = tableColumn.get('key');
        if (column_key === namingKey) {
          tableColumn.set('isNaming', true);
        }
        // must check for undefined in columns, which can happen if column is only in
        // tableColumns but not in this.columns, which is the case at the beginning
        // when the server has not delivered the columns
        if (columnModelsByKey[column_key]) {
          var colDef = columnModelsByKey[column_key];
          if (column_key === namingKey) {
            colDef.set('isNaming', true); // needed for factory to return cell view for naming column
          }
          var CellView = cellViewFactory.getCellView(colDef);
          // merge settings from CellView and tableColumn definition
          var propertiesToMerge = ['permanentColumn', 'noTitleInHeader', 'title', 'align',
            'widthFactor', 'isNaming'];
          _.each(propertiesToMerge, function (propName) {
            var propToMerge = tableColumn.get(propName);
            if (propToMerge) {
              colDef.set(propName, propToMerge, {silent: true});
            } else {
              if (CellView[propName]) {
                colDef.set(propName, CellView[propName], {silent: true});
              }
            }
          });
          sortedColumns.push(colDef);
        }
      }, this);

      //Get selectable columns not provided in the node definitions from server.
      //Make sure that there are columns returned before adding additional columns
      // to avoid grey box at the right corner of table header.
      if (sortedColumns.length > 0) {
        sortedColumns = getAdditionalColumns(this, sortedColumns);
      }

      cols = _.map(sortedColumns, function (definition) {
        var propertyName = definition.get("column_key"),
            CellView     = cellViewFactory.getCellView(definition);
        var column = {
          //added later: columnWrapped: definition.columnWrapped,
          CellView: CellView,
          name: propertyName,
          noTitleInHeader: definition.get('noTitleInHeader'),
          isNaming: definition.get('isNaming'), // if true, use this column for
          // inline-form, inline-actionbar, etc.
          title: definition.get('title') || definition.get('name'),
          orderable: !!definition.get("sort"),
          filterable: !!definition.get("filter"),
          className: CellView.columnClassName,
          defaultAction: definition.get("default_action"),
          contextualMenu: definition.get("contextual_menu"),
          data: function (source, type) {
            if (type === 'orderBy') {
              return definition.get('sort_key') ||
                     definition.get("column_key");
            }
            if (type === 'filterBy') {
              return definition.get('filter_key') ||
                     definition.get("column_key");
            }
            if (type === 'set') {
              throw new Error('Setting column value not implemented');
            } else {
              // The column handler has not been created yet; before the table
              // cell is rendered, the cell value can be obtaind for other
              // purposes (sorting) by a static method of the column handler
              return CellView.getValue(source, column);
            }
          },

          render: function () {
            // Rendering will be done by the column handler when the table
            // cell is added; the interface using a string with HTML markup
            // is not enough to support Backbone.View-based column handlers
            return '';
          }
        };

        var alignment = definition.get("align");
        if (alignment) {
          // FIXME: global csui identifier should not be used in controls
          if (window.csui && window.csui.rtl) {
            alignment === "left" && (alignment = "right") ||
            alignment === "right" && (alignment = "left");
          }
          column.className += " csui-align-" + alignment;
        }

        //For custom added columns, add the custom definition attributes to the column in order for
        //the values to be picked up by the node Model in the cell views.
        if (definition.attributes) {
          column.attributes = column.attributes || {};
          _.extend(column.attributes, definition.attributes);
        }
        return column;
      }, this);
    }

    this.allColumns = cols;
    this.displayedColumns = [];
    this.wrappedColumns = [];
    _.each(cols, function (colDef) {
      if (colDef.attributes && colDef.attributes.permanentColumn === true) {
        colDef.columnWrapped = false;
        this.displayedColumns.push(colDef);
      }
    }, this);

    if (this.allColumns.length) {
      // limit the columns by measuring the needed space of each column
      // and test how much fit into the table width
      setColumnsWrappedByAvailableWidth.call(this);
    }

    // console.log("Col. displayed: " + this.displayedColumns.length + ", wrapped: " +
    //             this.wrappedColumns.length);
    this.trigger("columnDefinitionsBuilt", {
      sender: this, columns: cols
    });
  }

  // determine which columns are not wrapped because they are marked as permanentColumn or
  // because there is enough space
  function setColumnsWrappedByAvailableWidth() {
    if (this.maxColumnsDisplayed || this.options.maxColumnsDisplayed) {

      var maxColumnsDisplayed = this.maxColumnsDisplayed || this.options.maxColumnsDisplayed;

      this.displayedColumns = [];
      this.wrappedColumns = [];

      // count all columns that are marked as permanent
      var colCount = 0;
      _.each(this.allColumns, function (colDef) {
        if (colDef.attributes && colDef.attributes.permanentColumn === true) {
          colDef.columnWrapped = false;
          colCount++;
        }
      }, this);

      if (accessibleTable) {
        this.displayedColumns = _.clone(this.allColumns);
        this.wrappedColumns = [];
      } else {
        // loop through all non permanent columns and determine those that still have space. all
        // others are marked as wrapped
        _.each(this.allColumns, function (colDef) {
          if (!colDef.attributes || colDef.attributes.permanentColumn !== true) {
            colCount++;
            if (maxColumnsDisplayed) {
              colDef.columnWrapped = (colCount > maxColumnsDisplayed);
            } else {
              colDef.columnWrapped = false; // have no maxColumnsDisplayed -> don't wrap
            }
          }
        }, this);

        this.displayedColumns = _.where(this.allColumns, {columnWrapped: false});
        this.wrappedColumns = _.where(this.allColumns, {columnWrapped: true});
      }
    }
  }

  function getAdditionalColumns(self, columns) {

    var options = self.options;

    if (options.selectColumn) {
      // Insert the row-selecting column as the first one
      columns.unshift(new NodeChildrenColumnModel({
        column_key: '_select',
        name: '',
        sortable: false,
        alignment: 'center',
        permanentColumn: true
      }));
    }

    if (options.additionalColumns && options.additionalColumns.length > 0) {
      _.each(options.additionalColumns, function (column, index) {
        columns.push(new NodeChildrenColumnModel(column));
      });
    }

    // Make the description column permanent for screen-reader users,
    // if it has not been added as a custom column.
    if (accessibleTable) {
      var hasCustomDescriptionColumn = columns.some(function (column) {
        return column.get("column_key") === 'description';
      });
      if (!hasCustomDescriptionColumn) {
        columns.push(new NodeChildrenColumnModel({
          column_key: 'description',
          name: lang.descriptionColumnTitle,
          sortable: false,
          permanentColumn: true
        }));
      }
    }

    // expand/collapse column at the very end
    if (options.haveDetailsRowExpandCollapseColumn) {
      // Append the column pointing to the node parent as the last one
      columns.push(new NodeChildrenColumnModel({
        column_key: '_toggledetails',
        name: '',
        sortable: false,
        alignment: 'center',
        permanentColumn: true
      }));
    }

    return columns;
  }

  function destroyTable() {
    if (this.table) {
      this.trigger("destroyingTable", {
        sender: this
      });
      this._inlineBarShouldDestroy();
      _.each(this.searchBoxes, function (sb) {
        sb.destroy();
      });
      this.searchBoxes.splice(0, this.searchBoxes.length);

      // @deprecated
      if (this._alternativeHeaderRegion) {
        this._alternativeHeaderRegion.empty();
        delete this._alternativeHeaderRegion;
      }

      if (this._selectAllCheckboxRegion) {
        this._selectAllCheckboxRegion.empty();
        delete this._selectAllCheckboxRegion;
      }
      delete this._detailRowsDescriptionTRs;
      delete this._detailRowViewsByModelId;

      this.table.destroy();
      cleanPlaceholder.call(this);
      delete this.table;
      delete this.tableTools;
      this.trigger("tableDestroyed", {
        sender: this
      });
    }
  }

  function cleanUpTableEventListeners() {
    _.each(this.csuiDestroyRowCallbacks, function (callBack) {
      callBack();
    });
    this.csuiDestroyRowCallbacks = [];
  }

  function cleanPlaceholder() {
    // There can be other child views appending their content.  Only
    // elements added by this object and not handled by Marionette should be
    // explicitly removed here.
    $("> table , > #message", this.$el).remove();
  }

  function saveStateBeforeRebuild() {
    var collection = this.collection;

    // TODO: Add more parameters we want to preserve when a rebuild comes.
    // (A container was entered with a different set of columns.) Add an
    // event or callback to enable adding parameters by extensions.

    var selectedRowsData = this.table.rows('.selected').data();
    var selectedNodesById = {};
    _.each(selectedRowsData, function (node) {
      selectedNodesById[node.id || node.get('id')] = true;
    });
    this.stateBeforeRebuild = {
      pageLength: (collection) ? collection.topCount : this.options.pageSize,
      selectedNodesById: selectedNodesById,
      currentScollPosition: this.$('tbody').scrollTop()
    };
  }

  function tryApplyingStateSavedBeforeRebuild(options) {
    if (this.stateBeforeRebuild) {
      _.extend(options, this.stateBeforeRebuild);
      delete this.stateBeforeRebuild;
    }
  }

  function fetchData(oTable, aoData, oSettings, fnCallback) {
    // The container can disable fetching the data, if the collection
    // doesn't have the full information available yet, but the
    // container has already rendered this view.
    if (this.refreshEnabled === false) {
      return;
    }
    // The first fetching request comes immediately after rendering the table,
    // but columns and children are not available yet.  Children can be fetched
    // from here, because the table directly controls the page to show, but
    // the columns shouldn't; they are owned by the parent of this view.
    // Let's wait until they are fetched; the parent is supposed to call the
    // rebuild method in such case.
    if (!(this.columns.length || this.columns.fetched)) {
      return;
    }

    // The following checks if anything was changed could return
    // false if the default collection settings matched the flags
    // retrieving the first node children page.
    var fetch = setOrder.call(this, aoData, oSettings);

    if (fetch) {
      this.collection.fetch();
    }

    var result = {
      sEcho: getDataParameter(aoData, "sEcho"),
      data: this.collection.models
    };
    this.trigger("settingServerData", {
      sender: this,
      result: result
    });
    fnCallback(result);
  }

  // TODO: Deprecate and remove this.  The client-side mixin does not need this.
  function clientSideUpdateData(oTable, aoData, oSettings, fnCallback) {
    if (!this.options.clientSideDataOperation) {
      return;
    }

    setOrder.call(this, aoData, oSettings);

    var result = {
      sEcho: getDataParameter(aoData, "sEcho"),
      data: this.collection.models
    };
    this.trigger("settingServerData", {
      sender: this, result: result
    });
    fnCallback(result);
  }

  function delegateClickAction(event, kind) {
    event.preventDefault();
    event.stopPropagation();
    var target = $(event.target);
    var tr = target.closest("tr");
    var position = tr[0]._DT_RowIndex;  // can't use tr.index() because detail rows (datatable
    // child) insert additional rows

    if (position !== undefined) {
      var node = this.table.row(position).data();
      this.trigger("click" + kind + "Action", {
        sender: this, target: target[0], node: node, event: event
      });
    }
  }

  function setOrder(aoData, oSettings) {
    var columns = oSettings.aoColumns;
    var orderBy = [];
    var api = oSettings.oInstance.api();
    var table = api.table();
    _.each(table.order(), function (orderinfo) {
      var sortColumnIndex = orderinfo[0];
      var sortColumnKey = columns[sortColumnIndex].data(undefined,
          'orderBy');
      if (sortColumnKey) {
        if (orderinfo[1]) {
          orderBy.push(sortColumnKey + " " + orderinfo[1]);
        } else {
          orderBy.push(sortColumnKey);
        }
      }
    });

    // Reset the Aria information manually [due to a bug in the pre-v1.10 version of dataTables]
    //var nTh = oSettings.columns[sortColumnIndex].nTh;
    //var title = oSettings.columns[sortColumnIndex].title.replace( /<.*?>/g, "" );
    //
    //nTh.removeAttribute('aria-sort');
    //nTh.removeAttribute('aria-label');
    //nTh.setAttribute('aria-sort', direction=="asc" ? "ascending" : "descending" );
    //nTh.setAttribute('aria-label', title + (direction != "asc" ? oSettings.oLanguage.oAria.sSortAscending : oSettings.oLanguage.oAria.sSortDescending) );

    if (orderBy.length) {
      // set order at collection but don't fetch immediately
      return this.collection.setOrder(orderBy.join(), false);
    } else {
      // don't sort the collection when no orderBy criterias are available
      return false;
    }
  }

  function getDataParameter(aoData, name) {
    return aoData ? aoData[name] : undefined;
  }

  _.extend(TableView.prototype, ViewEventsPropagationMixin);
  _.extend(TableView.prototype, GlobalAlertMixin);
  TableView.prototype._eventsToPropagateToViews.push('clicked:cell');

  return TableView;
})
;


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.list/impl/table.list.row',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "  <div class=\"csui-table-cell csui-table-cell-"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.name : depth0), depth0))
    + " "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0['class'] : depth0), depth0))
    + "\" role=\"cell\"></div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    return "  <div class=\"csui-table-extra-cols csui-column-wrapped\" role=\"cell\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.columns : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.hasWrappedColumns : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table.list_impl_table.list.row', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.list/impl/table.list.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.noTitleInHeader : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(7, data, 0)})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isToolbar : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(5, data, 0)})) != null ? stack1 : "");
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-table-header-cell csui-table-header-toolbar\" tabindex=\"-1\"\r\n           data-cstabindex=\"-1\" role=\"columnheader\">\r\n        <span class=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.className : depth0), depth0))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.addTitle || (depth0 != null ? depth0.addTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"addTitle","hash":{}}) : helper)))
    + "\"></span>\r\n      </div>\r\n";
},"5":function(depth0,helpers,partials,data) {
    return "      <div class=\"csui-table-header-cell "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.className : depth0), depth0))
    + "\" role=\"columnheader\"></div>\r\n";
},"7":function(depth0,helpers,partials,data) {
    return "    <div class=\"csui-table-header-cell "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.className : depth0), depth0))
    + "\" title=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.title : depth0), depth0))
    + "\" tabindex=\"-1\"\r\n         data-cstabindex=\"-1\" role=\"columnheader\">\r\n      <div class=\"csui-table-header-cell-container csui-fadeout\">\r\n        <span>\r\n          "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.title : depth0), depth0))
    + "\r\n        </span>\r\n      </div>\r\n    </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.columns : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\r\n\r\n";
}});
Handlebars.registerPartial('csui_controls_table.list_impl_table.list.header', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.list/impl/table.list',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-table-list-header\" role=\"rowgroup\"></div>\r\n<div class=\"csui-table-list-body\"></div>";
}});
Handlebars.registerPartial('csui_controls_table.list_impl_table.list', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.list/impl/empty.table',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return this.escapeExpression(((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"message","hash":{}}) : helper)));
}});
Handlebars.registerPartial('csui_controls_table.list_impl_empty.table', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table.list/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table.list/impl/nls/root/lang',{
  addTitle: 'Add'
});



csui.define('css!csui/controls/table.list/impl/table.list',[],function(){});
csui.define('csui/controls/table.list/table.list.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/utils/commands',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  "csui/controls/table/cells/cell.factory",
  'csui/controls/progressblocker/blocker',
  'csui/controls/globalmessage/globalmessage',
  'csui/controls/tableactionbar/tableactionbar.view',
  'csui/controls/table/rows/metadata/metadatarow.view',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/controls/table.list/impl/table.list.row',
  'hbs!csui/controls/table.list/impl/table.list.header',
  'hbs!csui/controls/table.list/impl/table.list',
  'hbs!csui/controls/table.list/impl/empty.table',
  'i18n!csui/controls/table.list/impl/nls/lang',
  'css!csui/controls/table.list/impl/table.list', 'csui/lib/jquery.mousehover'
], function (_, $, Backbone, Marionette, base, commands, LayoutViewEventsPropagationMixin,
    cellViewFactory, BlockingView, GlobalMessage, TableActionBarView, MetadataRowView,
    PerfectScrollingBehavior, TabableRegionBehavior, tableRowTemplate, tableHeaderTemplate,
    tableTemplate, emptyTableTemplate, lang) {
  'use strict';

  var EmptyTableView = Marionette.ItemView.extend({

    className: 'csui-table-empty',
    template: emptyTableTemplate,

    constructor: function EmptyTableView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    templateHelpers: function () {
      var emptyText = this.options.emptyTableText;
      return {
        message: emptyText
      };
    }
  });

  var TableRowView = Marionette.LayoutView.extend({

    className: 'csui-table-row',

    attributes: function () {
      return {role: 'row'};
    },

    tagName: 'div',

    template: tableRowTemplate,

    events: {
      'focusin .csui-table-cell': 'onFocusInTableCell',
      'blur .csui-table-cell': 'onFocusOutTableCell'
    },

    templateHelpers: function () {
      return {
        columns: this.options.columns,
        hasWrappedColumns: (this.options.wrappedColumns && this.options.wrappedColumns.length > 0)
      };
    },

    constructor: function TableRowView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
    },

    initialize: function () {
      var self = this;
      if (this.options.columns) {
        _.each(this.options.columns, function (column) {
          if (column.CellView) {
            var region = column.name;
            self.addRegion(region, ".csui-table-cell-" + region);
          }
        }, this);
      }

      if (this.options.wrappedColumns && this.options.wrappedColumns.length > 0) {
        self.addRegion('csui-column-wrapped', '.csui-column-wrapped');
      }

    },

    onRender: function () {
      var self = this;
      if (this.options.columns) {
        _.each(this.options.columns, function (column, index) {
          if (column.CellView) {
            var region = column.name;
            var cellView = new column.CellView({
              tagName: 'DIV',
              model: self.model,
              context: self.options.context,
              applyTo: self.options.applyTo,
              column: column,
              originatingView: self.options.originatingView
            });
            self[region].show(cellView);
            self.listenTo(cellView, 'clicked:cell', function (event) {
              self.trigger('clicked:cell', {
                cellView: cellView,
                rowIndex: self._index,
                colIndex: index,
                model: self.model
              });
            });
          }
        }, this);
      }

      if (this.options.wrappedColumns && this.options.wrappedColumns.length > 0) {
        var metadataRowView = new MetadataRowView({
          context: this.options.context,
          model: this.model,
          columns: this.options.wrappedColumns
        });
        this['csui-column-wrapped'].show(metadataRowView);
      }

      if (!base.isTouchBrowser() && this.options.showInlineToolbar && this.$el) {
        this._subscribeEventHandlers();
      }

      if (base.isTouchBrowser() && this.options.showInlineToolbar) {
        this._showInlineRowActions();
      }
    },

    _showInlineRowActions: function () {
      var inlineToolbarContainer = this.$el.find('.csui-row-inlinetoolbar').removeClass(
          "binf-hidden"),
          membersTypeSupport     = [0, 1];
      //TODO: Once REST API supports we will provide action for project members and Guests actions
      if (this.model.get('permissions') === null || !this.options.hasEditPermission ||
          (membersTypeSupport.indexOf(
              this.model.get("right_id_expand") && this.model.get("right_id_expand").type) < 0 &&
           this.model.get("type") === "custom")) {
        this.$el.find('.csui-row-inlinetoolbar').addClass("binf-hidden");
      }
      if (inlineToolbarContainer.length === 0 || this.inlineRowToolbarView !== undefined) {
        return;
      }
      this.inlineRowToolbarView = new TableActionBarView(_.extend({
            context: this.options.context,
            commands: commands,
            collection: this.options.toolbarItems.inlineToolbar,
            toolItemsMask: this.options.toolbarItemsMasks.toolbars.inlineToolbar,
            originatingView: this.options.originatingView,
            model: this.model,
            applyTo: this.options.applyTo,
            status: {
              model: this.model,
              targetView: this,
              connector: this.options.connector,
              applyTo: this.options.applyTo
            }
          }, this.options.toolbarItems.inlineToolbar.options, {maxItemsShown: 1})
      );

      this.listenTo(this.inlineRowToolbarView, 'before:execute:command', function (eventArgs) {
        //If targetView is given, highlight the targetView i.e. selected row of table list view
        if (eventArgs && eventArgs.status && eventArgs.status.targetView &&
            eventArgs.status.targetView.$el) {
          eventArgs.status.targetView.$el.addClass("active-row");
        }
        this.trigger('before:execute:action', eventArgs);
      });
      this.listenTo(this.inlineRowToolbarView, 'after:execute:command', function (eventArgs) {
        //If targetView is given, Remove highlighting from the targetView i.e. selected row
        if (eventArgs && eventArgs.status && eventArgs.status.targetView &&
            eventArgs.status.targetView.$el) {
          eventArgs.status.targetView.$el.removeClass("active-row");
        }
        this.trigger('after:execute:action', eventArgs);
      });

      if (this.options.originatingView) {
        this.listenTo(this.options.originatingView, "block:view:actions", function () {
          this.trigger('before:execute:action');
        });
        this.listenTo(this.options.originatingView, "unblock:view:actions", function () {
          this.trigger('after:execute:action');
        });
      }

      this.inlineRowToolbarView.render();
      inlineToolbarContainer.append(this.inlineRowToolbarView.$el);
      this.inlineRowToolbarView.triggerMethod("show");

    },

    _destroyInlineRowActionBar: function () {
      if (this.inlineRowToolbarView) {
        this.inlineRowToolbarView.destroy();
        this.inlineRowToolbarView = undefined;
        if (!!this.$el.find('active-row')) {
          this.$el.removeClass('active-row');
        }
      }
    },

    onBeforeRender: function () {
      if (!base.isTouchBrowser() && this.options.showInlineToolbar) {
        this._unsubscribeEventHandlers();
      }
    },

    onBeforeDestroy: function () {
      if (this.options.showInlineToolbar) {
        if (!base.isTouchBrowser()) {
          this._unsubscribeEventHandlers();
        } else {
          this._destroyInlineRowActionBar();
        }
      }
    },

    _subscribeEventHandlers: function () {
      this.$el && this.$el.mousehover(
          this.showInlineActions.bind(this),
          this.hideInlineActions.bind(this),
          {namespace: this.cid});
    },

    _unsubscribeEventHandlers: function () {
      if (this._isRendered) {
        this.$el.mousehover('off', {namespace: this.cid});
      }
    },

    showInlineActions: function (e) {
      var membersTypeSupport = [0, 1];
      if (membersTypeSupport.indexOf(
              this.model.get("right_id_expand") && this.model.get("right_id_expand").type) < 0 &&
          this.model.get("type") === "custom") {
        //TODO: Once REST API supports we will provide action for project members and Guests actions
        this.$el.find('.csui-inlinetoolbar').addClass("binf-hidden");
      } else {
        var inlineToolbarContainer = this.$el.find('.csui-inlinetoolbar').removeClass(
            "binf-hidden");
        if (inlineToolbarContainer.length > 0) {
          var self = this,
              args = {
                sender: self,
                target: inlineToolbarContainer,
                model: self.model
              };
          self.trigger("mouseenter:row", args);
        }
      }
    },

    hideInlineActions: function (e) {
      var inlineToolbarContainer = this.$el.find('.csui-inlinetoolbar').addClass("binf-hidden");

      if (inlineToolbarContainer.length > 0) {
        var self = this,
            args = {
              sender: self,
              target: inlineToolbarContainer,
              model: self.model
            };
        self.trigger("mouseleave:row", args);
      }
    },

    onFocusInTableCell: function (event) {
      if (this.options.showInlineToolbar) {
        this._showInlineRowActions();
      }
    },

    onFocusOutTableCell: function (event) {
      if (this.options.showInlineToolbar) {
        /*Since dropdown inside toolbar cell triggers focusout event, which destroys inline
         actions if it gets executed immediately. To avoid it adding setTimeout. */
        setTimeout(_.bind(function () {
          if (this.$el.find(document.activeElement).length === 0 && !base.isTouchBrowser()) {
            this._destroyInlineRowActionBar();
          }
        }, this), 50);
      }
    }

  });

  var TableHeaderView = Marionette.ItemView.extend({

    className: 'csui-table-header',

    attributes: function () {
      return {role: 'row'};
    },

    tagName: 'div',

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior,
        initialActivationWeight: 100
      }
    },

    events: {
      "keydown": "onKeyInView"
    },

    template: tableHeaderTemplate,

    templateHelpers: function () {
      var userPermissions = this.options.userPermissionsModel &&
                            this.options.userPermissionsModel.get("permissions"),
          isToolbar       = _.contains(userPermissions, 'edit_permissions');
      return {
        columns: this.options.columns,
        addTitle: lang.addTitle,
        isToolbar: this.options.admin_permissions || isToolbar
      };
    },

    constructor: function TableHeaderView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.call(this, options);

    },

    onRender: function () {
      this.focusIndex = 0;
      this._columnCount = this.options.columns.length;
      this._toolbarHeaderColumnCount = 0;
      /*Maintain toolbar column count to handle Key focus issue*/
      var userPermissions = this.options.userPermissionsModel &&
                            this.options.userPermissionsModel.get("permissions");
      if (!this.options.admin_permissions && !_.contains(userPermissions, 'edit_permissions')) {
        for (var i = 0; i < this._columnCount; i++) {
          var column = this.options.columns[i];
          if (!column.isToolbar) {
            this._toolbarHeaderColumnCount++;
          }
          if (column.attributes.containsInlineActions !== undefined) {
            column.attributes.containsInlineActions = false;
          }
        }
      } else {
        this._toolbarHeaderColumnCount = this._columnCount;
      }
    },

    currentlyFocusedElement: function () {
      var focusedEl = this.$el.find(".csui-table-header-cell").eq(this.focusIndex);
      return focusedEl;
    },

    onKeyInView: function (event) {
      var changeFocus = true;
      switch (event.keyCode) {

      case 37: // Left Arrow
        if (this.focusIndex > 0) {
          this.focusIndex--;
        }
        break;

      case 39: // Right Arrow
        if (this.focusIndex < this._toolbarHeaderColumnCount - 1) {
          this.focusIndex++;
        }
        break;

      default:
        changeFocus = false;
      }

      if (changeFocus) {
        event.preventDefault();
        event.stopPropagation();
        this.$el.find(".csui-table-header-cell").eq(this.focusIndex).focus();
      }
    }

  });

  var TableBodyView = Marionette.CollectionView.extend({

    className: 'csui-table-body',

    attributes: function () {
      return {role: 'rowgroup'};
    },

    childView: TableRowView,

    childEvents: {
      'mouseenter:row': 'onChildShowInlineActionBarWithDelay',
      'mouseleave:row': 'onChildActionBarShouldDestroy',
      'clicked:cell': 'onClickedCell'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior,
        initialActivationWeight: 100
      }
    },

    events: {
      "keydown": "onKeyInView"
    },

    childViewOptions: function () {
      return {
        context: this.options.context,
        columns: this.options.columns,
        wrappedColumns: this.options.wrappedColumns,
        showInlineToolbar: this.showInlineToolbar,
        toolbarItems: this.options.toolbarItems,
        toolbarItemsMasks: this.options.toolbarItemsMasks,
        connector: this.options.collection.connector,
        originatingView: this.options.originatingView,
        applyTo: this.options.applyTo,
        hasEditPermission: this.hasEditPermissionUser(this.collection) ||
                           this.options.admin_permissions
      };
    },

    getEmptyView: function () {
      if (this.options.emptyView) {
        return this.options.emptyView;
      } else {
        return EmptyTableView;
      }
    },

    emptyViewOptions: function () {
      if (this.options.emptyView) {
        return {
          model: this.options.emptyViewModel
        };
      } else {
        return this.options;
      }
    },

    constructor: function TableBodyView(options) {
      Marionette.CollectionView.prototype.constructor.call(this, options);
      this.showInlineToolbar = (this.options.toolbarItems && this.options.toolbarItemsMasks);
      if (this.showInlineToolbar) {
        this.setInlineActionBarEvents();
      }
    },

    onRender: function () {
      this.nameColumnIndex = this.getNameColumnIndex(this.options.columns) || 0;
      this.accFocusedCell = this.options.accFocusedCell || {column: this.nameColumnIndex, row: 0};
      this.columnState = 0;
      this._columnCount = this.options.columns.length;
      this._toolbarColumnCount = 0;
      /*Maintain toolbar column count to handle Key focus issue*/
      this.hasEditPermission = this.hasEditPermissionUser(this.collection) ||
                               this.options.admin_permissions;
      if (!this.hasEditPermission) {
        for (var i = 0; i < this._columnCount; i++) {
          var column = this.options.columns[i];
          if (column.isToolbar) {
            this._toolbarColumnCount++;
          }
        }
      }
    },

    hasEditPermissionUser: function (collection) {
      var userPermissions = collection.options &&
                            collection.options.authenticatedUserPermissions,
          permissions     = userPermissions.get("permissions");
      return _.contains(permissions, 'edit_permissions');
    },

    setInlineActionBarEvents: function () {
      this.listenTo(this, 'closeOther', this._destroyInlineActionBar);
      this.listenTo(this.collection, "reset", this._destroyInlineActionBar);
    },

    _showInlineActionBar: function (args) {
      if (this.inlineToolbarView) {
        this._savedHoverEnterArgs = args;
        // ignore until action bar removed itself
      } else if (!!args) {
        this._savedHoverEnterArgs = null;

        this.inlineToolbarView = new TableActionBarView(_.extend({
              context: this.options.context,
              commands: commands,
              collection: this.options.toolbarItems.inlineToolbar,
              toolItemsMask: this.options.toolbarItemsMasks.toolbars.inlineToolbar,
              originatingView: this.options.originatingView,
              applyTo: this.options.applyTo,
              model: args.model,
              status: {
                model: args.model,
                targetView: args.sender,
                connector: this.options.collection.connector,
                filterId: this.options.memberFilter.get("id"),
                applyTo: this.options.applyTo,
                admin_permissions: this.options.admin_permissions
              },
              customError: true
            }, this.options.toolbarItems.inlineToolbar.options)
        );

        this.listenTo(this.inlineToolbarView, 'before:execute:command', function (eventArgs) {
          this.lockedForOtherContols = true;
          //If targetView is given, highlight the targetView i.e. selected row of table list view
          if (eventArgs && eventArgs.status && eventArgs.status.targetView &&
              eventArgs.status.targetView.$el) {
            eventArgs.status.targetView.$el.addClass("active-row");
          }
          this._destroyInlineActionBar();
        });
        this.listenTo(this.inlineToolbarView, 'after:execute:command', function (eventArgs) {
          this.lockedForOtherContols = false;
          //If targetView is given, Remove highlighting from the targetView i.e. selected row
          if (eventArgs && eventArgs.status && eventArgs.status.targetView &&
              eventArgs.status.targetView.$el) {
            eventArgs.status.targetView.$el.removeClass("active-row");
          }
          this._toolbarActionTriggered(eventArgs);
        });

        if (this.options.originatingView) {
          this.listenTo(this.options.originatingView, "block:view:actions", function () {
            this.lockedForOtherContols = true;
            this._destroyInlineActionBar();
          });
          this.listenTo(this.options.originatingView, "unblock:view:actions", function () {
            this.lockedForOtherContols = false;
          });
        }

        this.inlineToolbarView.render();
        this.listenTo(this.inlineToolbarView, 'destroy', function () {
          this.inlineToolbarView = undefined;
          if (this._savedHoverEnterArgs) {
            this.onChildShowInlineActionBarWithDelay(this._savedHoverEnterArgs);
          }
        }, this);
        $(args.target).append(this.inlineToolbarView.$el);
        this.inlineToolbarView.triggerMethod("show");
      }
    },

    onChildShowInlineActionBarWithDelay: function (childView, args) {
      if (this._showInlineActionbarTimeout) {
        clearTimeout(this._showInlineActionbarTimeout);
      }
      var self = this;
      this._showInlineActionbarTimeout = setTimeout(function () {
        self._showInlineActionbarTimeout = undefined;
        if (!self.lockedForOtherContols) {
          // don't show the action bar control if the searchresult view is locked because a different
          // control is already open
          self._showInlineActionBar.call(self, args);
        }
      }, 200);
    },

    onChildActionBarShouldDestroy: function (childView, args) {
      if (this._showInlineActionbarTimeout) {
        clearTimeout(this._showInlineActionbarTimeout);
        this._showInlineActionbarTimeout = undefined;
      }
      if (this.inlineToolbarView) {
        this.inlineToolbarView.destroy();
      }
    },

    onChildviewBeforeExecuteAction: function () {
      if (base.isTouchBrowser()) {
        //Disable all inline actions
        this.children.each(function (childview, index) {
          if (childview.inlineRowToolbarView && childview.inlineRowToolbarView.$el) {
            childview.inlineRowToolbarView.$el.addClass('binf-disabled');
          }
        });
      }
    },

    onChildviewAfterExecuteAction: function () {
      if (base.isTouchBrowser()) {
        //Enable all inline actions
        this.children.each(function (childview, index) {
          if (childview.inlineRowToolbarView && childview.inlineRowToolbarView.$el) {
            childview.inlineRowToolbarView.$el.removeClass('binf-disabled');
            if (!!childview.$el.find('active-row')) {
              childview.$el.removeClass('active-row');
            }
          }
        });
      }
    },

    _destroyInlineActionBar: function () {
      if (this.inlineToolbarView) {
        this.inlineToolbarView.destroy();
        this.inlineToolbarView = undefined;
      }
    },

    // controller for the toolbar actions
    _toolbarActionTriggered: function (context) {
      if (context && context.commandSignature) {
        this.trigger('after:action:execute', context);
      }
      //return focus to the cell after closing popover
      this.currentlyFocusedElement().focus();

    },

    currentlyFocusedElement: function () {
      if (this.collection.length > 0 && this.accFocusedCell.column != null) {
        var rowView = this.children.findByIndex(this.accFocusedCell.row);
        return rowView && rowView.$el.find(
                '.csui-table-cell:nth-child(' + (this.accFocusedCell.column + 1) + ')').children(
                'DIV');
      }
      return $();
    },

    onClickedCell: function (childView, args) {
      this.accFocusedCell.row = args.rowIndex;
      if (args.colIndex < this._columnCount - this._toolbarColumnCount) {
        this.accFocusedCell.column = args.colIndex;
      } else {
        //Set focus on last non-toolbar cell
        this.accFocusedCell.column = this._columnCount - this._toolbarColumnCount - 1;
      }
      this._accSetFocusToCurrentlyFocusedElement();
    },

    onKeyInView: function (event) {
      var changeFocus = true;
      var currentlyFocusedElement = this.currentlyFocusedElement();
      var initialFocusIndex,
          dropDownEle,
          dropDownEleIndex;
      switch (event.keyCode) {
      case 33:  // Page Up Key > goto first row
        this.accFocusedCell.row = 0;
        break;

      case 34:  // Page Down Key > goto last row
        if (this.collection.length > 0) {
          this.accFocusedCell.row = this.collection.length - 1;
        } else {
          this.accFocusedCell.row = 0;
        }
        break;

      case 35:  // END key > goto rightmost column
        this.accFocusedCell.column = this._columnCount - this._toolbarColumnCount - 1;
        break;

      case 36:  // POS1 key > goto first column
        this.accFocusedCell.column = 0;
        break;

      case 37: // Left Arrow
        if (this.accFocusedCell.column > 0) {
          initialFocusIndex = this.accFocusedCell.column;
          this.accFocusedCell.column--;
          currentlyFocusedElement = this.currentlyFocusedElement();
          if (currentlyFocusedElement.attr('data-csui-empty-cell') === 'true' &&
              currentlyFocusedElement.children().length < 1) {
            var focusable = this._getNextFocusableElementIndex(37, --this.accFocusedCell.column);
            if (focusable >= 0) {
              this.accFocusedCell.column = focusable;
            }
            else {
              this.accFocusedCell.column = initialFocusIndex;
            }
          }
        }
        break;

      case 38: // Up Arrow
        if (this.$('.binf-dropdown-toggle').parent('.binf-dropdown').hasClass('binf-open')) {
          dropDownEle = this.$('.binf-dropdown-menu li').length - 1,
              dropDownEleIndex = $(document.activeElement.parentElement).index();
          if (dropDownEle <= dropDownEleIndex) {
            dropDownEleIndex = dropDownEleIndex - 1;
            this.$(this.$('.binf-dropdown-menu li a')[dropDownEleIndex]).focus().focus();
          }
          changeFocus = false;
          break;
        }

        if (this.accFocusedCell.row > 0) {
          initialFocusIndex = this.accFocusedCell.column;
          this.accFocusedCell.row--;
          currentlyFocusedElement = this.currentlyFocusedElement();
          if (currentlyFocusedElement.attr('data-csui-empty-cell') === 'true' &&
              currentlyFocusedElement.children().length < 1) {
            this.accFocusedCell.row = initialFocusIndex;
          }
        }
        break;

      case 39: // Right Arrow
        if (this.accFocusedCell.column < this._columnCount - this._toolbarColumnCount - 1) {
          initialFocusIndex = this.accFocusedCell.column;
          this.accFocusedCell.column++;
          currentlyFocusedElement = this.currentlyFocusedElement();
          if (currentlyFocusedElement.attr('data-csui-empty-cell') === 'true' &&
              currentlyFocusedElement.children().length < 1) {
            this.accFocusedCell.column = initialFocusIndex;
          }
        }
        break;

      case 40: // Down Arrow
        if (this.$('.binf-dropdown-toggle').parent('.binf-dropdown').hasClass('binf-open')) {
          dropDownEle = this.$('.binf-dropdown-menu li').length - 1,
              dropDownEleIndex = $(document.activeElement.parentElement).index();
          if (dropDownEle > dropDownEleIndex) {
            dropDownEleIndex = dropDownEleIndex + 1;
            this.$(this.$('.binf-dropdown-menu li a')[dropDownEleIndex]).focus().focus();
          }
          changeFocus = false;
          break;
        }

        if (this.accFocusedCell.row < this.collection.length - 1) {
          initialFocusIndex = this.accFocusedCell.row;
          this.accFocusedCell.row++;
        }
        break;

      default:
        changeFocus = false;

      }

      if (changeFocus) {
        event.preventDefault();
        event.stopPropagation();
        this.trigger('closeOther'); // force inline bar to close
        this._accSetFocusToCurrentlyFocusedElement();
      }
    },
    _getNextFocusableElementIndex: function (modifyCellIndex, index) {
      var currentlyFocusedElement = this.currentlyFocusedElement();
      switch (modifyCellIndex) {
      case 37:
        if (this.accFocusedCell.column >= 0 &&
            currentlyFocusedElement.attr('data-csui-empty-cell') === 'true') {
          return index;
        }
        else {
          return -1;
        }
        break;

      default :
        return -1;
      }
    },

    _accSetFocusToCurrentlyFocusedElement: function () {
      var el = this.currentlyFocusedElement();
      if (el.length > 0) {
        el = $(el[0]);
        this.trigger('changed:focus', this);
        if (base.isVisibleInWindowViewport(el)) {
          el.focus();
        }
      }
    },

    getNameColumnIndex: function (displayedColumns) {
      if (!displayedColumns) {
        // skip rest of function if no columns are displayed
        return undefined;
      }

      for (var colIdx = 0; colIdx < displayedColumns.length; colIdx++) {
        var column = displayedColumns[colIdx];
        if (column.isNaming) {
          return colIdx;
        }
      }
      return undefined;
    }

  });

  var TableListView = Marionette.LayoutView.extend({

    className: 'csui-table-list',

    attributes: function () {
      return {role: 'table'};
    },

    template: tableTemplate,

    regions: {
      headerRegion: '.csui-table-list-header',
      bodyRegion: '.csui-table-list-body'
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.csui-table-list-body',
        suppressScrollX: true
      }
    },

    constructor: function TableListView(options) {
      options || (options = {});
      options.maxColumnsDisplayed || (options.maxColumnsDisplayed = 10);
      options.tableColumns || (options.tableColumns = []);

      Marionette.LayoutView.prototype.constructor.call(this, options);
      this.context = options.context;
      this.collection = options.collection;

      this.listenTo(this.collection.delayedActions, 'error',
          function (collection, request, options) {
            var error = new base.Error(request);
            GlobalMessage.showMessage('error', error.message);
          });

      this.listenTo(this.collection, 'sync', this._updateTable);
      this.listenTo(this.collection, "update", this.render);
      this.listenTo(this, "update:table", this._updateTable);

      this.onTableWinResize = _.bind(function (event) {
        this._adjustColumnsAfterWindowResize();
        this.trigger('resizetable', event);
      }, this);
      $(window).bind("resize", this.onTableWinResize);
      //Adjust permission table colums on clicking toggle icon
      $(window).bind("resize.tableview", this.onTableWinResize);
    },

    onBeforeDestroy: function () {
      $(window).unbind("resize", this.onTableWinResize);
    },
    //return focus to the cell after refresh
    _updateTable: function (collectionOrModel) {
      if (!!this.tableBodyView && !!this.tableBodyView.accFocusedCell) {
        var row    = this.tableBodyView.accFocusedCell.row,
            column = this.tableBodyView.accFocusedCell.column;
        if (collectionOrModel === this.collection) {
          this.render();
        } else {
          this.tableBodyView.children.findByModel(collectionOrModel).render();
          this.triggerMethod('dom:refresh');
        }
        this.tableBodyView.accFocusedCell.row = row;
        this.tableBodyView.accFocusedCell.column = column;
        this.tableBodyView.trigger('changed:focus', this.tableBodyView);
      }
      else {
        this.render();
      }

    },

    onRender: function () {
      this.allColumns = this.getColumns();
      this.displayedColumns = _.where(this.allColumns, {columnWrapped: false});
      this.wrappedColumns = _.where(this.allColumns, {columnWrapped: true});
      this.tableHeaderView = new TableHeaderView({
        columns: this.displayedColumns,
        context: this.context,
        admin_permissions: this.options.admin_permissions,
        userPermissionsModel: this.collection.options.authenticatedUserPermissions,
        hasPermissionAction: !!this.options.hasPermissionAction
      });
      this.headerRegion.show(this.tableHeaderView);

      this.tableBodyView = new TableBodyView(_.defaults({
        columns: this.displayedColumns,
        wrappedColumns: this.wrappedColumns,
        context: this.context,
        collection: this.collection,
        toolbarItems: this.options.toolbarItems,
        toolbarItemsMasks: this.options.toolbarItemsMasks,
        emptyView: this.options.emptyView,
        emptyViewModel: this.options.emptyViewModel
      }, this.options));

      this.bodyRegion.show(this.tableBodyView);

      // perfect scrollbar stops 'scroll' event propagation, trigger it for elements to listen to
      var self = this;
      this.$el.find('.csui-table-list-body').bind('scroll', function (event) {
        self.trigger('scroll', event);
      });

      this._rebuildingTable = false;
    },

    onBeforeRender: function () {
      this._rebuildingTable = true;
    },

    onDomRefresh: function (event) {
      if (this.$el.is(':visible')) {
        this._adjustColumnsAfterWindowResize();
        this.trigger('resizetable', event);
      }
    },

    getColumns: function () {
      var cols = [], self = this;
      if (this.options.tableColumns) {
        var tableColumns = this.options.tableColumns.deepClone(); // use fresh collection every time

        // use only those columns that are referenced in the tableColumns collection,
        // which is sorted by sequence
        var sortedColumns = [];
        tableColumns.each(function (tableColumn) {
          var colDef     = tableColumn,
              column_key = tableColumn.get('key');
          tableColumn.attributes.column_key = column_key;

          sortedColumns.push(colDef);

        }, this);

        cols = _.map(sortedColumns, function (definition) {
          var CellView        = cellViewFactory.getCellView(definition),
              propertyName    = definition.get("column_key"),
              columnClassName = CellView.columnClassName;
          if (!columnClassName) {
            columnClassName = "csui-table-cell-" + propertyName;
          }

          // merge settings from CellView and tableColumn definition
          var propertiesToMerge = ['permanentColumn', 'noTitleInHeader', 'title', 'align',
            'widthFactor', 'isNaming', 'containsInlineActions'];
          _.each(propertiesToMerge, function (propName) {
            if (CellView[propName]) {
              definition.set(propName, CellView[propName], {silent: true});
            }
          });
          var column = {
            CellView: CellView,
            name: propertyName,
            noTitleInHeader: definition.get('noTitleInHeader'),
            isToolbar: definition.get('isToolbar'),
            title: definition.get('title') || definition.get('name') ||
                   definition.get("column_name"),
            className: columnClassName
          };

          var alignment = definition.get("align");
          if (alignment) {
            // FIXME: global csui identifier should not be used in controls
            if (window.csui && window.csui.rtl) {
              alignment === "left" && (alignment = "right") ||
              alignment === "right" && (alignment = "left");
            }
            column.className += " csui-align-" + alignment;
          }

          //For custom added columns, add the custom definition attributes to the column in order for
          //the values to be picked up by the node Model in the cell views.
          if (definition.attributes) {
            column.attributes = column.attributes || {};
            _.extend(column.attributes, definition.attributes);
          }

          return column;
        });
      }

      if (this.options.maxColumnsDisplayed || this.maxColumnsDisplayed) {
        var colCount = 0;
        // count all columns that must not be wrapped
        _.each(cols, function (colDef) {
          if (colDef.attributes && colDef.attributes.permanentColumn === true) {
            colCount++;
            colDef.columnWrapped = false;
          }
        }, this);

        this.maxColumnsDisplayed = this.calculateMaxColumnsDisplayed(cols);
        _.each(cols, function (colDef) {
          if (!colDef.attributes || colDef.attributes.permanentColumn !== true) {
            colCount++;
            colDef.columnWrapped = (colCount > this.maxColumnsDisplayed);
          }
        }, this);

      }
      return cols;
    },

    _adjustColumns: function () {
      if (!this.displayedColumns || !this.$el.is(':visible')) {
        // skip rest of function if no columns are displayed or the view is hidden
        return;
      }
      //TODO: Remove below 5 px width from tableWidth once perfect scrollbar enabled
      var tableWidth = this.$el.width() - 5;
      var numberColumnsWithFixedWidth = 0;
      var sumFixedWidth = 0;
      var spaceBetweenCells = 4;  //Inline-block div has 4px space in between
      var columnCells;
      var headerCells = this.$el.find('.csui-table-header-cell');
      if (this.collection.length > 0) {
        columnCells = this.$el.find('.csui-table-body>div').first().find(
            '.csui-table-cell');  //TODO:Check for presence of first element
      } else {
        columnCells = headerCells;
      }

      var widerCellIndexes = {};
      var normalCellIndexes = [];
      var displayedColumns = this.displayedColumns;
      var widthFactorSum                 = 0,
          widestColumnIndex,
          largestWidthFactor             = 0,
          flexibleColumnWidth            = 0,
          numberColumnsWithFlexibleWidth = 0;
      columnCells.each(function (index) {
        if (index < displayedColumns.length) {
          var el = $(this);
          //var classes = getClassesFromElement(el);
          //console.log("Classes: ", classes);

          var column = displayedColumns[index];
          if (column.CellView && column.CellView.hasFixedWidth) {
            sumFixedWidth += el.outerWidth();
            numberColumnsWithFixedWidth++;
          } else {
            var widthFactor = (column.attributes && column.attributes.widthFactor) || 1.0;
            if (widthFactor && widthFactor !== 1.0) {
              widerCellIndexes[index] = widthFactor;
              widthFactorSum += widthFactor;
            } else {
              if (column.CellView && column.CellView.flexibleWidth) {
                flexibleColumnWidth += el.outerWidth();
                numberColumnsWithFlexibleWidth++;
              } else {
                normalCellIndexes.push(index);
                widthFactorSum += 1;
              }

            }
            if (widthFactor > largestWidthFactor) {
              largestWidthFactor = widthFactor;
              widestColumnIndex = index;
            }
          }
        }
      });
      var remainingWidth             = tableWidth - sumFixedWidth - flexibleColumnWidth -
                                       (spaceBetweenCells * displayedColumns.length),
          numberColumnsNonFixedWidth = displayedColumns.length - numberColumnsWithFixedWidth -
                                       numberColumnsWithFlexibleWidth,
          remainingWidthPerCell      = numberColumnsNonFixedWidth > 0 ?
                                       remainingWidth / numberColumnsNonFixedWidth : 0,
          sumWidthOfWideCells        = 0,
          averageWidthFactor         = widthFactorSum / numberColumnsNonFixedWidth;
      _.each(widerCellIndexes, function (widthFactor, columnIndex) {
        // scale width factors so sum of width factors equals number of columns and the
        // average width factor is 1 again.
        var wf = widthFactor / averageWidthFactor,
            w  = remainingWidthPerCell * wf;
        if (sumWidthOfWideCells + w > remainingWidth) {
          w = remainingWidth - sumWidthOfWideCells;
          if (w < 0) {
            w = 0;
          }
        }
        w = Math.floor(w);
        widerCellIndexes[columnIndex] = w;
        sumWidthOfWideCells += w;
      });
      // subtract the sum of wide cells widths and distribute the rest for the remaining cells
      // and as we use full pixels, compute a correction width to apply on the widest element.
      var correctionWidth;
      if (normalCellIndexes.length > 0) {
        remainingWidthPerCell = (remainingWidth - sumWidthOfWideCells) /
                                normalCellIndexes.length / averageWidthFactor;
        remainingWidthPerCell = Math.floor(remainingWidthPerCell);
        correctionWidth = remainingWidth - sumWidthOfWideCells -
                          remainingWidthPerCell * normalCellIndexes.length;
      } else {
        remainingWidthPerCell = 0;
        correctionWidth = remainingWidth - sumWidthOfWideCells;
      }
      correctionWidth = Math.floor(correctionWidth);

      var cachedColumnWidths = {},
          view               = this;
      columnCells.each(function (index) {
        if (index < displayedColumns.length) {
          var el = $(this);
          var column = displayedColumns[index];
          var hasFixedWidth = column.CellView && column.CellView.hasFixedWidth;
          var widthStyle = {"width": el.outerWidth() + "px"};
          if (!hasFixedWidth) {
            var columnWidth;
            if (widerCellIndexes[index] && widerCellIndexes[index] > 0) {
              columnWidth = widerCellIndexes[index];
            } else {
              columnWidth = remainingWidthPerCell;
            }
            if (index === widestColumnIndex && correctionWidth) {
              columnWidth += correctionWidth;
            }
            var px = columnWidth + 'px';

            if (column.CellView.flexibleWidth) {
              $(headerCells[index]).css(widthStyle);
            } else {
              // set width of table header and body cells of the current column
              widthStyle = {"min-width": px, "max-width": px};
              $(headerCells[index]).css(widthStyle);
            }

            var tdCells = view.$el.find(
                '.csui-table-cell:nth-child(' + (index + 1) + ')');
            tdCells.css(widthStyle);
          }
          cachedColumnWidths[column.className] = widthStyle;
        }
      });
      this.cachedColumnWidths = cachedColumnWidths;
    },

    calculateMaxColumnsDisplayed: function (cols) {
      if (!cols || cols.length === 0) {
        return;
      }
      // assume an average of 120px width per column
      var maxColumnsDisplayed = 0, usedWidth = 0, widthFactor, width, averageWidth = 120;
      if (this.$el.length > 0 && this.$el[0].children.length > 0) {
        var tw = this.$el.width();
        _.each(cols, function (column) {
          if (column.attributes && column.attributes.permanentColumn === true) {
            widthFactor = column.attributes.widthFactor;
            width = widthFactor ? averageWidth * widthFactor : averageWidth;
            usedWidth += width;
            maxColumnsDisplayed++;
          }
        }, this);
        for (var colno = 0; colno < cols.length; colno++) {
          var column = cols[colno], selectorWidth, allNthColumns;
          if (column.attributes) {
            if (!column.attributes.permanentColumn) {
              widthFactor = column.attributes.widthFactor;
              selectorWidth = averageWidth;
              width = widthFactor ? selectorWidth * widthFactor : selectorWidth;
              usedWidth += width;
              if (usedWidth > tw) {
                break;
              }
              maxColumnsDisplayed++;
            }
          }
        }
        if (maxColumnsDisplayed > this.options.maxColumnsDisplayed) {
          maxColumnsDisplayed = this.options.maxColumnsDisplayed;
        }
        if (maxColumnsDisplayed < 1) {
          maxColumnsDisplayed = 1;
        }
      } else {
        maxColumnsDisplayed = this.options.maxColumnsDisplayed;
      }
      return maxColumnsDisplayed;
    },

    _adjustColumnsAfterWindowResize: function () {

      if (!this.allColumns.length) {
        // prevent rebuild if there are no columns
        return;
      }
      if (this.maxColumnsDisplayed && this.$el.is(':visible')) {
        var maxColumns = this.calculateMaxColumnsDisplayed(this.allColumns);
        if (maxColumns !== this.maxColumnsDisplayed) {
          this.maxColumnsDisplayed = maxColumns;
          if (!this._rebuildingTable) {
            return setTimeout(_.bind(this.render, this));
          }
        }
      }
      this._adjustColumns();
    }

  });

  _.extend(TableListView.prototype, LayoutViewEventsPropagationMixin);

  return TableListView;
});
csui.define('csui/controls/tabletoolbar/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/tabletoolbar/impl/nls/root/localized.strings',{

  // controls/tabletoolbar
  ToolbarItemFilter: 'Filter',
  ToolbarItemOpen: 'Open',
  ToolbarItemDownload: 'Download',
  ToolbarItemBrowse: 'Browse',
  ToolbarItemCopy: 'Copy',
  ToolbarItemEmailLink: 'Email link',
  ToolbarItemPaste: 'Paste',
  ToolbarItemMove: 'Move',
  ToolbarItemShare: 'Share',
  ToolbarItemNavigate: 'Visit',
  ToolbarItemViewProperties: 'Properties',
  ToolbarItemVersionHistory: 'Version history',
  ToolbarItemDelete: 'Delete',
  ToolbarItemReserve: 'Reserve',
  ToolbarItemUnreserve: 'Unreserve',
  ToolbarItemEdit: 'Edit',
  ToolbarItemRename: 'Rename',
  ToolbarItemRenameFavorite: 'Rename Favorite',
  ToolbarItemOpenSavedQuery: 'Open',
  ToolbarItemExecuteSavedQuery: 'Execute',
  ToolbarItemInfo: 'Properties',
  ToolbarItemTimeline: 'Timeline',
  ToolbarItemToggleTableLayout: 'Toggle layout',
  ToolbarItemSettings: 'Settings',
  ToolbarItemAddFolder: 'Folder',
  ToolbarItemAddDocument: 'Document',
  ToolbarItemAdd: 'Add',
  ToolbarItemAddItem: 'Add Item',
  ToolbarItemAddVersion: 'Add version',
  ToolbarItemAddCategories: 'Add Categories',
  ToolbarItemMore: 'More actions',
  ToolbarItemPrint: 'Print',
  ToolbarItemOriginalEdit: 'Edit original',
  ToolbarItemOriginalShare: 'Share original',
  ToolbarItemOriginalReserve: 'Reserve original',
  ToolbarItemOriginalUnreserve: 'Unreserve original',
  ToolbarItemOriginalCopy: 'Copy original',
  ToolbarItemOriginalMove: 'Move original',
  ToolbarItemOriginalDownload: 'Download original',
  ToolbarItemOriginalDelete: 'Delete original',
  ToolbarItemCopyLink: 'Copy link',
  ToolbarItemOriginalCopyLink: 'Copy link original',
  ToolbarItemPermissions: 'View permissions',
  ToolbarItemDeletePermission: 'Remove from list',
  ToolbarItemEditPermission: 'Edit permissions',
  ToolbarItemApplyPermission: 'Apply permissions to sub-items',
  ToolbarItemChangeOwnerPermission: 'Change owner',
  ToolbarItemRemoveCollectionItems: 'Remove from collection',
  ToolbarItemInformation: 'Properties',
  ToolbarItemFilterAria: 'Show filter panel ',
  ToolbarGoToLocation:'Go to location',

  // dropdown menu in table header caption
  MenuItemUploadFile: 'Upload file',
  MenuItemAddNewFolder: 'Add new Folder',
  MenuItemZipAndDownload: 'Zip & Download',
  MenuItemCopy: 'Copy',
  MenuItemMove: 'Move',
  MenuItemEmailLink: 'Email link',
  MenuItemShare: 'Share',
  MenuItemReserve: 'Reserve',
  MenuItemUnreserve: 'Unreserve',
  MenuItemDelete: 'Delete',
  MenuItemSendToDevice: 'Send to device',
  MenuItemRename: 'Rename',
  MenuItemTimeline: 'Timeline',
  MenuItemInformation: 'Properties',
  MenuItemCopyLink: 'Copy link',

  // right toolbar
  ToolbarItemComment: 'Comment',
  ToolbarItemShowDescription: 'Show description',
  ToolbarItemConfiguration: 'Configuration',
  ToolbarItemMaximizeWidgetView: 'Maximize widget view',
  ToolbarItemRestoreWidgetViewSize: 'Restore widget view size',

  // permission dropdown command names

  AddUserOrGroups: 'Add user or groups',
  AddOwnerOrGroup: 'Add owner or owner group',
  RestorePublicAccess: 'Restore public access',

  //Title for add toolbar items as 'add folder'
  AddToolbarItemsTitle: 'Add {0}',
  ToolbarItemThumbnail: "Grid view",
  ToolbarItemListView: "List view",
  ThumbnailTitle: "Grid view",
  ListViewTitle: "List view"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/tabletoolbar/impl/tabletoolbar',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-tabletoolbar tile-nav\" aria-label=\"Table menubar\" role=\"menu\">\r\n  <div class=\"csui-filterToolbar\" ></div>\r\n  <div class=\"csui-addToolbar\" role=\"menuitem\"></div>\r\n  <div class=\"csui-leftToolbar\" ></div>\r\n  <div class=\"csui-otherToolbar\" ></div>\r\n  <div class=\"csui-toolbar-caption\" ></div>\r\n  <div class=\"csui-rightToolbar\" ></div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_tabletoolbar_impl_tabletoolbar', t);
return t;
});
/* END_TEMPLATE */
;


csui.define('css!csui/controls/tabletoolbar/impl/tabletoolbar',[],function(){});
csui.define('csui/controls/tabletoolbar/tabletoolbar.view',['module', 'require', 'csui/lib/jquery', 'csui/lib/underscore',
  'csui/lib/backbone', 'csui/lib/marionette', 'csui/utils/log', 'csui/utils/base',
  'csui/models/nodes', 'csui/controls/toolbar/toolitem.model',
  'csui/controls/toolbar/toolitems.filtered.model',
  'csui/controls/toolbar/toolbar.view',
  'csui/controls/item.title/item.title.view',
  'csui/controls/toolbar/delayed.toolbar.view',
  'csui/utils/commandhelper', 'csui/utils/commands/add',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/table/inlineforms/inlineform.factory',
  'hbs!csui/controls/tabletoolbar/impl/tabletoolbar',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/controls/mixins/global.alert/global.alert.mixin',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/toolbar/toolbar.state.behavior',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/utils/commands',
  'csui-ext!csui/controls/tabletoolbar/tabletoolbar.view',
  'csui/lib/jquery.when.all',
  'css!csui/controls/tabletoolbar/impl/tabletoolbar'
], function (module, require, $, _, Backbone, Marionette, log, base,
    NodeCollection, ToolItemModel, FilteredToolItemsCollection,
    ToolbarView, ItemTitleView, DelayedToolbarView, CommandHelper, AddCommand,
    tableToolbarLang, inlineFormViewFactory, template,
    LayoutViewEventsPropagationMixin, GlobalAlertMixin, TabableRegionBehavior,
    ToolbarStateBehavior, ToolbarCommandController, commands,
    toolbarExtensions) {
  'use strict';

  var TableToolbarView = Marionette.LayoutView.extend({
    template: template,

    regions: {
      filterToolbarRegion: '.csui-filterToolbar', // filter toolbar
      addToolbarRegion: '.csui-addToolbar', // add toolbar
      leftToolbarRegion: '.csui-leftToolbar', // left toolbar
      otherToolbarRegion: '.csui-otherToolbar', // other toolbar
      toolbarCaptionRegion: '.csui-toolbar-caption', // caption
      rightToolbarRegion: '.csui-rightToolbar' // right toolbar
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    },

    toolbarItemSelector: 'a.' + TabableRegionBehavior.accessibilityFocusableClass + ',' +
                         'button.' + TabableRegionBehavior.accessibilityFocusableClass + ',' +
                         'div.' + TabableRegionBehavior.accessibilityFocusableClass,

    events: {"keydown": "onKeyInView"},

    currentlyFocusedElement: function () {

      var toolbarElements = this.$(this.toolbarItemSelector);
      //Since jquery returns an init object for $(undefined), a check is made first to
      //see if there are any toolbar elements.
      var elementOfFocus = toolbarElements.length ?
                           $(toolbarElements[this.accNthToolbarItemFocused]) : null;
      return elementOfFocus;

      //
      // var focused = this.$('.' + TabableRegionBehavior.accessibilityActiveElementClass);
      // if (focused.length > 0) {
      //   return focused;
      // } else {
      //   focused = this.$('a.' + TabableRegionBehavior.accessibilityFocusableClass + ':first');
      //   focused.addClass(TabableRegionBehavior.accessibilityActiveElementClass);
      //   return focused;
      // }
    },

    constructor: function TableToolbarView(options) {
      options || (options = {});

      this.context = options.context;
      this.commandController = options.toolbarCommandController ||
                               new ToolbarCommandController({
                                 commands: options.commands || commands
                               });
      this.addableTypes = options.addableTypes;
      this.originatingView = options.originatingView || this;
      this.blockingParentView = options.blockingParentView;
      this.selectedNodes = new NodeCollection();
      this.accNthToolbarItemFocused = 0;
      this.toolbarNames = ['filter', 'add', 'left', 'other', 'right'];

      Marionette.LayoutView.prototype.constructor.apply(this, arguments); // sets this.options

      this.listenTo(this, 'before:regions:reinitialize', this.initialize);
    },

    initialize: function (options) {
      this.container = options.container || this.collection.node;

      var status = {
        context: this.context,
        nodes: this.selectedNodes,
        container: this.container,
        collection: this.collection,
        data: {
          addableTypes: this.addableTypes,
        }
      };

      _.each(this.toolbarNames, function (toolbarName) {
        var fullToolbarName = toolbarName + 'Toolbar',
            toolItemFactory = this.options.toolbarItems[fullToolbarName];

        // create toolbar only if toolbar items (toolItemFactory) is defined
        if (toolItemFactory) {
          var toolbarItemsMask = this.options.toolbarItemsMasks &&
                                 this.options.toolbarItemsMasks.toolbars[fullToolbarName];
          // actions on the 'other' toolbar can be loaded later
          var delayedActions = toolbarName === 'other' &&
                               this.collection.delayedActions;
          // make filtered collection of toolbar items
          var filteredCollection = new FilteredToolItemsCollection(
              toolItemFactory, {
                status: status,
                commands: this.commandController.commands,  // todo: move filteredCollection to
                // commandController and do not access the commands via the commandController here
                delayedActions: delayedActions,
                mask: toolbarItemsMask
        });

          // create toolbar view
          var toolbarClass = delayedActions ? DelayedToolbarView : ToolbarView,
              toolbarView  = new toolbarClass(_.extend({
                collection: filteredCollection,
                toolbarName: toolbarName,
                toolbarCommandController: this.commandController,
                toolbarItemsMask: toolbarItemsMask,
                originatingView: this.originatingView,
                blockingParentView : this.blockingParentView
              }, toolItemFactory.options));
          this[toolbarName + 'ToolbarView'] = toolbarView;
          if (toolbarView.closeDropdown) {
            toolbarView.listenTo(this, 'changed:focus close:dropdown', toolbarView.closeDropdown);
          }

          // attach event listener for clicked toolbar items
          this
              .listenTo(toolbarView, 'childview:toolitem:action',
                  this._toolbarItemClicked)
              .listenTo(toolbarView, 'dom:refresh', function () {
                this.triggerMethod('refresh:tabindexes');
              }).listenTo(this.commandController, 'after:execute:command', function (eventArgs) {
                //If command is cancelled then bring back focus to the table toolbar item
                if (eventArgs && eventArgs.cancelled) {
                  var targetToolItem  = this.$el.find('[data-csui-command=' +
                                                      eventArgs.commandSignature.toLowerCase() +
                                                      '] a'),
                      //check if the tool item is inside drop down
                      isUnderDropDown = targetToolItem.length ?
                                        targetToolItem.closest('ul.csui-more-dropdown-menu') : {};
                  if (isUnderDropDown.length) {
                    //focus on drop down icon
                    isUnderDropDown.siblings('a.binf-dropdown-toggle').focus();
                  } else {
                    //focus on tool item
                    targetToolItem.focus();
                  }
                }
              });
          if (delayedActions) {
            this.listenTo(this.selectedNodes, 'reset', function () {
              toolbarView.actionState.set('showMessage', !!this.selectedNodes.length);
            });
          }
        }
      }, this);

      if (this.options.toolbarItems.addToolbar && this.addableTypes) {
        this._updateAddToolbar();
        this.listenTo(this.addableTypes, 'reset', this._updateAddToolbar, this);
      }

      if (this.options.headermenuItems &&
          this.options.headermenuItems.headerMenuToolbar && this.container) {
        this.captionView = new ItemTitleView({
          model: this.container,
          toolItems: this.options.headermenuItems.headerMenuToolbar,
          toolItemsMask: this.options.headermenuItemsMask,
          context: this.context,
          commands: this.commandController.commands,
          originatingView: this.originatingView
        });
        this.captionView.listenTo(this, 'changed:focus', this.captionView.closeMenu);
      }

      this.propagateEventsToRegions();
      this.prepareForGlobalAlert();

      var self = this;
      if (toolbarExtensions) {
        toolbarExtensions.forEach(function (entryPoint) {
          entryPoint(self);
        });
      }
    },

    _moveTo: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger('changed:focus', this);
      this.currentlyFocusedElement().focus();
    },

    onKeyInView: function (event) {

      var toolbarElements;
      if ($(event.target).is(':input') &&
          !$(event.target).hasClass(TabableRegionBehavior.accessibilityFocusableClass)) {
        return; // if keyboard event was from input element, ignore it
      }
      switch (event.keyCode) {
      case 9:
        // tab
        this.trigger('close:dropdown');
        break;
      case 37:
        // left arrow
        toolbarElements = this.$(this.toolbarItemSelector);
        if (this.accNthToolbarItemFocused > 0) {
          this.accNthToolbarItemFocused--;
        }
        this._moveTo(event);
        break;
      case 39:
        // right arrow
        toolbarElements = this.$(this.toolbarItemSelector);
        if (this.accNthToolbarItemFocused < toolbarElements.length - 1) {
          this.accNthToolbarItemFocused++;
        }
        this._moveTo(event);
        break;
      case 35:
        // For Bootstrap dropdown menu, End key goes to the last menu item
        if (!$(event.target).closest('ul').hasClass('binf-dropdown-menu')) {
          // END key > goto rightmost column
          toolbarElements = this.$(this.toolbarItemSelector);
          this.accNthToolbarItemFocused = toolbarElements.length - 1;
          this._moveTo(event);
        }
        break;
      case 36:
        // For Bootstrap dropdown menu, Home key goes to the first menu item
        if (!$(event.target).closest('ul').hasClass('binf-dropdown-menu')) {
          // POS1 key > goto first column
          this.accNthToolbarItemFocused = 0;
          this._moveTo(event);
        }
        break;
      }
    },

    _updateAddToolbar: function () {
      var toolbarItems = [];
      this.addableTypes.each(function (addableType) {
        var addType = addableType.get('type');
        var isAddableWithoutInlineForm = AddCommand.isAddableTypeWithoutInlineForm(addType);
        var inlineFormView;
        if (!isAddableWithoutInlineForm) {
          inlineFormView = inlineFormViewFactory.getInlineFormView(addType);
        }
        if (isAddableWithoutInlineForm || inlineFormView) {
          var toolItem = new ToolItemModel({
            signature: 'Add',
            name: addableType.get('type_name'),
            title: _.str.sformat(tableToolbarLang.AddToolbarItemsTitle,
                addableType.get('type_name')),
            // TODO: Move all this single command specific attributes
            // to the commandData object
            type: addType,
            group: 'add',
            commandData: {
              type: addType,
              addableTypes: this.addableTypes
            }
          });
          toolbarItems.push(toolItem);
        }
      }, this);

      var deferreds = [],
          self      = this;
      this.triggerMethod('before:updateAddToolbar', {
        context: this.context,
        container: this.container,
        addableTypes: this.addableTypes,
        toolbarItems: toolbarItems,
        async: function () {
          var deferred = $.Deferred();
          deferreds.push(deferred);
          return function () {
            deferred.resolve();
          };
        }
      });

      $.whenAll.apply($, deferreds).always(function () {
        if (self.options.creationToolItemsMask) {
          toolbarItems = self.options.creationToolItemsMask.maskItems(toolbarItems);
        }
        self.options.toolbarItems.addToolbar.reset(toolbarItems);
      });
    },

    // This method is triggered as a nested 'childview:...' event; such
    // events always get the childView as the first argument.
    _toolbarItemClicked: function (toolItemView, args) {
      var executionContext = {
        context: this.context,
        nodes: this.selectedNodes,
        container: this.container,
        collection: this.collection,
        originatingView: this.originatingView,
        toolItemView: toolItemView
      };

      this.commandController.toolitemClicked(args.toolItem, executionContext);
    },

    // called from nodestable.view when the selection of nodes changed -> update the toolbars
    updateForSelectedChildren: function (selectedNodes) {
      this.selectedNodes.reset(selectedNodes);
    },

    onRender: function () {
      if (this.options.height) {
        this.$el.height(this.options.height);
      }
      // call show on each toolbar region with the associated view
      _.each(this.toolbarNames, function (toolbarName) {
        // call show of view in region if view is instantiated
        var view = this[toolbarName + 'ToolbarView'];
        if (view) {
          // TODO: Fix update of toolbars, which are displayed permanently.
          // Workaround for a missing refilter, if the status changes: the
          // collection listens only to selection changes; if the current
          // container or data change, commands are not re-enabled)
          view.collection.refilter();
          this[toolbarName + 'ToolbarRegion'].show(view);
        }
      }, this);
      if (this.captionView) {
        this.toolbarCaptionRegion.show(this.captionView);
      }
    }

  });

  _.extend(TableToolbarView.prototype, LayoutViewEventsPropagationMixin);
  _.extend(TableToolbarView.prototype, GlobalAlertMixin);

  return TableToolbarView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table.configuration.toolbar/impl/configuration.toolbar.dropdown',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"binf-dropdown\">\r\n  <button id=\""
    + this.escapeExpression(((helper = (helper = helpers.btnId || (depth0 != null ? depth0.btnId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"btnId","hash":{}}) : helper)))
    + "\" type=\"button\" class=\"binf-dropdown-toggle csui-acc-focusable\"\r\n          data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\r\n          title=\""
    + this.escapeExpression(((helper = (helper = helpers.configurationButtonTooltip || (depth0 != null ? depth0.configurationButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"configurationButtonTooltip","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.configurationButtonTooltip || (depth0 != null ? depth0.configurationButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"configurationButtonTooltip","hash":{}}) : helper)))
    + "\">\r\n    <span class=\"icon icon-toolbar-settings\"></span>\r\n  </button>\r\n  <ul class=\"binf-dropdown-menu\" role=\"menu\"></ul>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_table.configuration.toolbar_impl_configuration.toolbar.dropdown', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table.configuration.toolbar/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table.configuration.toolbar/impl/nls/root/localized.strings',{

  configurationButtonTooltip: 'Settings'

});



csui.define('css!csui/controls/table.configuration.toolbar/impl/configuration.toolbar.dropdown',[],function(){});
csui.define('csui/controls/table.configuration.toolbar/configuration.toolbar.dropdown.view',['csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/utils/log', 'csui/controls/toolbar/toolitem.view',
  'csui/models/nodes', 'csui/controls/toolbar/toolitems.filtered.model', 'csui/utils/commands',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/behaviors/dropdown.menu/dropdown.menu.behavior',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'hbs!csui/controls/table.configuration.toolbar/impl/configuration.toolbar.dropdown',
  'i18n!csui/controls/table.configuration.toolbar/impl/nls/localized.strings',
  'css!csui/controls/table.configuration.toolbar/impl/configuration.toolbar.dropdown',
  'csui/lib/binf/js/binf'
], function ($, _, Backbone, Marionette, log, ToolItemView,
    NodeCollection, FilteredToolItemsCollection, commands, ToolbarCommandController,
    DropdownMenuBehavior, PerfectScrollingBehavior, template, lang) {

  //
  // This view shows the configuration icon for toolbar items that can be shown as dropdown
  // menu items instead of toolbar buttons.
  //
  //
  var ConfigurationDropdownMenuView = Marionette.CompositeView.extend({

    className: "csui-configuration-view",

    template: template,
    templateHelpers: function () {
      return {
        btnId: _.uniqueId('configurationButton'),
        configurationButtonTooltip: lang.configurationButtonTooltip
      };
    },

    childView: ToolItemView,
    childViewContainer: "ul.binf-dropdown-menu",
    childViewOptions: function (model) {
      return {
        renderTextOnly: true,
        role: 'menuitem'
      };
    },

    ui: {
      dropdownDiv: '.binf-dropdown',
      dropdownToggle: '.binf-dropdown-toggle',
      dropdownMenu: '.binf-dropdown-menu',
      loadingIconsDiv: '.csui-loading-parent-wrapper'
    },

    behaviors: {
      DropdownMenuBehavior: {
        behaviorClass: DropdownMenuBehavior
      },
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.command-view-region'
      }
    },

    constructor: function ConfigurationDropdownMenuView(options) {
      options || (options = {});
      this.context = options.context;
      this.commands = options.commands || commands;
      this.commandController = options.toolbarCommandController ||
                               new ToolbarCommandController({commands: this.commands});
      this.selectedNodes = (options.status && options.status.nodes) || new NodeCollection();
      this.container = options.container;

      this.status = options.status || {
            context: this.context,
            nodes: this.selectedNodes,
            container: this.container
          };

      options.collection = new FilteredToolItemsCollection(
          options.toolbarItems, {
            status: this.status,
            commands: this.commands,
            mask: options.toolbarItemsMask
          });

      Marionette.CompositeView.prototype.constructor.apply(this, arguments);

      this.listenTo(this, 'childview:toolitem:action', this._triggerMenuItemAction)
          .listenTo(Backbone, 'closeToggleAction', this._closeToggle);
    },

    enabled: function () {
      return this.options.context ? true : false;
    },

    onRender: function () {
      if (this.collection.length < 1) {
        // hide the Configuration button if there is no items
        this.$el.addClass('binf-hidden');
        this.ui.dropdownToggle.attr('data-cstabindex', '-1');
        this.ui.dropdownToggle.removeClass('csui-acc-focusable');
      } else {
        // show the view because with the latest code the view now can be hidden by the PUT call
        // event that the node does not have any actions yet until it is re-fetched
        this.$el.find('.binf-dropdown').removeClass('binf-hidden');
        this.$el.removeClass('binf-hidden');
        this.ui.dropdownToggle.attr('data-cstabindex', '0');
        this.ui.dropdownToggle.addClass('csui-acc-focusable');
      }

      if (this.collection.length > 0) {
        // make the dropdown menu when there are 1 or more items
        this.ui.dropdownToggle.binf_dropdown();
        this.ui.dropdownDiv.on('hide.binf.dropdown', _.bind(function () {
          // empty and close commandView region in case user clicks outside the dropdown menu
          this._showMenuItems();
        }, this));
      }
    },

    _closeToggle: function () {
      var dropdownToggleEl = this.$el.find('.binf-dropdown-toggle');
      if (dropdownToggleEl.parent().hasClass('binf-open')) {
        dropdownToggleEl.binf_dropdown('toggle', false);
      }
      // in case user clicks outside dropdown menu, show menu items and close commandView region
      this._showMenuItems();
    },

    _triggerMenuItemAction: function (toolItemView, args) {
      // menu with more options: run the command with its view inside the dropdown menu
      if (args && args.toolItem && args.toolItem.get('menuWithMoreOptions') === true) {
        this._toolitemClicked(toolItemView, args);
      } else {
        var dropdownToggleEl = this.$el.find('.binf-dropdown-toggle');
        dropdownToggleEl.binf_dropdown('toggle'); // close dropdown menu before triggering the event

        var executionContext = _.extend(this.status, {
          originatingView: this.options.originatingView,
          blockingParentView: this.options.blockingParentView,
          configurationMenuView: this,
          toolItemView: toolItemView
        });
        this.commandController.toolitemClicked(args.toolItem, executionContext);
      }
    },

    // different than commandController's method: runs the command inside dropdown menu
    _toolitemClicked: function (toolItemView, args) {
      var self = this;
      var signature = args.toolItem.get("signature");
      var command = this.commandController.commands.findWhere({
        signature: signature
      });

      var status = _.extend(this.status, {
        originatingView: this.options.originatingView,
        blockingParentView: this.options.blockingParentView,
        configurationMenuView: this,
        toolItemView: toolItemView
      });
      var data = _.extend({}, status.data, args.toolItem.get('commandData'));
      status = _.defaults({
        toolItem: args.toolItem,
        data: data
      }, status);

      var eventArgs = {
        status: status,
        commandSignature: signature,
        command: command
      };
      this.commandController.trigger('before:execute:command', eventArgs);

      var executeOptions = {
        context: status.context
      };
      // command with more options runs in dropdown menu with its view
      command.execute(status, executeOptions)
          .done(function (args) {
            if (args && args.viewClass) {
              self._showCommandViewInDropdownMenu(args.viewClass, args.viewOptions || {});
            }
            self.commandController.trigger('after:execute:command', eventArgs);
          })
          .fail(function (error) {
            // in case the command was cancelled, error is undefined
            if (error === undefined) {
              error = {
                cancelled: true,
                commandSignature: signature
              };
            }
            self.commandController.trigger('after:execute:command', error);
          });
    },

    _showCommandViewInDropdownMenu: function (viewClass, viewOptions) {
      var commandView = new viewClass(viewOptions);
      this.listenTo(commandView, 'go:back', _.bind(function () {
        // close and destroy commandView, but keeps dropdown menu open
        this._showMenuItemsWithAnimation();
      }, this));
      this.listenTo(commandView, 'close:menu', _.bind(function () {
        // close and destroy commandView, and also close dropdown menu
        this._showMenuItems();
        this._closeToggle();
      }, this));
      this.listenTo(commandView, 'dom:refresh', _.bind(function () {
        // event for perfect scrollbar
        this.trigger('render');
        this.trigger('update:scrollbar');
      }, this));

      // hide menu items and show commandView in commandView Region of the dropdown menu
      this._ensureCommandViewRegion();
      this.commandViewRegion.show(commandView);
      this._hideMenuItemsWithAnimation();
    },

    _ensureCommandViewRegion: function () {
      // create the Region to show the commandView
      if (!this.commandViewRegion) {
        this.ui.dropdownMenu.append('<div class="command-view-region"></div>');
        var commandViewRegion = this.ui.dropdownMenu.find('.command-view-region');
        this.commandViewRegion = new Marionette.Region({
          el: commandViewRegion
        });
        commandViewRegion.on('click', function(event) {
          // prevent closing dropdown menu when the user clicks on the Command View Region and if
          // the event is not handled by the Command View
          event.preventDefault();
          event.stopPropagation();
        });
        this.commandViewRegion.$el.hide();
      }
    },

    _emptyCommandViewRegion: function () {
      if (this.commandViewRegion) {
        // empty the commandView region and destroy the commandView
        this.commandViewRegion.empty();
      }
    },

    _showMenuItems: function () {
      this.ui.dropdownMenu.find('> li').show();
      this._emptyCommandViewRegion();
      this.commandViewRegion && this.commandViewRegion.$el.hide();
    },

    _showMenuItemsWithAnimation: function () {
      var self = this;

      // hide the right arrows because when in keyboard navigation mode, it shows during animation
      var $rightArrows = this.ui.dropdownMenu.find('.csui-icon-rightArrow');
      $rightArrows.addClass('binf-hidden');

      // animate dropdown menu size to its original size
      self.ui.dropdownMenu.css('overflow', 'hidden');
      self.ui.dropdownMenu.animate({
        'width': self.dropdownMenuOriginalWidth,
        'height': self.dropdownMenuOriginalHeight
      }, 500);

      // and in parallel, animate commandView region sliding out from the left
      self.commandViewRegion.$el.css({
        'position': 'absolute',
        'top': self.ui.dropdownMenu.css('padding-top'),
        'background-color': self.ui.dropdownMenu.css('background-color'),
        'opacity': 1
      });
      self.ui.dropdownMenu.find('> li').show();
      self.commandViewRegion.$el.hide('blind', {
        direction: 'right',
        complete: function () {
          self._emptyCommandViewRegion();
          $rightArrows.removeClass('binf-hidden');
          self.commandViewRegion.$el.css({
            'position': '',
            'top': '',
            'background-color': '',
            'opacity': ''
          });
          self.ui.dropdownMenu.css({
            'overflow': '',
            'width': '',
            'height': ''
          });
        }
      }, 500);
    },

    _hideMenuItemsWithAnimation: function () {
      var self = this;

      // hide the right arrows because when in keyboard navigation mode, it shows during animation
      var $rightArrows = this.ui.dropdownMenu.find('.csui-icon-rightArrow');
      $rightArrows.addClass('binf-hidden');

      // animate dropdown menu size to the commandView size
      self.dropdownMenuOriginalWidth = self.ui.dropdownMenu.css('width');
      self.dropdownMenuOriginalHeight = self.ui.dropdownMenu.css('height');
      self.ui.dropdownMenu.css('overflow', 'hidden');
      self.ui.dropdownMenu.animate({
        'width': self.commandViewRegion.$el.width(),
        'height': self.commandViewRegion.$el.height()
      }, 500);

      // and in parallel, animate commandView region sliding in from the right
      self.commandViewRegion.$el.css({
        'position': 'absolute',
        'top': self.ui.dropdownMenu.css('padding-top'),
        'background-color': self.ui.dropdownMenu.css('background-color'),
        'opacity': 1
      });
      self.commandViewRegion.$el.show('blind', {
        direction: 'right',
        complete: function () {
          self.ui.dropdownMenu.find('> li').hide();
          $rightArrows.removeClass('binf-hidden');
          self.commandViewRegion.$el.css({
            'position': '',
            'top': '',
            'background-color': '',
            'opacity': ''
          });
          self.ui.dropdownMenu.css({
            'width': '',
            'height': ''
          });
        }
      }, 500);
    }

  });

  return ConfigurationDropdownMenuView;
});

csui.define('csui/controls/table/inlineforms/favorite/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/inlineforms/favorite/impl/nls/root/lang',{
  CancelButtonLabel: "Cancel",
  NewNamePlaceholder: 'Enter name'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/inlineforms/favorite/impl/favorite',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" class=\"csui-btn-edit-cancel binf-btn\"><span class=\"icon edit-cancel\"\r\n                                                                 title=\""
    + this.escapeExpression(((helper = (helper = helpers.EditCancelTooltip || (depth0 != null ? depth0.EditCancelTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditCancelTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n    </button>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" class=\"csui-btn-metadata binf-btn\"><span\r\n        class=\"icon icon-toolbar-metadata\"></span></button>\r\n    <button type=\"button\"\r\n            class=\"csui-btn-save csui-btn binf-btn\" disabled>"
    + this.escapeExpression(((helper = (helper = helpers.SaveButtonLabel || (depth0 != null ? depth0.SaveButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"SaveButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n    <button type=\"button\" class=\"csui-btn-cancel csui-btn binf-btn\">"
    + this.escapeExpression(((helper = (helper = helpers.CancelButtonLabel || (depth0 != null ? depth0.CancelButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"CancelButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n";
},"5":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-inlineform-group csui-inlineform-group-error\" role=\"alert\">\r\n    <div class=\"binf-text-danger\">"
    + this.escapeExpression(((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"errorMessage","hash":{}}) : helper)))
    + "</div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<form class=\"csui-inlineform-group csui-inlineform-group-favorite-name\">\r\n  <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.namePlaceholder || (depth0 != null ? depth0.namePlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"namePlaceholder","hash":{}}) : helper)))
    + "\"\r\n         class=\"binf-form-control csui-inlineform-input-name\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.formModeIsEdit : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "</form>\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.haveErrorMessage : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_inlineforms_favorite_impl_favorite', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/inlineforms/favorite/impl/favorite',[],function(){});
csui.define('csui/controls/table/inlineforms/favorite/favorite.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  "csui/lib/marionette",
  'i18n!csui/controls/table/inlineforms/favorite/impl/nls/lang',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/inlineform/impl/inlineform.view',
  "hbs!csui/controls/table/inlineforms/favorite/impl/favorite",
  "css!csui/controls/table/inlineforms/favorite/impl/favorite"
], function ($, _, Marionette, lang, inlineFormViewRegistry, InlineFormView, template) {

  var InlineFormFavoriteView = InlineFormView.extend({

        className: function () {
          var className = "csui-inlineform-favorite";
          if (InlineFormView.prototype.className) {
            className += ' ' + _.result(InlineFormView.prototype, 'className');
          }
          return className;
        },

        template: template,

        templateHelpers: function () {
          var dataFromInlineFormView = this._templateHelpers();
          var disableSavebtn = !(!!this.model.get("favorite_name"));
          var data = _.extend(dataFromInlineFormView, {
            name: this.model.get('favorite_name'),
            namePlaceholder: lang.NewNamePlaceholder,
            disableSavebtn: disableSavebtn
          });
          return data;
        },

        ui: {},

        constructor: function InlineFormFavoriteView(options) {
          this.options = options || {};

          // extend the base class ui and events hashes
          this.ui = _.extend({}, this.ui, InlineFormView.prototype.ui);
          this.events = _.extend({}, this.events, InlineFormView.prototype.events);

          InlineFormFavoriteView.__super__.constructor.apply(this, arguments);
        },

        _saveIfOk: function () {
          var inputName = this._getInputName();
          var name = this.model.get('favorite_name');
          if (inputName.length > 0 && inputName === name) {
            this.cancel();
          } else {
            if (inputName.length > 0) {
              this._save({favorite_name: inputName});
            }
          }
        }

      },
      {
        CSSubType: undefined  // favorites don't have a subtype in content server
      }
  );

  return InlineFormFavoriteView;
});

csui.define('csui/controls/table/inlineforms/permissions/user.picker/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/inlineforms/permissions/user.picker/impl/nls/root/lang',{
  CancelButtonLabel: "Cancel",
  SaveButtonLabel: 'Save',
  UserPickerPlaceHolder: 'Enter name',
  InvalidUser: "Invalid user"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/inlineforms/permissions/user.picker/impl/user.picker',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div id=\"csui-inline-permissions-user-picker\" class=\"csui-inline-permissions-user-picker\"></div>\r\n<div class=\"csui-user-picker-buttons csui-inlineform-group\">\r\n  <button class=\"binf-btn csui-btn binf-btn-primary cs-save-button\" tabindex=\"-1\" disabled>"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.SaveButtonLabel : depth0), depth0))
    + "</button>\r\n  <button class=\"binf-btn csui-btn binf-btn-default cs-cancel-button\" tabindex=\"-1\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.CancelButtonLabel : depth0), depth0))
    + "</button>\r\n</div>\r\n<div class=\"csui-change-user-error\"></div>";
}});
Handlebars.registerPartial('csui_controls_table_inlineforms_permissions_user.picker_impl_user.picker', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/inlineforms/permissions/user.picker/impl/user.picker',[],function(){});
csui.define('csui/controls/table/inlineforms/permissions/user.picker/user.picker.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  "csui/lib/marionette",
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'i18n!csui/controls/table/inlineforms/permissions/user.picker/impl/nls/lang',
  "hbs!csui/controls/table/inlineforms/permissions/user.picker/impl/user.picker",
  "css!csui/controls/table/inlineforms/permissions/user.picker/impl/user.picker"
], function ($, _, Marionette, TabableRegionBehavior, lang, template) {

  var UserLookupView = Marionette.ItemView.extend({

    className: 'cs-inline-user-lookup',

    template: template,

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior,
        initialActivationWeight: 100
      }
    },

    ui: {
      cancelButton: '.cs-cancel-button',
      saveButton: '.cs-save-button',
      inputBox: '.cs-search'
    },

    events: {
      'click @ui.saveButton': 'saveClicked',
      'click @ui.cancelButton': 'cancelClicked',
      'focus @ui.inputBox': 'inputBoxFocus',
      'click': 'handleClick'
    },

    handleClick: function (event) {
      event.preventDefault();
      event.stopPropagation();
    },

    templateHelpers: function () {
      return {
        SaveButtonLabel: lang.SaveButtonLabel,
        CancelButtonLabel: lang.CancelButtonLabel
      };
    },

    initialize: function (options) {
      this.options = options;
    },

    constructor: function UserLookupView(options) {
      var self = this;
      options || (options = {});
      options.data || (options.data = {});
      this.options = options;
      Marionette.ItemView.prototype.constructor.call(this, options);
    },

    inputBoxFocus: function () {
      this.focusIndex = 0;
    },

    onShow: function () {
      var self = this;
      this.focusIndex = 0;
      csui.require(['csui/controls/userpicker/userpicker.view'
      ], function (UserPickerView) {
        self.pickerView = new UserPickerView({
          context: self.options.context,
          limit: 5,
          memberFilter: self.options.memberFilter,
          widgetoptions: self.options,
          placeholder: lang.UserPickerPlaceHolder,
          prettyScrolling: true,
          scrollContainerHeight: 'auto',
          model: self.options.userPickerModel,
          id_input: _.uniqueId("csui-inline-permissions-user-picker-input"),
          lightWeight: false
        });
        var pickerRegion = new Marionette.Region({
          el: self.$el.find('#csui-inline-permissions-user-picker')
        });
        pickerRegion.show(self.pickerView);
        if (self.pickerView.$el.find("input")) {
          self.pickerView.$el.find("input").focus();
        }
        self.listenTo(self.pickerView, "item:change", self.processItemChange);
        self.listenTo(self.pickerView, "item:clear", self.processItemChange);

        //binding keydown event -- accessibility
        self.$el.bind('keydown', _.bind(self.onKeyInView, self));
        self.$el.find('input').focus().attr('tabindex', '-1');
      });
    },

    processItemChange: function () {
      var selectedModel = arguments.length > 0 && arguments[0].item;
      this.param = selectedModel;
      if (selectedModel) {
        this.options.currentRow.find(".cs-save-button").removeAttr("disabled");
      } else {
        this.options.currentRow.find(".cs-save-button").attr('disabled', true);
        this.$el.find('input').focus();
      }
    },

    currentlyFocusedElement: function () {
      var focusedEl = this.$el.find('input');
      return focusedEl;
    },

    cancelClicked: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.options.currentRow.removeClass("csui-changeowner-permission");
      this.options.currentRow.find(".member-info").removeClass("binf-hidden");
      this.trigger("change:completed");
    },

    saveClicked: function (event) {
      event.preventDefault();
      event.stopPropagation();
      if (this.$(".cs-search").val() === this.param.get("name_formatted")) {
        this.trigger("member:selected:save", this.param);
      } else {
        this.$(".csui-change-user-error").addClass('csui-change-user-error-display').html(
            lang.InvalidUser);
      }
    },

    onKeyInView: function (event) {
      var that = this;
      var elements              = this.$el.find("[tabindex]").filter(function (index, ele) {
            return that.$(ele).is(':visible') && !that.$(ele).is(':disabled');
          }),

          elemNum               = elements.length,
          currentElementInFocus = elements[this.focusIndex],
          textBoxFocused        = this.$(event.target).hasClass('cs-search');
      if (textBoxFocused) {
        this.focusIndex = 0;
      }

      switch (event.keyCode) {
      case 37 : // left arrow

        if (this.focusIndex > 0) {
          this.focusIndex--;
          elements[this.focusIndex].focus();
          event.preventDefault();
        }
        event.stopPropagation();
        break;

      case 9: //tab key
        if (!event.shiftKey) {
          this.focusIndex++;
          if (this.focusIndex <= elements.length - 1 && this.focusIndex >= 0) {
            elements[this.focusIndex].focus();
          }
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.focusIndex--;
          if (this.focusIndex >= 0 && this.focusIndex <= elements.length - 1) {
            elements[this.focusIndex].focus();
          }
          event.preventDefault();
          event.stopPropagation();
        }
        break;
      case 39: //right arrow
        event.stopPropagation();
        break;
      case 38: // arrow up
      case 40: //arrow down
        event.preventDefault();
        event.stopPropagation();
        break;
      case 32: //space
        event.stopPropagation();
        break;
      case 13: //enter
        this.$(event.target).trigger('click');
        event.preventDefault();
        event.stopPropagation();
        break;
      default:
        event.stopPropagation();
        break;
      }
    }
  });
  return UserLookupView;
});
csui.define('csui/controls/table/cells/celleditor/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/celleditor/impl/nls/root/lang',{
  NewNamePlaceholder: 'Enter name'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/celleditor/impl/celleditor',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "    <span class=\"csui-undo edit-cancel inline-edit-icon\"></span>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button class=\"csui-undo csui-btn-cancel binf-btn\">"
    + this.escapeExpression(((helper = (helper = helpers.CancelButtonLabel || (depth0 != null ? depth0.CancelButtonLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"CancelButtonLabel","hash":{}}) : helper)))
    + "</button>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-td-content-edit\">\r\n  <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.formattedValue || (depth0 != null ? depth0.formattedValue : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"formattedValue","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.inputPlaceholder || (depth0 != null ? depth0.inputPlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"inputPlaceholder","hash":{}}) : helper)))
    + "\" class=\"binf-form-control\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.useEditCancelIcon : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_table_cells_celleditor_impl_celleditor', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/table/cells/celleditor/impl/celleditor',[],function(){});
csui.define('csui/controls/table/cells/celleditor/celleditor.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'csui/utils/log',
  'csui/utils/base',
  'csui/controls/table/cells/templated/templated.view',
  'i18n!csui/controls/table/cells/celleditor/impl/nls/lang',
  'hbs!csui/controls/table/cells/celleditor/impl/celleditor',
  'css!csui/controls/table/cells/celleditor/impl/celleditor'
], function ($, _, Marionette, log, base, TemplatedCellView, lang, template) {

  var CellEditiorView = TemplatedCellView.extend({

    template: template,

    ui: {
      editCancel: '.csui-td-content-edit .csui-undo',
      cancelButton: '.csui-td-content-edit .csui-btn-cancel',
      inputField: '.csui-td-content-edit > input'
    },

    events: {
      'click @ui.editCancel': 'iconUndoClicked',
      'keyup @ui.inputField': 'keyReleased',
      'blur @ui.inputField': 'leftInputField',
      'click @ui.inputField': 'inputFieldClicked'
    },

    onRender: function () {
      // starts the animation to widen the input field
      this.ui.inputField.addClass('csui-input-full');
      this.ui.inputField.select();
    },

    // ... called also from the creator of the celleditor
    endEdit: function () {
      this.editStarted = false;
      this.saving = false;
      delete this.model.csuiValueEdited;
      var elEditor = this.$el.find('.csui-td-content-edit');
      if (elEditor.length > 0) {
        $(elEditor[0]).remove();
      }
      this.model.unset('csuiErrorMessage'); // remove any error message -> renders row in table
      this.trigger('closed', this);
    },

    _cancelEdit: function () {
      if (this.leftInputFieldTimer) {
        clearTimeout(this.leftInputFieldTimer);
      }
      // inform caller we want to cancel
      this.trigger('cancelEdit', this);
      this.endEdit();
    },

    _save: function () {
      if (this.editStarted) {

        // trigger save if there is a value entered in the input field

        var elInput = this.ui.inputField;
        var newName = elInput.val();
        newName = newName.trim();
        if (newName.length > 0) {
          this.saving = true;
          // inform caller we want to save the changes
          this.trigger('cellEditorWantsSave', {newName: newName});
        } else {
          this._cancelEdit(); // cancel if no value entered
        }
      }
    },

    inputFieldClicked: function (event) {
      // don't propagate click event into name cell, because it would cause drilldown (default
      // action)
      event.preventDefault();
      event.stopPropagation();
    },

    iconUndoClicked: function (event) {
      // don't propagate click event into name cell, because it would cause selecting the row
      event.preventDefault();
      event.stopPropagation();

      this._cancelEdit();
    },

    keyReleased: function (event) {
      event.preventDefault();
      event.stopPropagation();

      // clear the timeout if after leaving the input field the user types again in the input field
      if (this.leftInputFieldTimer) {
        clearTimeout(this.leftInputFieldTimer);
      }
      if (event.keyCode === 27) {
        this._cancelEdit();
      } else {
        if (event.keyCode === 13) {
          this._save();
        }
      }
    },

    leftInputField: function (event) {
      if (this.saving) {
        return;
      }

      var self = this;
      if (this.leftInputFieldTimer) {
        clearTimeout(this.leftInputFieldTimer);
      }
      this.leftInputFieldTimer = setTimeout(function () {
        self.leftInputFieldTimer = undefined;
        self._save();
      }, 100);

    },

    renderValue: function () {
      var data;
      // use value from last edit if possible
      if (this.model.csuiValueEdited) {
        data = {value: this.model.csuiValueEdited, formattedValue: this.model.csuiValueEdited};
      } else {
        data = this.getValueData();
      }
      data.useEditCancelIcon = this.model.get('id') !== undefined;
      data.CancelButtonLabel = lang.CancelButtonLabel;
      data.inputPlaceholder = lang.NewNamePlaceholder;

      var hasError = this.model.get('csuiErrorMessage') !== undefined;
      // Making the entire data object undefined renders nothing; if the object
      // contains undefined value the template should be prepared for it
      var html = data ? this.template(data) : '';
      var elEditor = this.$el.find('.csui-td-content-edit');
      if (elEditor.length > 0) {
        if (hasError) {
          $(elEditor[0]).addClass('binf-has-error');  // bootstrap validation error
        }
        $(elEditor[0]).replaceWith(html);
      } else {
        var newEditorEl = $(html);
        if (hasError) {
          newEditorEl.addClass('binf-has-error');  // bootstrap validation error
        }
        newEditorEl.appendTo(this.$el.find('.csui-td-container'));
      }
      this.editStarted = true;
      this.saving = false;
    }

  });

  return CellEditiorView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/reservation/impl/reservation',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.canRevokeShare : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isReservedByOther : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.canRevokeShare : depth0),{"name":"if","hash":{},"fn":this.program(8, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    var helper;

  return "    <button type=\"button\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedAria || (depth0 != null ? depth0.reservedAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedAria","hash":{}}) : helper)))
    + "\" class=\"csui-unreserve-cellview\">\r\n";
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedTooltip || (depth0 != null ? depth0.reservedTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedTooltip","hash":{}}) : helper)))
    + "\" class=\"icon icon-shared_collaborate_other\"></span>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedTooltip || (depth0 != null ? depth0.reservedTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedTooltip","hash":{}}) : helper)))
    + "\" class=\"icon icon-shared_collaborate_self\"></span>\r\n";
},"8":function(depth0,helpers,partials,data) {
    return "    </button>\r\n";
},"10":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.reserved : depth0),{"name":"if","hash":{},"fn":this.program(11, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"11":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.canUnreserve : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isReservedByOther : depth0),{"name":"if","hash":{},"fn":this.program(12, data, 0),"inverse":this.program(14, data, 0)})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.canUnreserve : depth0),{"name":"if","hash":{},"fn":this.program(8, data, 0),"inverse":this.noop})) != null ? stack1 : "");
},"12":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedTooltip || (depth0 != null ? depth0.reservedTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedTooltip","hash":{}}) : helper)))
    + "\" class=\"icon icon-reserved_other\"></span>\r\n";
},"14":function(depth0,helpers,partials,data) {
    var helper;

  return "      <span title=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedTooltip || (depth0 != null ? depth0.reservedTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedTooltip","hash":{}}) : helper)))
    + "\" class=\"icon icon-reserved_self\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.reservedSharedCollaboration : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(10, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_table_cells_reservation_impl_reservation', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/reservation/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/cells/reservation/impl/nls/root/lang',{
  reservedTooltipPrefix: 'Reserved by {0}\r\n{1}',
  reservedAria: 'Reserved by {0} at {1}, click to unreserve',
  reservedSharedCollaborationTooltipPrefix: 'Shared for collaboration by {0}\r\n{1}',
  reservedSharedCollaborationAria: 'Shared for collaboration by {0} at {1}'
});



csui.define('css!csui/controls/table/cells/reservation/impl/reservation',[],function(){});
csui.define('csui/controls/table/cells/reservation/reservation.view',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/utils/base', 'csui/utils/log',
  'csui/utils/contexts/factories/user',
  'csui/models/nodes',
  'csui/models/nodechildren',
  'csui/controls/table/cells/templated/templated.view',
  'csui/utils/commands',
  'csui/utils/commands/unreserve',
  'csui/utils/commandhelper',
  'csui/controls/table/cells/cell.registry',
  'hbs!csui/controls/table/cells/reservation/impl/reservation',
  'i18n!csui/controls/table/cells/reservation/impl/nls/lang',
  'css!csui/controls/table/cells/reservation/impl/reservation'
], function ($, _, base, log, UserModelFactory, NodeCollection,
    NodeChildrenCollection, TemplatedCellView, commands, UnreserveCommand,
    CommandHelper, cellViewRegistry, template, lang) {
  'use strict';

  var AddDeleteReservationView = TemplatedCellView.extend({
    template: template,

    triggers: {
      'click .csui-unreserve-cellview': 'remove:reservation'
    },

    events: {"keydown": "onKeyInView"},

    getValueData: function () {
      // handle both v1-expanded and not expanded (or v2-expanded) reserved_user_id scenarios
      var reservedById = this.model.get('reserved_user_id');
      if (reservedById && typeof reservedById === 'object') {
        reservedById = reservedById.id;
      }
      // Unreserving is made by emptying in the reserving user. Until the
      // server updates all properties, the model is inconsistent. That is
      // why both properties are tested here. A better fix will be welcome.
      var isReserved = this.model.get('reserved') && reservedById;
      var isReservedSharedCollaboration = this.model.get('reserved_shared_collaboration');
      var reservedBy;
      var isReservedByOther = false;
      //var reservedDate;
      if (isReserved) {
        // handle both v1 and v2 of the expanded 'reserved_user_id'
        var reservedData = this.model.get('reserved_user_id_expand') ||
                           this.model.get('reserved_user_id');
        reservedBy = base.formatMemberName(reservedData);
        isReservedByOther = this.userId !== reservedById;
        //reservedDate = base.formatExactDateTime(this.model.get('reserved_date'));
      }

      var reservedDate = base.formatExactDate(this.model.get('reserved_date')),
          reservedUser = base.formatMemberName(reservedBy),
          reservedTooltip, reservedAria;

      if (isReservedSharedCollaboration) {
        reservedTooltip = lang.reservedSharedCollaborationTooltipPrefix;
        reservedAria = lang.reservedSharedCollaborationAria;
      } else if (isReserved) {
        reservedTooltip = lang.reservedTooltipPrefix;
        reservedAria = lang.reservedAria;
      }
      if (reservedTooltip) {
        reservedTooltip = _.str.sformat(reservedTooltip, reservedBy, reservedDate);
        reservedAria = _.str.sformat(reservedAria, reservedBy, reservedDate);
      }

      var data = {
        reservedTooltip: reservedTooltip,
        reservedAria: reservedAria,
        canUnreserve: this.canUnreserve,
        reserved: isReserved,
        isReservedByOther: isReservedByOther,
        canRevokeShare: this.canRevokeShare,
        reservedSharedCollaboration: isReservedSharedCollaboration
      };

      return data;
    },

    initialize: function () {
      var user = this.options.context.getModel(UserModelFactory);
      this.userId = user.get('id');
      this.unreserveCommand = new UnreserveCommand();
      this.revokeShareCommand = commands.get('RevokeShare');
      this.commandStatus = {nodes: new NodeCollection([this.model]), context: this.options.context};
      this._checkEnabledAction();
      // Refresh the action availability for collections with delayed action loading
      var actions = this.model.collection.delayedActions;
      actions && this.listenTo(actions, 'sync', this._checkEnabledAction);
    },

    _checkEnabledAction: function () {
      this.canUnreserve = this.unreserveCommand.enabled(this.commandStatus);
      this.canRevokeShare = false;
      if (this.revokeShareCommand) {
        this.canRevokeShare = this.revokeShareCommand.enabled(this.commandStatus);
      }
      if (!this.isDestroyed) {
        this.render();
      }
    },

    onRemoveReservation: function (e) {
      var promiseFromCommand;

      if (this.canUnreserve) {
        promiseFromCommand = this.unreserveCommand.execute(this.commandStatus);

        CommandHelper.handleExecutionResults(
            promiseFromCommand, {
              command: this.unreserveCommand,
              suppressSuccessMessage: this.commandStatus.suppressSuccessMessage,
              suppressFailMessage: this.commandStatus.suppressFailMessage
            });
      } else if (this.canRevokeShare) {
        promiseFromCommand = this.revokeShareCommand.execute(this.commandStatus);

        CommandHelper.handleExecutionResults(
            promiseFromCommand, {
              command: this.revokeShareCommand,
              suppressSuccessMessage: this.commandStatus.suppressSuccessMessage,
              suppressFailMessage: this.commandStatus.suppressFailMessage
            });
      }
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        // space or enter key

        this.onRemoveReservation();
      }
    }
  }, {
    hasFixedWidth: true,

    columnClassName: 'csui-table-cell-reservation',

    getModelExpand: function (options) {
      return {properties: ['reserved_user_id']};
    }
  });

  // This column key is used on the client side only to give a hint that
  // one or multiple rows can be and/or are selected
  // TODO: Deprecate and remove this cell view
  // cellViewRegistry.registerByColumnKey('reserved', AddDeleteReservationView);

  return AddDeleteReservationView;
});

csui.define('csui/controls/table/cells/node.state/impl/node.state.icons',[
  'csui/controls/table/cells/node.state/impl/reservation/reservation.view'
], function (ReservationIconView) {
  'use strict';

  return [
    {
      sequence: 50,
      iconView: ReservationIconView
    }
  ];
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/rows/description/impl/description',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <span class=\"description "
    + this.escapeExpression(((helper = (helper = helpers.truncate_fade_class || (depth0 != null ? depth0.truncate_fade_class : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"truncate_fade_class","hash":{}}) : helper)))
    + "\"\r\n        title=\""
    + this.escapeExpression(((helper = (helper = helpers.complete_description || (depth0 != null ? depth0.complete_description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"complete_description","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.current_description || (depth0 != null ? depth0.current_description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"current_description","hash":{}}) : helper)))
    + "</span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.current_description : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "<div class=\"description-caret-div\">\r\n  <span class=\"description-readmore icon-expandArrowDown\" role=\"button\" aria-expanded=\"false\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.showmore_tooltip || (depth0 != null ? depth0.showmore_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showmore_tooltip","hash":{}}) : helper)))
    + "\"\r\n        aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.showmore_aria || (depth0 != null ? depth0.showmore_aria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showmore_aria","hash":{}}) : helper)))
    + "\" tabindex=\"0\"></span>\r\n  <span class=\"description-showless icon-expandArrowUp\" role=\"button\" aria-expanded=\"true\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.showless_tooltip || (depth0 != null ? depth0.showless_tooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showless_tooltip","hash":{}}) : helper)))
    + "\"\r\n        aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.showless_aria || (depth0 != null ? depth0.showless_aria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"showless_aria","hash":{}}) : helper)))
    + "\" tabindex=\"0\"></span>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_table_rows_description_impl_description', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/rows/description/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/table/rows/description/impl/nls/root/lang',{
  showmore: 'Show more',
  showmoreAria: 'Show more description',
  showless: 'Show less',
  showlessAria: 'Show less description'
});



csui.define('css!csui/controls/table/rows/description/impl/description',[],function(){});
csui.define('csui/controls/table/rows/description/description.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 'csui/utils/base',
  'hbs!csui/controls/table/rows/description/impl/description',
  'i18n!csui/controls/table/rows/description/impl/nls/lang',
  'css!csui/controls/table/rows/description/impl/description'
], function (_, $, Marionette, base, template, lang) {

  var DescriptionView = Marionette.ItemView.extend({

    className: function () {
      if (this._collapsedHeightIsOneLine) {
        return "cs-description csui-description-short-lines-1";
      } else {
        return "cs-description";
      }
    },

    template: template,

    templateHelpers: function () {
      var description = this.model.get("instructions")
          || this.model.get("description") || '';
      return {
        complete_description: description,
        current_description: description,
        more_description: this.has_more_desc && !this.hideShowLess,
        showmore_tooltip: lang.showmore,
        showmore_aria: lang.showmoreAria,
        showless_tooltip: lang.showless,
        showless_aria: lang.showlessAria
      };
    },

    ui: {
      description: '.description',
      readMore: '.description-readmore',
      showLess: '.description-showless'
    },

    events: {
      'keydown @ui.readMore': 'readMoreClicked',
      'keydown @ui.showLess': 'showLessClicked',
      'click @ui.readMore': 'readMoreClicked',
      'click @ui.showLess': 'showLessClicked'
    },

    constructor: function DescriptionView(options) {
      this._preinitializeFlags(options);

      Marionette.ItemView.prototype.constructor.apply(this, arguments);

      this.listenTo(this, 'dom:refresh', this._truncateIfNecessary)
          .listenTo(this.options.tableView, 'dom:refresh',
              this.triggerMethod.bind(this, 'dom:refresh'));
    },

    currentlyFocusedElement: function () {
      if (this.has_more_desc) {
        if (this.shortDescMode) {
          return this.ui.readMore;
        } else {
          return this.ui.showLess;
        }
      } else {
        return $();
      }
    },

    _preinitializeFlags: function (options) {
      this.shortDescMode = true;
      this.hideShowLess = false;
      this.has_more_desc = false;
      this._collapsedHeightIsOneLine = options && options.collapsedHeightIsOneLine;
    },

    _updateDescriptionAndCaret: function () {
      this._enableCaretState();
      if (this.shortDescMode && this.has_more_desc) {
        this.$el.addClass('csui-description-collapsed');
      } else {
        this.$el.removeClass('csui-description-collapsed');
      }
    },

    _truncateIfNecessary: function () {
      var actualHeight = this.ui.description.height();
      if (actualHeight) {
        var maxHeight = parseFloat(this.ui.description.css("line-height"));
        if (!this._collapsedHeightIsOneLine) {
          maxHeight = maxHeight * 2;  // if not one line, use 2 lines
        }
        if (actualHeight > maxHeight) {
          this.has_more_desc = true;
        }
        this._updateDescriptionAndCaret();
      }
    },

    readMoreClicked: function (event) {
      if (!!event && (event.keyCode === 13 || event.keyCode === 32 || event.type === 'click')) {
        event.preventDefault();
        event.stopPropagation();

        this.shortDescMode = false;
        this._updateDescriptionAndCaret();
        //not triggering in onRender because every time nodestable re-renders, this will re-render
        this.options.tableView && this.options.tableView.trigger('update:scrollbar');
        this.ui.showLess.focus();
      }
    },

    showLessClicked: function (event) {
      if (!!event && (event.keyCode === 13 || event.keyCode === 32 || event.type === 'click')) {
        event.preventDefault();
        event.stopPropagation();

        this.shortDescMode = true;
        this._updateDescriptionAndCaret();
        this.options.tableView && this.options.tableView.trigger('update:scrollbar');
        this.ui.readMore.focus();
      }
    },

    _enableCaretState: function () {
      if (this.has_more_desc) {
        this.ui.readMore.toggleClass('caret-hide', this.shortDescMode ? false : true);
        this.ui.showLess.toggleClass('caret-hide', this.shortDescMode ? true : false);
      } else {
        // text is not truncated -> no need for readMore or showLess caret to display
        this.ui.readMore.addClass('caret-hide');
        this.ui.showLess.addClass('caret-hide');
      }
    }

  });

  return DescriptionView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/impl/metadata/thumbnail.metadata',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <span class=\"csui-thumbnail-metadata-label\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</span>\r\n  <span class=\"csui-thumbnail-metadata-spacer\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.displayHeader : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "<span class=\"csui-thumbnail-metadata-val\">"
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "</span>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_impl_metadata_thumbnail.metadata', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/impl/metadata/thumbnail.metadata.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'hbs!csui/controls/thumbnail/impl/metadata/thumbnail.metadata'
], function (_, $, Backbone, Marionette, base, itemTemplate) {
  "use strict";

  var ThumbnailMetadataItemView = Marionette.ItemView.extend({
    className: "csui-thumbnail-item-details binf-col-lg-12",
    template: itemTemplate,
    templateHelpers: function () {
      this.$el.attr('role', 'listitem');
      var value = this.getValueData();
      return {
        displayHeader: this.model.get("noTitleHeader"),
        label: this.model.get("key"),
        value: value
      };
    },
    getValueData: function () {
      var model      = this.options.thumbnailItemModel,
          column     = this.model.get("key"),
          columnType = this.model.get("column_type"),
          value      = model.get(column);
      if (columnType === 'date') {
        value = base.formatExactDateTime(value);
      }
      return value;
    }
  });

  var ThumbnailMetadataCollectionView = Marionette.CollectionView.extend({
    className: "csui-thumbnail-metadata",
    childView: ThumbnailMetadataItemView,
    childViewOptions: function () {
      return {
        rowId: this.options.rowId,
        thumbnailItemModel: this.model
      };
    },
    filter: function (child, index, collection) {
      if (child.get('key') === 'size') {
        return (this.model.get(child.get('key')) &&
                this.model.get(child.get('key') + "_formatted") !== "");
      } else {
        return (this.model.get(child.get('key')) && this.model.get(child.get('key')) !== "");
      }
    },
    onRender: function () {
      var collection = this.collection;
      this.bindUIElements();
    }
  });

  return ThumbnailMetadataCollectionView;
});
csui.define('csui/controls/thumbnail/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/impl/nls/root/lang',{
  addTitle: 'Add',
  searchIconTooltip: 'Search by {0}',
  selectAll: 'Select all',
  selectAllTitle: 'Select all items',
  noResults: 'No results found',
  dragAndDropMessage: 'Drag and drop files here to add new content',
  items: 'Items',
  formatForNone: "{0} items",
  formatForOne: "{0} item",
  formatForTwo: "{0} items",
  formatForFive: "{0} items",
  asc_name: "Name (A-Z)",
  desc_name: "Name (Z-A)",
  asc_modify_date:"Modified (new-old)",
  desc_modify_date:"Modified (old-new)", 
  asc_size: "Size (small-large)",
  desc_size: "Size (large-small)",
  name: "Name",
  modified: "Modified",
  size: "Size",
  selectItem: 'Select {0}',
  selectItemAria: 'Select {0}. When selected an action bar of options can be reached per shift-tab'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/impl/sort/impl/sort.menu',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return "      <li role=\"presentation\"><a role=\"menuitem\" href=\"#\" class=\"csui-sort-option\"\r\n                                 data-binf-toggle=\"tab\">                                \r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selected : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(4, data, 0)})) != null ? stack1 : "")
    + "        <span class=\"cs-label\" title=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.value : depth0), depth0))
    + "\" id=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.key : depth0), depth0))
    + "\">"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.value : depth0), depth0))
    + " </span></a></li>\r\n";
},"2":function(depth0,helpers,partials,data) {
    return "          <span class=\"cs-icon icon-listview-checkmark\"></span>\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "          <span class=\"cs-icon \"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-search-sort-options\">\r\n  <button id=\""
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\" type=\"button\" class=\"binf-btn binf-btn-default binf-dropdown-toggle\"\r\n          data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n    <span class=\"cs-label\">"
    + this.escapeExpression(((helper = (helper = helpers.selectedValue || (depth0 != null ? depth0.selectedValue : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectedValue","hash":{}}) : helper)))
    + "</span>\r\n    <span class=\"csui-button-icon icon-caret-down\"></span>\r\n  </button>\r\n  <span id=\"search-sort-btn\" class=\"csui-sort-arrow  "
    + this.escapeExpression(((helper = (helper = helpers.selectedArrow || (depth0 != null ? depth0.selectedArrow : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectedArrow","hash":{}}) : helper)))
    + "\"></span>\r\n  <ul class=\"binf-dropdown-menu\" role=\"menu\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.sortListArray : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  </ul>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_impl_sort_impl_sort.menu', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/impl/sort/sort.view',['module',
  'require',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/log',
  'i18n!csui/controls/thumbnail/impl/nls/lang',
  'hbs!csui/controls/thumbnail/impl/sort/impl/sort.menu',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/lib/binf/js/binf'
], function (module, require, $, _, Backbone, Marionette, log, lang, template,
    PerfectScrollingBehavior, TabableRegionBehavior) {

  var SortingView = Marionette.ItemView.extend({

    className: 'cs-sort-links',
    template: template,

    constants: {
      NAME_ASC: "asc_name",
      NAME_DESC: "desc_name",
      MODIFIED_ASC: "asc_modify_date",
      MODIFIED_DESC: "desc_modify_date",
      SIZE_ASC: "asc_size",
      SIZE_DESC: "desc_size"
    },

    templateHelpers: function () {
      var self          = this,
          sortListArray = [];
      _.each(this.constants, function (val, key) {
        sortListArray.push({key: val, value: lang[val], selected: false});
      });

      var isfound = _.any(sortListArray, function (a) {
        return (a.value === self.actualValue) ? a.selected = true : a.selected = false;
      }, self);

      return {
        id: _.uniqueId('sortButton'),
        selectedValue: self.selectedValue,
        selectedArrow: self.selectedArrow,
        sortListArray: sortListArray
      };
    },

    ui: {
      sortOrderBtn: '#search-sort-btn'
    },

    events: {
      'click .binf-dropdown-menu > li > a': 'onSortOptionClick'
    },

    constructor: function SortingView(options) {
      Marionette.ItemView.prototype.constructor.call(this, options);
      var state_order = options.collection.sorting.sort[0].value;
      var setLableName = state_order || this.constants.NAME_ASC;
      var labelName = this.OverlapDisplayText(setLableName);
      this.selectedValue = labelName;
      this.actualValue = lang[state_order] || lang[this.constants.NAME_ASC];
      this.selectedArrow = this.options.collection.orderstate || "icon-sortArrowDown";
      this.config = this.options.config || {};
    },

    onSortOptionClick: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.$el.find(".csui-search-sort-options li>a").removeClass("binf-active");
      this.$el.find(".csui-search-sort-options li>a>span").removeClass("icon-listview-checkmark");
      this.$(event.currentTarget).addClass('binf-active');
      this.resetSelection(event.currentTarget.children[1].id);
    },

    resetSelection: function (name) {
      switch (name) {
      case this.constants.NAME_ASC:
        this.collection.setOrder("name asc");
        this.selectedValue = lang[name];
        this.actualValue = lang.name;
        this.selectedArrow = "icon-sortArrowDown";
        this.options.collection.state = this.constants.NAME_ASC;
        this.options.collection.sorting.sort[0].value = this.constants.NAME_ASC;
        this.options.collection.orderstate = this.selectedArrow;
        break;
      case this.constants.NAME_DESC:
        this.collection.setOrder("name desc");
        this.selectedValue = lang[name];
        this.actualValue = lang.name;
        this.selectedArrow = "icon-sortArrowUp";
        this.options.collection.state = this.constants.NAME_DESC;
        this.options.collection.sorting.sort[0].value = this.constants.NAME_DESC;
        this.options.collection.orderstate = this.selectedArrow;
        break;
      case this.constants.MODIFIED_ASC:
        this.collection.setOrder("modify_date asc");
        this.selectedValue = lang[name];
        this.actualValue = lang.modified;
        this.selectedArrow = "icon-sortArrowDown";
        this.options.collection.state = this.constants.MODIFIED_ASC;
        this.options.collection.sorting.sort[0].value = this.constants.MODIFIED_ASC;
        this.options.collection.orderstate = this.selectedArrow;
        break;
      case this.constants.MODIFIED_DESC:
        this.collection.setOrder("modify_date desc");
        this.selectedValue = lang[name];
        this.actualValue = lang.modified;
        this.selectedArrow = "icon-sortArrowUp";
        this.options.collection.state = this.constants.MODIFIED_DESC;
        this.options.collection.sorting.sort[0].value = this.constants.MODIFIED_DESC;
        this.options.collection.orderstate = this.selectedArrow;
        break;
      case this.constants.SIZE_ASC:
        this.collection.setOrder("size asc");
        this.selectedValue = lang[name];
        this.actualValue = lang.size;
        this.selectedArrow = "icon-sortArrowDown";
        this.options.collection.state = this.constants.SIZE_ASC;
        this.options.collection.sorting.sort[0].value = this.constants.SIZE_ASC;
        this.options.collection.orderstate = this.selectedArrow;
        break;
      case this.constants.SIZE_DESC:
        this.collection.setOrder("size desc");
        this.selectedValue = lang[name];
        this.actualValue = lang.size;
        this.selectedArrow = "icon-sortArrowUp";
        this.options.collection.state = this.constants.SIZE_DESC;
        this.options.collection.sorting.sort[0].value = this.constants.SIZE_DESC;
        this.options.collection.orderstate = this.selectedArrow;
        break;
      }

      var self = this;
      this.options.collection.fetch({silent: true})
          .then(function () {
            self.trigger('render:sortmenu', name);
            self.$el.find('.binf-dropdown-toggle >span').innerText = lang[name];
            self.$el.find('.csui-sort-option.binf-active >span.cs-icon').addClass('icon-listview-checkmark');
            var labelName = self.OverlapDisplayText(name);
            self.$el.find('.binf-dropdown-toggle >span.cs-label').html(labelName);
            self.$el.find('.csui-sort-arrow').removeClass('icon-sortArrowDown');
            self.$el.find('.csui-sort-arrow').removeClass('icon-sortArrowUp');
            self.$el.find('.csui-sort-arrow').addClass(self.selectedArrow);
            self.$el.find('.csui-search-sort-options').removeClass('binf-open');
          }, self);

    },

    OverlapDisplayText: function (displayname) {
      var labelName = "";
      switch (displayname) {
      case this.constants.NAME_ASC:
        labelName = lang.name;
        break;
      case this.constants.NAME_DESC:
        labelName = lang.name;
        break;
      case this.constants.MODIFIED_ASC:
        labelName = lang.modified;
        break;
      case this.constants.MODIFIED_DESC:
        labelName = lang.modified;
        break;
      case this.constants.SIZE_ASC:
        labelName = lang.size;
        break;
      case this.constants.SIZE_DESC:
        labelName = lang.size;
        break;
      default:
        labelName = lang.name;
      }
      return labelName;
    },

    onRender: function () {
      var self = this;
      self.$el.find('.csui-search-sort-options li>a span.cs-label').each(function () {
        if ($(this).text().trim() === self.selectedValue) {
          $(this).siblings().addClass("icon-listview-checkmark");
        }
      }, self);
    }
  });
  return SortingView;
});

csui.define('csui/controls/thumbnail/content/content.registry',['csui/lib/underscore'], function (_) {

  function ContentViewRegistry() {
    this._contentKeys = {};
    this._dataTypes = {};
  }

  _.extend(ContentViewRegistry.prototype, {

    getContentView: function (contentDefinition) {
      var columnTypeIdentifier = contentDefinition.get('column_type_identifier');
      if (columnTypeIdentifier !== 'type') {
        var columnKey   = contentDefinition.get('key'),
            ContentView = columnKey && this._contentKeys[columnKey];
        if (ContentView) {
          return ContentView;
        }
      }
      var dataType = contentDefinition.get('type');
      return dataType && this._dataTypes[dataType.toString()];
    },

    registerByKey: function (key, handlerClass) {
      if (!(_.isString(key) && key)) {
        throw new Error('Key must be a non-empty string');
      }
      this._registerContentView(this._contentKeys, key, handlerClass);
    },

    registerByDataType: function (dataType, handlerClass) {
      if (!(_.isNumber(dataType) && dataType)) {
        throw new Error('Data type must be a non-zero number');
      }
      this._registerContentView(this._dataTypes, dataType.toString(),
          handlerClass);
    },

    _registerContentView: function (handlerMap, handlerKey, handlerClass) {
      if (typeof handlerClass !== 'function') {
        throw new Error('Column handler must be a function object');
      }
      handlerMap[handlerKey] = handlerClass;
    }
  });
  return new ContentViewRegistry();
});
csui.define('csui/controls/thumbnail/content/favorite/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/favorite/impl/nls/root/localized.strings',{
  ColumnTitle: "Favorite"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/favorite/impl/favorite',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<span class=\"csui-thumbnail-favorite\"></span>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_favorite_impl_favorite', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/favorite/impl/favorite',[],function(){});
csui.define('csui/controls/thumbnail/content/favorite/favorite.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/widgets/favorites/favorite.star.view',
  'csui/controls/thumbnail/content/content.registry',
  'i18n!csui/controls/thumbnail/content/favorite/impl/nls/localized.strings',
  'hbs!csui/controls/thumbnail/content/favorite/impl/favorite',
  'css!csui/controls/thumbnail/content/favorite/impl/favorite'
], function ($, _, Backbone, Marionette, FavoriteStarView, ContentRegistry, lang, template) {
  'use strict';

  var FavoriteView = Marionette.LayoutView.extend({
    template: template,
    className: 'csui-thumbnail-favorite-container',

    regions: {
      favRegion: '.csui-thumbnail-favorite'
    },

    constructor: function FavoriteView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
    },
    onRender: function () {
      if (!this.favStarView) {
        this.favStarView = new FavoriteStarView(_.extend({
          checkVisible: true,
          popoverAtBodyElement: true,
          focusable: true
        }, this.options));
        this.favRegion.show(this.favStarView);
      }
      this.listenTo(this.favStarView, 'show:add:favorite:form', function () {
        this.triggerMethod('show:add:favorite:form');
      });
      this.listenTo(this.favStarView, 'close:add:favorite:form', function () {
        this.triggerMethod('close:add:favorite:form');
      });
      this.favStarView.render();
      this.$el.append(this.favStarView.el);

      this.listenTo(this.options.originatingView.thumbnail, 'scroll', function () {
        this.favStarView && this.favStarView.closePopover();
      });
    }
  });
  ContentRegistry.registerByKey('favorite', FavoriteView);
  return FavoriteView;
});


csui.define('csui/controls/thumbnail/content/node.state/node.state.icons',['csui/lib/underscore', 'csui/lib/backbone',
  'csui-ext!csui/controls/table/cells/node.state/node.state.icons',
  // Load external icon views maintaining node states
  'csui-ext!csui/controls/thumbnail/content/node.state/node.state.icons'
], function (_, Backbone, extraNodeStateIcons, extraThumbnailNodeStateIcons) {
  'use strict';

  var NodeStateIconModel = Backbone.Model.extend({

    defaults: {
      sequence: 100,
      iconView: null,
      iconViewOptions: null
    },

    constructor: function NodeStateIconModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);
    }

  });

  var NodeStateIconCollection = Backbone.Collection.extend({

    model: NodeStateIconModel,
    comparator: 'sequence',

    constructor: function NodeStateIconCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
    }

  });

  var nodeStateIcons = new NodeStateIconCollection();

  if (extraThumbnailNodeStateIcons) {
    extraThumbnailNodeStateIcons = _.flatten(extraThumbnailNodeStateIcons, true);
    nodeStateIcons.add(extraThumbnailNodeStateIcons);
  }

  /*if (extraNodeStateIcons) {
    extraNodeStateIcons = _.flatten(extraNodeStateIcons, true);
    nodeStateIcons.add(extraNodeStateIcons);
  }*/

  return nodeStateIcons;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/node.state/impl/node.state',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-thumbnail-nodestate\"></div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_node.state_impl_node.state', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/content/node.state/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/node.state/impl/nls/root/localized.strings',{
  stateListAria: 'List of states',
  someStateIconsAria: 'State available',
  noStateIconsAria: 'No state',
  bool_value_true: 'true',
  bool_value_false: 'false',
  reservedTooltip: 'Reserved by {0}\r\n{1}',
  reservedAria: 'Reserved by {0} at {1}, click to unreserve',
  reservedSharedCollaborationTooltip: 'Shared for collaboration by {0}\r\n{1}',
  reservedSharedCollaborationAria: 'Shared for collaboration by {0} at {1}, click to unshare',
  reserved_attribute_title: 'Reserved',
  reserved_attribute_name: 'reserved',
  reserved_shared_collaboration_attribute_title: 'Shared for collaboration',
  reserved_shared_collaboration_attribute_name: 'reserved_shared_collaboration',
  nodeStateTitle_thumbnail: 'Open info panel to see status icons'
});


csui.define('csui/controls/thumbnail/content/node.state/node.state.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/thumbnail/content/content.registry',
  'csui/controls/thumbnail/content/node.state/node.state.icons',
  'csui/models/mixins/v2.fields/v2.fields.mixin',
  'hbs!csui/controls/thumbnail/content/node.state/impl/node.state',
  'i18n!csui/controls/thumbnail/content/node.state/impl/nls/localized.strings'
], function ($, _, Backbone, Marionette, ContentRegistry, nodeStateIcons,
    FieldsV2Mixin, template, lang) {
  'use strict';

  var NodeStateCollectionView = Marionette.CollectionView.extend({
    tagName: 'ul',

    attributes: {
      'aria-label': lang.stateListAria
    },

    getChildView: function (iconModel) {
      return iconModel.get('iconView');
    },

    childViewOptions: function (iconModel) {
      return _.extend({
        context: this.options.context,
        model: this.options.node,
        originatingView: this.options.originatingView,
        targetView: this.options.targetView
      }, iconModel.get('iconViewOptions'));
    }
  });

  var ThumbnailNodeStateView = Marionette.LayoutView.extend({
    template: template,
    className: 'csui-thumbnail-nodestate-container',

    regions: {
      nodeStateRegion: '.csui-thumbnail-nodestate'
    },

    constructor: function ThumbnailNodeStateView(options) {
      options || (options = {});
      this.options = options;
      Marionette.LayoutView.prototype.constructor.call(this, options);
    },
    onRender: function () {
      var enabledStateIcons = this._getEnabledNodeStateIcons(),
          message           = enabledStateIcons.length ?
                              lang.someStateIconsAria : lang.noStateIconsAria,
          title             = this.options.displayTitle ? lang.nodeStateTitle_thumbnail : "";
      this.el.setAttribute('aria-label', message);
      this.el.setAttribute('title', title);
      if (enabledStateIcons.length) {
        var iconsView = new NodeStateCollectionView({
          context: this.options.context,
          node: this.model,
          originatingView: this.options.originatingView,
          targetView: this.options.targetView,
          collection: enabledStateIcons
        });
        this.nodeStateRegion.show(iconsView);
        if (this.options.displayTitle) {
          iconsView.$el.find("button").attr("tabindex", "-1");
        }
      }
    },

    _getEnabledNodeStateIcons: function () {

      var nodeStateIconsPrototype;
      var enabledNodeStateIcons;

      nodeStateIconsPrototype = Object.getPrototypeOf(nodeStateIcons);
      enabledNodeStateIcons = new nodeStateIconsPrototype.constructor(
          nodeStateIcons.filter(function (iconModel) {
            var IconView = iconModel.get('iconView');
            return IconView && (!IconView.enabled || IconView.enabled({
                  context: this.options.context,
                  node: this.model
                }));
          }, this));

      return enabledNodeStateIcons;
    }
  });
  ContentRegistry.registerByKey('reserved', ThumbnailNodeStateView);
  return ThumbnailNodeStateView;
});
csui.define('csui/controls/thumbnail/content/name/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/name/impl/nls/root/localized.strings',{
  ColumnTitle: "Name",
  nameAria: '{0}',
  nameNoOpenAria: '{0}. Can not be opened.'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/name/impl/name',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "  <div class=\"csui-thumbnail-overview-icon\"></div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.inactive : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "");
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-thumbnail-name csui-thumbnail-name-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n      <div class=\"csui-thumbnail-name-justify-div\">\r\n        <p class=\"csui-thumbnail-name-value csui-thumbnail-no-default-action\"\r\n           title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nameNoOpenAria || (depth0 != null ? depth0.nameNoOpenAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nameNoOpenAria","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</p>\r\n      </div>\r\n    </div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-thumbnail-name csui-thumbnail-name-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n      <a href=\""
    + this.escapeExpression(((helper = (helper = helpers.defaultActionUrl || (depth0 != null ? depth0.defaultActionUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"defaultActionUrl","hash":{}}) : helper)))
    + "\"\r\n         class=\"csui-thumbnail-name-value csui-thumbnail-default-action csui-thumbnail-name-justify-div\"\r\n         title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nameAria || (depth0 != null ? depth0.nameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nameAria","hash":{}}) : helper)))
    + "\">\r\n        <span class=\"csui-thumbnail-name-link-text\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n      </a>\r\n    </div>\r\n";
},"8":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-thumbnail-name csui-thumbnail-name-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n    <div class=\"csui-thumbnail-name-justify-div\">\r\n      <p class=\"csui-thumbnail-name-value csui-thumbnail-no-default-action\"\r\n         title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.nameNoOpenAria || (depth0 != null ? depth0.nameNoOpenAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"nameNoOpenAria","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</p>\r\n    </div>\r\n  </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.displayIcon : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.defaultAction : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(8, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_name_impl_name', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/name/impl/name',[],function(){});
csui.define('csui/controls/thumbnail/content/name/name.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/utils/node.links/node.links',
  'csui/controls/thumbnail/content/content.registry',
  'i18n!csui/controls/thumbnail/content/name/impl/nls/localized.strings',
  'hbs!csui/controls/thumbnail/content/name/impl/name',
  'css!csui/controls/thumbnail/content/name/impl/name'
], function ($, _, Backbone, Marionette, NodeTypeIconView, nodeLinks, ContentRegistry, lang,
    template) {
  'use strict';

  var NameView = Marionette.ItemView.extend({
    template: template,
    className: 'csui-thumbnail-name-container',

    templateHelpers: function () {
      var column           = this.options.column,
          node             = this.model,
          name             = node.get(column.name),
          defaultActionUrl = nodeLinks.getUrl(node);
      return {
        cid: this.model.cid,
        defaultAction: column.defaultAction,
        defaultActionUrl: defaultActionUrl,
        contextualMenu: column.contextualMenu,
        name: name,
        nameAria: _.str.sformat(lang.nameAria, name),
        nameNoOpenAria: _.str.sformat(lang.nameNoOpenAria, name),
        inactive: node.get('inactive'),
        displayIcon: this.options.displayIcon
      };
    },

    constructor: function NameView(options) {
      options || (options = {});
      this.options = options;
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      if (this.options.displayIcon) {
        this.listenTo(this, 'render', this._createNodeTypeIcon)
            .listenTo(this, 'before:render', this._destroyNodeTypeIcon)
            .listenTo(this, 'before:destroy', this._destroyNodeTypeIcon);
      }
    },

    _createNodeTypeIcon: function () {
      var iconView = new NodeTypeIconView({node: this.model});
      this.typeIconRegion = new Marionette.Region({el: this.$('.csui-thumbnail-overview-icon')});
      this.typeIconRegion.show(iconView);
    },

    _destroyNodeTypeIcon: function () {
      if (this.typeIconRegion) {
        this.typeIconRegion.empty();
        this.typeIconRegion = null;
      }
    },

    onRender: function () {
      var self = this;
      this.$el.find(".csui-thumbnail-default-action").on('click.' + this.cid, function (event) {
        if (!self.model.inlineFormView) {
          self.trigger('execute:defaultAction', event);
        }
      });
    }
  });
  ContentRegistry.registerByKey('name', NameView);
  return NameView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/member/impl/member',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-thumbnail-user csui-thumbnail-user-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n  <div class=\"csui-thumbnail-label csui-thumbnail-user-content-label\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "\">\r\n    <span>"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</span>\r\n  </div>\r\n  <div class=\"csui-thumbnail-value csui-thumbnail-user-content-justify-div\">\r\n    <p class=\"csui-thumbnail-item-content-value\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\"\r\n       aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.userNoOpenAria || (depth0 != null ? depth0.userNoOpenAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"userNoOpenAria","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "</p>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_member_impl_member', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/content/member/member.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/thumbnail/content/content.registry',
  'hbs!csui/controls/thumbnail/content/member/impl/member'
], function ($, _, Backbone, Marionette, base, ContentRegistry, template) {
  'use strict';

  var MemberrView = Marionette.ItemView.extend({
    template: template,
    className: 'csui-thumbnail-user-container',

    templateHelpers: function () {
      var columnName = this.options.column.name,
          value      = this.model.get(columnName + "_expand") ||
                       this.model.get(columnName) || '',
          label      = this.options.contentModel.get("name"),
          text;
      if (_.isObject(value)) {
        // Prefer the expanded user information
        text = base.formatMemberName(value);
      } else {
        // Then try the server-pre-formatted value and fall back to the id
        text = this.model.get(columnName + "_formatted") || value.toString();
      }
      return {
        label: label,
        value: text
      };
    },

    constructor: function MemberrView(options) {
      options || (options = {});
      this.options = options;
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }
  });
  ContentRegistry.registerByDataType(14, MemberrView);
  ContentRegistry.registerByDataType(19, MemberrView);
  ContentRegistry.registerByKey('owner_id', MemberrView);
  return MemberrView;
});
csui.define('csui/controls/thumbnail/content/size/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/size/impl/nls/root/localized.strings',{
  sizeLabel: "Size",
  ColumnTitle: "Size",
  formatForNone: "{0} items",
  formatForOne: "{0} item",
  formatForTwo: "{0} items",
  formatForFive: "{0} items",
  sizeUnavailable: "Size unavailable for {0}"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/size/impl/size',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-thumbnail-label csui-thumbnail-size-label\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "\">\r\n      <span>"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</span>\r\n    </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-thumbnail-size csui-thumbnail-size-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.displayLabel : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <div class=\"csui-thumbnail-value csui-thumbnail-size-justify-div\">\r\n    <p class=\"csui-thumbnail-size-value\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\"\r\n       aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.formattedValue || (depth0 != null ? depth0.formattedValue : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"formattedValue","hash":{}}) : helper)))
    + "</p>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_size_impl_size', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/size/impl/size',[],function(){});
csui.define('csui/controls/thumbnail/content/size/size.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/thumbnail/content/content.registry',
  'i18n!csui/controls/thumbnail/content/size/impl/nls/localized.strings',
  'hbs!csui/controls/thumbnail/content/size/impl/size',
  'css!csui/controls/thumbnail/content/size/impl/size'
], function ($, _, Backbone, Marionette, base, ContentRegistry, lang, template) {
  'use strict';

  var SizeView = Marionette.ItemView.extend({
    template: template,
    className: 'csui-thumbnail-size-container',

    templateHelpers: function () {
      var model = this.model,
          column = this.options.column,
          columnName = column.name,
          value = model.get(columnName),
          type = model.get('type'),
          formattedValue;

      if (value == null) {
        // Perform the common formatting for empty value
        return "";
      }
      if (model.get('container')) {
        //899 = virtual folder
        value = formattedValue = type !== 202 && type !== 899 ?
                                 base.formatMessage(value, lang) : '';
      } else if (type === 144 || type === 749 || type === 736 || type === 30309) {
        //Perform formatting for document(144) and active view(30309) types
        formattedValue = base.formatFriendlyFileSize(value);
        value = base.formatExactFileSize(value);
      } else {
        // Perform the common formatting for other node types
        return "";
      }

      return {
        value: value,
        formattedValue: formattedValue,
        displayLabel: this.options.displayLabel,
        label: this.options.displayLabel ? lang.sizeLabel : "",
        cid: this.model.cid
      };
    },

    constructor: function SizeView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }
  });
  ContentRegistry.registerByKey('size', SizeView);
  return SizeView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/select/impl/select',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "  <div class=\"csui-focusable-table-column-header\">\r\n    <div class=\"csui-selected-checkbox csui-checkbox-primary\">\r\n      <input type=\"checkbox\" class=\"selectAction\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.selectItemName || (depth0 != null ? depth0.selectItemName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectItemName","hash":{}}) : helper)))
    + "\"\r\n             "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.checked : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + " >\r\n      <div class=\"csui-selectlabel\"></div>\r\n    </div>\r\n  </div>\r\n";
},"2":function(depth0,helpers,partials,data) {
    return "checked";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.selectable : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_select_impl_select', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/select/impl/select',[],function(){});
csui.define('csui/controls/thumbnail/content/select/select.view',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/thumbnail/content/content.registry',
  'i18n!csui/controls/thumbnail/impl/nls/lang',
  'hbs!csui/controls/thumbnail/content/select/impl/select',
  'css!csui/controls/thumbnail/content/select/impl/select'
], function (_, Backbone, Marionette, ContentRegistry, lang, template) {
  'use strict';

  var SelectContentView = Marionette.ItemView.extend({
        template: template,

        templateHelpers: function () {
          return {
            selectable: this.model.get('selectable') !== false,
            checked: this.model.get(SelectContentView.isSelectedModelAttributeName) === true,
            selectItemName: _.str.sformat(lang.selectItem, this.model.get('name')),
            selectItemAria: _.str.sformat(lang.selectItemAria, this.model.get('name'))
          };
        },

        events: {
          keydown: 'onKeyInView'
        },

        constructor: function (options) {
          Marionette.ItemView.prototype.constructor.apply(this, arguments);
          this.rowIndex = options.rowIndex;
          this.listenTo(this.model, 'change:' + SelectContentView.isSelectedModelAttributeName,
              this.render);
          this.listenTo(this, 'before:render', this._detachClickHandler)
              .listenTo(this, 'before:destroy', this._detachClickHandler);
        },

        onKeyInView: function (event) {
          if (event.keyCode === 32 || event.keyCode === 13) {
            // space or enter key
            this._toggleCheckbox(event);
          }
        },

        _attachClickHandler: function () {
          var self = this;
          var $cbEl = this.$el.find('input[type="checkbox"]');
          var $labelEl = this.$el.find('.csui-selectlabel');
          $labelEl.on('click.' + this.cid, function (event) {
            // stop this event and change checkbox instead (including triggering the change event)
            event.preventDefault();
            event.stopPropagation();
            if (self.options.thumbnailView && self.options.thumbnailView._isSelectCheckBoxBlocked) {
              return;
            }
            $cbEl.prop("checked", !$cbEl.prop("checked")).change();
            self.triggerMethod('clicked:checkbox', event);
          });

          $cbEl.on('change.' + this.cid, function (event) {
            Backbone.trigger('closeToggleAction');
            var checked = $cbEl.prop("checked");
            self.triggerMethod('clicked:checkbox', {view: self, checked: checked});
          });
        },

        _detachClickHandler: function () {
          var $cbEl = this.$el.find('input[type="checkbox"]');
          var $labelEl = this.$el.find('.csui-selectlabel');
          $cbEl.off('change.' + this.cid);
          $labelEl.off('click.' + this.cid);
          this.$el.off('click.' + this.cid);
        },

        // called mainly to handle checking/unchecking by keyboard
        _toggleCheckbox: function (event) {
          var $cbEl = this.$el.find('input[type="checkbox"]');

          $cbEl.prop("checked", !$cbEl.prop("checked")).change();  // invert checked state and
          this.$el.attr("aria-checked", $cbEl.prop("checked"));
          event.preventDefault();
          event.stopPropagation();
          // fire change event
          return $cbEl.prop("checked");
        },

        onRender: function () {
          this._ensureViewIsIntact();
          this.triggerMethod('before:render', this);
          this.$el.attr('aria-label', lang.selectItemAria);
          this.$el.attr('role', 'checkbox');
          var $cbEl = this.$el.find('input[type="checkbox"]');
          var checkedState = $cbEl.prop("checked");
          this.$el.attr('aria-checked', checkedState);
          this._attachClickHandler();
          return this;
        }
      },
      {
        columnClassName: 'csui-table-cell-_select',
        isSelectedModelAttributeName: 'csuiIsSelected'
      }
  );
  ContentRegistry.registerByKey('_select', SelectContentView);

  return SelectContentView;
});

csui.define('csui/controls/thumbnail/content/date/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/date/impl/nls/root/localized.strings',{
  ColumnTitle: "Date",
  dateLabel: "Modified date"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/date/impl/date',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-thumbnail-label csui-thumbnail-date-label\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "\">\r\n      <span>"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</span>\r\n    </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-thumbnail-date csui-thumbnail-date-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.displayLabel : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <div class=\"csui-thumbnail-value csui-thumbnail-date-justify-div\">\r\n    <p class=\"csui-thumbnail-date-value\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\"\r\n       aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "</p>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_date_impl_date', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/date/impl/date',[],function(){});
csui.define('csui/controls/thumbnail/content/date/date.view',[
  'module',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/thumbnail/content/content.registry',
  'i18n!csui/controls/thumbnail/content/date/impl/nls/localized.strings',
  'hbs!csui/controls/thumbnail/content/date/impl/date',
  'css!csui/controls/thumbnail/content/date/impl/date'
], function (module, $, _, Backbone, Marionette, base, ContentRegistry, lang, template) {
  'use strict';

  var config = _.extend({
    multiValueSeparator: ', '
  }, module.config());

  var DateView = Marionette.ItemView.extend({
    template: template,
    className: 'csui-thumbnail-date-container',

    templateHelpers: function () {
      var propertyValue = this.model.get(this.options.column.name);

      function format(singleValue) {
        return base.formatExactDateTime(singleValue);
      }

      var displayContent = this.getSingleOrMultipleValueData(propertyValue, format, format);
      if (this.options.displayLabel) {
        displayContent.label = this.options.contentModel.get("name") ?
                               this.options.contentModel.get("name") : lang.dateLabel;
      }
      displayContent.displayLabel = this.options.displayLabel;
      displayContent.cid = this.model.cid;
      return displayContent;
    },

    getSingleOrMultipleValueData: function (propertyValue, valueFormatter,
        formattedValueFormatter) {
      var value, formattedValue;
      if (Array.isArray(propertyValue)) {
        value = this.concatenateTextValues(propertyValue, valueFormatter);
        formattedValue = this.concatenateTextValues(propertyValue,
            formattedValueFormatter);
      } else {
        value = valueFormatter(propertyValue);
        formattedValue = formattedValueFormatter(propertyValue);
      }
      return {
        value: value,
        formattedValue: formattedValue
      };
    },

    concatenateTextValues: function (array, formatter) {
      formatter = this._validateFormater(formatter);
      return array.map(formatter).join(config.multiValueSeparator);
    },

    _validateFormater: function (formatter) {
      return formatter || function (value) { return value };
    },

    constructor: function DateView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }
  });
  ContentRegistry.registerByDataType(-7, DateView);
  return DateView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/thumbnail.icon/impl/thumbnail.icon',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div\r\n      class=\"csui-thumbnail-content-icon csui-thumbnail-content-no-default-action thumbnail-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\"\r\n      aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.typeAndNameAria || (depth0 != null ? depth0.typeAndNameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"typeAndNameAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\"></div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.inactive : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "");
},"4":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-thumbnail-content-icon csui-thumbnail-content-no-default-action inactive\"\r\n         aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.typeAndNameAria || (depth0 != null ? depth0.typeAndNameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"typeAndNameAria","hash":{}}) : helper)))
    + "\"></div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.inCreateMode : depth0),{"name":"if","hash":{},"fn":this.program(7, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "");
},"7":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-thumbnail-content-icon csui-thumbnail-content-default-action\"\r\n           aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.typeAndNameAria || (depth0 != null ? depth0.typeAndNameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"typeAndNameAria","hash":{}}) : helper)))
    + "\" tabindex=\"0\"></div>\r\n";
},"9":function(depth0,helpers,partials,data) {
    var helper;

  return "      <a class=\"csui-thumbnail-content-icon csui-thumbnail-content-default-action thumbnail-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\"\r\n         href=\""
    + this.escapeExpression(((helper = (helper = helpers.defaultActionUrl || (depth0 != null ? depth0.defaultActionUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"defaultActionUrl","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.typeAndNameAria || (depth0 != null ? depth0.typeAndNameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"typeAndNameAria","hash":{}}) : helper)))
    + "\"></a>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.thumbnailAction : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_thumbnail.icon_impl_thumbnail.icon', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/content/thumbnail.icon/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/thumbnail.icon/impl/nls/root/localized.strings',{
  typeAndNameAria: '{0} {1}',
  downloadTitle: 'Download',
  hideTitle: 'Hide filmstrip',
  showTitle: 'Show filmstrip',
  nextTitle: 'Next',
  previousTitle: 'Previous',
  videoNotSupportMsg: 'Your browser does not support the video tag.'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/thumbnail.icon/util/gallery',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-current-total-items\">"
    + this.escapeExpression(((helper = (helper = helpers.currentItem || (depth0 != null ? depth0.currentItem : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"currentItem","hash":{}}) : helper)))
    + " / "
    + this.escapeExpression(((helper = (helper = helpers.totalItems || (depth0 != null ? depth0.totalItems : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"totalItems","hash":{}}) : helper)))
    + "</div>\r\n<div class=\"csui-active-item-name\">\r\n  <span class=\"item-name\">"
    + this.escapeExpression(((helper = (helper = helpers.currentItemName || (depth0 != null ? depth0.currentItemName : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"currentItemName","hash":{}}) : helper)))
    + "</span>\r\n  <span title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.downloadTitle : stack1), depth0))
    + "\" class=\"icon icon-download-white csui-download-gallery\"\r\n        tabindex=\"0\"></span>\r\n</div>\r\n<div class=\"csui-carousel-container\">\r\n  <div class=\"csui-preview-carousal-container\">\r\n    <div id=\"binf-carousel\" class=\"binf-carousel binf-slide\" data-binf-ride=\"carousel\">\r\n      <div class=\"csui-preview-carousal\"></div>\r\n      <a class=\"binf-left binf-carousel-control\" href=\"#binf-carousel\" role=\"binf_button\"\r\n         data-binf-slide=\"binf-prev\" title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.previousTitle : stack1), depth0))
    + "\" tabindex=\"0\">\r\n        <span class=\"binf-glyphicon binf-glyphicon-menu-left\" aria-hidden=\"true\"></span>\r\n      </a>\r\n      <a class=\"binf-right binf-carousel-control\" href=\"#binf-carousel\" role=\"binf_button\"\r\n         data-binf-slide=\"binf-next\" title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.nextTitle : stack1), depth0))
    + "\" tabindex=\"0\">\r\n        <span class=\"binf-glyphicon binf-glyphicon-menu-right\" aria-hidden=\"true\"></span>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"csui-carousel-film-strip\">\r\n    <div class=\"binf-carousel binf-slide binf-filmstrip-container\" data-interval=\"false\"></div>\r\n    <a class=\"binf-left binf-carousel-control csui-thumb-toggle-control\" href=\"javascript:void(0);\"\r\n       role=\"binf_button\">\r\n    <span class=\"binf-glyphicon binf-glyphicon-menu-down\" aria-hidden=\"true\"\r\n          title=\""
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.lang : depth0)) != null ? stack1.hideTitle : stack1), depth0))
    + "\"></span>\r\n    </a>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_thumbnail.icon_util_gallery', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/thumbnail.icon/util/gallery.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.activeItem : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(13, data, 0)})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isVideo : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.program(8, data, 0)})) != null ? stack1 : "");
},"3":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <div class=\"binf-item binf-active binf-item-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.originalAvailable : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "      </div>\r\n";
},"4":function(depth0,helpers,partials,data) {
    return "          <div class=\"csui-video\">\r\n            <video preload=\"none\" poster=\"\" controls=\"controls\">\r\n              <source src=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.contentURL : depth0), depth0))
    + "\" type='"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.videoType : depth0), depth0))
    + "'>\r\n              </source>\r\n              "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.videoNotSupportMsg : depth0), depth0))
    + "\r\n            </video>\r\n          </div>\r\n";
},"6":function(depth0,helpers,partials,data) {
    return "          <div class=\"csui-video\">\r\n            <video preload=\"none\" poster=\"\" controls=\"controls\">\r\n              <source src=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.contentURL : depth0), depth0))
    + "\" type='"
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.videoType : depth0), depth0))
    + "'>\r\n              </source>\r\n              "
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.videoNotSupportMsg : depth0), depth0))
    + "\r\n            </video>\r\n            <div class=\"csui-img-loader\">\r\n              <div class=\"csui-img-loader-inner\"></div>\r\n            </div>\r\n          </div>\r\n";
},"8":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <div class=\"binf-item binf-active binf-item-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.originalAvailable : depth0),{"name":"if","hash":{},"fn":this.program(9, data, 0),"inverse":this.program(11, data, 0)})) != null ? stack1 : "")
    + "      </div>\r\n";
},"9":function(depth0,helpers,partials,data) {
    return "          <div class=\"csui-img-box csui-gallery-original-icon\">\r\n            <img src=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.contentURL : depth0), depth0))
    + "\" tabindex=\"0\">\r\n          </div>\r\n";
},"11":function(depth0,helpers,partials,data) {
    return "          <div class=\"csui-img-box csui-gallery-thumbnail-icon\">\r\n            <div>\r\n              <img src=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.contentURL : depth0), depth0))
    + "\" tabindex=\"0\">\r\n              <div class=\"csui-img-loader\">\r\n                <div class=\"csui-img-loader-inner\"></div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"csui-img-box csui-gallery-original-icon binf-hidden\">\r\n            <img src=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.contentURL : depth0), depth0))
    + "\" tabindex=\"0\">\r\n          </div>\r\n";
},"13":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isVideo : depth0),{"name":"if","hash":{},"fn":this.program(14, data, 0),"inverse":this.program(16, data, 0)})) != null ? stack1 : "");
},"14":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <div class=\"binf-item binf-item-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.originalAvailable : depth0),{"name":"if","hash":{},"fn":this.program(4, data, 0),"inverse":this.program(6, data, 0)})) != null ? stack1 : "")
    + "      </div>\r\n";
},"16":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "      <div class=\"binf-item binf-item-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.originalAvailable : depth0),{"name":"if","hash":{},"fn":this.program(9, data, 0),"inverse":this.program(11, data, 0)})) != null ? stack1 : "")
    + "      </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.data : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_thumbnail.icon_util_gallery.item', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/thumbnail.icon/util/filmstrip.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.activeItem : depth0),{"name":"if","hash":{},"fn":this.program(2, data, 0),"inverse":this.program(9, data, 0)})) != null ? stack1 : "");
},"2":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"binf-item binf-filmstrip-item-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + " binf-active\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" tabindex=\"0\">\r\n      <div class=\"binf-thumb\" data-binf-target=\"#binf-carousel\" data-binf-slide-to= "
    + this.escapeExpression(((helper = (helper = helpers.index || (depth0 != null ? depth0.index : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"index","hash":{}}) : helper)))
    + ">\r\n        <div class=\"binf-thumb-caption\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</div>\r\n        <div class=\"binf-thumb-img-container\">\r\n          <div class=\"binf-thumb-img "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isVideo : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isVideo : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.program(7, data, 0)})) != null ? stack1 : "")
    + "          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    return "binf-video-container ";
},"5":function(depth0,helpers,partials,data) {
    return "              <div class=\"binf-play-arrow-container\"><span\r\n                  class=\"binf-play-arrow\"></span></div>\r\n";
},"7":function(depth0,helpers,partials,data) {
    return "              <div>\r\n                <img src=\""
    + this.escapeExpression(this.lambda((depth0 != null ? depth0.thumbnailURL : depth0), depth0))
    + "\">\r\n              </div>\r\n";
},"9":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "    <div class=\"binf-item binf-filmstrip-item-"
    + this.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"id","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" tabindex=\"0\">\r\n      <div class=\"binf-thumb\" data-binf-target=\"#binf-carousel\" data-binf-slide-to= "
    + this.escapeExpression(((helper = (helper = helpers.index || (depth0 != null ? depth0.index : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"index","hash":{}}) : helper)))
    + ">\r\n        <div class=\"binf-thumb-caption\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</div>\r\n        <div class=\"binf-thumb-img-container\">\r\n          <div class=\"binf-thumb-img "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isVideo : depth0),{"name":"if","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isVideo : depth0),{"name":"if","hash":{},"fn":this.program(5, data, 0),"inverse":this.program(7, data, 0)})) != null ? stack1 : "")
    + "          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.data : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_thumbnail.icon_util_filmstrip.item', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/thumbnail.icon/util/gallary',[],function(){});
csui.define('csui/controls/thumbnail/content/thumbnail.icon/util/gallery.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'i18n',
  'hbs!csui/controls/thumbnail/content/thumbnail.icon/util/gallery',
  'hbs!csui/controls/thumbnail/content/thumbnail.icon/util/gallery.item',
  'hbs!csui/controls/thumbnail/content/thumbnail.icon/util/filmstrip.item',
  'css!csui/controls/thumbnail/content/thumbnail.icon/util/gallary'
], function (_, $, i18n, GalleryTemplate, GalleryItemTemplate, FlimStripItemTemplate) {
  'use strict';

  var data, galleryContent, galleryItems, galleryFilmItems, totalItems, currentItem, currentItemName, filmStripActiveItem, filmStripWidth;

  function createGalleryContainer(galleryData, currentItemIndex, lang) {
    data = galleryData;
    totalItems = galleryData.length;
    currentItem = galleryData[currentItemIndex];
    currentItemName = currentItem.name;

    galleryContent = $('<div />', {
      'class': 'binf-gallery-container',
      'html': GalleryTemplate({
        "totalItems": galleryData.length,
        "currentItem": currentItem.index + 1,
        "currentItemName": currentItemName,
        "lang": lang
      })
    });

    galleryItems = $('<div />', {
      'class': 'binf-carousel-inner',
      'html': GalleryItemTemplate({data: galleryData})
    });

    galleryFilmItems = $('<div />', {
      'class': 'csui-carousel-film-strip-inner',
      'html': FlimStripItemTemplate({data: galleryData})
    });

    galleryContent.find(".csui-carousel-film-strip .binf-carousel").html(galleryFilmItems);
    galleryContent.find(".csui-preview-carousal").html(galleryItems);

    if (data.length < 2) {
      galleryContent.find("#binf-carousel").children(".binf-left").hide();
      galleryContent.find("#binf-carousel").children(".binf-right").hide();
    }
    filmStripWidth = 74;
    //adjust film strip items
    var carouselFilmStripWidth = filmStripWidth * data.length;
    if ($(window).width() < carouselFilmStripWidth) {
      galleryContent.find('.csui-carousel-film-strip-inner').css('width',
          carouselFilmStripWidth + 'px');
      galleryContent.find('.csui-carousel-film-strip-inner').addClass('csui-film-strip-adjust');
    }

    galleryContent.find('#binf-carousel').on('slid.binf.carousel', updateSlide);
    galleryContent.find('.csui-thumb-toggle-control').on('click', {lang: lang}, thumbToggle);
    galleryContent.find('.csui-download-gallery').on('click', downloadItem);
    galleryFilmItems.find(".binf-item").on('keyup', function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        $(event.currentTarget) && $(event.currentTarget).find(".binf-thumb").trigger("click");
      }
    });
    return galleryContent;
  }

  function downloadItem(event) {
    currentItem.downloadItem(event);
  }

  function updateSlide(e) {
    //active item of film strip
    filmStripWidth = $(
            galleryContent.find('.csui-carousel-film-strip-inner .binf-thumb-img')[0]).width() + 10;
    filmStripActiveItem = galleryContent.find('.csui-carousel-film-strip-inner').find(
        '.binf-item').removeClass('binf-active');
    var filmStripActiveElement = $(filmStripActiveItem[$(e.relatedTarget).index()]);
    filmStripActiveElement.addClass('binf-active');
    if (currentItem && currentItem.index >= 0) {
      //current item and item name
      currentItem = data[$(e.relatedTarget).index()];
      //update with original image
      if (data[currentItem.index].model && data[currentItem.index].model.contentURL &&
          !data[currentItem.index].model.addedOriginalImage) {
        $(e.relatedTarget).addClass("csui-item-original");
        data[currentItem.index].addedOriginalImage = true;
        if ($(e.relatedTarget).find("img").length > 0) {
          $(e.relatedTarget).find("img").attr("src", data[currentItem.index].model.contentURL);
        }
        if ($(e.relatedTarget).find("video").length > 0) {
          $(e.relatedTarget).find("video").attr("src", data[currentItem.index].model.contentURL);
          $(e.relatedTarget).find(".outer-border").addClass("binf-hidden");
        }
      }
      currentItemName = currentItem.name;
      galleryContent.find('.csui-current-total-items').html(
          (currentItem.index + 1) + ' / ' + totalItems);
      galleryContent.find('.csui-active-item-name .item-name').html(currentItemName);
      currentItem.updateScroll(filmStripActiveElement);
    }
  }

  // toggle button for film strip
  function thumbToggle(event) {
    galleryContent.find('.csui-carousel-film-strip .binf-carousel').slideToggle();
    galleryContent.find('.binf-glyphicon-menu-down').toggleClass('binf-glyphicon-menu-up');
    if (galleryContent.find('.binf-glyphicon-menu-up').length > 0) {
      galleryContent.find('.binf-glyphicon-menu-up').attr('title', event.data.lang.showTitle);
    } else {
      galleryContent.find('.binf-glyphicon-menu-down').attr('title', event.data.lang.hideTitle);
    }
  }

  return {
    createGalleryContainer: createGalleryContainer,
    updateSlide: updateSlide,
    thumbToggle: thumbToggle,
    downloadItem: downloadItem
  };
});

csui.define('css!csui/controls/thumbnail/content/thumbnail.icon/impl/thumbnail.icon',[],function(){});
csui.define('csui/controls/thumbnail/content/thumbnail.icon/thumbnail.icon.view',[
  'module',
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/utils/node.links/node.links',
  'hbs!csui/controls/thumbnail/content/thumbnail.icon/impl/thumbnail.icon',
  'i18n!csui/controls/thumbnail/content/thumbnail.icon/impl/nls/localized.strings',
  'csui/controls/thumbnail/content/content.registry',
  'csui/controls/dialog/dialog.view',
  'csui/controls/thumbnail/content/thumbnail.icon/util/gallery.view',
  'csui/utils/commands/impl/thumbnail/thumbnail.object',
  'csui/models/nodes',
  'csui/utils/url',
  'csui/utils/taskqueue',
  'csui/utils/commands/download',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/lib/exif',
  'css!csui/controls/thumbnail/content/thumbnail.icon/impl/thumbnail.icon'
], function (module, _, $, Backbone, Marionette, base, NodeTypeIconView, nodeLinks, template, lang,
    ContentRegistry, DialogView, GalleryView, Thumbnail, NodeCollection, Url, TaskQueue,
    DownloadCommand, PerfectScrollingBehavior, EXIF) {
  'use strict';

  var config = module.config();
  _.defaults(config, {
    parallelism: 3
  });

  var ThumbnailIconView = Marionette.ItemView.extend({

    ui: {
      thumbnailIcon: '.csui-thumbnail-content-icon',
      iconcloseGallery:'.icon-close-gallery'
    },

    events: {
      'keydown': 'onKeyInView',
      'keydown @ui.iconcloseGallery':'handleShiftKey',
      'click @ui.thumbnailIcon': 'showThumbCarousel',
      'keyup @ui.thumbnailIcon': 'showGalleryView'
    },

    template: template,

    templateHelpers: function () {
      var node             = this.model,
          thumbnailAction  = this.model.get("mime_type") &&
                             this.model.get("mime_type").match(/^image|video\/*[-.\w\s]*$/g) ||
                             this.model.get("type") === 144,
          defaultActionUrl = nodeLinks.getUrl(this.model),
          typeAndName      = _.str.sformat(lang.typeAndNameAria, node.get('type_name'),
              node.get('name'));
      return {
        thumbnailAction: thumbnailAction,
        cid: (this.model && this.model.cid) || this.options.model.cid,
        defaultActionUrl: defaultActionUrl,
        typeAndNameAria: typeAndName,
        inactive: node.get('inactive'),
        inCreateMode: !this.model.get('id') // if node is in create mode e.g. add folder,
        // then id will not exist
      };
    },

    constructor: function ThumbnailIconView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.listenTo(this, 'render', this._createNodeTypeIcon)
          .listenTo(this, 'before:render', this._destroyNodeTypeIcon)
          .listenTo(this, 'before:destroy', this._destroyNodeTypeIcon)
          .listenTo(this.model, "update:thumbnail", this.updateThumbnailImage)
          .listenTo(this.model, "update:default:thumbnail", this.updateDefaultThumbnailImage);
    },

    showGalleryView: function (event) {
      if (event.keyCode === 13 || event.keyCode === 32) {
        this.showThumbCarousel(event);
      }
    },

    showThumbCarousel: function (event) {
      var self            = this,
          showGalleryView = false;
      if (base.isSafari() || base.isMSBrowser() || base.isAppleMobile()) {
        showGalleryView = this.model.get("mime_type") &&
                          (this.model.get("mime_type").match(/^image\/*[-.\w\s]*$/g) ||
                           this.model.get("mime_type").match(/^video\/(mp4|mov)$/g));
      } else {
        showGalleryView = this.model.get("mime_type") &&
                          (this.model.get("mime_type").match(/^image\/*[-.\w\s]*$/g) ||
                           this.model.get("mime_type").match(/^video\/(mp4|webm|ogg|mov)$/g));
      }
      if (showGalleryView && showGalleryView.length > 0) {
        this.options.originatingView.blockingView.enable();
        var thumbNailCollection = _.filter(self.model.collection.models, function (model) {
          if (base.isSafari() || base.isMSBrowser() || base.isAppleMobile()) {
            return model.get("mime_type") &&
                   (model.get("mime_type").match(/^image\/*[-.\w\s]*$/g) ||
                    model.get("mime_type").match(/^video\/(mp4|mov)$/g));
          } else {
            return model.get("mime_type") &&
                   (model.get("mime_type").match(/^image\/*[-.\w\s]*$/g) ||
                    model.get("mime_type").match(/^video\/(mp4|webm|ogg|mov)$/g));
          }
        }, this);
        this.fetchGalleryImageURL(thumbNailCollection);
        var thumbnailGalleryData = [],
            currentItemIndex     = 0;

        self.thumbNailCollection = thumbNailCollection;
        _.each(thumbNailCollection, function (model, idx) {
          var thumbnailData = {
            name: model.get('name'),
            contentURL: model.contentURL ? model.contentURL :
                        model.thumbnail ? model.thumbnail.url : "",
            thumbnailURL: (model.thumbnail && model.thumbnail.url) ? model.thumbnail.url :
                          model.contentURL ? model.contentURL : "",
            id: model.cid,
            index: idx,
            activeItem: model.get('id') === self.model.get('id'),
            downloadItem: self.downloadItem.bind(null, model),
            updateScroll: self.updateScroll.bind(null, self),
            isVideo: model.get("mime_type").match(/^video\/*[-.\w\s]*$/g),
            videoType: model.get("mime_type"),
            model: model,
            videoNotSupportMsg: lang.videoNotSupportMsg,
            originalAvailable: model.contentURL ? true : false
          };
          if (model.get('id') === self.model.get('id')) {
            currentItemIndex = idx;
          }
          thumbnailGalleryData.push(thumbnailData);

        }, self);
        var galleryContainer = GalleryView.createGalleryContainer(thumbnailGalleryData,
            currentItemIndex, lang),
            galleryView      = new GalleryContentView({el: galleryContainer[0]});
        var dialog = new DialogView({
          title: "",
          headerView: '',
          view: galleryView,
          className: "csui-thumbcarousel-dialog",
          userClassName: "",
          largeSize: true
        });
        dialog.show();
        dialog.headerView.$el.find('.cs-icon-cross').removeClass("cs-icon-cross").addClass(
            "icon-close-gallery");
        dialog.headerView.$el.bind('keydown', _.bind(this.handleShiftKey, this));
        self.options.originatingView.blockingView.disable();
        self.galleryView = galleryView;
      } else if (!this.model.get("inactive") && !!this.model.get('id')) {
        this.trigger('execute:defaultAction', event);
      }
    },
    handleShiftKey: function(event) {
      var shiftKey = event.shiftKey;
      if(event.shiftKey && event.keyCode == 9) {              
        var cid = this.thumbNailCollection[this.thumbNailCollection.length-1].cid;
        setTimeout(function() {
          $(".binf-filmstrip-item-" + cid).focus();          
          }, 200);     
          }      
    },

    downloadItem: function (nodeModel, event) {
      new DownloadCommand().execute({
        nodes: new NodeCollection([nodeModel])
      });
    },

    updateScroll: function (view, element) {
      view.galleryView.updateScrollbar(element);
    },

    fetchOriginalThumbNails: function (thumbnailForNode) {
      var self     = this,
          model    = thumbnailForNode,
          deferred = $.Deferred();

      self._fetchThumbNailObject(model).done(function (node) {
        deferred.resolve(node);
      }).fail(function (node) {
        deferred.reject(node);
      });
      return deferred.promise();
    },

    _fetchThumbNailObject: function (node) {
      var deferredObject = $.Deferred(),
          thumbnail      = new Thumbnail({
            node: node
          });
      thumbnail.load();
      this.listenTo(thumbnail, 'load', function (thumbnail) {
            node.thumbnail = {};
            node.thumbnail.url = thumbnail.url;
            node.attributes.thumbnailPreviewAvailable = true;
            node.trigger('update:thumbnail', node);
            deferredObject.resolve(node);
          })
          .listenTo(thumbnail, 'error', function (thumbnail) {
            node.thumbnail = {};
            node.thumbnail.url = undefined;
            node.attributes.thumbnailPreviewAvailable = false;
            node.trigger('update:default:thumbnail', node);
            deferredObject.reject(node);
          });
      return deferredObject.promise();
    },

    updateThumbnailImage: function (node) {
      if (node && node.thumbnail) {
        var thumbnailItemContainer = this.$el.find(
            '.csui-thumbnail-content-icon.thumbnail-' + node.cid);
        thumbnailItemContainer.find(".csui-icon-group").css('background-image',
            'url(' + node.thumbnail.url + ')');
        thumbnailItemContainer.addClass('thumbnailPreview');
        if ($(".binf-filmstrip-item-" + node.cid).length > 0) {
          var filmStripImage = $(".binf-filmstrip-item-" + node.cid).find("img");
          if (filmStripImage.length > 0) {
            filmStripImage.attr("src", node.thumbnail.url);
          }
        }
      }
    },

    updateDefaultThumbnailImage: function (node) {
      if (node && node.thumbnail && node.thumbnail.url) {
        var thumbnailItemContainer = this.$el.find(
            '.csui-thumbnail-content-icon.thumbnail-' + node.cid);
        thumbnailItemContainer.find(".csui-icon-group").css('background-image',
            'url(' + node.thumbnail.url + ')');
        thumbnailItemContainer.find(".csui-icon").addClass("binf-hidden");
      }
    },

    fetchGalleryImageURL: function (models) {
      var self     = this,
          queue    = new TaskQueue({
            parallelism: config.parallelism
          }),
          promises = _.map(models, function (model) {
            var deferred = $.Deferred();
            if (!model.contentURL) {
              queue.pending.add({
                worker: function () {
                  self._fetchImageOpenURL(model).done(function (node) {
                    deferred.resolve(node);
                  }).fail(function (node) {
                    deferred.reject(node);
                  });

                  return deferred.promise();
                }
              });
            }
            return deferred.promise(promises);  // return promises
          });
      return $.whenAll.apply($, promises);
    },

    _fetchImageOpenURL: function (node) {
      var self            = this,
          deferredObject  = $.Deferred(),
          photoUrl        = Url.combine(node.connector.connection.url, '/nodes',
              node.get('id'), '/content?action=open&suppress_response_codes'),
          getPhotoOptions = node.connector.extendAjaxOptions({
            url: photoUrl,
            dataType: 'binary'
          });
      if (node.get("type") === 144) {
        var transformDegrees = 0, flipRight = false;
        $.ajax(getPhotoOptions)
            .always(_.bind(function (response, statusText, jqxhr) {
              if (jqxhr.status === 200) {
                node.contentURL = URL.createObjectURL(response);
                node.addedOriginalImage = true;
                if (node.get("mime_type").match(/^video\/!*[-.\w\s]*$/g)) {
                  var video = self.galleryView &&
                              self.galleryView.$el.find(".binf-item-" + node.cid).find("video");
                  if (video.length > 0) {
                    video.attr("src", node.contentURL);
                    self.galleryView.$el.find(".binf-item-" + node.cid).addClass(
                        "csui-item-original");
                    self.galleryView.$el.find(
                        ".binf-item-" + node.cid + " .csui-img-loader").addClass(
                        "binf-hidden");
                  }
                } else {
                  var galleryItem    = self.galleryView &&
                                       self.galleryView.$el.find(".binf-item-" + node.cid),
                      thumbnailImage = galleryItem.find(".csui-gallery-thumbnail-icon"),
                      originalImage  = galleryItem.find(".csui-gallery-original-icon");
                  EXIF.getData(response, function () {
                    var myData      = this,
                        orientation = myData && myData.exifdata && myData.exifdata.Orientation;
                    /*1: it means it needs no rotation
                      2: it means it needs to flip right
                      3: it means it needs to rotate 180deg
                      4: it means it needs to flip right and rotate 180deg
                      5: it means it needs to flip right and rotate 90deg
                      6: it means it needs to rotate 90deg
                      7: it means it needs to flip right rotate -90deg
                      8: it means it needs to rotate -90deg*/
                    if (orientation === 7 || orientation === 8) {
                      transformDegrees = -90;
                    } else if (orientation === 5 || orientation === 6) {
                      transformDegrees = 90;
                    } else if (orientation === 3 || orientation === 4) {
                      transformDegrees = 180;
                    } else {
                      transformDegrees = 0;
                    }
                    if (orientation === 2 || orientation === 4 || orientation === 5 ||
                        orientation === 7) {
                      flipRight = true;
                    }
                    if (thumbnailImage.length > 0) {
                      originalImage.find("img").attr("src", node.contentURL);
                      originalImage.find("img").addClass("csui-item-original");
                      originalImage.removeClass("binf-hidden");
                      thumbnailImage.addClass("binf-hidden");
                      if (flipRight) {
                        originalImage.find("img").css({
                          "-webkit-transform": "scaleX(-1)",
                          "-moz-transform": "scaleX(-1)",
                          "-o-transform": "scaleX(-1)",
                          "transform": "scaleX(-1)",
                          "filter": "FlipH",
                          "-ms-filter": "FlipH"
                        });
                      }
                      originalImage.find("img").css({
                        "-webkit-transform": "rotate(" + transformDegrees + "deg)",
                        "-moz-transform": "rotate(" + transformDegrees + "deg)",
                        "-ms-transform": "rotate(" + transformDegrees + "deg)",
                        "-o-transform": "rotate(" + transformDegrees + "deg)",
                        "transform": "rotate(" + transformDegrees + "deg)"
                      });
                    }
                  });
                }
                deferredObject.resolve();
              }
            }, this));
      }
      return deferredObject.promise();
    },

    _createNodeTypeIcon: function () {
      var iconView = new NodeTypeIconView({node: this.model});
      this.contentRegion = new Marionette.Region({el: this.$('> *')});
      this.contentRegion.show(iconView);
      if (this.model.get("type") === 144 && !(this.model.thumbnail && this.model.thumbnail.url)) {
        this.fetchOriginalThumbNails(this.model);
      } else if (this.model.get("type") === 144 && this.model.thumbnail &&
                 this.model.thumbnail.url) {
        this.updateThumbnailImage(this.model);
      } else if (this.model.get("type") === 144 && this.model.thumbnail &&
                 !this.model.thumbnail.url) {
        this.updateDefaultThumbnailImage(this.model);
      }
    },

    _destroyNodeTypeIcon: function () {
      if (this.contentRegion) {
        this.contentRegion.empty();
        this.contentRegion = null;
      }
    },

    onKeyInView: function (event) {
      // Watch for Enter and Space keys
      if (event.keyCode === 13 || event.keyCode === 32) {
        this.$el.find('a.csui-thumbnail-content-default-action').click();
      }
    }
  });

  var GalleryContentView = Marionette.View.extend({

    constructor: function GalleryContentView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.binf-filmstrip-container',
        suppressScrollY: true,
        scrollXMarginOffset: 2
      }
    },
    updateScrollbar: function (element) {
      this.trigger('update:scrollbar');
      var container = this.$(this.behaviors.PerfectScrolling.contentParent),
          scrollX   = this.$el.find('.binf-filmstrip-container').scrollLeft(),
          adjustScrollLeft;
      if (element.offset().left + element.width() >= container.width()) {
        adjustScrollLeft = element.offset().left - container.width() + scrollX + element.width() +
                           20;
      } else if (element.offset().left <= 0) {
        adjustScrollLeft = element.offset().left + scrollX - 5;
      }
      this.$(this.behaviors.PerfectScrolling.contentParent).animate(
          {scrollLeft: adjustScrollLeft}, "fast");
    }
  });

  ContentRegistry.registerByKey('thumbnailIcon', ThumbnailIconView);
  return ThumbnailIconView;
});


csui.define('csui/controls/thumbnail/content/overview/overview.content',['csui/lib/underscore', "csui/lib/backbone",
  'csui-ext!csui/controls/thumbnail/content/overview/overview.content'
], function (_, Backbone, extraOverviewContent) {

  var OverviewContentModel = Backbone.Model.extend({

    idAttribute: "key",

    defaults: {
      key: null,  // key from the resource definitions
      sequence: 0 // smaller number moves the column to the front
    }

  });

  var OverviewContentCollection = Backbone.Collection.extend({

    model: OverviewContentModel,
    comparator: "sequence",

    getColumnKeys: function () {
      return this.pluck('key');
    },

    deepClone: function () {
      return new OverviewContentCollection(
          this.map(function (column) {
            return column.attributes;
          }));
    }

  });

  // Content delivered from server get sequence set to 500

  var overviewContent = [
    {
      key: 'type',
      sequence: 2,
      defaultAction: false
    },
    {
      key: 'name',
      sequence: 4,
      displayLabel: true,
      defaultAction: false,
      displayIcon: true
    },
    {
      key: 'properties',
      title: 'properties',
      sequence: 7
    },
    {
      key: 'reserved',
      sequence: 100,
      title: 'State'
    }
  ];

  var fixedOrRemovedOverviewContent = ['type', 'name', 'properties', 'reserved', 'wnd_comments'];

  if (extraOverviewContent) {
    _.each(extraOverviewContent, function (moduleOverviewContent) {
      _.each(moduleOverviewContent, function (contentData, key) {
        overviewContent.push(contentData);
      });
    });
  }

  var overviewContentCollection = new OverviewContentCollection(overviewContent);
  overviewContentCollection.fixedOrRemovedOverviewContent = fixedOrRemovedOverviewContent;

  return overviewContentCollection;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/impl/content',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "    <div class=\"csui-thumbnail-label csui-thumbnail-item-content-label\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "\">\r\n      <span>"
    + this.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"label","hash":{}}) : helper)))
    + "</span>\r\n    </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-thumbnail-item-content csui-thumbnail-item-content-"
    + this.escapeExpression(((helper = (helper = helpers.cid || (depth0 != null ? depth0.cid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"cid","hash":{}}) : helper)))
    + "\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.displayLabel : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "  <div class=\"csui-thumbnail-value csui-thumbnail-item-content-justify-div\">\r\n    <p class=\"csui-thumbnail-item-content-value\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\"\r\n       aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"value","hash":{}}) : helper)))
    + "</p>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_impl_content', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/content/content.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'hbs!csui/controls/thumbnail/content/impl/content'
], function ($, _, Backbone, Marionette, template) {
  'use strict';

  var ContentView = Marionette.ItemView.extend({
    template: template,
    className: 'csui-thumbnail-content-item',

    templateHelpers: function () {
      var model = this.options.contentModel,
          columnName = model.get("name"),
          key = model.get("key"),
          value = this.model.get(key);
      return {
        value: value,
        displayLabel: this.options.displayLabel,
        label: this.options.displayLabel ? columnName : "",
        cid: this.model.cid
      };
    },

    constructor: function ContentView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }
  });
  return ContentView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/properties/impl/properties',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-thumbnail-properties\">\r\n  <button type=\"button\" class=\"csui-btn-metadata binf-btn\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.propertiesTitle || (depth0 != null ? depth0.propertiesTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"propertiesTitle","hash":{}}) : helper)))
    + "\"><span\r\n    class=\"icon icon-toolbar-metadata\"></span></button>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_properties_impl_properties', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/content/properties/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/properties/impl/nls/root/localized.strings',{
  propertiesTitle: "Properties"
});


csui.define('csui/controls/thumbnail/content/properties/properties.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'csui/controls/thumbnail/content/content.registry',
  'csui/utils/commands/properties',
  'csui/models/nodes',
  'hbs!csui/controls/thumbnail/content/properties/impl/properties',
  'i18n!csui/controls/thumbnail/content/properties/impl/nls/localized.strings'
], function ($, _, Marionette, ContentRegistry, PropertiesCommand, NodeCollection, template, lang) {
  'use strict';

  var ThumbnailPropertiesView = Marionette.LayoutView.extend({
    template: template,
    templateHelpers: function () {
      return {
        propertiesTitle: lang.propertiesTitle
      };
    },
    className: 'csui-thumbnail-properties-container',

    regions: {
      propertiesRegion: '.csui-thumbnail-properties'
    },

    events: {
      'click .csui-btn-metadata': 'showMetadataForm'
    },

    constructor: function ThumbnailPropertiesView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
    },

    showMetadataForm: function (event) {
      var nodes = new NodeCollection([this.model]);

      var status = {
        nodes: nodes,
        data: {},
        container: this.options.collection.node,
        context: this.options.context,
        collection: this.options.collection,
        showThumbnails: true
      };

      status = _.extend(status, {originatingView: this.options.originatingView});
      // view properties of an existing item
      var propertiesCmd = new PropertiesCommand();
      propertiesCmd.execute(status, this.options)
          .always(function (args) {
            // Applying z-index property to handle the long configurable items in popover
            $('body').addClass('csui-apply-zero-zindex');
          });
          // Removing the z-index property to make the breadcrumb items clickable      
          $('body').removeClass('csui-apply-zero-zindex');
    },

    cancel: function (options) {
      options || (options = {});
      this.destroy();
    }

  });
  ContentRegistry.registerByKey('properties', ThumbnailPropertiesView);
  return ThumbnailPropertiesView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/overview/impl/properties.overview',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return "  <div class=\"csui-thumbnail-properties csui-thumbnail-overview-"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.attributes : depth0)) != null ? stack1.key : stack1), depth0))
    + "\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-thumbnail-properties csui-thumbnail-overview-name\"></div>\r\n<div class=\"csui-thumbnail-metadata-container\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.columns : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</div>\r\n<div class=\"csui-thumbnail-properties-actions\">\r\n  <div class=\"csui-thumbnail-properties csui-thumbnail-overview-properties\"></div>\r\n  <div class=\"csui-thumbnail-properties csui-thumbnail-overview-reserved\"></div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_overview_impl_properties.overview', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/thumbnail/content/overview/properties.overview',[
  'module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/thumbnail/content/overview/overview.content',
  'csui/controls/thumbnail/content/content.view',
  'csui/controls/thumbnail/content/name/name.view',
  'csui/controls/thumbnail/content/properties/properties.view',
  'csui/controls/thumbnail/content/node.state/node.state.view',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'hbs!csui/controls/thumbnail/content/overview/impl/properties.overview'
], function (module, _, $, Backbone, Marionette, OverviewContent, DefaultContentView, NameView,
    PropertiesView, NodeStateView, PerfectScrollingBehavior, template) {
  'use strict';
  var PropertiesOverview = Marionette.LayoutView.extend({

    className: 'csui-overview-container',
    template: template,
    templateHelpers: function () {
      return {
        columns: this.columnModels
      };
    },
    regions: {
      nameRegion: '.csui-thumbnail-overview-name',
      propertiesRegion: '.csui-thumbnail-overview-properties',
      nodeStateRegion: '.csui-thumbnail-overview-reserved'
    },
    events: {
      'keydown': 'onKeyInView'
    },
    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.csui-thumbnail-metadata-container',
        suppressScrollX: true,
        // like bottom padding of container, otherwise scrollbar is shown always
        scrollYMarginOffset: 15
      }
    },

    initialize: function () {
      this.propertiesCollection = this.getColumns();
      var self = this, columnModels = [];
      if (this.propertiesCollection && this.propertiesCollection.models) {
        _.each(this.propertiesCollection.models, function (model, index) {
          var region = model.get("key");
          if (!!self.model.get(region)) {
            columnModels.push(model);
          }
        });
      }
      this.columnModels = columnModels;
    },

    constructor: function PropertiesOverview(options) {
      options || (options = {});
      this.options = options;
      Marionette.LayoutView.prototype.constructor.call(this, options);
      var self = this;
      if (this.columnModels) {
        _.each(this.columnModels, function (model, index) {
          var region  = model.get("key"),
              content = options.ContentFactory.getContentView(model);
          if (content) {
            self.addRegion(region, ".csui-thumbnail-overview-" + region);
          } else {
            self.addRegion(region, ".csui-thumbnail-overview-" + region);
          }
        }, this);
      }
    },

    getColumns: function () {
      var self = this,
          cols = [],
          properties;
      if (OverviewContent && OverviewContent.models) {
        this.fixedContent = OverviewContent.fixedOrRemovedOverviewContent;
        properties = OverviewContent.deepClone(); // use fresh collection every time
        properties.remove(
            properties.findWhere({key: 'properties'}));
        var columnModelsByKey = {}, clientNamingKey, serverNamingKey;

        // add the columns that come from the server to the columns collection, which automatically
        // sort the items by sequence
        this.options.columns.each(function (nodeColumnModel) {
          // The server used to send columns without type.  It probably included also
          // those not ready for display yet.
          var key   = nodeColumnModel.get("column_key"),
              name  = nodeColumnModel.get("name"),
              order = nodeColumnModel.get("definitions_order");
          if (nodeColumnModel.get("isNaming") === true) {
            serverNamingKey = key;
            nodeColumnModel.unset('isNaming', {silent: true});
          }
          columnModelsByKey[key] = nodeColumnModel;
          if (nodeColumnModel.get("type") && order) {

            // search server defined column in client side defined columns
            var tableColumnToMergeWithServerColumn = properties.findWhere({key: key});
            if (tableColumnToMergeWithServerColumn) {
              // column is defined on server and client side
              if (tableColumnToMergeWithServerColumn.get('isNaming') === true) {
                clientNamingKey = tableColumnToMergeWithServerColumn.get("key");
              }
              // use server side defined attributes, except for sequence
              var sequence = tableColumnToMergeWithServerColumn.get('sequence');
              var mergedColumnAttributes = _.extend({sequence: sequence},
                  nodeColumnModel.attributes);
              tableColumnToMergeWithServerColumn.set(mergedColumnAttributes);
            } else {
              nodeColumnModel.attributes.sequence = order;
              properties.add(nodeColumnModel.attributes);
            }
          }
          if (self.fixedContent.indexOf(key) >= 0) {
            properties.remove(
                properties.findWhere({key: key}));
          }
        }, this);
      }
      return properties;
    },

    currentlyFocusedElement: function (event) {
      return this.$el.find(":focusable")[0];
    },

    onKeyInView: function (event) {
      if (event && event.keyCode === 27) {
        event.preventDefault();
        event.stopPropagation();
        var popoverTarget = this.$el.parents('body').find('.binf-popover');
        popoverTarget.parent().click();
      }
    },

    onRender: function (e) {
      var self = this;
      var nameView = new NameView({
        model: self.model,
        context: self.options.context,
        column: {name: 'name', defaultAction: false},
        displayIcon: true
      });
      this.nameRegion.show(nameView);
      if (this.columnModels) {
        _.each(this.columnModels, function (model, index) {
          var content = this.options.ContentFactory.getContentView(model);
          content = content ? content : DefaultContentView;
          if (content) {
            var region        = model.get("key"),
                defaultAction = model.get("defaultAction"),
                displayLabel  = true,
                displayIcon   = model.get("displayIcon"),
                name          = model.get("key");
            var contentView = new content({
              tagName: 'DIV',
              contentModel: model,
              model: self.model,
              context: self.options.context,
              column: {name: name, defaultAction: defaultAction},
              displayLabel: displayLabel,
              displayIcon: displayIcon
            });
            self[region].show(contentView);
            if (contentView.$el.find(".csui-thumbnail-value p").length > 0 &&
                contentView.$el.find(".csui-thumbnail-value p")[0].innerHTML === "") {
              contentView.$el.parent().addClass("binf-hidden");
            }
            self.listenTo(contentView, 'clicked:content', function (event) {
              self.trigger('clicked:content', {
                contentView: contentView,
                rowIndex: self._index,
                colIndex: index,
                model: self.model
              });
            });
          }
        }, this);
      }
      var propertiesView = new PropertiesView({
        model: self.model,
        context: self.options.context,
        column: {name: 'properties', defaultAction: true},
        displayIcon: true,
        selectedChildren: self.options.selectedChildren,
        collection: self.options.collection,
        originatingView: self.options.originatingView
      });
      this.propertiesRegion.show(propertiesView);
      var nodeStateView = new NodeStateView({
        model: self.model,
        context: self.options.context,
        column: {name: 'reserved', defaultAction: true},
        displayTitle: false,
        selectedChildren: self.options.selectedChildren,
        collection: self.options.collection,
        originatingView: self.options.originatingView,
        targetView: this
      });
      this.nodeStateRegion.show(nodeStateView);
    }

  });
  return PropertiesOverview;
});
csui.define('csui/controls/thumbnail/content/overview/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/thumbnail/content/overview/impl/nls/root/localized.strings',{
  ColumnTitle: "Metadata",
  Modified: "Modified",
  Size: "Size"
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/overview/impl/overview',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "tabindex=\"0\"\r\n        ";
},"3":function(depth0,helpers,partials,data) {
    return "tabindex=\"-1\"";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<button type=\"button\" class=\"csui-thumbnail-overview-icon\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.overViewTitle || (depth0 != null ? depth0.overViewTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"overViewTitle","hash":{}}) : helper)))
    + "\"\r\n        aria-haspopup=\"dialog\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.overViewTitle || (depth0 != null ? depth0.overViewTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"overViewTitle","hash":{}}) : helper)))
    + "\" "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.focusable : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + ">\r\n  <span class=\"icon icon-thumbnail-metadata-overview\"></span>\r\n</button>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_overview_impl_overview', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/overview/impl/overview',[],function(){});
csui.define('csui/controls/thumbnail/content/overview/overview.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/thumbnail/content/content.registry',
  'csui/controls/thumbnail/content/content.factory',
  'csui/controls/thumbnail/content/overview/properties.overview',
  'csui/controls/mixins/keyboard.navigation/modal.keyboard.navigation.mixin',
  'csui/utils/base',
  'i18n',
  'i18n!csui/controls/thumbnail/content/overview/impl/nls/localized.strings',
  'hbs!csui/controls/thumbnail/content/overview/impl/overview',
  'css!csui/controls/thumbnail/content/overview/impl/overview'
], function ($, _, Backbone, Marionette, ContentRegistry, ContentFactory, PropertiesOverview,
    ModalKeyboardNavigationMixin, base,
    i18n, lang, template) {
  'use strict';

  var OverviewView = Marionette.LayoutView.extend({
    className: 'csui-thumbnail-overview-container',
    template: template,

    constructor: function OverviewView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
      _.defaults(options, {
        formPopoverPlacement: 'right'
      });
      this.options = options;
    },

    templateHelpers: function () {
      return {
        overViewTitle: lang.ColumnTitle,
        focusable: this.options.focusable || true
      };
    },

    events: {
      'keydown': 'onKeyInView',
      'click .csui-thumbnail-overview-icon': '_showPopover'
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {  // space or
        // enter key
        // if the overview Popover is currently shown, do nothing here
        if (this.$el.find('.binf-popover').length > 0) {
          event.stopPropagation();
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._showPopover();
      } else if (event.keyCode === 27) { //esc key
        if (this.$el.find('.binf-popover').length > 0) {
          event.preventDefault();
          event.stopPropagation();
          this._closePopover();
        }
      }
    },

    _capturePreviousFocusElement: function () {
      // capture focus element before popover opens
      this._previousFocusElm = document.activeElement;
    },

    _restorePreviousFocusAfterClosingPopover: function () {
      // restore focus on previous focusing element
      if (this._previousFocusElm) {
        var $previousElm = $(this._previousFocusElm);
        if ($previousElm.hasClass('csui-thumbnail-overview-icon')) {
          this.$el.find('button.csui-thumbnail-overview-icon').focus();
        } else {
          $previousElm.focus();
        }
        this._previousFocusElm = undefined;
      }
    },

    _showPopover: function (event) {
      var self = this;
      // Return if PopOver is already opened
      if (this.$el.find('.binf-popover').length > 0) {
        return;
      }
      this._capturePreviousFocusElement();
      var placement = this.options.formPopoverPlacement;

      if (i18n && i18n.settings.rtl) {
        this.rtl = true;
      }

      this.propertiesOverview = new PropertiesOverview({
        model: this.model,
        context: this.options.context,
        ContentFactory: this.options.ContentFactory,
        originatingView: this.options.originatingView,
        selectedChildren: this.options.selectedChildren,
        collection: this.options.collection,
        columns: this.options.columns
      });
      this.propertiesOverview.render();

      this.$popoverEl = this.$el.find('.csui-thumbnail-overview-icon');
      this._previousTitle = this.$popoverEl.attr('title');
      this.$popoverEl.attr("title", "");
      var leftPercent = (this.$popoverEl.offset().left / $(window).width()) * 100;
      if (leftPercent > 80) {
        this.plcamentChanged = true;
        placement = (placement === 'right') ? 'left' : 'right';
      }

      this.$popoverEl.binf_popover({
        content: _.bind(function () {
          return this.propertiesOverview.el;
        }, this),
        html: true,
        placement: function (tip, element) {
          var self     = this,
              position = placement;
          /* setTimeout(function () {
             self.$tip.css('top', (self.$arrow.parent().offset().top - self.$arrow.offset().top));
           }, 0);*/
          return position;
        },
        trigger: 'manual'
      });

      this.$popoverEl.binf_popover('show');
      this.propertiesOverview.trigger('dom:refresh');
      this.engageModalKeyboardFocusOnOpen(this.propertiesOverview.el);
      this.$popoverEl.on('shown.binf.popover', _.bind(function (event) {
        $(document).on('click.popover', {view: this}, this._handleClickEvent);
        this.scrollEle = this.$el.closest('.csui-thumbnail-results');
        this.scrollEle.on('scroll.popover', {view: this}, this._handleScrollEvent);
        self.onShowOverviewFlyout(event);
        self.triggerMethod("shown:overview:flyout");
        this.propertiesOverview && this.propertiesOverview.currentlyFocusedElement().focus();
        }, this));
    },

    onShowOverviewFlyout: function (args) {
      var flyOutTarget        = this.$el,
          popoverContainer    = this.$el.parent().find(".binf-popover"),
          popoverArrowEl      = popoverContainer.find('.binf-arrow'),
          popoverArrowTop     = parseInt(popoverArrowEl.css('top')),
          popoverArrowHeight  = parseInt(popoverArrowEl.css('height')),
          arrowWidth          = popoverArrowEl.outerWidth() === 0 ? 28 :
                                popoverArrowEl.outerWidth(),
          scrollableParent    = this.$el.closest('.csui-thumbnail-results'),
          scrollableContainer = (scrollableParent.closest('.ps-container').length > 0 ?
                                 scrollableParent.closest('.ps-container') :
                                 scrollableParent.closest('.csui-normal-scrolling')),
          popoverMetadata     = popoverContainer.find(".csui-thumbnail-metadata-container"),
          popoverName         = popoverContainer.find(".csui-thumbnail-overview-name"),
          popoverActions      = popoverContainer.find(".csui-thumbnail-properties-actions"),
          flyOutTopPosition;

      //Set the height
      var popoverMetadataHeight = (popoverMetadata.height() > window.innerHeight) ?
                                  window.innerHeight -
                                  (popoverName.height() + popoverActions.height() + 100) :
                                  (window.innerHeight <
                                   popoverMetadata.height() + popoverName.height() +
                                   popoverActions.height() + 100) ? popoverMetadata.height() - 100 :
                                  popoverMetadata.height();
      popoverMetadata.css({'height': popoverMetadataHeight});
      if (base.isIE11()) {
        flyOutTopPosition = flyOutTarget.offset().top - parseInt(popoverArrowEl.css('top')) + 12;
      } else {
        flyOutTopPosition = flyOutTarget.offset().top - ($('nav.csui-navbar').innerHeight() +
                                                         $('#breadcrumb-wrap').innerHeight() +
                                                         parseInt(popoverArrowEl.css('top'))) + 11;
      }
      var perspectivePanel          = $(".cs-perspective-panel"),
          perspectivePanelClientTop = perspectivePanel.length > 0 ?
                                      perspectivePanel[0].getBoundingClientRect().top : 0;
      if (base.isIE11() &&
          flyOutTopPosition < (perspectivePanelClientTop + $('#breadcrumb-wrap').innerHeight())) {
        flyOutTopPosition = flyOutTarget.offset().top - ($('nav.csui-navbar').innerHeight() +
                                                         $('#breadcrumb-wrap').innerHeight()) + 12;
        popoverArrowTop = (flyOutTarget.offset().top - flyOutTopPosition) + 12;
        popoverArrowEl.css('top', popoverArrowTop);
      }
      if (flyOutTopPosition < perspectivePanelClientTop && !base.isIE11()) {
        flyOutTopPosition = 0;
        popoverArrowTop = flyOutTarget.offset().top - ($('nav.csui-navbar').innerHeight() +
                                                       $('#breadcrumb-wrap').innerHeight()) + 11;
        popoverArrowEl.css('top', popoverArrowTop);
      }
      popoverContainer.css({
        'position': 'fixed',
        'top': flyOutTopPosition
      });

      //update scrollbar for touch Browser
      if (base.isTouchBrowser()) {
        scrollableContainer.css({'-webkit-overflow-scrolling': 'auto'});
      }
      var flyOutLeft;
      if (this.plcamentChanged) {
        flyOutLeft = flyOutTarget.offset().left - popoverContainer.outerWidth();
      } else {
        flyOutLeft = flyOutTarget.offset().left + flyOutTarget.width();
      }

      popoverContainer.css({
        'right': 'auto',
        'left': flyOutLeft
      });

      this._adjustFlyOut();
      //update flyOut popover top position
      var documentHeight     = ($(window).height()),
          originalPopoverTop = popoverContainer.offset().top,
          flyOutHeight       = popoverContainer.innerHeight() - parseInt(popoverArrowEl.css('top')),
          flyOutTargetTop    = flyOutTarget.offset().top,
          adjustedPosition   = flyOutTargetTop + flyOutHeight + popoverArrowHeight - documentHeight;

      //Trigger dom:refresh event to attach perfect scrollbar. dom:refresh will not be triggered
      // automatically for this view
      Marionette.triggerMethodOn(this, 'dom:refresh', this);
      flyOutTarget.focus();
    },

    _adjustFlyOut: function () {
      this.propertiesOverview.trigger('update:scrollbar');
      var scrollableParent = this.$el.closest('.csui-thumbnail-results'),
          documentHeight   = ($(window).height()),
          headerHeight     = $('nav.csui-navbar').innerHeight() / 2;
      this.currentNavbarIndex = $('nav.csui-navbar').css('z-index');
      this.currentBreadcrumbIndex = $('#breadcrumb-wrap').css('z-index');
      //update flyOut popover height for small screens
      if (this.$el.height() > documentHeight) {
        this.$el.height(documentHeight - headerHeight);
      }

      $('body').addClass('csui-apply-zero-zindex');
      //close flyOut popover
      var scrollableContainer = (scrollableParent.closest('.ps-container').length > 0 ?
                                 scrollableParent.closest('.ps-container') :
                                 scrollableParent.closest('.csui-normal-scrolling'));

      $(scrollableContainer).on("scroll", function () {
        if ($(this).data('binf.popover')) {
          $(this).binf_popover('destroy');
          $('body').removeClass('csui-apply-zero-zindex');
        }
      });

      return false;
    },

    _closePopover: function () {
      this.disengageModalKeyboardFocusOnClose();
      this.$popoverEl.binf_popover('destroy');
      if (this._previousTitle) {
        this.$popoverEl.attr('title', this._previousTitle);
        this._previousTitle = undefined;
      }
      $(document).off('click.popover', this._handleClickEvent);
      this.scrollEle.off('scroll.popover', this._handleScrollEvent);
      $('body').removeClass('csui-apply-zero-zindex');
      this.triggerMethod("hide:overview:flyout");
      this._restorePreviousFocusAfterClosingPopover();
    },

    _handleClickEvent: function (event) {
      if (!$(event.target).closest('.binf-popover').length) {
        var view = event.data.view;
        $(document).off('click.popover', this._handleClickEvent);
        view._closePopover();
      }
    },

    _handleScrollEvent: function (event) {
      var self = event.data.view;
      if (!$(event.target).closest('.binf-popover').length) {
        // always turn off the scroll event in case the popover was already closed
        self.scrollEle.off('scroll.popover', self._handleScrollEvent);
        self && self._closePopover();
      }
    }
  });
  ContentRegistry.registerByKey('overview', OverviewView);
  ModalKeyboardNavigationMixin.mixin(OverviewView.prototype);
  return OverviewView;
});


csui.define('csui/controls/thumbnail/content/content.factory',['csui/lib/underscore', 'csui/controls/thumbnail/content/content.registry',
  'csui/controls/thumbnail/content/favorite/favorite.view',
  'csui/controls/thumbnail/content/node.state/node.state.view',
  'csui/controls/thumbnail/content/name/name.view',
  'csui/controls/thumbnail/content/member/member.view',
  'csui/controls/thumbnail/content/size/size.view',
  'csui/controls/thumbnail/content/select/select.view',
  'csui/controls/thumbnail/content/date/date.view',
  'csui/controls/thumbnail/content/thumbnail.icon/thumbnail.icon.view',
  'csui/controls/thumbnail/content/overview/overview.view',
  'csui/controls/thumbnail/content/properties/properties.view',
  // Load and register external content
  'csui-ext!csui/controls/thumbnail/content/content.factory'
], function (_, contentViewRegistry) {

  function ContentViewFactory() {}

  _.extend(ContentViewFactory.prototype, {
    getContentView: function (columnDefinition) {
      var ContentView = contentViewRegistry.getContentView(columnDefinition);
      return ContentView;
    }
  });

  return new ContentViewFactory();
});

csui.define('csui/controls/thumbnail/thumbnail.content',['csui/lib/underscore', "csui/lib/backbone",
  'csui-ext!csui/controls/thumbnail/thumbnail.content'
], function (_, Backbone, extraThumbnailContent) {

  var ThumbnailContentModel = Backbone.Model.extend({

    idAttribute: "key",

    defaults: {
      key: null,  // key from the resource definitions
      sequence: 0 // smaller number moves the column to the front
    }

  });

  var ThumbnailContentCollection = Backbone.Collection.extend({

    model: ThumbnailContentModel,
    comparator: "sequence",

    getColumnKeys: function () {
      return this.pluck('key');
    },

    deepClone: function () {
      return new ThumbnailContentCollection(
          this.map(function (column) {
            return column.attributes;
          }));
    }

  });

  // Content delivered from server get sequence set to 500

  var thumbnailContent = [
    {
      key: 'name',
      sequence: 4,
      defaultAction: true
    },
    {
      key: 'reserved',
      sequence: 5,
      displayTitle: true,
      title: 'State'
    },
    {
      key: 'wnd_comments',
      sequence: 900
    },
    {
      key: 'favorite',
      sequence: 910
    },
    {
      key: 'overview',
      sequence: 920,
      showoverview: true
    }
  ];

  if (extraThumbnailContent) {
    _.each(extraThumbnailContent, function (moduleThumbnailContent) {
      _.each(moduleThumbnailContent, function (thumbnailContent, key) {
        thumbnailContent.push(thumbnailContent);
      });
    });
  }

  var thumbnailContentCollection = new ThumbnailContentCollection(thumbnailContent);

  return thumbnailContentCollection;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/impl/thumbnail.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-selected-checkbox csui-checkbox-primary csui-checkbox-selectAll\">\r\n        <input class=\"csui-selectAll-input\" type=\"checkbox\" disabled=\"\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.selectAllTitle || (depth0 != null ? depth0.selectAllTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectAllTitle","hash":{}}) : helper)))
    + "\" tabindex=\"-1\">\r\n        <div class=\"csui-selectAll-header csui-selectlabel\"></div>\r\n        <span>"
    + this.escapeExpression(((helper = (helper = helpers.selectAll || (depth0 != null ? depth0.selectAll : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectAll","hash":{}}) : helper)))
    + "</span>\r\n      </div>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "      <div class=\"csui-selected-checkbox csui-checkbox-primary csui-checkbox-selectAll\">\r\n        <input class=\"csui-selectAll-input\" type=\"checkbox\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.selectAllTitle || (depth0 != null ? depth0.selectAllTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectAllTitle","hash":{}}) : helper)))
    + "\" tabindex=\"-1\">\r\n        <div class=\"csui-selectAll-header csui-selectlabel\"></div>\r\n        <span>"
    + this.escapeExpression(((helper = (helper = helpers.selectAll || (depth0 != null ? depth0.selectAll : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"selectAll","hash":{}}) : helper)))
    + "</span>\r\n      </div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"csui-thumbnail-header-data\">\r\n  <div class=\"csui-thumbnail-select\">\r\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isEmptyNode : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "  </div>\r\n  <div class=\"csui-thumbnail-itemcount\">"
    + this.escapeExpression(((helper = (helper = helpers.items || (depth0 != null ? depth0.items : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"items","hash":{}}) : helper)))
    + "</div>\r\n  <div class=\"csui-thumbnail-sort-search-container\">\r\n    <div id=\"csui-sorting-container\" class=\"csui-sorting-container\"></div>\r\n    <div id=\"csui-thumbnail-column-search\" class=\"csui-thumbnail-column-search\"></div>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_impl_thumbnail.header', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/impl/thumbnail.item',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return " csui-checkbox ";
},"3":function(depth0,helpers,partials,data) {
    var stack1;

  return "    <div class=\"csui-thumbnail-content csui-thumbnail-"
    + this.escapeExpression(this.lambda(((stack1 = (depth0 != null ? depth0.attributes : depth0)) != null ? stack1.key : stack1), depth0))
    + "\"></div>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-thumbnail-item-container\">\r\n<div class=\"csui-thumbnail-icon-container\">\r\n  <div class=\"csui-thumbnail-select "
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isChecked : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "\"></div>\r\n  <div class=\"csui-thumbnail-actionbar\"></div>\r\n  <div class=\"csui-thumbnail-thumbnailIcon\"></div>\r\n</div>\r\n<div class=\"csui-thumbnail-content-container\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.columns : depth0),{"name":"each","hash":{},"fn":this.program(3, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</div>\r\n</div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_impl_thumbnail.item', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/impl/thumbnail',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div id=\"csui-thumbnail-header\" class=\"csui-thumbnail-header\"></div>\r\n<div id=\"csui-thumbnail-results\" class=\"csui-thumbnail-results\"></div>";
}});
Handlebars.registerPartial('csui_controls_thumbnail_impl_thumbnail', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/impl/empty.thumbnail',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<p class='csui-no-result-message' title=\""
    + this.escapeExpression(((helper = (helper = helpers.noResults || (depth0 != null ? depth0.noResults : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"noResults","hash":{}}) : helper)))
    + "\">\r\n  "
    + this.escapeExpression(((helper = (helper = helpers.noResults || (depth0 != null ? depth0.noResults : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"noResults","hash":{}}) : helper)))
    + "\r\n</p>\r\n";
}});
Handlebars.registerPartial('csui_controls_thumbnail_impl_empty.thumbnail', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/thumbnail',[],function(){});
csui.define('csui/controls/thumbnail/thumbnail.view',[
  'module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/utils/base', 'csui/utils/commands',
  'csui/behaviors/default.action/default.action.behavior',
  'csui/behaviors/default.action/impl/defaultaction',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/thumbnail/impl/metadata/thumbnail.metadata.view',
  'csui/controls/thumbnail/impl/sort/sort.view',
  'csui/controls/thumbnail/content/content.factory',
  'csui/controls/thumbnail/thumbnail.content',
  'csui/controls/thumbnail/content/thumbnail.icon/thumbnail.icon.view',
  'csui/controls/thumbnail/content/select/select.view',
  'csui/controls/table/cells/searchbox/searchbox.view',
  'csui/controls/tableactionbar/tableactionbar.view',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/controls/progressblocker/blocker',
  'hbs!csui/controls/thumbnail/impl/thumbnail.header',
  'hbs!csui/controls/thumbnail/impl/thumbnail.item',
  'hbs!csui/controls/thumbnail/impl/thumbnail',
  'hbs!csui/controls/thumbnail/impl/empty.thumbnail',
  'i18n!csui/controls/thumbnail/impl/nls/lang',
  'css!csui/controls/thumbnail/thumbnail',
  'csui/lib/jquery.mousehover'
], function (module, _, $, Backbone, Marionette, base, commands, DefaultActionBehavior,
    DefaultActionController, PerfectScrollingBehavior, TabableRegionBehavior, ThumbnailMetadataView,
    SortView, ContentFactory, ThumbnailContent, ThumbnailIconView, SelectContentView, SearchBoxView,
    TableActionBarView, LayoutViewEventsPropagationMixin, BlockingView, thumbnailHeaderTemplate,
    thumbnailItemTemplate, thumbnailTemplate, emptyThumbnailTemplate, lang) {
  'use strict';
  var config = _.extend({}, module.config());

  var NoThumbnailView = Marionette.ItemView.extend({

    className: 'csui-thumbnail-empty',
    template: emptyThumbnailTemplate,

    templateHelpers: function () {
      return {
        noResults: (this.options.isFilterApplied ||
                    ([298, 899].indexOf(this._parent.collection.node.get('type')) !== -1)) ?
                   lang.noResults : lang.dragAndDropMessage
      };
    },

    constructor: function NoThumbnailView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    onRender: function () {
      this.options.$parentEl.addClass('csui-thumbnail-empty');
    },

    onShow: function () {
      this.$el.addClass('icon-thumbnail-empty-page');
    },

    onDestroy: function () {
      this.options.$parentEl.removeClass('csui-thumbnail-empty');
    }
  });

  var ThumbnailItemView = Marionette.LayoutView.extend({

    className: function () {
      var className = 'csui-thumbnail-item' + ' csui-thumbnail-item-' + this.model.cid;
      if (this.model.inlineFormView) {
        className = className + ' csui-thumbnail-item-form';
      }
      return className;
    },
    template: thumbnailItemTemplate,
    templateHelpers: function () {
      return {
        columns: ThumbnailContent.models,
        isChecked: this.options.thumbnailView.collection.itemchecked
      };
    },

    regions: {
      selectContentRegion: ".csui-thumbnail-select",
      thumbnailIconRegion: ".csui-thumbnail-thumbnailIcon"
    },

    initialize: function () {
      var self = this;
      if (ThumbnailContent && ThumbnailContent.models) {
        _.each(ThumbnailContent.models, function (model, index) {
          var content = ContentFactory.getContentView(model);
          if (content) {
            var region = model.get("key");
            self.addRegion(region, ".csui-thumbnail-" + region);
          }
        }, this);
      }
      if (!base.isTouchBrowser() && this.options.showInlineToolbar) {
        this._subscribeEventHandlers();
      }
      this.model.set('inactive', !this.options.thumbnailView.checkModelHasAction(this.model),
          {silent: true});
      self.ContentFactory = ContentFactory;
    },

    constructor: function ThumbnailItemView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
      this.listenTo(this.model, 'sync', this.render);
    },

    _subscribeEventHandlers: function () {
      this.$el && this.$el.mousehover(
          this.showInlineActions.bind(this),
          this.hideInlineActions.bind(this),
          {namespace: this.cid});
    },

    _unsubscribeEventHandlers: function () {
      if (this._isRendered) {
        this.$el.mousehover('off', {namespace: this.cid});
      }
    },

    showInlineActions: function (e) {
      if (this.$el.find(".csui-inlineform-group").length === 0) {
        var inlineToolbarContainer = this.$el.find('.csui-thumbnail-actionbar');
        if (inlineToolbarContainer.length > 0 &&
            !this.options.originatingView.lockedForOtherContols) {
          var self = this,
              args = {
                sender: self,
                target: inlineToolbarContainer,
                model: self.model
              };
          self.trigger("mouseenter:row", args);
        }
      } else {
        this.$el.find(".csui-thumbnail-select").css({"display": "none"});
      }
    },

    hideInlineActions: function (e) {
      var inlineToolbarContainer = this.$el.find('.csui-thumbnail-actionbar');
      if (inlineToolbarContainer.length > 0) {
        var self = this,
            args = {
              sender: self,
              target: inlineToolbarContainer,
              model: self.model
            };
        self.trigger("mouseleave:row", args);
      }
    },

    onRender: function (e) {
      var self = this;
      if (self.model.isLocallyCreated && !self.model.inlineFormView) {
        this.$el.find('.csui-thumbnail-content-container').addClass('csui-new-item');
      }
      this.selectContentView = new SelectContentView({
        tagName: 'div',
        model: this.options.model,
        thumbnailView: this.options.thumbnailView,
        events: function () {
          if (base.isFirefox()) {
            return _.extend({}, SelectContentView.prototype.events, {
              'keydown': self.onKeyInView
            });
          }
          return SelectContentView.prototype.events;
        }
      });
      this.selectContentRegion.show(this.selectContentView);
      if (this.options.model.get('csuiIsSelected')) {
        this.selectContentRegion.$el.addClass('csui-checkbox');
        this.$el.addClass('csui-thumbnail-item-selected');
      }
      if (this.options.model.get(SelectContentView.isSelectedModelAttributeName)) {
        this.$el.addClass('csui-thumbnail-item-selected');
      }
      self.listenTo(this.selectContentView, 'clicked:checkbox', function (event) {
        if (this.options.thumbnailView.activeInlineForm && event.checked) {
          this.options.thumbnailView.cancelAnyExistingInlineForm();
        }
        self.showToolBarActions(event);
        if (event.checked) {
          if (this.options.thumbnailView.resultsView.inlineToolbarView) {
            this.options.thumbnailView.resultsView.inlineToolbarView.destroy();
          }
          self._parent.$el.find(".csui-thumbnail-select").addClass(
              'csui-checkbox');
          self.$el.addClass('csui-thumbnail-item-selected');

          self.model.set(SelectContentView.isSelectedModelAttributeName, true);
          self.model.attributes.isSelected = true;
        } else {
          self.$el.removeClass('csui-thumbnail-item-selected');
          self.model.set(SelectContentView.isSelectedModelAttributeName, false);
          self.model.attributes.isSelected = false;
          var selectedModelsCount = 0;
          _.each(self._parent.collection.models, function (model) {
            if (!!model.attributes.csuiIsSelected) {
              selectedModelsCount++;
            }
          });

          if (selectedModelsCount === 0 ||
              (!!self.model.get('selectAllThumbnailsEnabled') &&
               (selectedModelsCount === 0))) {
            self._parent.$el.find(".csui-thumbnail-select").removeClass('csui-checkbox');
            self.$el.removeClass('csui-thumbnail-item-selected');
          }
        }
        this.options.thumbnailHeaderView.trigger('selectOrUnselect.mixed');
      });
      this.thumbnailIconView = new ThumbnailIconView({
        model: this.options.model,
        context: this.options.context,
        column: {defaultAction: true},
        originatingView: this.options.originatingView
      });
      this.thumbnailIconRegion.show(this.thumbnailIconView);
      this.listenTo(this.thumbnailIconView, 'execute:defaultAction', function (event) {
        event.preventDefault();
        event.stopPropagation();
        self.options.thumbnailView.trigger("execute:defaultAction", self.model);
      });
      if (ThumbnailContent && ThumbnailContent.models) {
        _.each(ThumbnailContent.models, function (model, index) {
          var content = ContentFactory.getContentView(model);
          if (content) {
            var region        = model.get("key"),
                defaultAction = model.get("defaultAction"),
                conFactory    = model.get("showoverview") ? ContentFactory : undefined,
                name          = model.get("key");
            var contentView = new content({
              tagName: 'DIV',
              model: self.model,
              context: self.options.context,
              column: {name: name, defaultAction: defaultAction},
              ContentFactory: conFactory,
              displayLabel: model.get("displayLabel"),
              displayTitle: model.get("displayTitle"),
              displayIcon: true,
              originatingView: self.options.originatingView,
              selectedChildren: this.options.thumbnailView.options.selectedChildren,
              collection: this.options.thumbnailView.options.collection,
              columns: this.options.columns
            });
            self.model.collection = this.options.thumbnailView.options.collection;
            self[region].show(contentView);
            self.listenTo(contentView, 'clicked:content', function (event) {
              self.trigger('clicked:content', {
                contentView: contentView,
                rowIndex: self._index,
                colIndex: index,
                model: self.model
              });
            });
            self.listenTo(contentView, 'execute:defaultAction', function (event) {
              event.preventDefault();
              event.stopPropagation();
              self.options.thumbnailView.trigger("execute:defaultAction", self.model);
            });
            self.listenTo(contentView, 'show:add:favorite:form', function () {
              self.hideInlineActions();
              self.options.originatingView.lockedForOtherContols = true;
            });
            self.listenTo(contentView, 'close:add:favorite:form', function () {
              self.options.originatingView.lockedForOtherContols = false;
            });
            self.listenTo(contentView, 'shown:overview:flyout', function () {
              self.hideInlineActions();
              self.options.originatingView.lockedForOtherContols = true;
            });
            self.listenTo(contentView, 'hide:overview:flyout', function () {
              self.options.originatingView.lockedForOtherContols = false;
            });
          }
        }, this);
      }
    },

    showToolBarActions: function (event) {
      var self         = this,
          args         = {},
          selectedNode = [];
      if (event.checked) {
        self.model.set(SelectContentView.isSelectedModelAttributeName, true, {silent: true});
        self.model.attributes.isSelected = true;
      } else {
        this._subscribeEventHandlers();
        self.model.set(SelectContentView.isSelectedModelAttributeName, false, {silent: true});
        self.model.attributes.isSelected = false;
      }
      this.options.thumbnailView.showToolBarActions();
    },

    getSelectedChildren: function () {
      return this.model.collection.where({csuiIsSelected: true});
    }
  });

  var ThumbnailListView = Marionette.CollectionView.extend({

    className: 'csui-thumbnail-collection',

    childView: ThumbnailItemView,

    childViewOptions: function () {
      return {
        context: this.options.context,
        showInlineToolbar: this.showInlineToolbar,
        toolbarItems: this.options.inlineBar.options.collection,
        toolbarItemsMasks: this.options.inlineBar.options.toolItemsMask,
        originatingView: this.options.originatingView,
        thumbnailView: this.options.thumbnailView,
        thumbnailHeaderView: this.options.thumbnailHeaderView,
        tableColumns: this.options.tableColumns,
        columns: this.options.columns
      };
    },

    childEvents: {
      'mouseenter:row': 'onChildShowInlineActionBarWithDelay',
      'mouseleave:row': 'onChildActionBarShouldDestroy'
    },

    emptyView: NoThumbnailView,
    emptyViewOptions: function () {
      return {
        isFilterApplied: _.some(this.collection.filters, function (filter) {
          return filter && filter.trim().length > 0;
        }),
        $parentEl: this.$el,
        model: this.emptyModel
      };
    },

    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      }
    },

    constructor: function ThumbnailListView(options) {
      options || (options = {});
      this.context = options.context;
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
      this.showInlineToolbar = (this.options.inlineBar.options.collection &&
                                this.options.inlineBar.options.toolItemsMask);
      if (this.showInlineToolbar) {
        this.setInlineActionBarEvents();
      }
      $(window).bind('resize', _.bind(this._adjustThumbnailWidth, this));
    },

    setInlineActionBarEvents: function () {
      this.listenTo(this, 'closeOther', this._destroyInlineActionBar);
      this.listenTo(this.collection, "reset", this._destroyInlineActionBar);
    },

    _destroyInlineActionBar: function () {
      if (this.inlineToolbarView) {
        this.inlineToolbarView.destroy();
        this.inlineToolbarView = undefined;
      }
    },

    _showInlineActionBar: function (args) {
      if (this.inlineToolbarView) {
        this._savedHoverEnterArgs = args;
        // ignore until action bar removed itself
      } else if (!!args) {
        this._savedHoverEnterArgs = null;

        this.inlineToolbarView = new TableActionBarView(_.extend({
              context: this.options.context,
              commands: commands,
              collection: this.options.inlineBar.options.collection,
              toolItemsMask: this.options.inlineBar.options.toolItemsMask,
              originatingView: this.options.originatingView,
              model: args.model,
              status: {
                targetView: args.sender,
                connector: this.options.collection.connector
              }
            }, this.options.inlineBar.options)
        );

        this.listenTo(this.inlineToolbarView, 'before:execute:command', function (eventArgs) {
          this.lockedForOtherContols = true;
          //If targetView is given, highlight the targetView i.e. selected row of thumbnail view
          if (eventArgs && eventArgs.status && eventArgs.status.targetView &&
              eventArgs.status.targetView.$el) {
            eventArgs.status.targetView.$el.addClass("active-row");
          }
          this._destroyInlineActionBar();
        });
        this.listenTo(this.inlineToolbarView, 'after:execute:command', function (eventArgs) {
          this.lockedForOtherContols = false;
          //If targetView is given, Remove highlighting from the targetView i.e. selected row
          if (eventArgs && eventArgs.status && eventArgs.status.targetView &&
              eventArgs.status.targetView.$el) {
            eventArgs.status.targetView.$el.removeClass("active-row");
          }
        });

        if (this.options.originatingView) {
          this.listenTo(this.options.originatingView, "block:view:actions", function () {
            this.lockedForOtherContols = true;
            this._destroyInlineActionBar();
          });
          this.listenTo(this.options.originatingView, "unblock:view:actions", function () {
            this.lockedForOtherContols = false;
          });
        }

        this.inlineToolbarView.render();
        this.listenTo(this.inlineToolbarView, 'destroy', function () {
          this.inlineToolbarView = undefined;
          if (this._savedHoverEnterArgs) {
            this.onChildShowInlineActionBarWithDelay(this._savedHoverEnterArgs);
          }
        }, this);
        $(args.target).append(this.inlineToolbarView.$el);
        this.inlineToolbarView.triggerMethod("show");
      }
    },

    onChildShowInlineActionBarWithDelay: function (childView, args) {
      if (this._showInlineActionbarTimeout) {
        clearTimeout(this._showInlineActionbarTimeout);
      }
      var self = this;
      self.isSelected = self.collection.where({csuiIsSelected: true}).length > 0;
      self._showInlineActionbarTimeout = setTimeout(function () {
        self._showInlineActionbarTimeout = undefined;
        self.lockedForOtherContols = self.options.thumbnailView && self.options.thumbnailView.lockedForOtherContols;
        if (!self.lockedForOtherContols && !self.isSelected) {
          // don't show the action bar control if the searchresult view is locked because a different
          // control is already open
          !self.isSelected && self._showInlineActionBar.call(self, args);
        }
      }, 200);
    },

    onChildActionBarShouldDestroy: function (childView, args) {
      if (this._showInlineActionbarTimeout) {
        clearTimeout(this._showInlineActionbarTimeout);
        this._showInlineActionbarTimeout = undefined;
      }
      if (this.inlineToolbarView) {
        this.inlineToolbarView.destroy();
      }
    },
    showOrHideZeroRecordsMessage: function () {
      this.$el.find('div.csui-thumbnail-empty').remove();
      if (this.collection.length === 0) {
        //check for search results once search is implemented in thumbnail view
        this.$el.addClass("csui-thumbnail-empty");
        var emptyThumbnailText = "", zeroRecords;
        if (this._showingEmptyView) {
          //check for node type collection and update the empty thumbnail message
          zeroRecords = (this.collection.node.get("container") &&
                        ([298, 899].indexOf(this.collection.node.get('type')) !== -1)) &&
                        lang.noResults;

          emptyThumbnailText = (!!this.collection.filters && this.collection.filters.name ?
                                lang.noResults : lang.dragAndDropMessage);
          emptyThumbnailText = zeroRecords ? zeroRecords : emptyThumbnailText;
        }
        var emptyEl = $(
            "<div class='csui-thumbnail-empty  icon-thumbnail-empty-page'><p class='csui-no-result-message' title='" +
            emptyThumbnailText + "'>" + emptyThumbnailText + "</p></div>");
        this.$el.append(emptyEl);
      } else {
        this.$el.removeClass("csui-thumbnail-empty");
        this.$el.removeClass("icon-thumbnail-empty-page");
      }
    },

    onRender: function () {
      this.showOrHideZeroRecordsMessage();
      this._adjustThumbnailWidth();
    },

    _adjustThumbnailWidth: function () {
      var thumbnailViewItem             = this.$el.find('.csui-thumbnail-item'),
          thumbnailViewItemWidth        = 190, //min, max width                   
          parentWidth                   = $('.csui-table-facetview .csui-facet-panel').length > 0 ?
                                          $('.csui-facet-table-container').width() -
                                          $('.csui-table-facetview').width() :
                                          $('.cs-thumbnail-wrapper').width(),
          spaceBetweenItems             = 2,
          thumbnailViewItemWidthPercent = thumbnailViewItemWidth / parentWidth * 100;
      for (var i = 1; i <= thumbnailViewItem.length; i++) {
        var thumbnailViewItemTotalWidth = i * thumbnailViewItemWidthPercent;
        if (thumbnailViewItemTotalWidth > 100) {
          i = i - 1;
          thumbnailViewItemWidthPercent = 100 / i;
          break;
        }
      }
      thumbnailViewItem.css({
        'maxWidth': "calc(" + thumbnailViewItemWidthPercent + '% - ' + spaceBetweenItems * 2 +
                    "px)",
        'minWidth': "calc(" + thumbnailViewItemWidthPercent + '% - ' + spaceBetweenItems * 2 +
                    "px)"
      });
    }
  });

  var ThumbnailHeaderView = Marionette.LayoutView.extend({

    className: 'csui-thumbnail-header',

    tagName: 'div',

    regions: {
      sortRegion: '#csui-sorting-container',
      searchRegion: '#csui-thumbnail-column-search'
    },

    behaviors: {
      TabableRegion: {
        behaviorClass: TabableRegionBehavior,
        initialActivationWeight: 100
      }
    },

    ui: {
      selectAll: '.csui-selectAll-input'
    },

    events: {
      "keydown": "onKeyInView",
      'click @ui.selectAll': 'selectAllThumbnails'
    },

    template: thumbnailHeaderTemplate,

    templateHelpers: function () {
      return {
        columns: this.options.thumbnailColumns,
        addTitle: lang.addTitle,
        selectAll: lang.selectAll,
        selectAllTitle: lang.selectAllTitle,
        isEmptyNode: this.collection.models.length === 0,
        items: base.formatMessage(this.collection.length, lang)
      };
    },

    constructor: function ThumbnailHeaderView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.call(this, options);
      this.columnsWithSearch = options.columnsWithSearch || [];
      this.listenTo(this, 'selectOrUnselect.mixed', this.thumbnailItemClicked);
    },

    sortmenurender: function (name) {
      this.options.thumbnailView.resultsView.render();
      this.sortRegion.$el.find('button.binf-dropdown-toggle').focus();
    },

    thumbnailItemClicked: function () {
      var selection = this.collection.filter(function (model) {
        return model.get(SelectContentView.isSelectedModelAttributeName);
      });
      var all = selection.length === this.collection.length;
      if (selection.length > 0 && !all) {
        this.$el.find('.csui-selected-checkbox').addClass('csui-checkbox-atleastone');
      } else {
        this.$el.find('.csui-selected-checkbox').removeClass('csui-checkbox-atleastone');
      }
      this.$(".csui-selectAll-input").prop("checked", all);
    },

    selectAllThumbnails: function (event) {
      if (this.options.thumbnailView.activeInlineForm) {
        this.options.thumbnailView.cancelAnyExistingInlineForm();
      }
      this.$el.find('.csui-checkbox-atleastone').removeClass('csui-checkbox-atleastone');
      this.trigger('selectOrUnselect.all', event.target.checked);
      if (this.collection.where({csuiIsSelected: true}).length > 0) {
        this.trigger('selectOrUnselect.mixed');
      }
    },

    onRender: function (e) {
      var event         = e || window.event,
          thumbnailView = this.options.thumbnailView;
      this.focusIndex = 0;
      var length = thumbnailView.$el.find('.csui-thumbnail-item-selected').length;
      if (this.collection.where({csuiIsSelected: true}).length > 0) {
        this.trigger('selectOrUnselect.mixed');
      } else if (length > 0) {
        thumbnailView.$el.find('.csui-checkbox').removeClass();
        this.trigger('selectOrUnselect.all', event.target && event.target.checked);
      } else if (length === 0) {
        var selectedNodes = thumbnailView.getSelectedChildren();
        thumbnailView.options.selectedChildren &&
        thumbnailView.options.selectedChildren.reset(selectedNodes);
      }
      var sortView = new SortView({
        collection: this.collection,
        resultView: this
      });
      this.sortRegion.show(sortView);
      this.listenTo(sortView, 'render:sortmenu', this.sortmenurender);
      this.ensureAllSearchBox();
    },

    ensureAllSearchBox: function () {
      var self          = this,
          thumbnailView = this.options.thumbnailView,
          searchWrapper = this.$el.find('.csui-thumbnail-column-search'),
          sortWrapper   = this.$el.find('.csui-sorting-container'),
          columnName    = "name";
      if ($(this).find('.csui-thumbnail-column-search').length === 0) {
        var searchbox = new SearchBoxView(self.collection.filters[columnName], {
          column: columnName,
          columnTitle: lang.name
        });
        self.searchBoxes = searchbox;
        searchbox.on('change:filterValue', function (data) {
          self.applyFilter(data);
        });
        searchbox.on('opened', function () {
          sortWrapper.addClass('binf-hidden');
          self.searchColumn = columnName;
        });
        searchbox.on('closed', function () {
          sortWrapper.removeClass('binf-hidden');
          self.collection.filters[columnName] = undefined;
        });
        this.searchRegion.show(self.searchBoxes);
        if (columnName === self.searchColumn) {
          searchbox.setFocus();
        }
        searchWrapper = $(this).find('.csui-table-column-search');
        if (searchWrapper) {
          searchWrapper.attr('aria-label',
              _.str.sformat(lang.searchIconTooltip, lang.name));
        }
      }
    },
    applyFilter: function (data) {
      var filterObj = {};
      filterObj[data.column] = data.keywords;
      if (this.collection.fetching) {
        this.filterValuePending = filterObj;
      } else {
        this.collection.resetLimit(false);
        this.collection.setFilter(filterObj);
      }
    }
  });

  var ThumbnailView = Marionette.LayoutView.extend({

    className: 'csui-thumbnail-container',
    template: thumbnailTemplate,
    regions: {
      headerRegion: '#csui-thumbnail-header',
      resultsRegion: '#csui-thumbnail-results'
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.csui-thumbnail-results',
        suppressScrollX: true,
        // like bottom padding of container, otherwise scrollbar is shown always
        scrollYMarginOffset: 15
      },
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      }
    },

    constructor: function ThumbnailView(options) {
      options || (options = {});
      this.options = options;
      if (options.actionItems && options.commands) {
        this.defaultActionController = new DefaultActionController({
          actionItems: options.actionItems,
          commands: options.commands
        });
        this.checkModelHasAction = this.defaultActionController.hasAction.bind(
            this.defaultActionController);
      } else {
        // this is the fallback for ThumbnailView usages where no commands and actionItems are
        // passed in the options to the thumbnail.view -> never set thumbnail items inactive
        this.checkModelHasAction = function () {
          return true;
        };
      }
      Marionette.LayoutView.prototype.constructor.call(this, options);
      this.context = options.context;
      this.collection = options.collection;
      var checkSelection = this.collection.where({csuiIsSelected: true});
      this.collection.itemchecked = false;
      if (checkSelection.length > 0) {
        this.collection.itemchecked = true;
      }
      BlockingView.imbue(this);
      this.listenTo(this.collection, "update", this._handleModelsUpdate);
      this.listenTo(this.collection, "change", _.debounce(this.updateRow, 100));

      if (this.context) {
        this.listenTo(this.context, 'request', this._handleContextRequest)
            .listenTo(this.context, 'sync error', this._handleContextFinish)
            .listenTo(this.context, 'sync', this._handleContextSync);
      }

      if (this.collection.node) {
        this.listenTo(this.collection.node, "change:id", this._clearSearchBoxes);
      }

      this.listenTo(this.collection, "request", this.blockActions)
          .listenTo(this.collection, "sync", this.unblockActions)
          // Destroying a node does not send sync, but destroy event
          .listenTo(this.collection, "destroy", this.unblockActions)
          .listenTo(this.collection, "error", this.unblockActions);

      this._ViewCollection = Backbone.Collection.extend({
        model: this.collection.model
      });
      this.selectedChildren = new this._ViewCollection();
      var self = this;
      this.el.addEventListener('scroll', function () {
        self.trigger('scroll');
      }, true);
      this.listenTo(this.collection, "reset", this._updateSelectedChildren);
      this.listenTo(this.collection, "new:page", this.resetScrollToTop);
      this.listenTo(this.collection, "reset", function () {
        if (!this._isRendered) {
          return;
        }
        this.resetScrollToTop();  // reset scroll when navigating from breadcrumb
        if (this.thumbnailHeaderView) {
          this.thumbnailHeaderView.render();
        }
      });
      /* this.listenTo(this, "apply:transition", function(args){
         this.$el.find(".csui-thumbnail-item-"+args.cid).addClass('csui-thumbnail-item-save-transition');
       });
       this.listenTo(this, "remove:transition", function(args){
         this.$el.find(".csui-thumbnail-item-"+args.cid).removeClass('csui-thumbnail-item-save-transition');
       });*/
    },

    _updateSelectedChildren: function () {
      if (!this._isRendered) {
        return;
      }
    },

    _handleContextRequest: function () {
      this._fetchingContext = true;
      this._columnsReset = false;
      this._collectionReset = false;
    },

    _handleContextSync: function () {
      if (!this._isRendered) {
        return;
      }
      if (this._columnsReset) {
        this.rebuild();
      } else if (this._collectionReset) {
        this.render();
      }
    },

    _handleContextFinish: function () {
      this._fetchingContext = false;
    },

    resetScrollToTop: function () {
      if (this._isRendered && this.resultsRegion) {
        this.resultsRegion.$el.scrollTop(0);
      }
    },

    onDestroy: function () {
      // If the collection was passed from outside and might be of a limited scope
      if (this._originalScope) {
        // Restore the scope of the response
        this.options.collection.setResourceScope(this._originalScope);
      }
    },

    _handleModelsUpdate: function (collection, options) {
      if (!this._isRendered) {
        return;
      }
      var models = options.changes.added,
          self   = this;
      if (models.length > 0) {
        _.each(models, function (model) {
          model.unset(SelectContentView.isSelectedModelAttributeName);
        });
        this.triggerMethod('before:render', this);
        var nodeModel = null;
        _.each(models, function (model) {
          nodeModel = model;
        });
        if (nodeModel.inlineFormView) {
          if (self.activeInlineForm) {
            self.activeInlineForm.destroy();
          }
          self.activeInlineForm = new nodeModel.inlineFormView({
            model: nodeModel,
            originatingView: self.options.originatingView,
            context: self.context
          });
          var className = '.csui-thumbnail-name-' + nodeModel.cid;
          var divForInlineForm = this.$el.find(className);
          self.activeInlineForm.listenTo(self.activeInlineForm, 'destroy', function () {
            self.lockedForOtherContols = false;
            delete self.activeInlineForm;
          });
          var inlineFormRegion = new Marionette.Region({el: divForInlineForm});
          inlineFormRegion.show(self.activeInlineForm);
        }
        this.resultsView.showOrHideZeroRecordsMessage();
        this._adjustThumbnailWidth();
        this.trigger('dom:refresh');  // fix for perfect scrollbar on updating collection (adding or removing node)
        _.each(models, function (model) {
          if (model.isLocallyCreated && !model.inlineFormView) {
            self.$el.find(".csui-thumbnail-item-" + model.cid).find(
                ".csui-thumbnail-content-container").addClass("csui-new-item");
          }
        });
      }
      if (this.thumbnailHeaderView) {
        this.thumbnailHeaderView.render();
      }
    },

    _maintainNodeState: function (model) {
      var nodeModel = model,
          self      = this;
      if (model && !!model.inlineFormView) {
        self.activeInlineForm = new nodeModel.inlineFormView({
          model: nodeModel,
          originatingView: self.options.originatingView,
          context: self.context
        });
        self.$el.find('.csui-thumbnail-item-' + nodeModel.cid).addClass('csui-thumbnail-item-form');
        var className = '.csui-thumbnail-name-' + nodeModel.cid;
        var divForInlineForm = this.$el.find(className);
        var inlineFormRegion = new Marionette.Region({el: divForInlineForm});
        inlineFormRegion.show(self.activeInlineForm);
      }
      else {
        return false;
      }
    },

    updateRow: function (collectionOrModel) {
      if (collectionOrModel.isLocallyCreated) {
        this.$el.find(".csui-thumbnail-item-form") &&
        this.$el.find(".csui-thumbnail-item-form").find(
            ".csui-thumbnail-content-container").addClass("csui-new-item");
      }
      this.isSelected = this.collection.where({csuiIsSelected: true}).length > 0;
      /* if (collectionOrModel !== this.collection && this.isSelected) {
        // Model inside collection changed. Just ignore it here since it will be taken care at ThumnailItemView
        return;
      } */
      if (collectionOrModel.inlineFormView) {
        this.options.originatingView.updateRowIndex = this.collection.indexOf(collectionOrModel);
        var self = this;

        if (self.activeInlineForm && self.activeInlineForm.model !== collectionOrModel) {
          this.$el.find(".csui-thumbnail-item-form").removeClass('csui-thumbnail-item-form');
          this.$el.find(".csui-thumbnail-item-form").removeClass('csui-thumbnail-item-rename-form');
          this.activeInlineForm.model.trigger('sync');
          this.cancelAnyExistingInlineForm({silent: true});
        }
        self.activeInlineForm = new collectionOrModel.inlineFormView({
          model: collectionOrModel,
          originatingView: self.options.originatingView,
          context: self.context
        });
        this.$el.find(".csui-thumbnail-item-" + collectionOrModel.cid).addClass(
            "csui-thumbnail-item-rename-form");
        var className = '.csui-thumbnail-name-' + collectionOrModel.cid;
        var divForInlineForm = this.$el.find(className);
        self.activeInlineForm.listenTo(self.activeInlineForm, 'destroy', function () {
          self.lockedForOtherContols = false;
          self.activeInlineForm.model.trigger('sync');
          delete self.activeInlineForm;
        });
        this.$el.find(".csui-thumbnail-item-" + collectionOrModel.cid).removeClass(
            'csui-thumbnail-item-apply-transition');

        self.$el.find(".csui-thumbnail-item-" + self.activeInlineForm.model.cid).addClass(
            'csui-thumbnail-item-form');
        var inlineFormRegion = new Marionette.Region({el: divForInlineForm});
        inlineFormRegion.show(self.activeInlineForm);

        self.$el.find(".csui-thumbnail-item-" + self.activeInlineForm.model.cid).removeClass(
            'csui-thumbnail-item-rename-form');
            self.lockedForOtherContols = true;
        self.$el.find(".csui-thumbnail-item-" + self.activeInlineForm.model.cid).find(
            "div.csui-thumbnail-overview-icon").addClass("binf-hidden");
        if (this.$el.find(".csui-thumbnail-item-form") &&
            this.$el.find(".csui-thumbnail-item-form").find(
                ".csui-thumbnail-content-container .csui-inlineform-error").length > 0) {
          this.$el.find(".csui-thumbnail-item-form").find(
              ".csui-thumbnail-content-container.csui-new-item").addClass("csui-new-item-error");
          collectionOrModel.isLocallyCreated = true;
        }
      } else {
        this.$el.find(".csui-thumbnail-item-" + collectionOrModel.cid).removeClass(
            'csui-thumbnail-item-form');
        this.$el.find(".csui-thumbnail-item-" + collectionOrModel.cid).addClass(
            'csui-thumbnail-item-apply-transition');

        /*this.$el.find(".csui-thumbnail-item-" + collectionOrModel.cid).removeClass(
              'csui-thumbnail-item-save-transition');*/
        if (this.activeInlineForm && this.activeInlineForm.model.cid === collectionOrModel.cid) {
          this.activeInlineForm.model.trigger('sync');
          this.cancelAnyExistingInlineForm({silent: true});
        }
        if (this.collection && this.collection.filters.name) {
          this.thumbnailHeaderView.searchBoxes.setFocus();
        }
        if (this.$el.find(
                ".csui-thumbnail-content-container.csui-new-item.csui-new-item-error").length > 0) {
          this.$el.find(
              ".csui-thumbnail-content-container.csui-new-item.csui-new-item-error").removeClass(
              "csui-new-item-error");
        }
      }
    },

    onAfterShow: function () {
      this.thumbnailHeaderView.searchBoxes.setFocus();
    },

    _adjustThumbnailWidth: function () {
      var thumbnailViewItem             = this.$el.find('.csui-thumbnail-item'),
          thumbnailViewItemWidth        = 190, //min, max width          
          parentWidth                   = $('.csui-table-facetview .csui-facet-panel').length > 0 ?
                                          $('.csui-facet-table-container').width() -
                                          $('.csui-table-facetview').width() :
                                          $('.cs-thumbnail-wrapper').width(),
          spaceBetweenItems             = 2,
          thumbnailViewItemWidthPercent = thumbnailViewItemWidth / parentWidth * 100;
      for (var i = 1; i <= thumbnailViewItem.length; i++) {
        var thumbnailViewItemTotalWidth = i * thumbnailViewItemWidthPercent;
        if (thumbnailViewItemTotalWidth > 100) {
          i = i - 1;
          thumbnailViewItemWidthPercent = 100 / i;
          break;
        }
      }
      thumbnailViewItem.css({
        'maxWidth': "calc(" + thumbnailViewItemWidthPercent + '% - ' + spaceBetweenItems * 2 +
                    "px)",
        'minWidth': "calc(" + thumbnailViewItemWidthPercent + '% - ' + spaceBetweenItems * 2 +
                    "px)"
      });
    },

    cancelAnyExistingInlineForm: function (options) {
      if (this.activeInlineForm) {
        this.activeInlineForm.cancel(options);
      }
    },

    startCreateNewModel: function (newNode, inlineFormView) {
      // cancel any active inline form before starting with a new one
      this.cancelAnyExistingInlineForm();
      if (this.collection && this.collection.node) {
        newNode.set("parent_id", this.collection.node.get('id'));
        newNode.isLocallyCreated = true;
        newNode.inlineFormView = inlineFormView;
        this.collection.add(newNode, {at: 0});
        this._adjustThumbnailWidth();
      }
    },

    _clearSearchBoxes: function () {
      if (!this._isRendered) {
        return;
      }
      _.each(this.searchBoxes, function (sb) {
        sb.hideAndClear();
      });
    },

    onRender: function () {
      this.thumbnailHeaderView = new ThumbnailHeaderView({
        columns: this.displayedColumns,
        context: this.context,
        columnsWithSearch: this.options.columnsWithSearch,
        filterBy: this.options.filterBy,
        collection: this.options.collection,
        thumbnailView: this
      });
      this.headerRegion.show(this.thumbnailHeaderView);
      var self = this;
      this.listenTo(this.thumbnailHeaderView, 'selectOrUnselect.all', function (isSelectAll) {
        if (isSelectAll) {
          if (self.collection.models.length > 0) {
            _.each(self.collection.models, function (model) {
              model.set(SelectContentView.isSelectedModelAttributeName, true);
              model.attributes.selectAllThumbnailsEnabled = true;
              model.attributes.isSelected = true;
            });
          }
          self.$el.find(".csui-thumbnail-results .csui-thumbnail-select").addClass('csui-checkbox');
          self.$el.find(".csui-thumbnail-results .csui-thumbnail-item").addClass(
              'csui-thumbnail-item-selected');
        } else {
          if (self.collection.models.length > 0) {
            _.each(self.collection.models, function (model) {
              model.set(SelectContentView.isSelectedModelAttributeName, false);
              model.attributes.selectAllThumbnailsEnabled = false;
              model.attributes.isSelected = false;
            });
            self.$el.find(".csui-thumbnail-select").removeClass('csui-checkbox');
            self.$el.find(".csui-thumbnail-results .csui-thumbnail-item").removeClass(
                'csui-thumbnail-item-selected');

          }
        }
        self.showToolBarActions();
      });

      this.resultsView = new ThumbnailListView({
        context: this.options.context,
        collection: this.options.collection,
        thumbnailView: this,
        originatingView: this.options.originatingView,
        inlineBar: this.options.inlineBar,
        thumbnailHeaderView: this.thumbnailHeaderView,
        tableColumns: this.options.tableColumns,
        columns: this.options.columns
      });
      this.showToolBarActions();
      this.resultsRegion.show(this.resultsView);
    },

    showToolBarActions: function (e) {
      var selectedNodes = this.getSelectedChildren();
      this.options.selectedChildren.reset(selectedNodes);
    },
    getSelectedChildren: function () {
      var self          = this,
          selectedNodes = [];
      this.options.collection.each(function (model) {
        if (!!model.get('csuiIsSelected')) {
          selectedNodes.push(model);
        }
      });
      return selectedNodes;
    }
  });

  _.extend(ThumbnailView.prototype, LayoutViewEventsPropagationMixin);

  return ThumbnailView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/thumbnail/content/node.state/impl/reservation/reservation',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "other";
},"3":function(depth0,helpers,partials,data) {
    return "self";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<button type=\"button\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedAria || (depth0 != null ? depth0.reservedAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedAria","hash":{}}) : helper)))
    + "\">\r\n<span class=\"icon "
    + this.escapeExpression(((helper = (helper = helpers.iconPrefix || (depth0 != null ? depth0.iconPrefix : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"iconPrefix","hash":{}}) : helper)))
    + "_"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isReservedByOther : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "")
    + "\"\r\n        title=\""
    + this.escapeExpression(((helper = (helper = helpers.reservedTooltip || (depth0 != null ? depth0.reservedTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"reservedTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n</button>\r\n\r\n";
}});
Handlebars.registerPartial('csui_controls_thumbnail_content_node.state_impl_reservation_reservation', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/thumbnail/content/node.state/impl/reservation/reservation',[],function(){});
csui.define('csui/controls/thumbnail/content/node.state/impl/reservation/reservation.view',[
  'csui/lib/underscore', 'csui/lib/marionette', 'csui/utils/base',
  'csui/utils/contexts/factories/user', 'csui/models/nodes',
  'csui/utils/commands', 'csui/utils/commandhelper',
  'hbs!csui/controls/thumbnail/content/node.state/impl/reservation/reservation',
  'i18n!csui/controls/thumbnail/content/node.state/impl/nls/localized.strings',
  'css!csui/controls/thumbnail/content/node.state/impl/reservation/reservation'
], function (_, Marionette, base, UserModelFactory, NodeCollection,
    commands, CommandHelper, template, publicLang) {
  'use strict';

  var ReservationIconView = Marionette.ItemView.extend({
    tagName: 'li',

    className: 'csui-node-state-reservation',

    template: template,

    triggers: {
      'click button': 'remove:reservation'
    },
	
    constructor: function ReservationIconView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      var user = this.options.context.getModel(UserModelFactory);
      this.userId = user.get('id');
      this.unreserveCommand = commands.get('UnreserveDoc');
      this.revokeShareCommand = commands.get('RevokeShare');
      this.commandStatus = {
        nodes: new NodeCollection([this.model]),
        context: this.options.context
      };
      // Refresh the state icon for collections with delayed action loading
      // (when the delayed actions are loaded, the model.actions are updated)
      var actions = this.model.actions;
      actions && this.listenTo(actions, 'update', function () {
        if (!this._isDestroyed) {
          this.render();
        }
      });
    },

    templateHelpers: function () {
      var reservedStatus = this._getReservedStatus(),
          isReserved = reservedStatus.isReserved,
          isSharedCollaboration = reservedStatus.isSharedCollaboration,
          reservedBy = reservedStatus.reservedBy,
          reservedTooltip, reservedAria, iconPrefix;

      if (isReserved) {
        var reservedDate = base.formatExactDate(this.model.get('reserved_date')),
            reservedUser = base.formatMemberName(reservedBy);
        if (isSharedCollaboration) {
          reservedTooltip = publicLang.reservedSharedCollaborationTooltip;
          reservedAria = publicLang.reservedSharedCollaborationAria;
        } else {
          reservedTooltip = publicLang.reservedTooltip;
          reservedAria = publicLang.reservedAria;
        }
        reservedTooltip = _.str.sformat(reservedTooltip, reservedUser, reservedDate);
        reservedAria = _.str.sformat(reservedAria, reservedUser, reservedDate);
        iconPrefix = isSharedCollaboration ? 'icon-shared_collaborate' : 'icon-reserved';
      }

      // Share the status with the click handler.
      this._reservedStatus = {
        isReserved: isReserved,
        isSharedCollaboration: isSharedCollaboration,
        isReservedByOther: reservedBy && this.userId !== reservedBy.id,
        canUnreserve: reservedStatus.canUnreserve,
        reservedTooltip: reservedTooltip,
        reservedAria: reservedAria,
        iconPrefix: iconPrefix
      };

      return this._reservedStatus;
    },

    onRemoveReservation: function (e) {
      if(!!this.model.get('FromThumbnailStateIconView')){
        return;
      }      
      if (this._reservedStatus.canUnreserve) {
        var command = this._reservedStatus.isSharedCollaboration ?
                      this.revokeShareCommand : this.unreserveCommand,
            promise = command.execute(this.commandStatus);
        CommandHelper.handleExecutionResults(
            promise, {
              command: command,
              suppressSuccessMessage: this.commandStatus.suppressSuccessMessage,
              suppressFailMessage: this.commandStatus.suppressFailMessage
            });
      }
    },

    _getReservedStatus: function () {
      var isReserved = this.model.get('reserved'),
          isSharedCollaboration = this.model.get('reserved_shared_collaboration'),
          command = isSharedCollaboration ? this.revokeShareCommand : this.unreserveCommand,
          reservedBy = this.model.get('reserved_user_id_expand');
      // handle both v1-expanded and not expanded (or v2-expanded) reserved_user_id scenarios
      if (!reservedBy) {
        reservedBy = this.model.get('reserved_user_id');
        if (reservedBy && typeof reservedBy === 'number') {
          reservedBy = {id: reservedBy};
        }
      }
      return {
        // Unreserving is made by emptying in the reserving user. Until the
        // server updates all properties, the model is inconsistent. That is
        // why both properties are tested here. A better fix will be welcome.
        isReserved: (isReserved && (reservedBy !== undefined)) || isSharedCollaboration,
        isSharedCollaboration: isSharedCollaboration,
        reservedBy: reservedBy,
        canUnreserve: command.enabled(this.commandStatus)
      };
    },

    getAttributes: function() {
      var data = this.templateHelpers(),
          label, name;

      if (data.isSharedCollaboration) {
        label = publicLang.reserved_shared_collaboration_attribute_title;
        name = publicLang.reserved_shared_collaboration_attribute_name;
      } else {
        label = publicLang.reserved_attribute_title;
        name = publicLang.reserved_attribute_name;
      }

      return [
        {
          label: label,
          value: data.isReserved,
          name: name,
          tooltip: data.reservedTooltip,
          aria: data.reservedAria
        }
      ];
    }
  }, {
    enabled: function (status) {
      var model = status.node,
          isReserved = model.get('reserved'),
          isSharedCollaboration = model.get('reserved_shared_collaboration'),
          reservedBy = model.get('reserved_user_id');
      return isReserved && reservedBy || isSharedCollaboration;
    },

    getModelExpand: function (options) {
      return {properties: ['reserved_user_id']};
    }
  });

  return ReservationIconView;
});

csui.define('csui/controls/thumbnail/content/node.state/impl/node.state.icons',[
  'csui/controls/thumbnail/content/node.state/impl/reservation/reservation.view'
], function (ReservationIconView) {
  'use strict';

  return [
    {
      sequence: 5,
      iconView: ReservationIconView
    }
  ];
});

csui.define('csui/dialogs/node.picker/start.locations/location.base.factory',['csui/lib/underscore', 'csui/lib/backbone'
], function (_, Backbone) {
  "use strict";

  function LocationBaseFactory(options) {
    this.options = options || {};
  }

  _.extend(LocationBaseFactory.prototype, {

    updateLocationModel: function (model) {
    },

    getLocationParameters: function () {
      return {
        container: null,
        collection: null,
        locationName: ''
      };
    }

  });

  LocationBaseFactory.extend = Backbone.View.extend;

  return LocationBaseFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/node.base.factory',['csui/lib/jquery', 'csui/lib/underscore',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/node/node.model', 'csui/models/nodechildren', 'csui/utils/commands'
], function ( $, _, LocationBaseFactory, NodeModel, NodeChildrenCollection, commands) {
  "use strict";

  var NodeBaseFactory = LocationBaseFactory.extend({

    constructor: function PersonalVolumeFactory(options) {
      LocationBaseFactory.prototype.constructor.apply(this, arguments);
      this.container = new NodeModel(this.options.node, {
        connector: this.options.connector
      });
    },

    updateLocationModel: function (model) {
      var self = this,
        deferred  = $.Deferred();
      this.container.fetch()
          .then(function () {
            model.set({
              name: self.container.get('name') || self.options.defaultName,
              icon: self.options.icon,
              invalid: false,
              selectable: self.options.selectable
            });
          deferred.resolve();
          }, function () {
            // TODO: Issue warning
            model.set({invalid: true});
            deferred.reject();
          });
      return deferred.promise();
    },

    getLocationParameters: function () {
      var children = new NodeChildrenCollection(undefined, {
        node: this.container,
        autoreset: true,
        // TODO:  This will not be enough for the consumer.  How to work
        // around the skinflint in the REST API?
        expand: ['node'],
        orderBy: 'name asc',
        commands: commands.getAllSignatures()
      });
      this.container.set('unselectable', this.options.unselectable);
      return {
        container: this.container,
        collection: children
      };
    }

  });

  return NodeBaseFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/current.location/current.location.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/nodechildren', 'csui/utils/commands',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, NodeChildrenCollection, commands, lang) {
  "use strict";

  var CurrentLocationFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        name: lang.labelCurrentLocation,
        icon: 'location',
        invalid: !(container && container.isFetchable())
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var children = new NodeChildrenCollection(undefined, {
        node: this.options.container,
        autoreset: true,
         // TODO:  This will not be enough for the consumer.  How to work
        // around the skinflint in the REST API?
        expand: ['node'],
        orderBy: 'name asc',
        commands: commands.getAllSignatures()
      });
      container.set('unselectable', false);
      return {
        container: container,
        collection: children,
        locationName: lang.labelCurrentLocation
      };
    }

  });

  return CurrentLocationFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/enterprise.volume/enterprise.volume.factory',['csui/lib/underscore',
  'csui/dialogs/node.picker/start.locations/node.base.factory',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, NodeBaseFactory, lang) {
  "use strict";

  var EnterpriseVolumeFactory = NodeBaseFactory.extend({

    constructor: function EnterpriseVolumeFactory(options) {
      options = _.defaults({
        node: {
          id: 'volume',
          type: 141
        },
        icon: 'enterprise',
        unselectable: false,
        defaultName: lang.labelEnterpriseVolume
      }, options);
      NodeBaseFactory.prototype.constructor.call(this, options);
    }

  });

  return EnterpriseVolumeFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/favorites/impl/favorite.collection',['csui/lib/underscore', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/node/node.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/client-side.mixin',
  'csui/models/browsable/v2.response.mixin'
], function (_, Backbone, Url, NodeModel, ConnectableMixin, FetchableMixin,
    ClientSideBrowsableMixin, BrowsableV2ResponseMixin) {
  "use strict";

  var FavoriteCollection = Backbone.Collection.extend({

    model: NodeModel,

    constructor: function FavoriteCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeClientSideBrowsable(options)
          .makeBrowsableV2Response(options);
    },

    url: function () {
      var orderBy = '';
      if (this.orderBy) {
        // TODO: Implement sorting by multiple columns on the server.
        var first = this.orderBy.split(",")[0].split(" ");
        orderBy = (first[1] || 'asc') + "_" + first[0];
      }
      var url = this.connector.connection.url.replace('/v1', '/v2'),
          query = Url.combineQueryString({
            fields: ['properties', 'versions.element(0)'],
            expand: 'properties{original_id}',
            orderBy: orderBy,
            actions: ''
          });
      return Url.appendQuery(Url.combine(url, 'members/favorites'), query);
    },

    parse: function (response, options) {
      this.parseBrowsedState(response, options);
      return this.parseBrowsedItems(response, options);
    }

  });

  ClientSideBrowsableMixin.mixin(FavoriteCollection.prototype);
  BrowsableV2ResponseMixin.mixin(FavoriteCollection.prototype);
  ConnectableMixin.mixin(FavoriteCollection.prototype);
  FetchableMixin.mixin(FavoriteCollection.prototype);

  return FavoriteCollection;

});

csui.define('csui/dialogs/node.picker/start.locations/favorites/favorites.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang',
  'csui/dialogs/node.picker/start.locations/favorites/impl/favorite.collection'
], function (_, $, LocationBaseFactory, lang, FavoriteCollection) {
  "use strict";

  var FavoritesFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      model.set({
        name: lang.labelFavorites,
        icon: 'favorites'
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var favorites = new FavoriteCollection(undefined, {
        connector: this.options.connector,
        autoreset: true,
        // TODO:  This will not be enough for the consumer.  How to work
        // around the skinflint in the REST API?
        expand: ['node']
      });
      return {
        container: null,
        collection: favorites,
        locationName: lang.labelFavorites
      };
    }

  });

  return FavoritesFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/personal.volume/personal.volume.factory',['csui/lib/underscore',
  'csui/dialogs/node.picker/start.locations/node.base.factory',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, NodeBaseFactory, lang) {
  "use strict";

  var PersonalVolumeFactory = NodeBaseFactory.extend({

    constructor: function PersonalVolumeFactory(options) {
      options = _.defaults({
        node: {
          id: 'volume',
          type: 142
        },
        icon: 'csui-icon-personal-volume',
        unselectable: false,
        defaultName: lang.labelPersonalVolume
      }, options);
      NodeBaseFactory.prototype.constructor.call(this, options);
    }

  });

  return PersonalVolumeFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/category.volume/category.volume.factory',['csui/lib/underscore',
  'csui/dialogs/node.picker/start.locations/node.base.factory',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, NodeBaseFactory, lang) {
  "use strict";

  var CategoryVolumeFactory = NodeBaseFactory.extend({

    constructor: function CategoryVolumeFactory(options) {
      options = _.defaults({
        node: {
          id: 'volume',
          type: 133
        },
        unselectable : true,
        icon: 'csui-icon-category-volume',
        defaultName: lang.labelCategoryVolume
      }, options);
      NodeBaseFactory.prototype.constructor.call(this, options);
    }
  });

  return CategoryVolumeFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/perspective.assets.volume/perspective.assets.volume.factory',['csui/lib/underscore',
  'csui/dialogs/node.picker/start.locations/node.base.factory',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, NodeBaseFactory, lang) {
  "use strict";

  var PerspectiveAssetsVolumeFactory = NodeBaseFactory.extend({

    constructor: function PerspectiveAssetsVolumeFactory(options) {
      options = _.defaults({
        node: {
          id: 'volume',
          type: 954
        },
        unselectable : true,
        icon: 'csui-icon-perspective-assets-volume',
        defaultName: lang.labelPerspectiveAssetsVolume
      }, options);
      NodeBaseFactory.prototype.constructor.call(this, options);
    }
  });

  return PerspectiveAssetsVolumeFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/recent.containers/impl/recent.containers.collection',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/node/node.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/client-side.mixin',
  'csui/models/browsable/v2.response.mixin'
], function (module, _, $, Backbone, Url, NodeModel, ConnectableMixin, FetchableMixin,
    ClientSideBrowsableMixin, BrowsableV2ResponseMixin) {
  "use strict";

  var RecentContainerCollection = Backbone.Collection.extend({

    model: NodeModel,

    constructor: function RecentContainerCollection(models, options) {
      _.defaults(options, {orderBy: ''});
      Backbone.Collection.prototype.constructor.call(this, models, options);

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeClientSideBrowsable(options)
          .makeBrowsableV2Response(options);

    },

    url: function () {
      var orderBy = '';
      if (this.orderBy) {
        // TODO: Implement sorting by multiple columns on the server.
        var first = this.orderBy.split(",")[0].split(" ");
        orderBy = (first[1] || 'asc') + "_" + first[0];
      }
      var url = this.connector.connection.url.replace('/v1', '/v2'),
          query = Url.combineQueryString({
            fields: ['properties', 'versions.element(0)'],
            expand: 'properties{original_id}',
            orderBy: orderBy,
            actions: ''
          });
      return Url.appendQuery(Url.combine(url, 'members/targets'), query);
    },

    parse: function (response, options) {
      this.parseBrowsedState(response, options);
      this.parseBrowsedItems(response, options);
      response.results.reverse();
      return response.results;
    }

  });

  ClientSideBrowsableMixin.mixin(RecentContainerCollection.prototype);
  BrowsableV2ResponseMixin.mixin(RecentContainerCollection.prototype);
  ConnectableMixin.mixin(RecentContainerCollection.prototype);
  FetchableMixin.mixin(RecentContainerCollection.prototype);

  return RecentContainerCollection;

});

csui.define('csui/dialogs/node.picker/start.locations/recent.containers/recent.containers.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang',
  'csui/dialogs/node.picker/start.locations/recent.containers/impl/recent.containers.collection'
], function (_, $, LocationBaseFactory, lang, RecentContainerCollection) {
  "use strict";

  var RecentContainerFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      model.set({
        name: lang.labelRecentContainers,
        icon: 'recent'
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var nodes = new RecentContainerCollection(undefined, {
        connector: this.options.connector,
        autoreset: true,
        // TODO:  This will not be enough for the consumer.  How to work
        // around the skinflint in the REST API?
        expand: ['node']
      });
      return {
        container: null,
        collection: nodes,
        locationName: lang.labelRecentContainers
      };
    }

  });

  return RecentContainerFactory;

});

csui.define('csui/dialogs/node.picker/start.locations/search.location/impl/search.collection',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/node/node.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/browsable.mixin',
  'csui/models/browsable/v1.request.mixin', 'csui/models/browsable/v2.response.mixin',
  'csui/utils/deepClone/deepClone'
], function (_, $, Backbone, Url, NodeModel, ConnectableMixin, FetchableMixin, BrowsableMixin,
    BrowsableV1RequestMixin, BrowsableV2ResponseMixin) {
  'use strict';

  var SearchResultCollection = Backbone.Collection.extend({

    model: NodeModel,

    constructor: function SearchResultCollection(models, options) {
      this.options = options || (options = {});
      Backbone.Collection.prototype.constructor.call(this, models, options);

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeBrowsable(options)
          .makeBrowsableV1Request(options)
          .makeBrowsableV2Response(options);
    },

    clone: function () {
      return new this.constructor(this.models, {
        connector: this.connector,
        skip: this.skipCount,
        top: this.topCount,
        filter: _.deepClone(this.filters),
        orderBy: _.clone(this.orderBy)
      });
    }
  });

  BrowsableMixin.mixin(SearchResultCollection.prototype);
  BrowsableV1RequestMixin.mixin(SearchResultCollection.prototype);
  BrowsableV2ResponseMixin.mixin(SearchResultCollection.prototype);
  ConnectableMixin.mixin(SearchResultCollection.prototype);
  FetchableMixin.mixin(SearchResultCollection.prototype);
  _.extend(SearchResultCollection.prototype, {

    isFetchable: function () {
      return true; //!!this.options.query.get('where');
    },

    cacheId: '',

    url: function () {
      var url   = this.connector.connection.url.replace('/v1', '/v2'),
          query = this.options.query.toJSON();
      query.where = "OTName:" + query.where;
      this.orderBy = "OTName";
      query = Url.combineQueryString(
          this.getBrowsableUrlQuery(),
          {
            actions: 'open',
            expand: 'properties{parent_id}'
          },
          query
      );
      return Url.combine(url, 'search?' + query);
    },

    parse: function (response, options) {
      this.parseBrowsedState(response.collection, options);
      response.results.sorting = response.collection.sorting;
      this.cacheId = (!!response.collection && !!response.collection.searching &&
                      !!response.collection.searching.cache_id) ?
                     response.collection.searching.cache_id : "";
      return this.parseBrowsedItems(response, options);
    }
  });
  return SearchResultCollection;
});
/**
 * Created by bbonthal on 9/30/2016.
 */
csui.define('csui/dialogs/node.picker/start.locations/search.location/search.location.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/dialogs/node.picker/start.locations/search.location/impl/search.collection',
  'csui/utils/commands', 'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, SearchCollection, commands, lang) {
  "use strict";

  var SearchLocationFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        hide: true,
        invalid: false
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function (options) {
      var container = this.options.container;
      var children = new SearchCollection(undefined, options);
      if (container) {
        container.set('unselectable', false);
      }
      return {
        container: container,
        collection: children
      };
    }
  });
  return SearchLocationFactory;
});


csui.define('csui/dialogs/node.picker/start.locations/default.location/default.location.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/nodechildren', 'csui/utils/commands',
  'i18n!csui/dialogs/node.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, NodeChildrenCollection, commands, lang) {
  "use strict";

  var DefaultLocationFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        hide: true,
        invalid: false
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var children = new NodeChildrenCollection(undefined, {
        node: this.options.container,
        autoreset: true,
        expand: ['node'],
        orderBy: 'name asc',
        commands: commands.getAllSignatures()
      });
      container.set('unselectable', false);
      return {
        container: container,
        collection: children,
        locationName: lang.labelCurrentLocation
      };
    }
  });
  return DefaultLocationFactory;
});

csui.define('csui/dialogs/members.picker/start.locations/location.base.factory',['csui/lib/underscore', 'csui/lib/backbone'
], function (_, Backbone) {
  "use strict";

  function LocationBaseFactory(options) {
    this.options = options || {};
  }

  _.extend(LocationBaseFactory.prototype, {

    updateLocationModel: function (model) {
    },

    getLocationParameters: function () {
      return {
        container: null,
        collection: null,
        locationName: ''
      };
    }

  });

  LocationBaseFactory.extend = Backbone.View.extend;

  return LocationBaseFactory;

});

csui.define('csui/dialogs/members.picker/start.locations/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/dialogs/members.picker/start.locations/impl/nls/root/lang',{
  labelNoSelection: 'Go to...',
  labelAllMembersAndGroups: 'All members and groups',
  labelRecentGroups: 'Recent groups',
  labelGroupWhereIamMember: 'Groups where I am member',
  labelAllGroups: 'All Groups'
});


csui.define('csui/dialogs/members.picker/start.locations/current.group/current.group.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/member/membercollection',
  'i18n!csui/dialogs/members.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, MemberCollectionModel, lang) {
  "use strict";

  var CurrentGroupFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        hide: true,
        invalid: false
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var memberCollectionModel = new MemberCollectionModel(undefined, {
        connector: this.options.connector,
        groupId: container.groupId,
        member: container
      });
      container.set('unselectable', false);
      return {
        container: this.options.container,
        collection: memberCollectionModel,
        locationName: lang.labelCurrentLocation
      };
    }
  });
  return CurrentGroupFactory;
});

csui.define('csui/dialogs/members.picker/start.locations/all.members/all.members.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/member/membercollection',
  'i18n!csui/dialogs/members.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, AllMembersCollection, lang) {
  "use strict";

  var AllMembersFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        name: lang.labelAllMembersAndGroups,
        icon: 'member',
        invalid: !(container && container.isFetchable())
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var membersCollectionModel = new AllMembersCollection(undefined, {
        connector: this.options.connector
      });
      return {
        container: this.options.container,
        collection: membersCollectionModel,
        locationName: lang.labelCurrentLocation
      };
    }
  });
  return AllMembersFactory;

});

csui.define('csui/dialogs/members.picker/start.locations/member.groups/member.groups.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/member/membercollection',
  'i18n!csui/dialogs/members.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, MemberCollectionModel, lang) {
  "use strict";

  var MemberGroupsFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        name: lang.labelGroupWhereIamMember,
        icon: 'location',
        invalid: !(container && container.isFetchable())
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var memberCollectionModel = new MemberCollectionModel(undefined, {
        connector: this.options.connector,
        type: 'GroupsOfCurrentUser'
      });
      container.set('unselectable', false);
      return {
        container: this.options.container,
        collection: memberCollectionModel,
        locationName: lang.labelCurrentLocation
      };
    }
  });

  return MemberGroupsFactory;
});
csui.define('csui/dialogs/members.picker/start.locations/recent.groups/impl/recent.groups.collection',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/member/member.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/client-side.mixin',
  'csui/models/browsable/v2.response.mixin'
], function (module, _, $, Backbone, Url, MemberModel, ConnectableMixin, FetchableMixin,
    ClientSideBrowsableMixin, BrowsableV2ResponseMixin) {
  "use strict";

  var RecentContainerCollection = Backbone.Collection.extend({

    model: MemberModel,

    constructor: function RecentContainerCollection(models, options) {
      Backbone.Collection.prototype.constructor.call(this, models, options);

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeClientSideBrowsable(options)
          .makeBrowsableV2Response(options);
    },

    url: function () {
      var url = this.connector.connection.url.replace('/v1', '/v2');
      return Url.appendQuery(Url.combine(url, 'members/targets'));
    },

    parse: function (response, options) {
      this.parseBrowsedState(response, options);
      this.parseBrowsedItems(response, options);
      response.results.reverse();
      return response.results;
    }

  });

  ClientSideBrowsableMixin.mixin(RecentContainerCollection.prototype);
  BrowsableV2ResponseMixin.mixin(RecentContainerCollection.prototype);
  ConnectableMixin.mixin(RecentContainerCollection.prototype);
  FetchableMixin.mixin(RecentContainerCollection.prototype);

  return RecentContainerCollection;
});
csui.define('csui/dialogs/members.picker/start.locations/recent.groups/recent.groups.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/dialogs/members.picker/start.locations/recent.groups/impl/recent.groups.collection',
  'csui/utils/commands', 'i18n!csui/dialogs/members.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, RecentContainerCollection, commands, lang) {
  "use strict";

  var RecentGroupsFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        name: lang.labelRecentGroups,
        icon: 'recent',
        invalid: !(container && container.isFetchable())
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var memberCollectionModel = new RecentContainerCollection(undefined, {
        connector: this.options.connector
      });
      container.set('unselectable', false);
      return {
        container: this.options.container,
        collection: memberCollectionModel,
        locationName: lang.labelCurrentLocation
      };
    }
  });
  return RecentGroupsFactory;
});
csui.define('csui/dialogs/members.picker/start.locations/all.groups/all.groups.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/models/member/membercollection',
  'i18n!csui/dialogs/members.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, AllMembersCollection, lang) {
  "use strict";

  var AllMembersFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        name: lang.labelAllGroups,
        icon: 'group',
        invalid: !(container && container.isFetchable())
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var membersCollectionModel = new AllMembersCollection(undefined, {
        connector: this.options.connector,
        type: 1
      });
      return {
        container: this.options.container,
        collection: membersCollectionModel,
        locationName: lang.labelCurrentLocation
      };
    }
  });
  return AllMembersFactory;

});

csui.define('csui/dialogs/members.picker/start.locations/acl.groups/impl/acl.groups.collection',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/member/member.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/client-side.mixin',
  'csui/models/browsable/v2.response.mixin'
], function (module, _, $, Backbone, Url, MemberModel, ConnectableMixin, FetchableMixin,
    ClientSideBrowsableMixin, BrowsableV2ResponseMixin) {
  "use strict";

  var AclContainerCollection = Backbone.Collection.extend({

    model: MemberModel,

    constructor: function AclContainerCollection(models, options) {
      this.options = options || {};
      Backbone.Collection.prototype.constructor.call(this, models, options);

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeClientSideBrowsable(options)
          .makeBrowsableV2Response(options);
    },

    url: function () {
      var url = Url.combine(this.connector.connection.url, 'nodes',
          this.options.nodeId), query;
      url = url.replace("/v1", "/v2");
      query = Url.combineQueryString(
          {
            fields: ['permissions{right_id, permissions, type}'],
            expand: 'permissions{right_id}'
          }, query);
      if (query) {
        url += '?' + query;
      }
      return url;
    },

    parse: function (response, options) {
      this.filterGroups(response);
      return response.aclGroups;
    },

    filterGroups: function (response) {
      var selectableMembers = response.results.data && response.results.data.permissions,
          selectableGroups  = [];
      _.each(selectableMembers, function (member) {
        if (member.right_id_expand &&
            member.right_id_expand.type === 1) {
          var group = {};
          group = member.right_id_expand;
          group.data = {};
          group.data.properties = member.right_id_expand;
          selectableGroups.push(group);
        }
      });
      response.aclGroups = selectableGroups;
      return response;
    }

  });

  ClientSideBrowsableMixin.mixin(AclContainerCollection.prototype);
  BrowsableV2ResponseMixin.mixin(AclContainerCollection.prototype);
  ConnectableMixin.mixin(AclContainerCollection.prototype);
  FetchableMixin.mixin(AclContainerCollection.prototype);

  return AclContainerCollection;
});
csui.define('csui/dialogs/members.picker/start.locations/acl.groups/acl.groups.factory',['csui/lib/underscore', 'csui/lib/jquery',
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/dialogs/members.picker/start.locations/acl.groups/impl/acl.groups.collection',
  'csui/utils/commands', 'i18n!csui/dialogs/members.picker/start.locations/impl/nls/lang'
], function (_, $, LocationBaseFactory, AclContainerCollection, commands, lang) {
  "use strict";

  var AclGroupsFactory = LocationBaseFactory.extend({

    updateLocationModel: function (model) {
      var container = this.options.container;
      model.set({
        hide: true,
        invalid: false
      });
      return $.Deferred().resolve().promise();
    },

    getLocationParameters: function () {
      var container = this.options.container;
      var groupCollectionModel = new AclContainerCollection(undefined, {
        connector: this.options.connector,
        nodeId: this.options.nodeId
      });
      container.set('unselectable', false);
      return {
        container: this.options.container,
        collection: groupCollectionModel,
        locationName: lang.labelCurrentLocation
      };
    }
  });
  return AclGroupsFactory;
});
csui.define('csui/widgets/nodestable/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/widgets/nodestable/impl/nls/root/lang',{
  columnTitleLocation: 'Location',
  dragAndDropMessage: 'Drag and drop files here to add new content.',
  filterExpandAria: 'Show filter panel ',
  filterCollapseAria: 'Hide filter panel '
});



csui.define('csui/utils/toolitem.masks/children.toolitems.mask',['csui/controls/toolbar/toolitems.mask',
  // Load and external tool item masks
  'csui-ext!csui/utils/toolitem.masks/children.toolitems.mask'
], function (ToolItemMask, masks) {
  'use strict';

  masks || (masks = []);

  var ChildrenToolItemsMask = ToolItemMask.extend({

    constructor: function ChildrenToolItemsMask(options) {
      ToolItemMask.prototype.constructor.apply(this);
      this.context = options.context;
      this.node = options.node;
      this._updateMask();
      this.listenTo(this.node, 'change:id', this._updateMask);
    },

    _updateMask: function () {
      var modified = this.restoreMask({silent: true});
      masks.forEach(function (mask) {
        mask = mask({
          context: this.context,
          node: this.node
        });
        if (mask) {
          modified = this.extendMask(mask, {silent: true}) || modified;
        }
      }, this);
      if (modified) {
        this.trigger('update', this);
      }
    }

  });

  return ChildrenToolItemsMask;

});


csui.define('csui/utils/toolitem.masks/creation.toolitems.mask',['module', 'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask',
  // Load and external tool item masks
  'csui-ext!csui/utils/toolitem.masks/creation.toolitems.mask'
], function (module, ToolItemMask, GlobalMenuItemsMask, dynamicMasks) {
  'use strict';

  dynamicMasks || (dynamicMasks = []);

  // Masks tool items for creating new nodes (in the context menu
  // of the "+" button) by blacklist and whitelist
  var CreationToolItemsMask = ToolItemMask.extend({

    constructor: function CreationToolItemsMask(options) {
      var staticMasks = module.config(),
          globalMask = new GlobalMenuItemsMask();
      ToolItemMask.prototype.constructor.call(this, globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      Object
          .keys(staticMasks)
          .forEach(function (key) {
            if (key != 'extensions') {
              this.extendMask(staticMasks[key]);
            }
          }, this);
      // Enable restoring the mask to its initial state
      this.storeMask();
      this.context = options.context;
      this.node = options.node;
      this._updateMask();
      this.listenTo(this.node, 'change:id', this._updateMask);
    },

    _updateMask: function () {
      var modified = this.restoreMask({silent: true});
      dynamicMasks.forEach(function (mask) {
        mask = mask({
          context: this.context,
          node: this.node
        });
        if (mask) {
          modified = this.extendMask(mask, {silent: true}) || modified;
        }
      }, this);
      if (modified) {
        this.trigger('update', this);
      }
    },

    // Possible inputs:
    //   'signature'      (signature as string)
    //   type             (type as number)
    //   {type: ..., ...} (object with 'type' and other properties)
    //   {commandData: {type: ..., ...}} (object with 'commandData' and other properties)
    // Output:            (object with 'signature' and other properties in 'commandData')
    // {
    //   signature: '...',
    //   commandData: {type: ..., ...}
    // }
    _normalizeRule: function (rule) {
      if (typeof rule !== 'object') {
        if (typeof rule === 'string') {
          rule = {signature: rule};
        } else {
          rule = {type: rule};
        }
      }
      if (!rule.commandData) {
        rule = {commandData: rule};
      }
      if (rule.type != null) {
        rule.commandData.type = rule.type;
        delete rule.type;
      }
      if (!rule.signature) {
        rule.signature = 'Add';
      }
      return rule;
    }

  });

  return CreationToolItemsMask;

});

csui.define('csui/controls/tabletoolbar/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/tabletoolbar/nls/root/localized.strings',{
  ToolbarItemReserve: 'Reserve',
  ToolbarItemUnreserve: 'Unreserve',
  ToolbarItemOriginalReserve: 'Reserve original',
  ToolbarItemOriginalUnreserve: 'Unreserve original',
  MenuItemReserve: 'Reserve',
  MenuItemUnreserve: 'Unreserve',
  ToolbarItemThumbnail: "Grid view",
  ToolbarItemListView: "List view",
  ThumbnailTitle: "Grid view",
  ListViewTitle: "List view"
});



csui.define('csui/widgets/nodestable/toolbaritems',[
  'csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/nls/localized.strings',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  'csui/widgets/favorites/favorite.star.view',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/nodestable/toolbaritems'
], function (_, publicLang, lang, ToolItemsFactory, TooItemModel, FavoriteStarView, extraToolItems) {
  'use strict';

  // Keep the keys in sync with csui/widgets/nodestable/toolbaritems.masks
  var toolbarItems = {

    filterToolbar: new ToolItemsFactory({
          filter: [
            {signature: "Filter", name: lang.ToolbarItemFilter, icon: "icon icon-toolbarFilter",
              toolItemAria: lang.ToolbarItemFilterAria, toolItemAriaExpand: false}
          ]
        },
        {
          maxItemsShown: 2, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-toolbar-more",
          dropDownText: lang.ToolbarItemMore,
          addTrailingDivider: false
        }),
    addToolbar: new ToolItemsFactory({
          add: []
        },
        {
          maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-toolbarAdd",
          dropDownText: lang.ToolbarItemAddItem,
          addTrailingDivider: false
        }),
    leftToolbar: new ToolItemsFactory(
        {
          main: [
            {
              signature: "CollectionCanCollect",
              name: lang.ToolbarItemAddItem,
              icon: "icon icon-toolbarAdd"
            }
          ]
        },
        {
          maxItemsShown: 2,
          dropDownIcon: "icon icon-toolbar-more",
          dropDownText: lang.ToolbarItemMore,
          addTrailingDivider: false
        }),
    tableHeaderToolbar: new ToolItemsFactory({
          info: [
            {
              signature: "Properties",
              name: lang.ToolbarItemInfo,
              icon: "icon icon-toolbar-metadata"
            }
          ],
          share: [
            {signature: "CopyLink", name: lang.ToolbarItemCopyLink},
            {
              signature: 'Share',
              name: lang.ToolbarItemShare,
              flyout: 'share',
              group: 'share'
            },
            {
              signature: 'EmailLink',
              name: lang.ToolbarItemEmailLink,
              flyout: 'share',
              promoted: true,
              group: 'share'
            }
          ],
          edit: [
            {signature: "Edit", name: lang.ToolbarItemEdit, flyout: "edit", promoted: true},
            {signature: "EditActiveX", name: "EditActiveX", flyout: "edit"},
            {signature: "EditOfficeOnline", name: "EditOfficeOnline", flyout: "edit"},
            {signature: "EditWebDAV", name: "EditWebDAV", flyout: "edit"}
          ],
          main: [
            {signature: "InlineEdit", name: lang.ToolbarItemRename, onlyInTouchBrowser: true},
            {signature: "permissions", name: lang.ToolbarItemPermissions},
            {signature: "Download", name: lang.ToolbarItemDownload},
            {signature: "ReserveDoc", name: publicLang.ToolbarItemReserve},
            {signature: "UnreserveDoc", name: publicLang.ToolbarItemUnreserve},
            {signature: "Copy", name: lang.ToolbarItemCopy},
            {signature: "Move", name: lang.ToolbarItemMove},
            {signature: "AddVersion", name: lang.ToolbarItemAddVersion},
            {signature: "Delete", name: lang.ToolbarItemDelete},
            {signature: "RemoveCollectedItems", name: lang.ToolbarItemRemoveCollectionItems}
          ],
          shortcut: [
            {signature: "OriginalCopyLink", name: lang.ToolbarItemOriginalCopyLink},
            {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
            {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
            {signature: "OriginalReserveDoc", name: publicLang.ToolbarItemOriginalReserve},
            {signature: "OriginalUnreserveDoc", name: publicLang.ToolbarItemOriginalUnreserve},
            {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
            {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
            {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
            {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload},
            {signature: "OriginalDelete", name: lang.ToolbarItemOriginalDelete}
          ]
        },
        {
          maxItemsShown: 15,
          dropDownIcon: "icon icon-toolbar-more",
          dropDownText: lang.ToolbarItemMore,
          addGroupSeparators: false,
          lazyActions: true
        }),
    captionMenuToolbar: new ToolItemsFactory({
          other: [
            {signature: "Properties", name: lang.MenuItemInformation},
            {signature: "CopyLink", name: lang.MenuItemCopyLink},
            {signature: "EmailLink", name: lang.MenuItemShare},
            {signature: "permissions", name: lang.ToolbarItemPermissions},
            {signature: "Rename", name: lang.MenuItemRename},
            {signature: "Copy", name: lang.MenuItemCopy},
            {signature: "Move", name: lang.MenuItemMove},
            {signature: "Delete", name: lang.MenuItemDelete}
          ]
        },
        {
          maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-expandArrowDown"
        }),
    inlineActionbar: new ToolItemsFactory({
          info: [
            {
              signature: "Properties", name: lang.ToolbarItemInfo,
              icon: "icon icon-toolbar-metadata"
            }
          ],
          share: [
            {
              signature: "CopyLink", name: lang.ToolbarItemCopyLink,
              icon: "icon icon-toolbar-copylink"
            }
          ],
          edit: [
            {signature: "Edit", name: lang.ToolbarItemEdit, icon: "icon icon-toolbar-edit"}
          ],
          other: [
            {
              signature: "InlineEdit", name: lang.ToolbarItemRename,
              icon: "icon icon-toolbar-rename"
            },
            {
              signature: "permissions",
              name: lang.ToolbarItemPermissions,
              icon: "icon icon-toolbar-permissions"
            },
            {
              signature: "Download", name: lang.ToolbarItemDownload,
              icon: "icon icon-toolbar-download"
            },
            {
              signature: "ReserveDoc", name: publicLang.ToolbarItemReserve,
              icon: "icon icon-toolbar-reserve"
            },
            {
              signature: "UnreserveDoc",
              name: publicLang.ToolbarItemUnreserve,
              icon: "icon icon-toolbar-unreserve"
            },
            {signature: "Copy", name: lang.ToolbarItemCopy, icon: "icon icon-toolbar-copy"},
            {signature: "Move", name: lang.ToolbarItemMove, icon: "icon icon-toolbar-move"},
            {
              signature: "AddVersion",
              name: lang.ToolbarItemAddVersion,
              icon: "icon icon-toolbar-add-version"
            },
            {signature: "Delete", name: lang.ToolbarItemDelete, icon: "icon icon-toolbar-delete"},
            {
              signature: "RemoveCollectedItems",
              name: lang.ToolbarItemRemoveCollectionItems,
              icon: "icon icon-toolbar-remove-collection-items"
            }
          ]
        },
        {
          maxItemsShown: 5,
          dropDownText: lang.ToolbarItemMore,
          dropDownIcon: "icon icon-toolbar-more",
          addGroupSeparators: false
        }),
    rightToolbar: new ToolItemsFactory({
      main: [
        {
          signature: "Thumbnail",
          name: lang.ToolbarItemThumbnail,
          icon: "icon icon-switch_thumbnails24",
          commandData: {useContainer: true},
          title: lang.ThumbnailTitle
        },
        {
          signature: "ToggleDescription",
          name: lang.ToolbarItemShowDescription,
          icon: "icon icon-description-toggle",
          commandData: {useContainer: true}
        },
        {
          signature: "Comment",
          name: lang.ToolbarItemComment,
          icon: "icon icon-socialComment",
          className: "esoc-socialactions-comment",
          customView: true,
          commandData: {useContainer: true}
        },
        {
          signature: "Favorite2",
          enabled: true,
          viewClass: FavoriteStarView,
          customView: true,
          commandData: {
            useContainer: true,
            viewOptions: {
              focusable: false
            }
          }
        },
        {
          signature: "RestoreWidgetViewSize",
          name: lang.ToolbarItemRestoreWidgetViewSize,
          icon: "icon icon-tileCollapse",
          commandData: {useContainer: true}
        },
        {
          signature: "MaximizeWidgetView",
          name: lang.ToolbarItemMaximizeWidgetView,
          icon: "icon icon-tileExpand",
          commandData: {useContainer: true}
        }
      ]
    }, {
      hAlign: "right",
      maxItemsShown: 5,
      dropDownIcon: "icon icon-toolbar-more",
      dropDownText: lang.ToolbarItemMore,
      addTrailingDivider: false
    })
  };

  if (extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar && key === 'otherToolbar') {
          targetToolbar = toolbarItems['tableHeaderToolbar'];
        }
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;
});

csui.define('csui/widgets/nodestable/toolbaritems.masks',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask'
], function (module, _, ToolItemMask, GlobalMenuItemsMask) {
  'use strict';

  // Keep the keys in sync with csui/widgets/nodestable/toolbaritems
  var toolbars = ['filterToolbar', 'leftToolbar', 'tableHeaderToolbar',
                  'inlineActionbar', 'rightToolbar'];

  function ToolbarItemsMasks() {
    var config = module.config(),
        globalMask = new GlobalMenuItemsMask();
    // Create and populate masks for every toolbar
    this.toolbars = _.reduce(toolbars, function (toolbars, toolbar) {
      var mask = new ToolItemMask(globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        source = source[toolbar];
        if (source) {
          mask.extendMask(source);
        }
      });
      // Enable restoring the mask to its initial state
      mask.storeMask();
      toolbars[toolbar] = mask;
      return toolbars;
    }, {});
  }

  ToolbarItemsMasks.toolbars = toolbars;

  return ToolbarItemsMasks;

});


csui.define('csui/widgets/nodestable/headermenuitems',['csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/nodestable/headermenuitems'
], function (_, lang, ToolItemsFactory, TooItemModel, extraMenuItems) {

  var toolbarItems = {
    headerMenuToolbar: new ToolItemsFactory({
          other: [
            {signature: "Properties", name: lang.MenuItemInformation},
            {signature: "CopyLink", name: lang.MenuItemCopyLink},
            {signature: "EmailLink", name: lang.MenuItemShare},
            {signature: "permissions", name: lang.ToolbarItemPermissions},
            {signature: "Rename", name: lang.MenuItemRename},
            {signature: "Copy", name: lang.MenuItemCopy},
            {signature: "Move", name: lang.MenuItemMove},
            {signature: "Delete", name: lang.MenuItemDelete}
          ]
        },
        {
          maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-expandArrowDown"
        }
    )
  };

  if (extraMenuItems) {
    _.each(extraMenuItems, function (moduleMenuItems) {
      _.each(moduleMenuItems, function (menuItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(menuItems, function (menuItem) {
          menuItem = new TooItemModel(menuItem);
          targetToolbar.addItem(menuItem);
        });
      });
    });
  }

  return toolbarItems;

});

csui.define('csui/widgets/nodestable/headermenuitems.mask',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask'
], function (module, _, ToolItemMask, GlobalMenuItemsMask) {
  'use strict';

  var HeaderMenuItemsMask = ToolItemMask.extend({

    constructor: function HeaderMenuItemsMask() {
      var config = module.config(),
          globalMask = new GlobalMenuItemsMask();
      ToolItemMask.prototype.constructor.call(this, globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        this.extendMask(source);
      }, this);
      // Enable restoring the mask to its initial state
      this.storeMask();
    }

  });

  return HeaderMenuItemsMask;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/nodestable/impl/nodestable',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-alternating-toolbars\">\r\n  <div class=\"csui-table-tabletoolbar\"></div>\r\n  <div class=\"csui-table-rowselection-toolbar\"></div>\r\n</div>\r\n<div class=\"csui-facet-table-container\">\r\n  <div class=\"csui-table-facetview csui-facetview-hidden csui-facetview-visibility\"></div>\r\n  <!--outer div is needed in order to float table contents right to accommodate  facets-->\r\n  <div class=\"csui-outertablecontainer\">\r\n    <!--inner div is needed in order to have tableview sized to remaining height of container-->\r\n    <div class=\"csui-innertablecontainer\">\r\n      <div class=\"csui-table-facetbarview\"></div>\r\n      <div class=\"csui-table-tableview\"></div>\r\n      <div class=\"cs-thumbnail-wrapper\"></div>\r\n      <div class=\"csui-table-paginationview\"></div>\r\n    </div>\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_widgets_nodestable_impl_nodestable', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/nodestable/impl/nodestable',[],function(){});
csui.define('csui/widgets/nodestable/nodestable.view',[
  'module', 'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/utils/log', 'csui/utils/base',
  'csui/models/utils/v1tov2',
  'csui/utils/contexts/factories/connector',
  'csui/utils/contexts/factories/columns',
  'csui/utils/contexts/factories/children',
  'csui/utils/contexts/factories/columns2',
  'csui/utils/contexts/factories/children2',
  'csui/utils/contexts/factories/node',
  'csui/models/node/node.addable.type.factory',
  'csui/models/node/node.facet.factory',
  'csui/models/node/node.model',
  'csui/models/nodes',
  'csui/controls/progressblocker/blocker',
  'csui/controls/tabletoolbar/tabletoolbar.view',
  'csui/controls/table/inlineforms/inlineform.factory',
  'csui/controls/facet.panel/facet.panel.view',
  'csui/controls/facet.bar/facet.bar.view',
  'csui/controls/table/table.view',
  'csui/controls/table/table.columns',
  'csui/controls/table/rows/description/description.view',
  'i18n!csui/widgets/nodestable/impl/nls/lang',
  'i18n!csui/utils/commands/nls/localized.strings',
  'i18n!csui/controls/table/impl/nls/lang',
  'csui/controls/pagination/nodespagination.view',
  'csui/behaviors/default.action/default.action.behavior',
  'csui/utils/toolitem.masks/children.toolitems.mask',
  'csui/utils/toolitem.masks/creation.toolitems.mask',
  'csui/widgets/nodestable/toolbaritems',
  'csui/widgets/nodestable/toolbaritems.masks',
  'csui/widgets/nodestable/headermenuitems',
  'csui/widgets/nodestable/headermenuitems.mask',
  'csui/utils/commands',
  'csui/controls/table.rowselection.toolbar/table.rowselection.toolbar.view',
  'csui/controls/tableactionbar/tableactionbar.view',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/controls/draganddrop/draganddrop.view',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/controls/globalmessage/globalmessage',
  'csui/controls/thumbnail/thumbnail.view',
  'csui/controls/thumbnail/thumbnail.content',
  'hbs!csui/widgets/nodestable/impl/nodestable',
  'csui/lib/jquery.redraw', 'css!csui/widgets/nodestable/impl/nodestable'
], function (module, $, _, Backbone, Marionette, log, base, v1tov2,
    ConnectorFactory,
    ColumnCollectionFactory,
    ChildrenCollectionFactory,
    Column2CollectionFactory,
    Children2CollectionFactory,
    NodeModelFactory,
    AddableTypeCollectionFactory,
    FacetFilterCollectionFactory,
    NodeModel,
    NodeCollection,
    BlockingView,
    TableToolbarView,
    inlineFormViewFactory,
    FacetPanelView,
    FacetBarView,
    TableView,
    tableColumns,
    DescriptionRowView,
    lang,
    cmdLang,
    controlLang,
    PaginationView,
    DefaultActionBehavior,
    ChildrenToolItemsMask,
    CreationToolItemsMask,
    toolbarItems,
    ToolbarItemsMasks,
    headermenuItems,
    HeaderMenuItemsMask,
    commands,
    TableRowSelectionToolbarView,
    TableActionBarView,
    ToolbarCommandController,
    DragAndDrop,
    LayoutViewEventsPropagationMixin,
    GlobalMessage,
    ThumbnailView,
    thumbnailColumns,
    template) {
  'use strict';

  var accessibleTable = /\baccessibleTable\b(?:=([^&]*)?)?/i.exec(location.search);
  accessibleTable = accessibleTable && accessibleTable[1] !== 'false';

  var config = module.config();
  _.defaults(config, {
    defaultPageSize: 30,
    defaultPageSizes: [30, 50, 100],
    showInlineActionBarOnHover: !accessibleTable,
    forceInlineActionBarOnClick: false,
    inlineActionBarStyle: "csui-table-actionbar-bubble",
    clearFilterOnChange: true,
    resetOrderOnChange: false,
    resetLimitOnChange: true,
    fixedFilterOnChange: false,
    useV2RestApi: false
  });

  var NodesTableView = Marionette.LayoutView.extend({

    className: function () {
      var className = 'csui-nodestable';
      if (accessibleTable) {
        className += ' csui-no-animation';
      }
      return className;
    },
    template: template,

    ui: {
      facetTableContainer: '.csui-facet-table-container',
      outerTableContainer: '.csui-outertablecontainer',
      innerTableContainer: '.csui-innertablecontainer',
      tableView: '.csui-table-tableview',
      thumbnail: '.csui-thumbnail-wrapper',
      toolbarContainer: '.csui-alternating-toolbars',
      facetView: '.csui-table-facetview',
      paginationView: '.csui-table-paginationview'
    },

    regions: {
      facetBarRegion: '.csui-table-facetbarview',
      tableToolbarRegion: '.csui-table-tabletoolbar',
      tableRowSelectionToolbarRegion: '.csui-table-rowselection-toolbar',
      facetRegion: '.csui-table-facetview',
      tableRegion: '.csui-table-tableview',
      thumbnailRegion: '.cs-thumbnail-wrapper',
      paginationRegion: '.csui-table-paginationview'
    },

    behaviors: {

      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      }

    },

    constructor: function NodesTableView(options) {
      options || (options = {});

      _.defaults(options, {
        data: {},
        pageSize: config.defaultPageSize,
        ddItemsList: config.defaultPageSizes,
        toolbarItems: toolbarItems,
        headermenuItems: headermenuItems,
        clearFilterOnChange: config.clearFilterOnChange,
        resetOrderOnChange: config.resetOrderOnChange,
        resetLimitOnChange: config.resetLimitOnChange,
        fixedFilterOnChange: config.fixedFilterOnChange,
        showDescriptions: false // do not show descriptions initially
      });

      var pageSize  = options.data.pageSize || options.pageSize,
          pageSizes = options.data.pageSizes || options.ddItemsList;
      if (!_.contains(pageSizes, pageSize)) {
        pageSizes.push(pageSize);
        options.data.pageSizes = pageSizes.sort();
      }

      this.context = options.context;

      this.tableColumns = tableColumns.deepClone();

      this.commands = options.commands || commands;
      this.commandController = new ToolbarCommandController({commands: this.commands});
      this.listenTo(this.commandController, 'before:execute:command', this._beforeExecuteCommand);
      this.listenTo(this.commandController, 'after:execute:command', this._toolbarActionTriggered);

      if (!options.connector) {
        options.connector = this.context.getObject(ConnectorFactory);
      }
      this.connector = options.connector;

      if (!options.toolbarItemsMasks) {
        options.toolbarItemsMasks = new ToolbarItemsMasks();
      }
      if (!options.headermenuItemsMask) {
        options.headermenuItemsMask = new HeaderMenuItemsMask();
      }

      // Inheritors of this object start blocking actions in initialize().
      // Initializing of the blocking view has to happen before the parent
      // constructor gets called, or better, before initialize() is executed.
      // This is a result of breaking two rules:
      // 1. Nobody should inherit from widgets.
      // 2. constructor should not be overridden together with initialize.
      BlockingView.imbue({
        parent: this,
        focus: true
      });

      Marionette.LayoutView.prototype.constructor.call(this, options);

      this.onWinRefresh = _.bind(this.windowRefresh, this);
      $(window).bind("resize.app", this.onWinRefresh);

      this.propagateEventsToRegions();

      this.listenTo(this, 'before:regions:reinitialize', this.initialize.bind(this, this.options))
          .listenTo(this, 'dom:refresh', this._refreshTableToolbar)
          .listenTo(this, 'enable:blocking', this._rememberFocusInTable)
          .listenTo(this, 'disable:blocking', this._restoreFocusInTable);
    },

    initialize: function (options) {
      function updateToolbarItemsMasks() {
        _.each(this.options.toolbarItemsMasks.toolbars, function (mask, key) {
          mask.restoreAndResetMask(this.options.childrenToolItemsMask);
        }, this);
      }

      // default action controller was set by DefaultActionBehavior...
      var defaultActionCommands = this.defaultActionController.commands,
          defaultActionItems    = this.defaultActionController.actionItems;

      if (this.options.container) {
        this.container = this.options.container;
      } else if (this.options.data.containerId) {
        this.container = this.context.getModel(NodeModelFactory, {
          node: {
            attributes: {id: this.options.data.containerId}
          }
        });
      }

      if (!this.collection) {
        this.collection = this.context.getCollection(
            ChildrenCollectionFactory, {
              options: {
                commands: this.defaultActionController.commands,
                // Fetch action permissions for non-default actions with a delay
                defaultActionCommands: defaultActionItems.getAllCommandSignatures(
                    defaultActionCommands),
                delayRestCommands: true,
                // use this node model as parent node to get the children
                node: this.container
              },
              // specify id-attribute to give the collection factory in the context a unique key
              attributes: this.options.data.containerId ? {id: this.options.data.containerId} :
                          undefined
            });
      }
      if (this.options.data.containerId && !this.collection.node.get('id')) {
        // this can happen if this.collection was set via options in constructor
        this.collection.node.set('id', this.options.data.containerId);
      }

      if (!this.container) { // if not created before when this.collection was undefined
        this.container = options.container || this.collection.node;
      }
      // Support passing the starting node ID among widget options
      //if (this.container && this.options.data.containerId) {
      //this.container.set('id', this.options.data.containerId);
      //}
      if (this.collection.delayedActions) {
        this.listenTo(this.collection.delayedActions, 'error',
            function (collection, request, options) {
              var error = new base.Error(request);
              GlobalMessage.showMessage('error', error.message);
            });
      }
      this.columns = options.columns ||
                     this.context.getCollection(ColumnCollectionFactory, {
                       options: {
                         // use this node model as parent node to get the children
                         node: this.container
                       },
                       // specify id-attribute to give the collection factory in the context a unique key
                       attributes: this.options.data.containerId ?
                           {id: this.options.data.containerId} :
                                   undefined
                     });
      this.addableTypes = options.addableTypes ||
                          this.context.getCollection(AddableTypeCollectionFactory, {
                            options: {
                              // use this node model as parent node to get the children
                              node: this.container
                            },
                            // specify id-attribute to give the collection factory in the context a unique key
                            attributes: this.options.data.containerId ?
                                {id: this.options.data.containerId} :
                                        undefined
                          });
      // Initialize facets not to be fetched together with other context modules;
      // If they were ever to be shared, we may need to control the fetch by the
      // context too; something like "delayed: true"
      this.facetFilters = options.facetFilters ||
                          this.context.getCollection(
                              FacetFilterCollectionFactory, {
                                options: {
                                  // use this node model as parent node to get the children
                                  node: this.container
                                },
                                // specify id-attribute to give the collection factory in the context a unique key
                                attributes: this.options.data.containerId ?
                                    {id: this.options.data.containerId} :
                                            undefined,
                                detached: true
                              });
      this.listenToOnce(this.context, 'request', function () {
        this.facetFilters.fetch();
      });

      if (this.container) {
        // Use a tool item mask, which is updated, whenever the container
        // node changes, to further filter the children toolbars
        if (!this.options.childrenToolItemsMask) {
          this.options.childrenToolItemsMask = new ChildrenToolItemsMask({
            context: this.context,
            node: this.container
          });
        }
        updateToolbarItemsMasks.call(this);
        this.listenTo(this.options.childrenToolItemsMask, 'update', updateToolbarItemsMasks);

        // Use a tool item mask, which is updated, whenever the container
        // node changes, to further filter the add-new-node toolbar-menu
        if (!this.options.creationToolItemsMask) {
          this.options.creationToolItemsMask = new CreationToolItemsMask({
            context: this.context,
            node: this.container
          });
        }

        // Fetch facets on node change.
        this.listenTo(this.container, 'change:id', function () {
          // Do not use the previous filter when entering other container
          var status = {container: this.container};
          if (this.commands.get('Filter').enabled(status)) {
            if (!this.facetFilters.clearFilter()) {
              this.facetFilters.fetch();
            }
          } else if (this.showFilter) {
            this._completeFilterCommand();
          }
          this._showOrHideLocationColumn(false);
        });
        // Enable the location column right away, if a VF is opened initially
        this._showOrHideLocationColumn();
      }
      this._setFacetBarView();
      this._setToolBar();
      this.setTableView();

      // must be after setTableView
      this.setTableRowSelectionToolbar({
        toolItemFactory: this.options.toolbarItems.tableHeaderToolbar,
        toolbarItemsMask: this.options.toolbarItemsMasks.toolbars.tableHeaderToolbar,
        // condensed header toggle is only available for main NodesTable, not derived tables
        showCondensedHeaderToggle: true
      });
      this._setTableRowSelectionToolbarEventListeners();
      this.setPagination();
      this.setDragNDrop();
    },

    _setThumbnailView: function () {
      var thumbnail = new ThumbnailView({
        originatingView: this,
        context: this.context,
        collection: this.collection,
        columns: this.columns,
        thumbnailColumns: this.tableView.columns,
        columnsWithSearch: ["name"],
        orderBy: this.options.data.orderBy || this.options.orderBy,
        filterBy: this.options.filterBy,
        selectedChildren: new NodeCollection(),
        actionItems: this.defaultActionController.actionItems,
        commands: this.defaultActionController.commands,
        tableColumns: thumbnailColumns,
        inlineBar: this.tableView.options.inlineBar,
        displayedColumns: this.tableView.displayedColumns
      });
      this.thumbnail = thumbnail;
      this.setThumbnailRowSelectionToolbar({
        toolItemFactory: this.options.toolbarItems.tableHeaderToolbar,
        toolbarItemsMask: this.options.toolbarItemsMasks.toolbars.tableHeaderToolbar,
        selectedChildren: this.thumbnail.options.selectedChildren,
        // condensed header toggle is only available for main NodesTable, not derived tables
        showCondensedHeaderToggle: true
      });
      this.listenTo(this.thumbnail, 'execute:defaultAction', function (node) {
        var args = {node: node};
        this.trigger('before:defaultAction', args);
        if (!args.cancel) {
          var self = this;
          this.defaultActionController
              .executeAction(node, {
                context: this.options.context,
                originatingView: this
              })
              .done(function () {
                self.trigger('executed:defaultAction', args);
              });
        }
      });
      return true;
    },

    setThumbnailRowSelectionToolbar: function (options) {
      this._thumbnailRowSelectionToolbarView = new TableRowSelectionToolbarView({
        toolItemFactory: options.toolItemFactory,
        toolbarItemsMask: options.toolbarItemsMask,
        toolbarCommandController: this.commandController,
        showCondensedHeaderToggle: options.showCondensedHeaderToggle,

        // if toolbarCommandController is not defined, a new ToolbarCommandController
        // with the following commands is created
        commands: this.defaultActionController.commands,
        selectedChildren: this.thumbnail.options.selectedChildren,
        container: this.collection.node,
        context: this.context,
        originatingView: this,
        collection: this.collection
      });

    },

    enableThumbnailView: function () {
      var tableView       = this.tableView,
          self            = this,
          deferred        = $.Deferred(),
          container       = this.container,
          context         = this.context,
          originatingView = this.originatingView;
      if (this.dragNDrop) {
        this.dragNDrop.destroy();
      }
      if (this.thumbnailViewState) {
        if (this.tableView.selectedChildren && this.tableView.selectedChildren.models.length > 0) {
          this.tableView.selectedChildren.models = [];
        }
        this._onSelectionUpdateCssClasses(this.tableView.selectedChildren.length, true);
        this._setThumbnailView();
        this._setThumbnailRowSelectionToolbarEventListeners();
      } else {
        this._onSelectionUpdateCssClasses(this.thumbnail.options.selectedChildren.length, true);
        this._setTableRowSelectionToolbarEventListeners();
      }
      this.setTableRowSelectionToolbar({
        toolItemFactory: this.options.toolbarItems.tableHeaderToolbar,
        toolbarItemsMask: this.options.toolbarItemsMasks.toolbars.tableHeaderToolbar,
        // condensed header toggle is only available for main NodesTable, not derived tables
        showCondensedHeaderToggle: true
      });

      if (this.tableView.options.inlineBar.options.maxItemsShown !== 1) {
        this.collection.defaultInlineMaxItemsShown = this &&
                                                     this.tableView.options.inlineBar.options.maxItemsShown;
      }
      if (this.thumbnailViewState) {
        this.tableView.options.inlineBar.options.maxItemsShown = 1;
        this.$el.find('table.dataTable').addClass("csui-thumbnail-view");
        this.thumbnailView = true;
      } else {
        this.thumbnailView = false;
        this.tableView.options.inlineBar.options.maxItemsShown = this.collection.defaultInlineMaxItemsShown;
        this.$el.find('table.dataTable').removeClass("csui-thumbnail-view");
      }

      var _showOriginatingView, $csThumbnail;
      var $originatingView = this.$el.find(".csui-table-tableview");
      $csThumbnail = $(this.thumbnailRegion.el)[0];
      $csThumbnail = $($csThumbnail);
      if (!$originatingView.is(":visible")) {
        //maintain state of sorting accross switching view 
        var sortingstate = this.collection.state;
        //  var selectedarrow = this.options.collection.selectedArrow;
        var listArrowState = this.collection.orderBy;
        this.thumbnail.destroy();
        this.res = listArrowState.split(" ");
        if (this.res[1] === 'asc') {
          this.collection.orderstate = 'icon-sortArrowUp';
        } else {
          if (this.res[1] === 'desc') {
            this.collection.orderstate = 'icon-sortArrowDown';
          }
        }
        this.setTableView();
        this.collection.state = sortingstate;
        if (this.collection.sorting && this.collection.sorting.sort.length > 0 &&
            this.collection.sorting.sort[0].value) {
          this.collection.sorting.sort[0].value = sortingstate;
        }
        //this.collection.selectedarrow =  selectedarrow;
        this.setTableRowSelectionToolbar({
          toolItemFactory: this.options.toolbarItems.tableHeaderToolbar,
          toolbarItemsMask: this.options.toolbarItemsMasks.toolbars.tableHeaderToolbar,
          // condensed header toggle is only available for main NodesTable, not derived tables
          showCondensedHeaderToggle: true
        });
        if (!this.thumbnailViewState && this.tableToolbarView.filterToolbarView) {
          this.tableToolbarView.filterToolbarView.collection.status.thumbnailViewState = this.tableView.thumbnailView;
        }
        this.tableToolbarView.rightToolbarView &&
        this.tableToolbarView.rightToolbarView.collection.refilter();
        if (this.tableView.collection && this.tableView.collection.length === 0) {
          this.tableView._showEmptyViewText = true;
        }
        this._updateZeroRecordsMessage();

        this.tableRegion.show(this.tableView);
        this.setDragNDrop();
        this._assignDragArea('.csui-table-tableview');
        this.tableView.render();
        $csThumbnail.hide('blind', {
          direction: 'right',
          complete: function () {
            $originatingView.show('blind',
                {
                  direction: 'left'
                },
                100);
            self.tableView.onAfterShow();
          }
        });
      } else {
        var gridArrowState = this.collection.orderBy;
        this.tableView.destroy();
        this.res = gridArrowState.split(" ");
        if (this.res[1] === 'asc') {
          this.collection.orderstate = 'icon-sortArrowDown';
        } else {
          if (this.res[1] === 'desc') {
            this.collection.orderstate = 'icon-sortArrowUp';
          }
        } 
        this.thumbnailRegion.show(this.thumbnail);
        this.setDragNDrop();
        this._assignDragArea('.cs-thumbnail-wrapper');
        this.tableToolbarView.rightToolbarView &&
        this.tableToolbarView.rightToolbarView.collection.refilter();
        var isUpdated = this.thumbnail._maintainNodeState(this.collection.at(0));
        if (!isUpdated) {
          var updateRowIndex = this.updateRowIndex;
          this.thumbnail._maintainNodeState(this.collection.at(updateRowIndex));
        }
        Marionette.triggerMethodOn(this.thumbnail, 'before:show');
        if (this.collection && this.collection.models &&
            this.collection.models.length >= 0) {
          if ($csThumbnail.length === 0) {
            $csThumbnail = $($(this.thumbnailRegion.el)[0]);
            Marionette.triggerMethodOn(this.thumbnail, 'before:show');
            $csThumbnail.append(this.thumbnail.el);
            $originatingView.hide('blind', {
              direction: 'left',
              complete: function () {
                $csThumbnail.show('blind',
                    {
                      direction: 'right',
                      complete: function () {
                        Marionette.triggerMethodOn(this.thumbnail, 'show');
                      }
                    }, 100);
              }
            }, 100);
          } else {
            $originatingView.hide('blind', {
              direction: 'left',
              complete: function () {
                $csThumbnail.show('blind',
                    {
                      direction: 'right',
                      complete: function () {
                        // fix for perfect scrollbar initial height
                        self.thumbnail.trigger('dom:refresh');
                      }
                    }, 100);
              }
            }, 100);
            self.thumbnail.onAfterShow();
          }
        }
      }
    },

    onDestroy: function () {
      $(window).unbind("resize.app", this.onWinRefresh);
      // FIXME: Refactor the table widget hierarchy not to inherit from
      // nodestable.  The initialize is rewritten in descendants, but
      // parts of the code here count on it called.
      if (this.dragNDrop) {
        this.dragNDrop.destroy();
      }
    },

    windowRefresh: function () {
      //Window refresh is triggered from the nodestable and not facet panel,  because the facet panel height
      //is not be known till after the nodetable is resized.
      if (this._isRendered && this.isDisplayed) {
        this.facetView && this.facetView.triggerMethod('dom:refresh');
      }
    },

    _refreshTableToolbar: function () {
      if (this.tableToolbarView && this.tableToolbarView.rightToolbarView) {
        this.tableToolbarView.rightToolbarView.collection.refilter();
      }
    },

    onRender: function () {
      if (this.facetBarView) {
        this.facetBarRegion.show(this.facetBarView);
      }
      this.tableToolbarRegion.show(this.tableToolbarView);

      if (this.tableRowSelectionToolbarRegion) {
        if (!this.thumbnailView && this._tableRowSelectionToolbarView) {
          this.tableRowSelectionToolbarRegion.show(this._tableRowSelectionToolbarView);
        } else if (this._thumbnailRowSelectionToolbarView) {
          this.tableRowSelectionToolbarRegion.show(this._thumbnailRowSelectionToolbarView);
        }
        // var self = this;
        // this.tableRowSelectionToolbarRegion.el.addEventListener("transitionend", function () {
        //   self._tableRowSelectionToolbarView.triggerMethod('dom:refresh');
        //   self.tableRowSelectionToolbarRegion.$el.removeClass('csui-transitioning');
        //   self.tableToolbarRegion.$el.removeClass('csui-transitioning');
        // });
        this.tableRowSelectionToolbarRegion.$el.find('ul').attr('aria-label',
            controlLang.selectedItemActionBarAria);
      }

      if (this.facetView) {
        this.facetRegion.show(this.facetView);
      }
      this.tableRegion.show(this.tableView);
      this.paginationRegion.show(this.paginationView);

      this._assignDragArea('.csui-table-tableview');

      this.listenTo(this, 'csui.description.toggled', function (args) {
        this.tableView.showDetailRowDescriptions(args.showDescriptions);
        this.tableView.trigger('update:scrollbar');
      });
      this.addFilterCommandAria();
    },

    onShow: function () {
      _.each(this.regionManager._regions, function (region) {
        if (region.currentView) {
          region.currentView.triggerMethod('show');
        }
      });
    },

    onAfterShow: function () {
      _.each(this.regionManager._regions, function (region) {
        if (region.currentView) {
          region.currentView.triggerMethod('after:show');
        }
      });
    },

    getSelectedNodes: function () {
      return new NodeCollection(this.tableView.getSelectedChildren());
    },

    setActionBarEvents: function () {
      // FIXME: deprecated - Remove this method.
      log.warn('The method \'setActionBarEvents\' has been deprecated and will be removed.') &&
      console.warn(log.last);
    },

    _updateToolItems: function () {
      // FIXME: deprecated - Remove this method.
      log.warn('The method \'_updateToolItems\' has been deprecated and will be removed.') &&
      console.warn(log.last);
    },

    setDragNDrop: function () {
      if (this.container) {
        this.dragNDrop = new DragAndDrop({
          container: this.container,
          collection: this.collection,
          addableTypes: this.addableTypes,
          context: this.options.context
        });
        this.listenTo(this.dragNDrop, 'drag:over', this._addDragDropBorder, this);
        this.listenTo(this.dragNDrop, 'drag:leave', this._removeDragDropBorder, this);
        if (this.container) {
          this.listenTo(this.container, 'change:id', this._updateZeroRecordsMessage);
          this.listenTo(this.addableTypes, 'reset', this._updateZeroRecordsMessage);
        }
      }
    },

    _updateZeroRecordsMessage: function () {
      this.tableView.setCustomLabels({
        // Workaround for VF - Smart UI does not want support uploading files to it,
        // because it is confusing, although it is technically possible.
        zeroRecords: (!this.container || this.container.get('type') !== 899) &&
                     // If drag'n'drop is enabled and adding files is possible to the
                     // current container, encourage users to drag'n'drop files to it.
                     this.dragNDrop && this.dragNDrop.canAdd() && lang.dragAndDropMessage
      });
    },

    _assignDragArea: function (el) {
      if (this.dragNDrop) {
        this.dragNDrop.setDragParentView(this, el);
      }
    },

    _addDragDropBorder: function (view, options) {
      var disableMethod = options && options.disabled ? 'addClass' : 'removeClass';
      if (!this.thumbnailViewState) {
        this.ui.tableView
            .addClass('drag-over')
            [disableMethod]('csui-disabled');
      } else {
        this.ui.thumbnail
            .addClass('drag-over')
            [disableMethod]('csui-disabled');
      }
    },

    _removeDragDropBorder: function () {
      if (!this.thumbnailViewState) {
        this.ui.tableView.removeClass('drag-over');
      } else {
        this.ui.thumbnail.removeClass('drag-over');
      }
    },

    setTableView: function (options) {
      options || (options = {});

      var self = this;
      var args = _.extend({
        context: this.options.context,
        connector: this.connector,
        collection: this.collection,
        columns: this.columns,
        tableColumns: this.tableColumns,
        descriptionRowView: DescriptionRowView,
        descriptionRowViewOptions: {
          firstColumnIndex: 2,
          lastColumnIndex: 2,
          showDescriptions: !accessibleTable && this.options.showDescriptions,
          collapsedHeightIsOneLine: true
        },
        pageSize: this.options.data.pageSize || this.options.pageSize,
        originatingView: this,
        columnsWithSearch: ["name"],
        orderBy: this.options.data.orderBy || this.options.orderBy,
        filterBy: this.options.filterBy,
        actionItems: this.defaultActionController.actionItems,
        commands: this.defaultActionController.commands,
        blockingParentView: this,
        parentView: this,
        inlineBar: {
          viewClass: TableActionBarView,
          options: _.extend({
            collection: this.options.toolbarItems.inlineActionbar,
            toolItemsMask: this.options.toolbarItemsMasks.toolbars.inlineActionbar,
            delayedActions: this.collection.delayedActions,
            container: this.container,
            containerCollection: this.collection
          }, this.options.toolbarItems.inlineActionbar.options, {
            inlineBarStyle: config.inlineActionBarStyle,
            forceInlineBarOnClick: config.forceInlineActionBarOnClick,
            showInlineBarOnHover: config.showInlineActionBarOnHover
          })
        }
      }, options);

      this.tableView = new TableView(args);

      this._ensureRequestingMetadata();
      // FIXME: Computing maximum column count (_adjustColumnsAfterWindowResize)
      // does not return the same value as set by rebuilding the table (rebuild)
      // unless an extra div  is appended to the table.  Why?
      this.listenTo(this.tableView, 'render', function () {
        this.tableView.$el.append($('<div>')[0]);
      });
      this._setTableViewEvents();
    },

    // Ensure, that the contextual node would fetch custom columns
    // and metadata to build the table header
    _ensureRequestingMetadata: function () {
      var container = this.container;
      if (container && container.makeFieldsV2) {
        ensureColumnInformation();
        this.listenTo(this.tableView, 'columnDefinitionsBuilt',
            ensureColumnInformation);
      }

      function ensureColumnInformation() {
        container.setFields('columns');
        container.includeResources('metadata');
      }
    },

    _setTableViewEvents: function () {
      this.listenTo(this.tableView, "tableRowSelected", function () {
        this.tableView.cancelAnyExistingInlineForm.call(this.tableView);
      });
      if (this.container) {
        this.listenTo(this.container, 'change:id', function () {
          if (this.options.fixedFilterOnChange) {
            this.collection.clearFilter(false);
            this.collection.setFilter(this.options.fixedFilterOnChange, false);
          }
          else if (this.options.clearFilterOnChange) {
            this.collection.clearFilter(false);
          }
          if (this.options.resetOrderOnChange) {
            this.collection.resetOrder(false);
          }
          if (this.options.resetLimitOnChange) {
            this.collection.resetLimit(false);
          }
        });
      }
      this.listenTo(this.tableView.selectedChildren, 'reset', function () {
        if (this.tableToolbarView) {
          // update table toolbar after row selection changed
          this.tableToolbarView.filterToolbarView.collection.status.thumbnailViewState = this.tableView.thumbnailView;
          this.tableToolbarView.updateForSelectedChildren(this.tableView.selectedChildren);
          this.tableRowSelectionToolbarRegion.show(this._tableRowSelectionToolbarView);
          this._onSelectionUpdateCssClasses(this.tableView.selectedChildren.length);
        }
      });

      this.listenTo(this.tableView, 'execute:defaultAction', function (node) {
        var args = {node: node};
        this.trigger('before:defaultAction', args);
        if (!args.cancel) {
          var self = this;
          this.defaultActionController
              .executeAction(node, {
                context: this.options.context,
                originatingView: this
              })
              .done(function () {
                self.trigger('executed:defaultAction', args);
              });
        }
      });

      return true;
    },

    _setToolBar: function () {
      // toolbarItems is an object with several TooItemFactories in it (for each toolbar one)
      this.tableToolbarView = new TableToolbarView({
        context: this.options.context,
        toolbarItems: this.options.toolbarItems,
        toolbarItemsMasks: this.options.toolbarItemsMasks,
        headermenuItems: this.options.headermenuItems,
        headermenuItemsMask: this.options.headermenuItemsMask,
        creationToolItemsMask: this.options.creationToolItemsMask,
        container: this.container,
        collection: this.collection,
        originatingView: this,
        blockingParentView: this,
        addableTypes: this.addableTypes,
        toolbarCommandController: this.commandController
      });
      return true;
    },

    setTableRowSelectionToolbar: function (options) {
      this._tableRowSelectionToolbarView = new TableRowSelectionToolbarView({
        toolItemFactory: options.toolItemFactory,
        toolbarItemsMask: options.toolbarItemsMask,
        toolbarCommandController: this.commandController,
        showCondensedHeaderToggle: options.showCondensedHeaderToggle,

        // if toolbarCommandController is not defined, a new ToolbarCommandController
        // with the following commands is created
        commands: this.defaultActionController.commands,
        selectedChildren: this.tableView.selectedChildren,
        container: this.collection.node,
        context: this.context,
        originatingView: this,
        collection: this.collection
      });

      // hide/show the condensed header
      var toolbarView;
      if (this.thumbnailViewState) {
        toolbarView = this._thumbnailRowSelectionToolbarView;
      } else {
        toolbarView = this._tableRowSelectionToolbarView;
      }
      this.listenTo(toolbarView, 'toggle:condensed:header', function () {
        // only show/hide the condensed header when in row selection mode
        if (this.tableToolbarRegion.$el.hasClass('csui-table-rowselection-toolbar-visible')) {
          this.ui.toolbarContainer && this.ui.toolbarContainer.toggleClass('csui-show-header');

          var showingBothToolbars = this.ui.toolbarContainer &&
                                    this.ui.toolbarContainer.hasClass('csui-show-header');
          if (showingBothToolbars) {
            this.tableToolbarRegion.$el.removeClass('binf-hidden');
          }
          // let the right toolbar know to update its attributes
          toolbarView.trigger('toolbar:activity', true, showingBothToolbars);
        }
      });

    },

    _triggerToolbarActivityEvent: function (toolbarVisible, headerVisible) {
      // let the right toolbar know to update its attributes
      var toolbarView = this.thumbnailView ?
                        this._thumbnailRowSelectionToolbarView : this._tableRowSelectionToolbarView;
      toolbarView.trigger('toolbar:activity', toolbarVisible, headerVisible);
    },

    _onSelectionUpdateCssClasses: function (selectionLength, stopTriggerToolbarActivity) {
      var self = this;
      var $rowSelectionToolbarEl = this.tableRowSelectionToolbarRegion.$el;

      function transitionEnd(headerVisible, stopTriggerToolbarActivity) {
        // let the right toolbar know to update its attributes
        if (stopTriggerToolbarActivity !== true) {
          self._triggerToolbarActivityEvent(self._tableRowSelectionToolbarVisible, headerVisible);
        }
        if (self._tableRowSelectionToolbarVisible) {
          if (!headerVisible) {
            // hide table toolbar completely so that screenreader does not see it
            self.tableToolbarRegion.$el.addClass('binf-hidden');
          }
        } else {
          self.tableRowSelectionToolbarRegion.$el.addClass('binf-hidden');
        }
      }

      var headerVisible;
      if (accessibleTable) {
        if (selectionLength > 0) {
          if (!this._tableRowSelectionToolbarVisible) {
            this._tableRowSelectionToolbarVisible = true;
            // make tableToolbar invisible
            //  and rowSelectionToolbar visible

            // this lets the tableToolbar disappear
            this.tableToolbarRegion.$el.addClass('csui-table-rowselection-toolbar-visible');

            // this lets the rowSelectionToolbar appear
            $rowSelectionToolbarEl.removeClass('binf-hidden');
            $rowSelectionToolbarEl.addClass('csui-table-rowselection-toolbar-visible');

            // it could be that both toolbars should be visible
            headerVisible = this.ui.toolbarContainer &&
                            this.ui.toolbarContainer.hasClass('csui-show-header');

            transitionEnd(headerVisible);
          }
        } else {
          if (this._tableRowSelectionToolbarVisible) {
            this._tableRowSelectionToolbarVisible = false;
            // make tableToolbar visible
            //  and rowSelectionToolbar invisible

            // without the rowSelectionToolbar, it is not necessary to have height for both toolbars
            this.ui.toolbarContainer && this.ui.toolbarContainer.removeClass('csui-show-header');

            // this lets the tableToolbar appear
            this.tableToolbarRegion.$el.removeClass('binf-hidden');
            this.tableToolbarRegion.currentView.trigger(this.tableToolbarRegion.currentView,
                'dom:refresh');
            this.tableToolbarRegion.$el.removeClass('csui-table-rowselection-toolbar-visible');

            // this lets the rowSelectionToolbar disappear
            $rowSelectionToolbarEl.removeClass('csui-table-rowselection-toolbar-visible');

            transitionEnd(false, stopTriggerToolbarActivity);
          }
        }
      } else {
        if (selectionLength > 0) {
          if (!this._tableRowSelectionToolbarVisible) {
            this._tableRowSelectionToolbarVisible = true;
            // make tableToolbar invisible
            //  and rowSelectionToolbar visible

            headerVisible = this.ui.toolbarContainer &&
                            this.ui.toolbarContainer.hasClass('csui-show-header');

            // this will start the transition on height of rowSelectionToolbar from 0 to full
            // height, which smoothly lets the rowSelectionToolbar appear
            $rowSelectionToolbarEl
                .removeClass('binf-hidden').redraw()
                .one('transitionend', function () {
                  transitionEnd(headerVisible);
                }.bind(this))
                .addClass('csui-table-rowselection-toolbar-visible');

            // this will start the transition on height of tableToolbar to 0, which finally lets
            // the tableToolbar disappear
            this.tableToolbarRegion.$el.addClass('csui-table-rowselection-toolbar-visible');
          }
        } else {
          if (this._tableRowSelectionToolbarVisible) {
            this._tableRowSelectionToolbarVisible = false;
            // make tableToolbar visible
            //  and rowSelectionToolbar invisible

            // without the rowSelectionToolbar, it is not necessary to have height for both toolbars
            this.ui.toolbarContainer && this.ui.toolbarContainer.removeClass('csui-show-header');

            this.tableToolbarRegion.$el.removeClass('binf-hidden').redraw();
            this.tableToolbarRegion.currentView.trigger(this.tableToolbarRegion.currentView,
                'dom:refresh');

            $rowSelectionToolbarEl
                .one('transitionend', function () {
                  transitionEnd(false, stopTriggerToolbarActivity);
                }.bind(this))
                .removeClass('csui-table-rowselection-toolbar-visible');

            // this will start the transition on height of tableToolbar from 0 to full
            // height, which smoothly lets the tableToolbar appear
            this.tableToolbarRegion.$el.removeClass('csui-table-rowselection-toolbar-visible');
          }
        }
      }
    },

    _setTableRowSelectionToolbarEventListeners: function () {
      // listen for change of the selected rows in the table.view and if at least one row is
      // selected, display the table-row-selected-toolbar and hide the table-toolbar
      this.listenTo(this.tableView.selectedChildren, 'reset', function () {
        this.tableToolbarView.filterToolbarView.collection.status.thumbnailViewState = this.thumbnailView;
        this.tableRowSelectionToolbarRegion.show(this._tableRowSelectionToolbarView);
        this._onSelectionUpdateCssClasses(this.tableView.selectedChildren.length);
      });

    },
    _setCommonRowSelectionToolbarEventListeners: function (selectedChildren) {
      this.listenTo(selectedChildren, 'reset', function () {
        this.tableToolbarView.filterToolbarView.collection.status.thumbnailViewState = this.thumbnailView;
        this.tableRowSelectionToolbarRegion.show(this._tableRowSelectionToolbarView);
        this._onSelectionUpdateCssClasses(selectedChildren.length);
      });

    },

    _setThumbnailRowSelectionToolbarEventListeners: function () {
      // listen for change of the selected rows in the table.view and if at least one row is
      // selected, display the table-row-selected-toolbar and hide the table-toolbar
      this.listenTo(this.thumbnail.options.selectedChildren, 'reset', function () {
        this.tableToolbarView.filterToolbarView.collection.status.thumbnailViewState = this.thumbnailView;
        this.tableRowSelectionToolbarRegion.show(this._thumbnailRowSelectionToolbarView);
        this._onSelectionUpdateCssClasses(this.thumbnail.options.selectedChildren.length);
      });
    },

    setPagination: function () {
      this.paginationView = new PaginationView({
        collection: this.collection,
        pageSize: this.options.data.pageSize || this.options.pageSize,
        defaultDDList: this.options.data.pageSizes || this.options.ddItemsList
      });
      return true;
    },

    _handleFacetBarVisible: function () {
      this.facetBarView.$el.find(".csui-facet-list-bar .csui-facet-item:last a").focus();
    },

    _handleFacetBarHidden: function () {
      //this.ui.innerTableContainer.find(".csui-checkbox-selectAll input").focus();
    },

    _showOrHideLocationColumn: function (show) {
      var subType = this.container && this.container.get('type');
      // Enable the location column right away, if a VF or Collection is opened initially
      // Fix me: obtain these details from REST API, results.data.columns.
      show = !!show || (!!subType && (subType === 899 || subType === 298));

      var expand = {properties: ['parent_id']};
      if (!this.useV2RestApi) {
        expand = v1tov2.expandsV2toV1(expand);
      }

      if (show) {
        if (!this.tableColumns.get('parent_id')) {
          this.tableColumns.add([
            {
              key: 'parent_id',
              title: lang.columnTitleLocation,
              sequence: 800,
              permanentColumn: false
            }
          ]);
          this.collection.setExpand(expand);
        }
      } else {
        this.tableColumns.remove('parent_id');
        this.collection.resetExpand(expand);
      }
    },

    _ensureFacetPanelViewDisplayed: function () {
      if (this.facetView === undefined) {
        this._setFacetPanelView();
        this.facetRegion.show(this.facetView);
      }
    },

    _setFacetPanelView: function () {
      this.facetView = new FacetPanelView({
        collection: this.facetFilters,
        blockingLocal: true
      });
      this.listenTo(this.facetView, 'remove:filter', this._removeFacetFilter)
          .listenTo(this.facetView, 'remove:all', this._removeAll)
          .listenTo(this.facetView, 'apply:filter', this._addToFacetFilter)
          .listenTo(this.facetView, 'apply:all', this._setFacetFilter);
    },

    _removeFacetPanelView: function () {
      !!this.thumbnailViewState ? this.thumbnail._adjustThumbnailWidth() : '';
      this.facetRegion.empty();
      this.facetView = undefined;
    },

    _setFacetBarView: function () {
      this.facetBarView = new FacetBarView({
        collection: this.facetFilters,
        context: this.options.context,
        showSaveFilter: true
      });
      this.listenTo(this.facetBarView, 'remove:filter', this._removeFacetFilter)
          .listenTo(this.facetBarView, 'remove:all', this._removeAll)
          .listenTo(this.facetBarView, 'facet:bar:visible', this._handleFacetBarVisible)
          .listenTo(this.facetBarView, 'facet:bar:hidden', this._handleFacetBarHidden);
    },

    _addToFacetFilter: function (filter) {
      this.facetFilters.addFilter(filter);
      var facetValues = this.facetFilters.getFilterQueryValue();
      this._showOrHideLocationColumn(true);
      this.collection.resetLimit();
      this.collection.setFilter({facet: facetValues});
    },

    _setFacetFilter: function (filter) {
      this.facetFilters.setFilter(filter);
      var facetValues = this.facetFilters.getFilterQueryValue();
      this._showOrHideLocationColumn(true);
      this.collection.resetLimit();
      this.collection.setFilter({facet: facetValues});
    },

    _removeFacetFilter: function (filter) {
      this.facetFilters.removeFilter(filter);
      var facetValues     = this.facetFilters.getFilterQueryValue(),
          accountForFacet = facetValues.length === 0 ? false : true;
      this.collection.resetLimit();
      this.collection.setFilter({facet: facetValues});
      this._showOrHideLocationColumn(accountForFacet);
    },

    _removeAll: function () {
      this.facetFilters.clearFilter();
      this.collection.resetLimit();
      this.collection.setFilter({facet: []});
      this._showOrHideLocationColumn(false);
    },

    _beforeExecuteCommand: function (toolbarActionContext) {
      if (toolbarActionContext && toolbarActionContext.commandSignature !== "Thumbnail" &&
          !this.thumbnailViewState) {
        this.tableView.cancelAnyExistingInlineForm.call(this.tableView);
      } else if (toolbarActionContext && toolbarActionContext.commandSignature !== "Thumbnail" &&
                 this.thumbnailViewState) {
        this.thumbnail.cancelAnyExistingInlineForm.call(this.thumbnail);
      }
      if (toolbarActionContext.commandSignature === 'Delete') {
        this.deletingNodes = true;
        this.tableView.setDeletingNodesState(true);
      }
    },

    // controller for the toolbar actions
    _toolbarActionTriggered: function (toolbarActionContext) {
      if (!toolbarActionContext || toolbarActionContext.cancelled) {
        // command was cancelled
        return;
      }
      if (toolbarActionContext.status.forwardToTable) {
        // if the command sent a addableType in the context it is one of the dynamically
        // created add-commands for the addable types of the current node
        var inlineFormView = inlineFormViewFactory.getInlineFormView(
            toolbarActionContext.addableType);
        if (inlineFormView) {
          // start node creation with inline form only if newNode is without error
          if (!toolbarActionContext.newNodes[0].error) {
            // for inline forms it's expected to have one single node given in the newNodes array
            if (!this.thumbnailView) {
              this.tableView.startCreateNewModel(toolbarActionContext.newNodes[0], inlineFormView);
            } else {
              this.thumbnail.startCreateNewModel(toolbarActionContext.newNodes[0], inlineFormView);
            }
          }
        }
      }
      // reducing performance to somewhat extent,
      // such that collection will be refetched iff it meets the following condtions
      // 1) if the current command allows to refetch from it's own implementation
      // 2) if the total count is > current page size.
      if (!!toolbarActionContext.command && !!toolbarActionContext.command.allowCollectionRefetch
          && toolbarActionContext.commandSignature !== 'Delete') {
        this.collection.fetch();
      }

      switch (toolbarActionContext.commandSignature) {
      case 'Delete':
        this.deletingNodes = false;
        this.tableView.setDeletingNodesState(false);
        // Fully success or partially fail: the collection always needs to fetch for Delete command.
        // Also the collection.fetch has be after the tableView.deletingNodes state change above.
        this.collection.fetch();
        break;
      case 'Filter':
        this._completeFilterCommand();
        break;
      case 'MaximizeWidgetView':
        this.tableToolbarView.rightToolbarView.collection.refilter();
        break;
      case 'RestoreWidgetViewSize':
        this.tableToolbarView.rightToolbarView.collection.refilter();
        break;
      case 'Thumbnail':
        this.thumbnailViewState = (!!this.thumbnailViewState) ? !this.thumbnailViewState : true;
        this.enableThumbnailView();
        break;
      }

    },

    _transitionEnd: _.once(
        function () {
          var transitions = {
                transition: 'transitionend',
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd otransitionend'
              },
              element     = document.createElement('div'),
              transition;
          for (transition in transitions) {
            if (typeof element.style[transition] !== 'undefined') {
              return transitions[transition];
            }
          }
        }
    ),

    _completeFilterCommand: function () {
      var self = this;
      this.showFilter = !this.showFilter;
      if (this.showFilter) {
        this._ensureFacetPanelViewDisplayed();
        this.ui.facetView.removeClass('csui-facetview-visibility');
        if (accessibleTable) {
          this.ui.facetView.removeClass('csui-facetview-hidden');
          this.triggerMethod('dom:refresh');
        } else {
          this.ui.facetView.one(this._transitionEnd(),
              function () {
                self.triggerMethod('dom:refresh');
                !!self.thumbnailViewState ? self.thumbnail._adjustThumbnailWidth() : '';
              }).removeClass('csui-facetview-hidden');
        }
      } else {
        if (accessibleTable) {
          this.ui.facetView.addClass('csui-facetview-hidden');
          this.triggerMethod('dom:refresh');
          this.ui.facetView.hasClass('csui-facetview-hidden') &&
          this.ui.facetView.addClass('csui-facetview-visibility');
          this._removeFacetPanelView();
        } else {
          this.ui.facetView.one(this._transitionEnd(),
              function () {
                self.triggerMethod('dom:refresh');
                self.ui.facetView.hasClass('csui-facetview-hidden') &&
                self.ui.facetView.addClass('csui-facetview-visibility');
                self._removeFacetPanelView();
              }).addClass('csui-facetview-hidden');
        }
      }
      this.addFilterCommandAria();
    },

    addFilterCommandAria: function () {
      if (this.ui.facetView.hasClass('csui-facetview-hidden') && this.tableToolbarView &&
          this.tableToolbarView.filterToolbarView) {
        this.tableToolbarView.filterToolbarView.$el.find(".csui-toolitem").attr("aria-label",
            lang.filterExpandAria);
        this.tableToolbarView.filterToolbarView.$el.find(".csui-toolitem").attr("aria-expanded",
            false);
      } else {
        this.tableToolbarView.filterToolbarView.$el.find(".csui-toolitem").attr("aria-label",
            lang.filterCollapseAria);
        this.tableToolbarView.filterToolbarView.$el.find(".csui-toolitem").attr("aria-expanded",
            true);
      }
    },

    _rememberFocusInTable: function () {
      if (this.tableView.el.contains(document.activeElement)) {
        this._tableFocused = true;
      }
    },

    _restoreFocusInTable: function () {
      if (this._tableFocused) {
        this.tableView.currentlyFocusedElement() &&
        this.tableView.currentlyFocusedElement().focus();
      }
    }
  }, {
    useV2RestApi: config.useV2RestApi
  });

  _.extend(NodesTableView.prototype, LayoutViewEventsPropagationMixin);
  NodesTableView.prototype._eventsToPropagateToRegions.push('global.alert.inprogress',
      'global.alert.completed');

  if (NodesTableView.useV2RestApi) {
    ChildrenCollectionFactory = Children2CollectionFactory;
    ColumnCollectionFactory = Column2CollectionFactory;
  }

  return NodesTableView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/integration/folderbrowser/impl/folderbrowser',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "\r\n<div id=\"csui-folderbrowser-core\">\r\n\r\n  <div class=\"csui-fb-breadcrumbs\"></div>\r\n  <div class=\"csui-fb-nodestable \"></div>\r\n</div>";
}});
Handlebars.registerPartial('csui_integration_folderbrowser_impl_folderbrowser', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/integration/folderbrowser/impl/folderbrowser',[],function(){});
csui.define('csui/integration/folderbrowser/impl/folderbrowser.view',["module", "require", "csui/lib/jquery", "csui/lib/underscore",
  "csui/lib/marionette", "csui/utils/log",
  "csui/utils/contexts/page/page.context", "csui/utils/contexts/factories/connector",
  "csui/utils/contexts/factories/node",
  'csui/utils/contexts/factories/next.node',
  'csui/utils/contexts/factories/user',
  'csui/utils/contexts/factories/children',
  'csui/utils/contexts/factories/children2',
  'csui/models/node/node.model', "csui/utils/connector", "csui/utils/base",
  "csui/utils/contexts/factories/ancestors", "csui/controls/breadcrumbs/breadcrumbs.view",
  "csui/widgets/nodestable/nodestable.view",
  'csui/behaviors/default.action/default.action.behavior',
  "csui/controls/table/table.columns",
  'csui/controls/globalmessage/globalmessage',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/default.action/impl/defaultaction',
  'csui/dialogs/modal.alert/modal.alert',
  "hbs!csui/integration/folderbrowser/impl/folderbrowser",
  'csui/controls/iconpreload/icon.preload.view',
  "css!csui/integration/folderbrowser/impl/folderbrowser"
], function (module, _require, $, _, Marionette, log,
    PageContext, ConnectorFactory, NodeModelFactory, NextNodeModelFactory,
    UserModelFactory, ChildrenCollectionFactory, Children2CollectionFactory,
    NodeModel, Connector, base, AncestorCollectionFactory, BreadcrumbsView,
    NodesTableView, DefaultActionBehavior, TableColumnCollection, GlobalMessage,
    LayoutViewEventsPropagationMixin, DefaultActionController, ModalAlert,
    template, IconPreloadView) {
  'use strict';

  if (NodesTableView.useV2RestApi) {
    ChildrenCollectionFactory = Children2CollectionFactory;
  }

  var FolderBrowserLayout = Marionette.LayoutView.extend({

    className: 'binf-widgets csui-folderbrowser',

    template: template,

    regions: {
      breadcrumbRegion: "#csui-folderbrowser-core div.csui-fb-breadcrumbs",
      nodeTableRegion: '#csui-folderbrowser-core div.csui-fb-nodestable'
    },

    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      }
    },

    constructor: function FolderBrowserLayout(options) {
      options || (options = {});
      this.setDefaultOptions(options);

      var connection = options.connection,
          connector  = options.connector,
          context    = options.context || new PageContext({
                factories: {
                  connector: connector ||
                             connection && {connection: connection} ||
                             undefined
                }
              });

      if (!connector) {
        connector = context.getObject(ConnectorFactory);
      }

      this.context = context;
      this.connector = connector;

      //Set context before calling parent constructor. If context is not set as an option
      //during a jasmine test, behaviors will throw an exception.
      if (options.context == null) {
        _.extend(options, {context: this.context});
      }

      Marionette.LayoutView.prototype.constructor.call(this, options); // sets this.options

      this.container = this._initializeContainer(context, options);
      this.collection = this._initializeChildCollection(context, options);
      this.nodesTable = this._initializeNodesTable(context, options);
      this.tableView = this.nodesTable.tableView;
      this.breadcrumbs = this._initializeBreadCrumb(this.options);

      this._nextNode = context.getModel(NextNodeModelFactory);
      this.listenTo(this._nextNode, 'change:id', function () {
        this.enterContainer(this._nextNode.attributes);
        this._nextNode.clear({silent: true});
      });

      // Ask for the current user model to be fetched with the context.
      // It is not used in this object, but commands fired from here
      // count on the user information filled.  It is done by the
      // perspective context automatically, but when using other
      // contexts, the models have to be included explicitly.  This
      // integration widget is a convenience wrapper, that is why it
      // should include all models, which the embedded views need.
      //
      // It would be better to have the commands request the models
      // too, but there is nothing for it in the current framework.
      context.getModel(UserModelFactory);

      this.prevNodeId = this.container.get('id');
      if (this.prevNodeId != null) {
        this.contextPromise = this.container.isFetchableDirectly() ?
                              context.fetch() :
                              this.container
                                  .fetch({silent: true})
                                  .fail(_.bind(this.handleFetchError, this))
                                  .then(function () {
                                    return context.fetch();
                                  });
      }

      // Handle errors from the drill-down action, which re-fetches the context
      this.listenTo(context, 'error', this.handleFetchError);

      this.propagateEventsToRegions();
    },

    setDefaultOptions: function (options) {
      _.defaults(options, {
        breadcrumb: true,
        facetPanel: true,
        columnsFromDefinitionsOrder: false
      });
    },

    onDestroy: function () {
      this.nodesTable.destroy();
      if (this.breadcrumbs) {
        this.breadcrumbs.destroy();
      }
    },

    onRender: function () {
      this.nodeTableRegion.show(this.nodesTable);

      if (this.breadcrumbs != null) {
        this.$el.addClass('csui-with-breadcrumb');
        this.breadcrumbRegion.show(this.breadcrumbs);
      }
      IconPreloadView.ensureOnThePage();
      GlobalMessage.setMessageRegionView(this, {classes: 'csui-globalMessenger'});
    },

    updateOptions: function (options) {
      if (options) {
        if (this.breadcrumbs) {
          this._updateBreadcrumbs(options);
        }
        if (options.start && options.start.id) {
          this.enterContainer(options.start.id);
        }
      }
    },

    //*********************************************************************
    //This function should be called before any node fetch. It
    //gives a client the opportunity to cancel the fetch before it happens.
    //The fetch will only run if the node id value has changed.
    //this function is public and can be called by the client to change a display node.
    //@param{Object} - the container to enter
    //@param{Objecgt} - internal param used to stop propagation
    //@return{Object} - This object itself to allow call chaining
    //*******************************************************************
    enterContainer: function (node, status) {
      var nodeAttr = {id: getNodeId(node)};

      if (nodeAttr.id != this.prevNodeId) {
        this.trigger("openingContainer", nodeAttr);
        if (nodeAttr.cancel) {
          if (status != null) {
            status.cancel = true;
          }
        } else {
          this.fetchNode(nodeAttr);
        }
      }
      return this;
    },

    fetchNode: function (nodeAttr) {
      var container = this.container;
      this.prevNodeId = nodeAttr.id;
      container.set(nodeAttr);
      this.context.fetch();
      //To help avoid a second collection fetch due to pagination changing page size
      //the collection limit is set prior to the fetch.
      //container.fetch().then(function () {
      // self.trigger('containerOpened', _.clone(container.attributes));
      //});
      return true;
    },

    _initializeContainer: function (context, options) {
      var container = context.getObject(NodeModelFactory);
      options.start || (options.start = {type: 141});

      if (options.start.id) {
        if (NodeModel.usesIntegerId && typeof options.start.id === 'string') {
          container.set({id: parseInt(options.start.id, 10)});
        } else {
          container.set({id: options.start.id});
        }
      }
      //create volume
      else if (options.start.type) {
        container.set({id: 'volume', type: options.start.type});
      }

      this._setContainerEvents(container);

      return container;
    },

    _setContainerEvents: function (container) {
      this.listenTo(container, "change:id", function (node, status) {
        this.enterContainer(node.get('id'), status);
      });

      return true;
    },

    _initializeChildCollection: function (context, options) {
      var collection = context.getCollection(
          ChildrenCollectionFactory, {
            options: {
              commands: this.defaultActionController.commands,
              // Fetch action permissions for non-default actions with a delay
              defaultActionCommands: this.defaultActionController.actionItems.getAllCommandSignatures(
                  this.defaultActionController.commands),
              delayRestCommands: true
            }
          });

      collection.setLimit(0, options.pageSize, false);
      collection.setFilter(options.filter, false);
      this.listenTo(collection, 'sync', function () {
        this._containerOpened(this.container);
      });
      return collection;
    },

    _initializeNodesTable: function (context, options) {
      var nodesTable = new NodesTableView({
        context: context,
        pageSize: options.pageSize,
        ddItemsList: options.pageSizes,
        tableColumns: options.tableColumns,
        clearFilterOnChange: options.clearFilterOnChange,
        resetOrderOnChange: options.resetOrderOnChange,
        resetLimitOnChange: options.resetLimitOnChange,
        fixedFilterOnChange: options.fixedFilterOnChange
      });

      this.listenTo(nodesTable, "executed:defaultAction", function (args) {
        if (args.signature === 'Browse') {
          this._containerOpened(args.node);
        }
      });

      this.listenTo(nodesTable.tableView, 'tableBodyRendered', function (args) {
        this.trigger('tableBodyRendered', {sender: this, target: args.target});
      });

      this.listenTo(nodesTable, 'before:defaultAction', function (args) {
        this._beforeDefaultAction(args);
      });

      return nodesTable;
    },

    _beforeDefaultAction: function (args) {
      var newOptions = {sender: this, node: args.node};
      this.trigger('executingDefaultAction', newOptions);
      args.cancel = newOptions.cancel;
      return true;
    },

    _containerOpened: function (node) {
      this.trigger('containerOpened', {sender: this, node: node});
      return true;
    },

    updateBreadcrumb: function (stopNode) {
      var stopNodeId = getNodeId(stopNode);
      this.breadcrumbs.updateStopId(stopNodeId);
    },

    _initializeBreadCrumb: function (options) {
      var breadcrumbView = null;

      if (this.options.breadcrumb) {
        _.isObject(this.options.breadcrumb) || (this.options.breadcrumb = {});
        breadcrumbView = new BreadcrumbsView({
          context: options.context,
          collection: options.context.getCollection(AncestorCollectionFactory),
          stop: options.breadcrumb.stop
          // TODO: Use {fetchOnCollectionUpdate: false} to prevent
          // the control from an extra fetching of the collection.
        });
        options.breadcrumb.isBreadcrumbsEmpty = true;
        this._setBreadcrumbEvents(breadcrumbView);
      }
      return breadcrumbView;
    },

    _setBreadcrumbEvents: function (breadcrumbView) {
      this.listenTo(breadcrumbView, 'before:defaultAction', this._beforeDefaultAction);
      return true;
    },

    handleFetchError: function (request) {
      var error = new base.Error(request);
      this.tableView.cancelFetch();
      this.tableView.renderError();
      ModalAlert.showError(error.message);
    }

  });

  _.extend(FolderBrowserLayout.prototype, LayoutViewEventsPropagationMixin);

  return FolderBrowserLayout;

  function getNodeId(node) {
    // Backbone model, attributes object or a number
    return node.get && node.get('id') || node.id || node;
  }

});



csui.define('csui/integration/folderbrowser/folderbrowser.widget',['csui/lib/underscore', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/integration/folderbrowser/impl/folderbrowser.view'
], function (_, Backbone, Marionette, FolderView) {
  'use strict';

  function FolderBrowserWidget(options) {
    this.options = options || (options = {});
    this.folderView = new FolderView(options);

    this.listenTo(this.folderView, 'containerOpened', function (args) {
      this.trigger('containerOpened', {
        sender: this,
        node: args.node.toJSON()
      });
    });

    this.listenTo(this.folderView, 'executingDefaultAction', function (args) {
      var sentArgs = {
        sender: this,
        node: args.node.toJSON()
      };
      this.trigger('executingDefaultAction', sentArgs);
      args.cancel = sentArgs.cancel;
    });

    this.listenTo(this.folderView, 'tableBodyRendered', function (args) {
      this.trigger('tableBodyRendered', {
        sender: this,
        target: args.target
      });
    });

    var selection = this.folderView.nodesTable.getSelectedNodes(),
        previousSelection = selection.clone();
    this.listenTo(selection, 'reset', function () {
      var eventName, difference;
      if (selection.length > previousSelection.length) {
        eventName = 'childSelected';
        difference = selection.reject(function (node) {
          return previousSelection.findWhere({id: node.get('id')});
        });
      } else {
        eventName = 'childUnselected';
        difference = previousSelection.reject(function (node) {
          return selection.findWhere({id: node.get('id')});
        });
      }
      if (difference.length) {
        this.trigger(eventName, {
          sender: this,
          nodes: _.invoke(difference, 'toJSON')
        });
      }
      previousSelection = selection.clone();
    });
  }

  var originalListenTo = Backbone.Events.listenTo;

  _.extend(FolderBrowserWidget.prototype, Backbone.Events, {

    constructor: FolderBrowserWidget,

    show: display,

    display: display,

    destroy: destroy,

    close: destroy,

    enterContainer: function (startNode, breadCrumbNode) {
      if (breadCrumbNode && breadCrumbNode.stop) {
        this.folderView.updateBreadcrumb(breadCrumbNode.stop);
      }
      this.folderView.enterContainer(startNode);
      return this;
    },

    getContainer: function () {
      return this.folderView.container.toJSON();
    },

    getSelectedChildren: function () {
      return this.folderView.nodesTable.selectedNodes.toJSON();
    },

    // Compatibility with the initial undocumented interface, which
    // still may be used; it broke the original v1 interface
    listenTo: function (other, event, callback) {
      return typeof other === 'string' ?
             originalListenTo.call(this, this, other, event) :
             originalListenTo.call(this, other, event, callback);
    }

  });

  function display(options) {
    var contextPromise = this.folderView.contextPromise;
    var self = this;
    options || (options = {});
    // Enable specifying options needed to show the widget later;
    // placeholder may not be known in the construction time
    _.extend(options, this.options);
    this.region = new Marionette.Region({el: options.placeholder});

    // Before
    if (contextPromise) {
      contextPromise.done(function () {
        if (self.region) {
          self.region.show(self.folderView);
        }
      });
    } else {
      self.region.show(self.folderView);
    }
    return this;
  }

  function destroy() {
    // Allow calling this method multiple times without error
    if (this.region) {
      // Destroy the application widget
      this.folderView.destroy();
      this.region.destroy();
      this.region = null;
    }
    return this;
  }

  FolderBrowserWidget.version = '1.0';

  return FolderBrowserWidget;

});


csui.define('csui/integration/target.picker/target.picker',['csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/dialogs/node.picker/node.picker', 'csui/utils/contexts/page/page.context'
], function (_, Backbone, Marionette, NodePicker, PageContext) {
  'use strict';

  var defaultOptions = {
    start: {},
    selectRows: 'single',
    filter: {},
    selectable: {},
    ui: {}
  };

  function TargetPicker(options) {
    this.options = _.defaults({}, options, defaultOptions);
  }

  _.extend(TargetPicker.prototype, Backbone.Events, {

    show: function (options) {
      options = _.defaults({}, options, this.options);

      var connector = options.connector || {connection: options.connection},
          context = new PageContext({
            factories: {connector: connector}
          }),

          initialContainer = _.isEmpty(options.start) ? undefined :
                             options.start.id ? options.start : {
                               id: 'volume',
                               type: options.start.type
                             },

          selectableTypes = _.isEmpty(options.selectable.type) ?
                            options.filter.type : options.selectable.type,

          nodePicker = new NodePicker({
            context: context,
            initialContainer: initialContainer,
            selectMultiple: options.selectRows === 'multiple',
            selectableTypes: selectableTypes,
            globalSearch: true,
            dialogTitle: options.ui.TargetPickerDialogTitle
          }),
          promise = nodePicker.show(),

          self = this;

      promise
          .done(function (args) {
            var firstNode = args.nodes[0],
                nodes = _.invoke(args.nodes, 'toJSON');
            // Compatibility with previous version
            self.trigger('childSelected', {
              sender: self,
              nodes: _.invoke(args.nodes, 'toJSON'),
              // TODO: Implement for compatibility with the old version
              ancestors: [] // old version compatibility
            });
            options.done && options.done({
              sender: self, // old version compatibility
              node: firstNode && firstNode.toJSON(), // old version compatibility
              // TODO: Implement for compatibility with the old version
              ancestors: [], // old version compatibility
              nodes: nodes
            });
          })
          .fail(function () {
            options.done && options.done({
              sender: self, // old version compatibility
              nodes: []
            });
          });

      return this;
    }

  });

  TargetPicker.defaults = {

    containers: {
      selectable: {
        type: NodePicker.defaults.containers.selectableTypes
      },
      ui: {
        TargetPickerDialogTitle: NodePicker.defaults.containers.dialogTitle
      }
    },

    documents: {
      selectable: {
        type: NodePicker.defaults.documents.selectableTypes
      },
      ui: {
        TargetPickerDialogTitle: NodePicker.defaults.documents.dialogTitle
      }
    },

    categories: {
      start: NodePicker.defaults.categories.initialContainer,
      selectable: {
        type: NodePicker.defaults.categories.selectableTypes
      },
      ui: {
        TargetPickerDialogTitle: NodePicker.defaults.categories.dialogTitle
      }
    }

  };

  return TargetPicker;

});

// Compatibility with the v1 widgets
csui.define('csui/integration/v1.widgets.wrapper',["csui/lib/underscore", "csui/utils/connector",
  "csui/integration/folderbrowser/folderbrowser.widget",
  "csui/integration/target.picker/target.picker"
], function (_, Connector, FolderBrowserWidget, TargetPicker) {

  var csui = window.csui;
  _.extend(csui, {

    version: "2.0",

    util: {
      Connector: Connector
    },

    widget: {
      FolderBrowserWidget: FolderBrowserWidget,
      TargetPickerDialogWidget: TargetPicker
    },

    // Compatibility with the pre-release v1 widgets
    Connector: Connector,
    FolderBrowserWidget: FolderBrowserWidget

  });

  return csui;

});

// Defines localizable strings in the default language (English)
csui.define('csui/integration/permission.header/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});
csui.define('csui/integration/permission.header/impl/nls/root/lang',{
  "lblSecurityClearance": "Security clearance",
  "lblSupplementalMarkings":  "Supplemental markings"
});




/* START_TEMPLATE */
csui.define('hbs!csui/integration/permission.header/impl/permission.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-permissions-rightbar-view\">\r\n  <div class=\"csui-secuirity-clearance\"><label>"
    + this.escapeExpression(((helper = (helper = helpers.lblSecurityClearance || (depth0 != null ? depth0.lblSecurityClearance : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"lblSecurityClearance","hash":{}}) : helper)))
    + "</label><span>Secret</span\r\n  ></div>\r\n  <div class=\"csui-supplimental-markings\"><label>"
    + this.escapeExpression(((helper = (helper = helpers.lblSupplementalMarkings || (depth0 != null ? depth0.lblSupplementalMarkings : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"lblSupplementalMarkings","hash":{}}) : helper)))
    + "</label><span\r\n  >Contractor; For official use only\r\n  </span\r\n></div>\r\n</div>";
}});
Handlebars.registerPartial('csui_integration_permission.header_impl_permission.header', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/integration/permission.header/impl/permission.header',[],function(){});
csui.define('csui/integration/permission.header/permission.header.view',["module", "require", "csui/lib/jquery", "csui/lib/underscore",
  "csui/lib/marionette",
  'i18n!csui/integration/permission.header/impl/nls/lang',
  "hbs!csui/integration/permission.header/impl/permission.header",
  "css!csui/integration/permission.header/impl/permission.header"
], function (module, _require, $, _, Marionette, lang, template) {
  'use strict';

  var PermissionHeaderView = Marionette.ItemView.extend({

    template: template,
    templateHelpers: function () {
      return {
        lblSecurityClearance: lang.lblSecurityClearance,
        lblSupplementalMarkings: lang.lblSupplementalMarkings
      };
    },

    constructor: function PermissionHeaderView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.call(this, options);
    }

  });
  return PermissionHeaderView;
});

csui.define('css!csui/integration/permission/table/cells/impl/security.permission.cell',[],function(){});
csui.define('csui/integration/permission/table/cells/security.permission.cell',['csui/controls/table/cells/cell/cell.view',
  'csui/controls/table/cells/cell.registry',
  'css!csui/integration/permission/table/cells/impl/security.permission.cell'
], function (CellView, cellViewRegistry) {
  'use strict';

  var SecurityPermissionCellView = CellView.extend({

    renderValue: function () {
      var value = this.getValueText();
      // adding the css class csui-table-cell-default-action lets the table.view.js select
      // this cell too when ataching a click handler for the default action
      if (value === 'true') {
        this.$el.append('<span class="csui-icon icon-true icon-checkmark-green"></span>');
      } else if (value === 'false') {
        this.$el.append('<span class="csui-icon icon-false circle_delete"></span>');
      } else {
        this.$el.text(value);
      }
    }
  }, {
    hasFixedWidth: true
  });

  cellViewRegistry.registerByColumnKey('security_clearance', SecurityPermissionCellView);
  cellViewRegistry.registerByColumnKey('supplemental_markings', SecurityPermissionCellView);

  return SecurityPermissionCellView;
});

csui.define('csui/integration/permission/table/permission.table.columns',['csui/lib/underscore'
], function (_) {

  var tableColumns = [
    {
      key: 'security_clearance',
      sequence: 31,
      permanentColumn: true
    },
    {
      key: 'supplemental_markings',
      sequence: 32,
      permanentColumn: true
    }];

  return tableColumns;

});

// Defines localizable strings in the default language (English)
csui.define('csui/integration/folderbrowser/impl/nls/folderbrowser.manifest',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});
csui.define('csui/integration/folderbrowser/impl/nls/root/folderbrowser.manifest',{
  "BackButtonToolItem": "Go Back",
  "PageWidgetToolItem":  "Open Full Page Container"
});




csui.define('css!csui/integration/folderbrowser/impl/icons',[],function(){});
csui.define('csui/integration/folderbrowser/impl/nodestable.toolitems',['csui/lib/underscore',
  'csui/utils/base',
  'csui/controls/toolbar/toolitems.factory',
  'i18n!csui/integration/folderbrowser/impl/nls/folderbrowser.manifest',
  'css!csui/integration/folderbrowser/impl/icons'
], function (_, base, ToolItemsFactory, FolderBrowseLang) {
  var toolbarItems = {
    leftToolbar: [
      {
        signature: "Back",
        name: FolderBrowseLang.BackButtonToolItem,
        icon: "icon arrow_back csui-icon-go-previous-node csui-no-hover-effect"
      }
    ],
    rightToolbar: [
      {
        signature: "Page",
        name: FolderBrowseLang.PageWidgetToolItem,
        icon: "icon csui-icon-open-full-page",
        group: 'main',
        options: {
          hAlign: "right"
        }
      }
    ]
  };

  return toolbarItems;

});

csui.define('csui/widgets/search.results/impl/search.results.factory',['csui/utils/contexts/factories/search.results.factory'
], function (SearchResultsFactory) {

  var SearchResultCollectionFactory = SearchResultsFactory.extend({

    constructor: function SearchResultCollectionFactory(context, options) {
      SearchResultsFactory.prototype.constructor.apply(this, arguments);
      console.warn('warning: "csui/widgets/search.results/impl/search.results.factory" has been' +
                  ' deprecated. Use "csui/utils/contexts/factories/search.results.factory');
    }

  });

  return SearchResultCollectionFactory;

});


csui.define('json!csui/utils/contexts/perspective/impl/perspectives/metadata.json',{
  "type": "grid",
  "options": {
    "rows": [
      {
        "columns": [
          {
            "sizes": {
              "md": 12
            },
            "heights": {
              "xs": "full"
            },
            "widget": {
              "type": "csui/widgets/metadata",
              "options": {
              }
            }
          }
        ]
      }
    ]
  }
}
);


csui.define('json!csui/utils/contexts/perspective/impl/perspectives/metadata.navigation.json',{
  "type": "grid",
  "options": {
    "rows": [
      {
        "columns": [
          {
            "sizes": {
              "md": 12
            },
            "heights": {
              "xs": "full"
            },
            "widget": {
              "type": "csui/widgets/metadata.navigation",
              "options": {
              }
            }
          }
        ]
      }
    ]
  }
}
);


csui.define('json!csui/utils/contexts/perspective/impl/perspectives/document.overview.json',{
  "type": "grid",
  "options": {
    "rows": [
      {
        "columns": [
          {
            "sizes": {
              "md": 12
            },
            "heights": {
              "xs": "full"
            },
            "widget": {
              "type": "csui/widgets/document.overview",
              "options": {
              }
            }
          }
        ]
      }
    ]
  }
}
);

csui.define('csui/utils/testutils/async.test.utils',['module', 'csui/lib/underscore', 'csui/lib/jquery'], function(module, _, $) {
  function asyncElement(parent, selector, options) {
    var deferred = $.Deferred(), el, intervalRef, newOptions = {};
    if (typeof options === 'number') {
      newOptions.interval = options;
    } else if (typeof options === 'boolean') {
      newOptions.removal = options;
    } else {
      newOptions = options;
    }
    options = _.extend({interval: 50, removal: false, length: 0}, newOptions);
    if (!parent || !selector) {
      console.warn('parent or child selector missing');
      deferred.reject();
    } else {
      el = $(parent).find(selector);
      //options.removal and length checking due to the use case
      //when element adding and removing is chained
      if (options.removal ? el.length === options.length : el.length > options.length) {
        deferred.resolve(el);
      } else {
        intervalRef = setInterval(function () {
          el = $(parent).find(selector);
          if (options.removal ? el.length === options.length : el.length > options.length) {
            clearInterval(intervalRef);
            deferred.resolve(el);
          }
        }, options.interval);
      }
    }
    //no need of deferred.reject if element not found as karma will timeout
    return deferred.promise();
  }
  return {
    asyncElement: asyncElement
  };
});


csui.define('csui/widgets/favorites/toolbaritems',[
  'csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/nls/localized.strings',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/favorites/toolbaritems'
], function (_, publicLang, lang, ToolItemsFactory, TooItemModel, extraToolItems) {
  'use strict';

  var toolbarItems = {
    tableHeaderToolbar: new ToolItemsFactory({
        info: [
          {
            signature: "Properties",
            name: lang.ToolbarItemInfo,
            icon: "icon icon-toolbar-metadata"
          }
        ],
        share: [
          {signature: "CopyLink", name: lang.ToolbarItemCopyLink},
          {
            signature: 'Share',
            name: lang.ToolbarItemShare,
            flyout: 'share',
            group: 'share'
          },
          {
            signature: 'EmailLink',
            name: lang.ToolbarItemEmailLink,
            flyout: 'share',
            promoted: true,
            group: 'share'
          }
        ],
        edit: [
          {signature: "Edit", name: lang.ToolbarItemEdit, flyout: "edit", promoted: true},
          {signature: "EditActiveX", name: "EditActiveX", flyout: "edit"},
          {signature: "EditOfficeOnline", name: "EditOfficeOnline", flyout: "edit"},
          {signature: "EditWebDAV", name: "EditWebDAV", flyout: "edit"}
        ],
        main: [
          {
            signature: "FavoriteRename",
            name: lang.ToolbarItemRename,
            onlyInTouchBrowser: true
          },
          {signature: "permissions", name: lang.ToolbarItemPermissions},
          {signature: "Download", name: lang.ToolbarItemDownload},
          {signature: "ReserveDoc", name: publicLang.ToolbarItemReserve},
          {signature: "UnreserveDoc", name: publicLang.ToolbarItemUnreserve},
          {signature: "Copy", name: lang.ToolbarItemCopy},
          {signature: "Move", name: lang.ToolbarItemMove},
          {signature: "AddVersion", name: lang.ToolbarItemAddVersion}
        ],
        shortcut: [
          {signature: "OriginalCopyLink", name: lang.ToolbarItemOriginalCopyLink},
          {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
          {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
          {signature: "OriginalReserveDoc", name: publicLang.ToolbarItemOriginalReserve},
          {signature: "OriginalUnreserveDoc", name: publicLang.ToolbarItemOriginalUnreserve},
          {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
          {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
          {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
          {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload}
        ]
      },
      {
        maxItemsShown: 15,
        dropDownText: lang.ToolbarItemMore,
        dropDownIcon: "icon icon-toolbar-more",
        addGroupSeparators: false,
        lazyActions:true
      }),

    inlineActionbar: new ToolItemsFactory({
        info: [
          {
            signature: "Properties", name: lang.ToolbarItemInfo,
            icon: "icon icon-toolbar-metadata"
          }
        ],
        share: [
          {
            signature: "CopyLink", name: lang.ToolbarItemCopyLink,
            icon: "icon icon-toolbar-copylink"
          }
        ],
        edit: [
          {signature: "Edit", name: lang.ToolbarItemEdit, icon: "icon icon-toolbar-edit"}
        ],
        other: [
          {signature: "permissions", name: lang.ToolbarItemPermissions, icon: "icon" +
          " icon-toolbar-permissions"},
          {
            signature: "FavoriteRename",
            name: lang.ToolbarItemRenameFavorite,
            icon: "icon icon-toolbar-rename"
          },
          {
            signature: "Download", name: lang.ToolbarItemDownload,
            icon: "icon icon-toolbar-download"
          },
          {
            signature: "ReserveDoc", name: publicLang.ToolbarItemReserve,
            icon: "icon icon-toolbar-reserve"
          },
          {
            signature: "UnreserveDoc",
            name: publicLang.ToolbarItemUnreserve,
            icon: "icon icon-toolbar-unreserve"
          },
          {signature: "Copy", name: lang.ToolbarItemCopy, icon: "icon icon-toolbar-copy"},
          {signature: "Move", name: lang.ToolbarItemMove, icon: "icon icon-toolbar-move"},
          {
            signature: "AddVersion",
            name: lang.ToolbarItemAddVersion,
            icon: "icon icon-toolbar-add-version"
          }
        ]
      },
      {
        maxItemsShown: 5,
        dropDownText: lang.ToolbarItemMore,
        dropDownIcon: "icon icon-toolbar-more",
        addGroupSeparators: false
      }),

    // Menu list for the Item Name's dropdown menu in Properties view
    dropdownMenuListInProperties: new ToolItemsFactory({
        main: [
          {signature: "Properties", name: lang.ToolbarItemInformation},
          {signature: "CopyLink", name: lang.ToolbarItemCopyLink},
          {signature: "Edit", name: lang.ToolbarItemEdit},
          {signature: "EmailLink", name: lang.ToolbarItemShare},
          {signature: "Download", name: lang.ToolbarItemDownload},
          {signature: "ReserveDoc", name: publicLang.ToolbarItemReserve},
          {signature: "UnreserveDoc", name: publicLang.ToolbarItemUnreserve},
          {signature: "Copy", name: lang.ToolbarItemCopy},
          {signature: "Move", name: lang.ToolbarItemMove},
          {signature: "AddVersion", name: lang.ToolbarItemAddVersion},
          {signature: "permissions", name: lang.ToolbarItemPermissions}
        ],
        shortcut: [
          {signature: "OriginalCopyLink", name: lang.ToolbarItemOriginalCopyLink},
          {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
          {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
          {signature: "OriginalReserveDoc", name: publicLang.ToolbarItemOriginalReserve},
          {signature: "OriginalUnreserveDoc", name: publicLang.ToolbarItemOriginalUnreserve},
          {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
          {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
          {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
          {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload}
        ]
      },
      {
        maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
        dropDownIcon: "icon icon-expandArrowDown"
      }
    )

  };

  if (extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar && key === 'otherToolbar') {
          targetToolbar = toolbarItems['tableHeaderToolbar'];
        }
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;
});

csui.define('csui/widgets/favorites/toolbaritems.masks',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask'
], function (module, _, ToolItemMask, GlobalMenuItemsMask) {
  'use strict';

  // Keep the keys in sync with csui/widgets/nodestable/toolbaritems
  var toolbars = ['tableHeaderToolbar', 'inlineActionbar'];

  function ToolbarItemsMasks() {
    var config = module.config(),
        globalMask = new GlobalMenuItemsMask();
    // Create and populate masks for every toolbar
    this.toolbars = _.reduce(toolbars, function (toolbars, toolbar) {
      var mask = new ToolItemMask(globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        source = source[toolbar];
        if (source) {
          mask.extendMask(source);
        }
      });
      // Enable restoring the mask to its initial state
      mask.storeMask();
      toolbars[toolbar] = mask;
      return toolbars;
    }, {});
  }

  ToolbarItemsMasks.toolbars = toolbars;

  return ToolbarItemsMasks;

});


csui.define('csui/widgets/recentlyaccessed/toolbaritems',[
  'csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/nls/localized.strings',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/recentlyaccessed/toolbaritems'
], function (_, publicLang, lang, ToolItemsFactory, TooItemModel, extraToolItems) {
  'use strict';

  var toolbarItems = {

    filterToolbar: new ToolItemsFactory({
      filter: [
        {signature: "Filter", name: lang.ToolbarItemFilter, icon: "icon icon-toolbarFilter"}
      ]
    }, {
      addTrailingDivider: false
    }),
    tableHeaderToolbar: new ToolItemsFactory({
          info: [
            {
              signature: "Properties",
              name: lang.ToolbarItemInfo,
              icon: "icon icon-toolbar-metadata"
            }
          ],
          share: [
            {signature: "CopyLink", name: lang.ToolbarItemCopyLink}
          ],
          edit: [
            {signature: "Edit", name: lang.ToolbarItemEdit, flyout: "edit", promoted: true},
            {signature: "EditActiveX", name: "EditActiveX", flyout: "edit"},
            {signature: "EditOfficeOnline", name: "EditOfficeOnline", flyout: "edit"},
            {signature: "EditWebDAV", name: "EditWebDAV", flyout: "edit"}
          ],
          main: [
            {signature: "permissions", name: lang.ToolbarItemPermissions},
            {signature: "Download", name: lang.ToolbarItemDownload},
            {signature: "ReserveDoc", name: publicLang.ToolbarItemReserve},
            {signature: "UnreserveDoc", name: publicLang.ToolbarItemUnreserve},
            {signature: "Copy", name: lang.ToolbarItemCopy},
            {signature: "Move", name: lang.ToolbarItemMove},
            {signature: "AddVersion", name: lang.ToolbarItemAddVersion}
          ],
          shortcut: [
            {signature: "OriginalCopyLink", name: lang.ToolbarItemOriginalCopyLink},
            {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
            {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
            {signature: "OriginalReserveDoc", name: publicLang.ToolbarItemOriginalReserve},
            {signature: "OriginalUnreserveDoc", name: publicLang.ToolbarItemOriginalUnreserve},
            {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
            {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
            {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
            {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload}
          ]
        },
        {
          maxItemsShown: 5,
          dropDownIcon: "icon icon-toolbar-more",
          addGroupSeparators: false
        }),
    // inline action bar
    inlineActionbar: new ToolItemsFactory({
          info: [
            {
              signature: "Properties", name: lang.ToolbarItemInfo,
              icon: "icon icon-toolbar-metadata"
            }
          ],
          share: [
            {
              signature: "CopyLink", name: lang.ToolbarItemCopyLink,
              icon: "icon icon-toolbar-copylink"
            },
            {
              signature: 'Share',
              name: lang.ToolbarItemShare,
              flyout: 'share',
              group: 'share'
            },
            {
              signature: 'EmailLink',
              name: lang.ToolbarItemEmailLink,
              flyout: 'share',
              promoted: true,
              group: 'share'
            }
          ],
          edit: [
            {signature: "Edit", name: lang.ToolbarItemEdit, icon: "icon icon-toolbar-edit"}
          ],
          other: [
            {signature: "permissions", name: lang.ToolbarItemPermissions, icon: "icon" +
                                                                                " icon-toolbar-permissions"},
            {
              signature: "Download", name: lang.ToolbarItemDownload,
              icon: "icon icon-toolbar-download"
            },
            {
              signature: "ReserveDoc", name: publicLang.ToolbarItemReserve,
              icon: "icon icon-toolbar-reserve"
            },
            {
              signature: "UnreserveDoc",
              name: publicLang.ToolbarItemUnreserve,
              icon: "icon icon-toolbar-unreserve"
            },
            {signature: "Copy", name: lang.ToolbarItemCopy, icon: "icon icon-toolbar-copy"},
            {signature: "Move", name: lang.ToolbarItemMove, icon: "icon icon-toolbar-move"},
            {
              signature: "AddVersion",
              name: lang.ToolbarItemAddVersion,
              icon: "icon icon-toolbar-add-version"
            }
          ]
        },
        {
          maxItemsShown: 5,
          dropDownText: lang.ToolbarItemMore,
          dropDownIcon: "icon icon-toolbar-more",
          addGroupSeparators: false
        }),

    // Menu list for the Item Name's dropdown menu in Properties view
    dropdownMenuListInProperties: new ToolItemsFactory({
          main: [
            {signature: "Properties", name: lang.ToolbarItemInformation},
            {signature: "CopyLink", name: lang.ToolbarItemCopyLink},
            {signature: "Edit", name: lang.ToolbarItemEdit},
            {signature: "EmailLink", name: lang.ToolbarItemShare},
            {signature: "Download", name: lang.ToolbarItemDownload},
            {signature: "ReserveDoc", name: publicLang.ToolbarItemReserve},
            {signature: "UnreserveDoc", name: publicLang.ToolbarItemUnreserve},
            {signature: "Copy", name: lang.ToolbarItemCopy},
            {signature: "Move", name: lang.ToolbarItemMove},
            {signature: "AddVersion", name: lang.ToolbarItemAddVersion}
          ],
          shortcut: [
            {signature: "OriginalCopyLink", name: lang.ToolbarItemOriginalCopyLink},
            {signature: "OriginalEdit", name: lang.ToolbarItemOriginalEdit},
            {signature: "OriginalEmailLink", name: lang.ToolbarItemOriginalShare},
            {signature: "OriginalReserveDoc", name: publicLang.ToolbarItemOriginalReserve},
            {signature: "OriginalUnreserveDoc", name: publicLang.ToolbarItemOriginalUnreserve},
            {signature: "OriginalCopy", name: lang.ToolbarItemOriginalCopy},
            {signature: "OriginalMove", name: lang.ToolbarItemOriginalMove},
            {signature: "OriginalAddVersion", name: lang.ToolbarItemAddVersion},
            {signature: "OriginalDownload", name: lang.ToolbarItemOriginalDownload}
          ]
        },
        {
          maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-expandArrowDown"
        }
    )

  };

  if (extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar && key === 'otherToolbar') {
          targetToolbar = toolbarItems['tableHeaderToolbar'];
        }
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;
});

csui.define('csui/widgets/recentlyaccessed/toolbaritems.masks',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask'
], function (module, _, ToolItemMask, GlobalMenuItemsMask) {
  'use strict';

  // Keep the keys in sync with csui/widgets/nodestable/toolbaritems
  var toolbars = ['tableHeaderToolbar', 'inlineActionbar'];

  function ToolbarItemsMasks() {
    var config = module.config(),
        globalMask = new GlobalMenuItemsMask();
    // Create and populate masks for every toolbar
    this.toolbars = _.reduce(toolbars, function (toolbars, toolbar) {
      var mask = new ToolItemMask(globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        source = source[toolbar];
        if (source) {
          mask.extendMask(source);
        }
      });
      // Enable restoring the mask to its initial state
      mask.storeMask();
      toolbars[toolbar] = mask;
      return toolbars;
    }, {});
  }

  ToolbarItemsMasks.toolbars = toolbars;

  return ToolbarItemsMasks;

});


csui.define('csui/widgets/favorites/tileview.toolbaritems',['csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/recentlyaccessed/tileview.toolbaritems'
], function (_, lang, ToolItemsFactory, TooItemModel, extraToolItems) {
  'use strict';
  var toolbarItems = {

    // inline action bar
    inlineActionbar: new ToolItemsFactory({
          info: [
            {
              signature: "Properties", name: lang.ToolbarItemInfo,
              commandData: {dialogView: true}
            }
          ],
          share: [
            {
              signature: "CopyLink", name: lang.ToolbarItemCopyLink
            },

          ],
          edit: [
            {signature: "Edit", name: lang.ToolbarItemEdit}
          ],
          other: [
            {
              signature: "Download", name: lang.ToolbarItemDownload
            },
            {
              signature: "goToLocation", name: lang.ToolbarGoToLocation
            }
          ]
        },
        {
          maxItemsShown: 1,
          dropDownText: lang.ToolbarItemMore,
          dropDownIcon: "icon icon-toolbar-more"
        })
  };

  if (extraToolItems) {
    addExtraToolItems(extraToolItems);
  }

  function addExtraToolItems(extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;

});

csui.define('csui/widgets/recentlyaccessed/tileview.toolbaritems',['csui/lib/underscore',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/recentlyaccessed/tileview.toolbaritems'
], function (_, lang, ToolItemsFactory, TooItemModel, extraToolItems) {
  'use strict';
  var toolbarItems = {

    // inline action bar
    inlineActionbar: new ToolItemsFactory({
          info: [
            {
              signature: "Properties", name: lang.ToolbarItemInfo,
              commandData: {dialogView: true}
            }
          ],
          share: [
            {
              signature: "CopyLink", name: lang.ToolbarItemCopyLink
            }
          ],
          edit: [
            {signature: "Edit", name: lang.ToolbarItemEdit}
          ],
          other: [
            {
              signature: "Download", name: lang.ToolbarItemDownload
            },
            {signature: "goToLocation", name: lang.ToolbarGoToLocation}
          ]
        },
        {
          maxItemsShown: 1,
          dropDownText: lang.ToolbarItemMore,
          dropDownIcon: "icon icon-toolbar-more"
        })
  };

  if (extraToolItems) {
    addExtraToolItems(extraToolItems);
  }

  function addExtraToolItems(extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorites2.groups.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<button title=\""
    + this.escapeExpression(((helper = (helper = helpers.groupAddButtonTitle || (depth0 != null ? depth0.groupAddButtonTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"groupAddButtonTitle","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.groupAddButtonTitle || (depth0 != null ? depth0.groupAddButtonTitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"groupAddButtonTitle","hash":{}}) : helper)))
    + "\" class=\"binf-btn csui-groups-header-plus\">\r\n  <span class=\"icon icon-toolbarAdd\"></span>\r\n</button><span class=\"csui-groups-header-text\">"
    + this.escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"text","hash":{}}) : helper)))
    + "</span>\r\n<button\r\n    class=\"binf-btn csui-groups-header-edit-mode csui-groups-header-edit-on\">"
    + this.escapeExpression(((helper = (helper = helpers.startEditMode || (depth0 != null ? depth0.startEditMode : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"startEditMode","hash":{}}) : helper)))
    + "</button>\r\n<button\r\n    class=\"binf-btn csui-groups-header-edit-mode csui-groups-header-edit-off\">"
    + this.escapeExpression(((helper = (helper = helpers.endEditMode || (depth0 != null ? depth0.endEditMode : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"endEditMode","hash":{}}) : helper)))
    + "</button>\r\n";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorites2.groups.header', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/favorites/impl/favorites2.groups.header.view',[],function(){});
csui.define('csui/widgets/favorites/impl/favorites2.groups.header.view',["module",
  "csui/lib/marionette",
  'i18n!csui/widgets/favorites/impl/nls/lang',
  'hbs!csui/widgets/favorites/impl/favorites2.groups.header',
  'css!csui/widgets/favorites/impl/favorites2.groups.header.view',
], function (module,
    Marionette,
    lang,
    template
) {
  'use strict';

  var FavoriteGroupsHeaderView = Marionette.ItemView.extend({
    className: 'csui-favorite-groups-header',
    template: template,

    initialize: function (options) {
      this._useEditMode = options && options.useEditMode;
      this._isGroupsEditing = false;
    },

    ui: {
      addButton: '.csui-groups-header-plus',
      editModeOn: '.csui-groups-header-edit-on',
      editModeOff: '.csui-groups-header-edit-off'
    },

    events: {
      'click @ui.addButton': '_addItem',
      'click @ui.editModeOn': '_switchEditModeOn',
      'click @ui.editModeOff': '_switchEditModeOff'
    },

    templateHelpers: function () {
      return {
        groupAddButtonTitle: lang.groupAddButtonTitle,
        text: lang.groupAdd,
        startEditMode: lang.startEditMode,
        endEditMode: lang.endEditMode,
        hasEditModeSwitch: this._useEditMode
      };
    },

    _addItem: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.triggerMethod('add:item');
    },

    _switchEditModeOn: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.triggerMethod('toggleEditMode:on');
    },

    _switchEditModeOff: function (event) {
      event.preventDefault();
      event.stopPropagation();
      this.triggerMethod('toggleEditMode:off');
    },

    isAddEnabled: function (enable) {
      if (enable !== undefined) {
        this._isAddEnabled = enable;
        if (enable) {
          this.ui.addButton.removeClass('binf-disabled');
        } else {
          this.ui.addButton.addClass('binf-disabled');
        }
      }
      return !!this._isAddEnabled;
    }
  });

  return FavoriteGroupsHeaderView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorites2.group',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    var helper;

  return "  <input type=\"text\" value=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\" placeholder=\""
    + this.escapeExpression(((helper = (helper = helpers.namePlaceholder || (depth0 != null ? depth0.namePlaceholder : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"namePlaceholder","hash":{}}) : helper)))
    + "\"\r\n         class=\"binf-flex-row binf-form-control csui-favorite-group-input-name\">\r\n  <button type=\"button\" class=\"binf-flex csui-btn-edit-cancel binf-btn\">\r\n    <span class=\"icon edit-cancel\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.EditCancelTooltip || (depth0 != null ? depth0.EditCancelTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditCancelTooltip","hash":{}}) : helper)))
    + "\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.EditCancelAria || (depth0 != null ? depth0.EditCancelAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditCancelAria","hash":{}}) : helper)))
    + "\"></span>\r\n  </button>\r\n";
},"3":function(depth0,helpers,partials,data) {
    var helper;

  return "  <div class=\"csui-favorite-group-selection-marker\"></div>\r\n  <div class=\"csui-favorite-group-draggable-handle\">\r\n    <span class=\" icon icon-draggable-handle\"></span>\r\n  </div>\r\n  <a role=\"button\" href=\"#\" class=\"binf-flex-row csui-favorite-group-name-link\" aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.groupNameAria || (depth0 != null ? depth0.groupNameAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"groupNameAria","hash":{}}) : helper)))
    + "\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "\"\r\n     tabindex=\""
    + this.escapeExpression(((helper = (helper = helpers.tabindex || (depth0 != null ? depth0.tabindex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"tabindex","hash":{}}) : helper)))
    + "\">\r\n    <span class=\"csui-favorite-group-name\">"
    + this.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"name","hash":{}}) : helper)))
    + "</span>\r\n  </a>\r\n  <button type=\"button\" class=\"binf-btn csui-btn-action csui-btn-edit-start\"\r\n          aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.EditStartAria || (depth0 != null ? depth0.EditStartAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditStartAria","hash":{}}) : helper)))
    + "\" tabindex=\""
    + this.escapeExpression(((helper = (helper = helpers.tabindex || (depth0 != null ? depth0.tabindex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"tabindex","hash":{}}) : helper)))
    + "\">\r\n    <span class=\"icon icon-edit\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.EditStartTooltip || (depth0 != null ? depth0.EditStartTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"EditStartTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n  </button>\r\n  <button type=\"button\" class=\"binf-btn csui-btn-action csui-btn-delete\"\r\n          aria-label=\""
    + this.escapeExpression(((helper = (helper = helpers.DeleteAria || (depth0 != null ? depth0.DeleteAria : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"DeleteAria","hash":{}}) : helper)))
    + "\" tabindex=\""
    + this.escapeExpression(((helper = (helper = helpers.tabindex || (depth0 != null ? depth0.tabindex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"tabindex","hash":{}}) : helper)))
    + "\">\r\n    <span class=\"icon icon-circle-close\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.DeleteTooltip || (depth0 != null ? depth0.DeleteTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"DeleteTooltip","hash":{}}) : helper)))
    + "\"></span>\r\n  </button><span class=\"csui-favorite-group-arrow-overlay\"></span>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.isRename : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.program(3, data, 0)})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorites2.group', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/favorites/impl/favorites2.groups.view',[],function(){});
csui.define('csui/widgets/favorites/impl/favorites2.group.view',["module",
  "csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/marionette",
  'csui/lib/hammer',
  "csui/utils/log",
  'csui/utils/base',
  'csui/dialogs/modal.alert/modal.alert',
  'hbs!csui/widgets/favorites/impl/favorites2.group',
  'i18n!csui/widgets/favorites/impl/nls/lang',
  'css!csui/widgets/favorites/impl/favorites2.groups.view',
], function (module, $, _, Marionette, Hammer, log, base,
    ModalAlertView,
    template,
    lang) {
  'use strict';

  var FavoriteGroupView = Marionette.ItemView.extend({
    className: 'csui-favorite-group',
    template: template,
    tagName: 'li',

    initialize: function (options) {
      this.parent = options.parent;
      this.groupsView = options.groupsView;
      this._dragData = options.dragData;
      this._useEditMode = options.useEditMode;
      this._dragAndDropEnabled = options.dragAndDropEnabled;
    },

    ui: {
      groupNameButton: '.csui-favorite-group-name-link',
      nameInput: '.csui-favorite-group-input-name',
      cancelButton: '.csui-btn-edit-cancel',
      startEditButton: '.csui-btn-edit-start',
      deleteButton: '.csui-btn-delete'
    },

    templateHelpers: function () {
      var name = this.model.get('name');
      return {
        tabindex: this.model.get('isTabable') && !this._isReadonly() ? '0' : '-1',
        isRename: this.model.get('isRename'),
        name: name,
        groupNameAria: name == lang.fav_ungrouped ? lang.fav_ungroupedAria :
                       _.str.sformat(lang.favoritesGroupAria, name),
        namePlaceholder: lang.addFavoriteNamePlaceHolder,
        EditCancelTooltip: lang.addFavoriteCancelButtonLabel,
        EditCancelAria: lang.addFavoriteCancelButtonAria,
        EditStartTooltip: lang.editGroupButtonLabel,
        EditStartAria: lang.editGroupButtonAria,
        DeleteTooltip: lang.deleteGroupButtonLabel,
        DeleteAria: lang.deleteGroupButtonAria
      };
    },

    modelEvents: {
      "change": "render"
    },

    onRender: function () {
      var groupClasses = this.className;
      if (this.model.get('isSelected')) {
        groupClasses += ' binf-active';
      }

      var isSingleGroupEditing = this.model.get('isSingleGroupEditing');
      var isRename = this.model.get('isRename');
      if (isRename) {
        groupClasses += ' csui-favorite-group-rename';
      }
      var isReadonly = this._isReadonly();
      if (isReadonly) {
        groupClasses += ' csui-favorite-group-readonly';
      }

      if (this.dragStarted) {
        groupClasses += ' csui-dragstarted';
      }

      // todo: remove || this._useEditMode when drag&drop on touch devices is implemented
      var draggable = !(isReadonly || isRename || isSingleGroupEditing || this._useEditMode ||
                        this.dragStarted || !this._dragAndDropEnabled);

      this.$el.attr('draggable', draggable);
      this.$el.find('a.csui-favorite-group-name-link').attr('draggable', draggable);

      this.$el.attr('class', groupClasses); // replace all classes

      if (this._useEditMode && !isReadonly && !isRename) {
        this._assignTouchControl();
      }

      if (this.model.isNew() && this.model.get('isRename')) {
        this._startEditing();
      } else {
        // this._setFocus();
      }

    },

    onDomRefresh: function () {
      if (this.model.isNew() || this.model.get('isRename')) {
        this.ui.nameInput.focus();
      } else {
        if (this._hasFocus && this.isRendered) {
          // need the hack with setTimeout here, because other view gets the focus due to
          // tabable region behavior, which is not used here
          var self = this;
          setTimeout(function () {
            if (self.isRendered) {
              self._setFocus();
            }
          }, 100);
        }
      }
    },

    onDestroy: function () {
      if (this.hammer) {
        this.hammer.destroy();
      }
    },

    _startDragOperation: function () {
      this._dragData.clear();
      var tab_id = this.model.get('tab_id');
      if (tab_id !== -1) {
        this._dragData.set('groupId', tab_id);
        this.dragStarted = true;
        return true;
      } else {
        return false;
      }
    },

    _stopDragOperation: function () {
      this.dragStarted = false;
      this._dragData.clear();
      this._removeDragline();
      this._removeDragStarted();
    },

    _moveItemsToThisGroup: function () {
      var args;

      var tab_id = this.model.get('tab_id');
      if (tab_id === undefined) {
        return; // do not allow to move items into unsaved group
      }
      var isGroupsEditing = this.model.get('isGroupsEditing');

      // allow dropping favorites only if not in groups-editing mode
      if (!isGroupsEditing && this._dragData.get('favorites') &&
          this._dragData.get('favorites').length && this._dragData.get('groupId') !== undefined) {
        args = {
          idSources: this._dragData.get('favorites'),
          tabIdSource: this._dragData.get('groupId'),
          tabIdDestination: tab_id
        };
        this.trigger('dropped:favorite', args);
        return args.savePromise;
      } else if (this._dragData.get('groupId') !== undefined) {
        args = {
          tabIdSource: this._dragData.get('groupId'),
          tabIdDestination: tab_id,
          dropAfter: this._dropAfter
        };
        this.trigger('group:dropped', args);
        return args.savePromise;
      } else {
        var deferred = $.Deferred();
        deferred.reject();
        return deferred.promise();
      }
    },

    _selectThisGroup: function () {
      var args = {groupModel: this.model};
      this.triggerMethod("before:group:selected", args);
      if (!args.cancel) {
        this.triggerMethod("group:selected", args);
      }
    },

    _isReadonly: function () {
      var isReadonly = this.model.get('tab_id') === -1 || this.model.get('isReadonly');
      return isReadonly;
    },

    events: {
      'click @ui.cancelButton': function (event) {
        event.preventDefault();
        event.stopPropagation();

        this._cancelEdit();
      },

      'click @ui.startEditButton': function (event) {
        event.preventDefault();
        event.stopPropagation();
        this._startEditing();
      },

      'click @ui.deleteButton': function (event) {
        event.preventDefault();
        event.stopPropagation();
        var self = this;
        ModalAlertView.confirmQuestion(lang.deleteGroupConfirmatonText,
            lang.deleteGroupConfirmatonTitle, {buttons: ModalAlertView.OkCancel})
            .fail(function () {
              self._setFocus();
            })
            .done(function (arg) {
              self.triggerMethod('group:delete', {model: self.model});
            });
      },

      'focus @ui.groupNameButton': function (event) {
        this._hasFocus = true;
        this.trigger('group:focused');
      },

      'focus @ui.startEditButton': function (event) {
        this._hasStartEditButtonFocus = true;
      },

      'focusout @ui.startEditButton': function (event) {
        this._hasStartEditButtonFocus = false;
      },

      'focus @ui.deleteButton': function (event) {
        this._hasDeleteButtonFocus = true;
      },

      'focusout @ui.deleteButton': function (event) {
        this._hasDeleteButtonFocus = false;
      },

      // Must be keydown. When using keyup it'll catch Enter event when hitting enter on focused
      // edit button, which closes the edit box immediately after opening it (when using enter-key).
      'keydown @ui.nameInput': function (event) {
        switch (event.keyCode) {
        case 13:
          event.preventDefault();
          event.stopPropagation();

          this._save();
          break;
        case 27:
          // ESC key

          event.preventDefault();
          event.stopPropagation();

          this._cancelEdit();
          break;
        }

      },

      // Must be keydown to work correctly. Keypress does not catch the cursor left/right keys.
      'keydown': function (event) {
        var id = this.model.get('tab_id');
        var isRename = this.model.get('isRename');
        var isMac = base.isMacintosh();

        switch (event.keyCode) {
        case 88:
          if (isMac && event.metaKey && !event.ctrlKey || !isMac && !event.metaKey &&
              event.ctrlKey) {

            // control-X or command-X (MacOS)

            event.preventDefault();
            event.stopPropagation();

            // dragData without favorites means that a group should be moved instead of favorites
            this._dragData.unset('favorites');
            if (id === -1) {
              // moving the ungrouped group is not allowed
              this._dragData.unset('favorites');
            } else {
              this._dragData.set({groupId: id});
            }

          }
          break;
        case 86:
          if (isMac && event.metaKey && !event.ctrlKey || !isMac && !event.metaKey &&
              event.ctrlKey) {

            // control-V or command-V (MacOS)

            event.preventDefault();
            event.stopPropagation();

            var dragSourceGroupId = this._dragData.get('groupId');
            if (id === dragSourceGroupId) {
              // ignore moving the favorites into the same group
              return;
            }

            this._dropAfter = false;

            var self = this;
            this._moveItemsToThisGroup().then(function () {
              self._selectThisGroup();
            });
          }
          break;
        case 37:
          // left cursor key
          if (this._hasFocus && !isRename) {
            if (this._hasStartEditButtonFocus) {
              event.preventDefault();
              event.stopPropagation();
              this.ui.groupNameButton.focus();
            } else {
              if (this._hasDeleteButtonFocus) {
                event.preventDefault();
                event.stopPropagation();
                this.ui.startEditButton.focus();
              }
            }
          }
          break;
        case 39:
          // right cursor key
          if (this._hasFocus && !isRename) {
            if (this._hasStartEditButtonFocus) {
              event.preventDefault();
              event.stopPropagation();
              this.ui.deleteButton.focus();
            } else {
              if (!this._hasDeleteButtonFocus) {
                event.preventDefault();
                event.stopPropagation();
                this.ui.startEditButton.focus();
              }
            }
          }
          break;
        }
      },

      'click': function (event) {
        if (!event.ctrlKey) { // don't handle ctrl-Enter (Enter also triggers 'click')

          event.preventDefault();

          // don't handle clicking the group when it's a newly created one
          // also don't handle clicking the group when it is in edit mode
          if (this.model.isNew() || this.model.get('isRename') ||
              this.model.get('isGroupsEditing')) {
            return;
          }
          this._selectThisGroup();
        }
      },
      'dragstart': function (event) {
        // fired on the source element
        if (this._startDragOperation()) {
          // must setData otherwise Firefox for example does not start drag&drop operation
          event.originalEvent.dataTransfer.setData('text', '');
        }
      },
      'dragover': function (event) {
        // fired on the target element

        if (this.dragStarted) {
          return; // don't allow dropping to the same element
        }

        var tab_id = this.model.get('tab_id');
        if (tab_id === undefined) {
          return; // don't allow dropping to a group that is about to be created but not saved yet
        }

        // drag source is a favorite group -> display insert lines for reordering of groups
        if (!this._dragData.get('favorites') || this._dragData.get('favorites').length === 0) {

          // remove any other dragline if it was not created by this group view
          // remove any dragline if  there was one before at the other side
          // add new dragline if there was none before or at the other side

          var h = this.$el.height();
          var targetTabId = this.model.get('tab_id');
          var dropAfter = event.offsetY > (h / 2);
          if (this._moveNotPossible(this.model.collection, this._dragData.get('groupId'),
              targetTabId,
              dropAfter)) {
            // dropping here should not be possible, because it would get the same position
            this._removeDragline();
            this._dropAfter = undefined;
            event.preventDefault();
          } else {
            if (dropAfter) {
              // do not allow dropping below "Ungrouped" group
              if (targetTabId === -1) {
                this._removeDragline();
                this._dropAfter = undefined;
              } else {
                if (this._dropAfter === undefined || this._dropAfter === false) {
                  this._removeDragline();
                  this.$el.after('<div class="csui-favorite-group csui-dragline">');
                  this._dropAfter = true;
                }
                event.preventDefault();
              }
            } else {
              if (this._dropAfter === undefined || this._dropAfter === true) {
                this._removeDragline();
                this.$el.before('<div class="csui-favorite-group csui-dragline">');
                this._dropAfter = false;
              }
              event.preventDefault();
            }
          }
        } else {
          if (this._dragData.get('favorites') && this._dragData.get('favorites').length) {
            // drag source is favorite items from table -> move favorites to group -> mark group
            // as possible drop target

            if (this._dragData.get('groupId') === tab_id) {
              // don't enable as drop target if favorite moved into same group
              return;
            }
            this.$el.addClass('csui-dragover');

            event.preventDefault();
          }
        }
      },
      'drop': function (event) {
        // fired on the target element

        this.$el.removeClass('csui-dragover');

        event.preventDefault();
        this._moveItemsToThisGroup();
        this._removeDragline();
      },
      'dragleave': function (event) {
        // fired on the target element
        this._removeDragline();
        this.$el.removeClass('csui-dragover');
      },
      'dragend': function (event) {
        // fired on the source element
        event.preventDefault();
        this._stopDragOperation();
      }
    },

    _cancelEdit: function () {
      if (this.model.isNew()) {
        this.triggerMethod('group:delete', {model: this.model});
      } else {
        // stop edit mode and render again with original name
        this.model.set('isRename', false);
        this.trigger('group:finished:editing');
      }
    },

    _moveNotPossible: function (collection, idSource, idDestination, moveAfterDestination) {
      var args = {
        idSource: idSource,
        idDestination: idDestination,
        moveAfterDestination: moveAfterDestination
      };
      this.trigger('group:before:dropped', args);
      return args.cancel;
    },

    _setFocus: function () {
      if (this.ui.groupNameButton.length > 0) {
        this.ui.groupNameButton.focus();
      }
    },

    _assignTouchControl: function () {
      this.hammer && this.hammer.destroy();

      var isGroupsEditing = this.model.get('isGroupsEditing');

      // enable long press only if global edit mode is not enabled
      if (this.$el.length > 0 && !isGroupsEditing) {

        this.hammer = new Hammer.Manager(this.$el[0]);

        // this.hammer.remove('rotate');
        // this.hammer.remove('pinch');
        // this.hammer.remove('pan');
        // this.hammer.remove('swipe');

        var press = new Hammer.Press({time: 500});
        this.hammer.add([press]);

        this.hammer.on('press', _.bind(this._onPress, this));
      }
    },

    _onPress: function () {
      this._startEditing();
    },

    _startEditing: function () {
      this.model.set('isRename', true);
      this.trigger('group:editing', {model: this.model});
    },

    _save: function () {
      var name = this.ui.nameInput.val();
      if (name) {
        this.model.set('name', name);
        this.triggerMethod('group:changed', {model: this.model});
      }
    },

    _removeDragline: function () {
      this.parent.$el.find('.csui-favorite-group.csui-dragline').remove();
      delete this._dropAfter;
    },

    _removeDragStarted: function () {
      this.parent.$el.find('.csui-dragstarted').removeClass('csui-dragstarted');
    }
  });

  return FavoriteGroupView;
});


csui.define('css!csui/widgets/favorites/impl/favorites2.groups.rows.view',[],function(){});
csui.define('csui/widgets/favorites/impl/favorites2.groups.rows.view',["module",
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/widgets/favorites/impl/favorites2.group.view',
  'css!csui/widgets/favorites/impl/favorites2.groups.rows.view'
], function (module,
    $,
    Marionette,
    FavoriteGroupView
) {
  'use strict';

  var FavoriteGroupsRowsView = Marionette.CollectionView.extend({
    className: 'csui-favorite-groups-rows',
    tagName: 'ul',
    childView: FavoriteGroupView,
    childViewOptions: function () {
      return {
        parent: this,
        groupsView: this.options.parent,
        groupsViewStateModel: this.options.groupsViewStateModel,
        dragData: this.options.dragData,
        useEditMode: this._useEditMode,
        dragAndDropEnabled: this.options.dragAndDropEnabled
      };
    },
    initialize: function (options) {
      this._useEditMode = options && options.useEditMode;
    },
    events: {
      'focusout': function (event) {
        // detect if the whole list lost the focus
        if (event.relatedTarget) {
          if ($.contains(this.el, event.relatedTarget) == false) {
            // focus out of this view
            this.trigger('groups:focusout');
          }
        }
      }
    }
  });

  return FavoriteGroupsRowsView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorites2.groups.footer',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(depth0,helpers,partials,data) {
    return "    <p class=\"csui-groups-footer-text\">"
    + this.escapeExpression(this.lambda(depth0, depth0))
    + "</p>\r\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"csui-groups-footer-wrapper binf-hidden\">\r\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.texts : depth0),{"name":"each","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop})) != null ? stack1 : "")
    + "</div>";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorites2.groups.footer', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/favorites/impl/favorites2.groups.footer.view',[],function(){});
csui.define('csui/widgets/favorites/impl/favorites2.groups.footer.view',["module",
  "csui/lib/marionette",
  'csui/utils/contexts/factories/favorite2groups',
  'i18n!csui/widgets/favorites/impl/nls/lang',
  'hbs!csui/widgets/favorites/impl/favorites2.groups.footer',
  'css!csui/widgets/favorites/impl/favorites2.groups.footer.view'
], function (module,
    Marionette,
    Favorite2GroupsCollectionFactory,
    lang,
    template
) {
  'use strict';

  var FavoriteGroupsFooterView = Marionette.ItemView.extend({
    className: 'csui-favorite-groups-footer',
    template: template,
    initialize: function () {
      this.groups = this.options.groups ||
                    this.context.getCollection(Favorite2GroupsCollectionFactory,
                        {detached: true, permanent: true}
                    );
      this.listenTo(this.groups, 'reset', this._groupsChanged);
      this.listenTo(this.groups, 'update', this._groupsChanged);
      // this.listenTo(this, 'render', this._groupsChanged);
    },

    templateHelpers: function () {
      return {
        texts: [lang.groupHint1, lang.groupHint2]
      };
    },

    _groupsChanged: function () {
      if (this.groups.length > 1) {
        this.$el.find('.csui-groups-footer-wrapper').addClass('binf-hidden');
      } else {
        this.$el.find('.csui-groups-footer-wrapper').removeClass('binf-hidden');
      }
    }
  });

  return FavoriteGroupsFooterView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorites2.groups',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-favorite-groups-header-region\"></div>\r\n<div class=\"csui-favorite-groups-rows-region binf-flex-column\"></div>\r\n<div class=\"csui-favorite-groups-footer-region\"></div>";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorites2.groups', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/favorites/impl/favorites2.groups.view',["module",
  "csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/backbone",
  "csui/lib/marionette",
  "csui/utils/log",
  'csui/utils/base',
  "csui/controls/tile/behaviors/perfect.scrolling.behavior",
  'csui/controls/globalmessage/globalmessage',
  'csui/utils/contexts/factories/favorite2groups',
  'csui/models/favorite2group',
  'csui/widgets/favorites/impl/favorites2.groups.header.view',
  'csui/widgets/favorites/impl/favorites2.groups.rows.view',
  'csui/widgets/favorites/impl/favorites2.groups.footer.view',
  "csui/controls/progressblocker/blocker",
  'i18n!csui/widgets/favorites/impl/nls/lang',
  'hbs!csui/widgets/favorites/impl/favorites2.groups',
  'css!csui/widgets/favorites/impl/favorites2.groups.view',
], function (module,
    $,
    _,
    Backbone,
    Marionette,
    log,
    base,
    PerfectScrollingBehavior,
    GlobalMessage,
    Favorite2GroupsCollectionFactory,
    Favorite2GroupModel,
    FavoriteGroupsHeaderView,
    FavoriteGroupsRowsView,
    FavoriteGroupsFooterView,
    BlockingView,
    lang,
    template
) {
  'use strict';

  var FavoriteGroupsView = Marionette.LayoutView.extend({

    className: 'csui-favorite-groups',
    template: template,

    ui: {
      // tableView: '.csui-table-view'
    },

    regions: {
      headerRegion: '.csui-favorite-groups-header-region',
      rowsRegion: '.csui-favorite-groups-rows-region',
      footerRegion: '.csui-favorite-groups-footer-region'
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.csui-favorite-groups-rows',
        suppressScrollX: true
      }
    },

    constructor: function FavoriteGroupsView(options) {
      options || (options = {});

      var config = module.config();
      // first use values from options and then fill undefined from module config and if still
      // not defined use hardcoded values
      _.defaults(options, {});

      FavoriteGroupsView.__super__.constructor.call(this, options);

      if (this.options.blockingParentView) {
        BlockingView.delegate(this, this.options.blockingParentView);
      } else {
        BlockingView.imbue(this);
      }

      // this.propagateEventsToRegions();  // propagate dom:refresh to child views
    },

    initialize: function () {
      var self = this;
      this.collection = this.options.collection ||
                        this.context.getCollection(Favorite2GroupsCollectionFactory,
                            {detached: true, permanent: true}
                        );

      this._useEditMode = base.isTouchBrowser();
      this._isSingleGroupEditing = false; // true if a single group is being renamed/edited
      this._isGroupsEditing = false; // only used for touch browsers

      this._dragData = this.options.dragData;

      if (this.options.collection) {
        this.collection.fetched = false;
      }

      this.listenTo(this.collection, 'reset', function () {
        // initialize all groups to be not tabable, except the first one
        this.collection.each(function (groupModel, index) {
          if (index > 0) {
            groupModel.set('isTabable', false);
          } else {
            groupModel.set('isTabable', true);  // only the first item is tabable
          }
        });
      });

      this.headerView = new FavoriteGroupsHeaderView({useEditMode: this._useEditMode});
      this.rowsView = new FavoriteGroupsRowsView({
        dragData: this._dragData,
        parent: this,
        collection: this.collection,
        sort: true,
        useEditMode: this._useEditMode,
        dragAndDropEnabled: this.options.dragAndDropEnabled
      });
      this.footerView = new FavoriteGroupsFooterView({groups: this.collection});

      this.listenTo(this.rowsView, 'childview:group:focused', function (childView) {
        this._setFocusAtView(childView);
      });
      this.listenTo(this.rowsView, 'groups:focusout', function () {
        this.$el.find('.csui-favorite-group.csui-in-focus').removeClass('csui-in-focus');
        this.$el.removeClass('csui-favorite-groups-has-group-in-focus');
        this.rowsView.children.each(function (aChildView) {
          delete aChildView._hasFocus;
        });
        // delete this._focusedModelIndex;
      });
      this.listenTo(this.rowsView, 'childview:before:group:selected', function (childView, args) {
        if (this._isSingleGroupEditing) {
          args.cancel = true; // inform caller to stop the selection
        } else {
          this.triggerMethod('before:group:selected', childView);
        }
      });
      this.listenTo(this.rowsView, 'childview:group:selected', function (childView, args) {
        if (this._modelOfNewlySelectedGroup(childView)) {
          this.triggerMethod('group:selected', childView);
          this.selectGroup(childView);
          this._tryReSetFocus();
        }
      });
      this.listenTo(this.rowsView, 'childview:group:before:dropped', function (childView, args) {
        if (this._checkMoveNotPossible(args.idSource, args.idDestination,
            args.moveAfterDestination)) {
          args.cancel = true; // tell sender that move won't be performed
        }
      });
      this.listenTo(this.rowsView, 'childview:group:dropped', function (childView, args) {
        this.triggerMethod('group:dropped', args);
      });
      this.listenTo(this.rowsView, 'childview:dropped:favorite', function (childView, args) {
        this.triggerMethod('dropped:favorite', args);
      });
      this.listenTo(this.rowsView, 'childview:group:editing', function (childView, args) {
        this._setSingleGroupEditingMode(childView);
      });
      this.listenTo(this.rowsView, 'childview:group:changed', function (childView, args) {
        var model = args.model;
        this._saveGroup(model);
        this._setSingleGroupEditingMode(false);
        this._setGroupsEditingMode(false);
        this._tryReSetFocus();
      });
      this.listenTo(this.rowsView, 'childview:group:delete', function (childView, args) {
        var model = args.model;
        if (model.isNew()) {
          model.destroy();  // destroy of a not saved model does not return a promise
          self._setSingleGroupEditingMode(false);
          self._setGroupsEditingMode(false);
          self.triggerMethod('group:deleted', model);
        } else {
          // called when a existing group should be deleted
          model.destroy({wait: true}).then(function () {
            self._setSingleGroupEditingMode(false);
            self._setGroupsEditingMode(false);
            self.triggerMethod('group:deleted', model);
          });
        }
        this._tryReSetFocus();
      });
      this.listenTo(this.rowsView, 'childview:group:finished:editing', function () {
        this._setSingleGroupEditingMode(false);
      });

      // listen for add at the header view

      this.listenTo(this.headerView, 'add:item', function (args) {
        if (!this._isSingleGroupEditing) {
          this._isSingleGroupEditing = true;
          this.headerView.isAddEnabled(false);

          var newGroup = new Favorite2GroupModel({
            "name": "", // start with empty name
            "order": 1,  // put it at first position
            "isRename": true
          }, {connector: this.collection.connector});

          this.collection.add(newGroup, {at: 0});
        }
      });

      this.listenTo(this.headerView, 'toggleEditMode:on', function () {
        this._setGroupsEditingMode(true);
      });

      this.listenTo(this.headerView, 'toggleEditMode:off', function () {
        // if there is any group editing, call save at the view to initiate saving
        if (this._editingView) {
          this._editingView._save();  // this comes back in handler for 'childview:group:changed'
          this._setSingleGroupEditingMode(false);
        } else {
          this._setGroupsEditingMode(false);
        }
      });
    },

    events: {
      'keydown': function (event) {
        var currentGroup;
        switch (event.keyCode) {

        case 38:
          // cursor UP key

          event.preventDefault();
          event.stopPropagation();

          if (!this._isSingleGroupEditing && this._focusedModelIndex !== undefined) {
            if (this._focusedModelIndex > 0) {
              currentGroup = this.collection.at(this._focusedModelIndex);
              var prevGroup = this.collection.at(this._focusedModelIndex - 1);

              var prevView = this.rowsView.children.findByModel(prevGroup);
              // this.listenToOnce(prevView, 'render', function(){
              //   prevView._setFocus();
              // });
              this._setFocusAtView(prevView);
              currentGroup.set('isTabable', false);
              prevGroup.set('isTabable', true);
            }
          }
          break;
        case 40:
          // cursor DOWN key

          event.preventDefault();
          event.stopPropagation();

          if (!this._isSingleGroupEditing && this._focusedModelIndex !== undefined) {
            if (this._focusedModelIndex < this.collection.length - 1) {
              currentGroup = this.collection.at(this._focusedModelIndex);
              var nextGroup = this.collection.at(this._focusedModelIndex + 1);

              var nextView = this.rowsView.children.findByModel(nextGroup);
              // this.listenToOnce(nextView, 'render', function(){
              //   nextView._setFocus();
              // });
              this._setFocusAtView(nextView);
              currentGroup.set('isTabable', false);
              nextGroup.set('isTabable', true);
            }
          }
          break;
        }
      }
    },

    onRender: function () {
      this._updateGroupsCssClasses();
      this.headerRegion.show(this.headerView);
      this.rowsRegion.show(this.rowsView);
      this.$el.find('.csui-favorite-groups-rows-region').attr('role', 'navigation').attr(
          'aria-label', lang.favoriteGroupsNavAria);
      this.footerRegion.show(this.footerView);
    },

    onBeforeDestroy: function () {
      // remove the unsaved group model before closing the view to not have the unsaved item in
      // the collection remaining and shows up in the little favorite tile
      if (this._isSingleGroupEditing) {
        if (this._editingView.model.isNew()) {
          this._editingView.model.destroy();
        }
      }
    },

    _setFocusAtView: function (childView) {
      // remove old focus markers
      this.rowsView.children.each(function (aChildView) {
        if (aChildView.cid !== childView.cid) {
          delete aChildView._hasFocus;
          aChildView.$el.removeClass('csui-in-focus');
        }
      });
      childView._hasFocus = true;
      childView.$el.addClass('csui-in-focus');

      this.$el.addClass('csui-favorite-groups-has-group-in-focus');
      this._focusedModelIndex = this.collection.indexOf(childView.model);
    },

    _setFocusedByIndex: function (groupToFocusIndex) {
      var focusedModel = this.rowsView.collection.at(groupToFocusIndex);
      var focusedView = this.rowsView.children.findByModel(focusedModel);
      this._setFocusAtView(focusedView);
    },

    _tryReSetFocus: function () {
      if (!this._isSingleGroupEditing && this._focusedModelIndex !== undefined) {
        var model = this.collection.at(this._focusedModelIndex);
        if (model) {
          var focusedView = this.rowsView.children.findByModel(model);
          if (focusedView) {
            focusedView._setFocus();
          }
        }
      }
    },

    _setGroupsEditingMode: function (on) {
      var isGroupsEditing = this._isGroupsEditing = on;
      this._updateGroupsCssClasses();
      this.collection.each(function (groupModel) {
        groupModel.set('isGroupsEditing', isGroupsEditing);
      });
      // this is mainly for informing table view to prevent drag&drop while group editing is on
      this.triggerMethod("group:any:editing", {on: on});
    },

    _setSingleGroupEditingMode: function (view) {
      var args;
      if (view) {
        this._isSingleGroupEditing = true;
        this._editingView = view;
        this.headerView.isAddEnabled(false);
        args = {on: true, groupModel: view.model};
      } else {
        this._editingView = undefined;
        this._isSingleGroupEditing = false;
        this.headerView.isAddEnabled(true);
        args = {on: false};
      }
      var isSingleGroupEditing = this._isSingleGroupEditing;
      this._updateGroupsCssClasses();

      this.collection.each(function (groupModel) {
        groupModel.set('isSingleGroupEditing', isSingleGroupEditing);
      });
      // this is for informing table view to prevent drag&drop while group editing is on
      this.triggerMethod("group:any:editing", args);
    },

    _updateGroupsCssClasses: function () {
      if (this._useEditMode) {
        this.$el.addClass('csui-favorite-groups-has-groups-editing');
      }
      if (this._isSingleGroupEditing || this._isGroupsEditing) {
        this.$el.removeClass('csui-favorite-groups-editing-none');
        this.$el.addClass('csui-favorite-groups-editing-any');
      } else {
        this.$el.addClass('csui-favorite-groups-editing-none');
        this.$el.removeClass('csui-favorite-groups-editing-any');
      }
      if (this._isSingleGroupEditing && !this._isGroupsEditing) {
        this.$el.addClass('csui-favorite-single-group-editing');
      } else {
        this.$el.removeClass('csui-favorite-single-group-editing');
      }
      if (!this._isSingleGroupEditing && this._isGroupsEditing) {
        this.$el.addClass('csui-favorite-groups-editing');
      } else {
        this.$el.removeClass('csui-favorite-groups-editing');
      }
    },

    _checkMoveNotPossible: function (idSource, idDestination, moveAfterDestination) {
      var modelSource = this.collection.get(idSource);
      var modelDestination = this.collection.get(idDestination);
      var sourceIndex = this.collection.indexOf(modelSource);
      var targetIndex = this.collection.indexOf(modelDestination);
      if (sourceIndex < targetIndex) {
        targetIndex = targetIndex - 1;
      }
      if (moveAfterDestination) {
        targetIndex = targetIndex + 1;
      }
      return sourceIndex === targetIndex;
    },

    _modelOfNewlySelectedGroup: function (newlySelectedGroup) {
      var newlySelectedGroupModel;
      if (newlySelectedGroup instanceof Backbone.Model) {
        newlySelectedGroupModel = newlySelectedGroup;
      } else {
        if (newlySelectedGroup instanceof Backbone.View) {
          newlySelectedGroupModel = newlySelectedGroup.model;
        }
      }

      // return undefined if nothing changed
      if (!newlySelectedGroupModel ||
          (this.selectedGroup &&
           newlySelectedGroupModel.get('tab_id') == this.selectedGroup.get('tab_id'))) {
        return undefined;
      } else {
        return newlySelectedGroupModel;
      }
    },

    selectGroup: function (group) {
      var newlySelectedGroupModel = this._modelOfNewlySelectedGroup(group);
      if (!newlySelectedGroupModel) {
        return;
      }

      if (this.selectedGroup) {
        this.selectedGroup.set('isSelected', false);
      }
      newlySelectedGroupModel.set('isSelected', true);
      this.selectedGroup = newlySelectedGroupModel;
    },

    _endEditing: function (model) {
      if (!model.isNew()) {
        model.set({'isRename': false}); // let the UI update
      }
      this._setSingleGroupEditingMode(false);
    },

    _saveGroup: function (model) {
      var self = this;

      model.save({}, {
        wait: true
      }).then(function () {
        // let the UI change back to non edit mode, in case saving went good
        self._endEditing(model);
      }).fail(function (err) {
        model.trigger('error', model); // need sync for blocking view

        var errorMessage;
        if (err && err.responseJSON && err.responseJSON.error) {
          errorMessage = err.responseJSON.error;
        } else {
          var errorHtml = base.MessageHelper.toHtml();
          base.MessageHelper.reset();
          errorMessage = $(errorHtml).text();
        }
        log.error('Saving failed. ', errorMessage) && console.error(log.last);
        GlobalMessage.showMessage('error', lang.errorFavoriteGroupSaveFailed + ' ' + errorMessage);
      });
    }
  });

  return FavoriteGroupsView;
});

csui.define('csui/widgets/favorites/impl/favorites2.table.columns',['csui/lib/underscore', 'csui/lib/backbone', 'i18n!csui/widgets/favorites/impl/nls/lang'
], function (_, Backbone, lang) {
  'use strict';

  var TableColumnModel = Backbone.Model.extend({

    idAttribute: "key",

    defaults: {
      key: null,  // key from the resource definitions
      sequence: 0 // smaller number moves the column to the front
    }

  });

  var TableColumnCollection = Backbone.Collection.extend({

    model: TableColumnModel,
    comparator: "sequence",

    getColumnKeys: function () {
      return this.pluck('key');
    },

    deepClone: function () {
      return new TableColumnCollection(
          this.map(function (column) {
            return column.attributes;
          }));
    },

    resetCollection: function (columns, options) {
      if (columns) {
        var sequence = 0;
        var models = _.map(columns, function (column) {
          var columnData = column instanceof Backbone.Model ? column.toJSON() : column;
          sequence += 10;
          return new TableColumnModel(_.defaults(columnData,
              {key: columnData.column_key, sequence: sequence}));
        });
        this.reset(models, options);
      }
    }

  });

  // Fixed (system) columns have sequence number < 100, dynamic columns
  // have sequence number > 1000

  var tableColumns = new TableColumnCollection([
    {
      key: 'type',
      sequence: 10,
      permanentColumn: true // don't wrap column due to responsiveness into details row
    },
    {
      key: 'favorite_name',
      title: lang.favoriteColumnNameTitle,
      cellViewClassname: "csui/controls/table/cells/name.view",
      sequence: 20,
      permanentColumn: true, // don't wrap column due to responsiveness into details row
      isNaming: true  // use this column as a starting point for the inline forms
    },
    {
      key: 'reserved',
      sequence: 30,
      noTitleInHeader: true // don't display a column header
    },
    {
      key: 'parent_id',
      sequence: 40
    },
    {
      key: 'favorite',
      sequence: 910,
      noTitleInHeader: true, // don't display a column header
      permanentColumn: true // don't wrap column due to responsiveness into details row
    }
  ]);

  return tableColumns;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/favorites/impl/favorites2.table',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-rowselection-toolbar\"></div>\r\n<div class=\"csui-favorite-masterdetail-view\">\r\n  <div class=\"csui-favorite-groups-view\"></div>\r\n  <div class=\"csui-table-view\"></div>\r\n</div>";
}});
Handlebars.registerPartial('csui_widgets_favorites_impl_favorites2.table', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/favorites/impl/favorites2.table.view',[],function(){});
csui.define('csui/widgets/favorites/impl/favorites2.table.view',["module",
  "csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/backbone",
  "csui/lib/marionette",
  "csui/utils/log",
  'csui/utils/base',
  'csui/utils/contexts/factories/connector',
  'csui/utils/contexts/factories/favorite2groups',
  'csui/models/favorite2columns',
  'csui/utils/contexts/factories/favorites2',
  'csui/models/favorites2',
  'csui/widgets/favorites/toolbaritems',
  'csui/widgets/favorites/toolbaritems.masks',
  'csui/controls/progressblocker/blocker',
  'csui/widgets/favorites/impl/favorites2.groups.view',
  "csui/controls/table/table.view",
  'csui/utils/commands',
  'csui/controls/toolbar/toolbar.view',
  'csui/controls/toolbar/delayed.toolbar.view',
  'csui/controls/tableactionbar/tableactionbar.view',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/behaviors/default.action/default.action.behavior',
  'csui/controls/tile/behaviors/infinite.scrolling.behavior',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/globalmessage/globalmessage',
  'csui/widgets/favorites/impl/favorites2.table.columns',
  'hbs!csui/widgets/favorites/impl/favorites2.table',
  'i18n!csui/widgets/favorites/impl/nls/lang',
  'csui/behaviors/table.rowselection.toolbar/table.rowselection.toolbar.behavior',
  'csui/lib/perfect-scrollbar',
  'css!csui/widgets/favorites/impl/favorites2.table.view'
], function (module, $, _, Backbone, Marionette, log, base,
    ConnectorFactory,
    Favorite2GroupsCollectionFactory,
    Favorite2ColumnCollection,
    Favorite2CollectionFactory,
    Favorite2Collection,
    toolbaritems,
    ToolbarItemsMasks,
    BlockingView,
    FavoriteGroupsView,
    TableView,
    commands,
    ToolbarView,
    DelayedToolbarView,
    TableActionBarView,
    ToolbarCommandController,
    LayoutViewEventsPropagationMixin,
    DefaultActionBehavior,
    InfiniteScrollingBehavior,
    PerfectScrollingBehavior,
    TabableRegionBehavior,
    GlobalMessage,
    favorites2TableColumns,
    template, lang,
    TableRowSelectionToolbarBehavior) {
  'use strict';

  var config = module.config();
  _.defaults(config, {
    defaultPageSize: 30,
    showGroupsRegion: true,
    dragAndDropEnabled: true
  });

  var InfiniteScrollingTableView = TableView.extend({
    constructor: function InfiniteScrollingTableView(options) {
      InfiniteScrollingTableView.__super__.constructor.apply(this, arguments);
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: 'tbody',
        suppressScrollX: true
      },
      InfiniteScrolling: {
        behaviorClass: InfiniteScrollingBehavior,
        // selector for scrollable area
        contentParent: 'tbody',
        // fetchMoreItemsThreshold: 90,
        content: 'tbody>tr:visible'
      },
      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }
    }
  });

  var Favorites2TableView = Marionette.LayoutView.extend({

    className: 'csui-fav2-table',
    template: template,

    ui: {
      tableView: '.csui-table-view'
    },

    regions: {
      toolbarRegion: '.csui-rowselection-toolbar',
      groupsRegion: '.csui-favorite-groups-view',
      tableRegion: '.csui-table-view'
    },

    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      },

      TableRowSelectionToolbar: {
        behaviorClass: TableRowSelectionToolbarBehavior
      }
    },

    constructor: function Favorites2TableView(options) {
      options || (options = {});

      // first use values from options and then fill undefined from module config and if still
      // not defined use hardcoded values
      _.defaults(options, {
        pageSize: config.defaultPageSize,
        showGroupsRegion: config.showGroupsRegion,
        clearFilterOnChange: config.clearFilterOnChange,
        resetOrderOnChange: config.resetOrderOnChange,
        resetLimitOnChange: config.resetLimitOnChange,
        fixedFilterOnChange: config.fixedFilterOnChange,
        dragAndDropEnabled: config.dragAndDropEnabled
      }, {
        showInlineActionBarOnHover: true,
        forceInlineActionBarOnClick: false,
        inlineActionBarStyle: "csui-table-actionbar-bubble",
        // orderBy: 'favorite_name asc',
        clearFilterOnChange: true,
        resetOrderOnChange: false,
        resetLimitOnChange: true,
        fixedFilterOnChange: false,
        toolbarItems: toolbaritems
      });

      if (!options.toolbarItemsMasks) {
        options.toolbarItemsMasks = new ToolbarItemsMasks();
      }

      this.context = options.context;
      this.connector = this.context.getObject(ConnectorFactory);

      this.commands = options.commands || commands;
      this.commandController = new ToolbarCommandController({
        commands: this.commands,
        nameAttribute: 'favorite_name'
      });

      this.favoritesTableOptions = {
        isFavoritesTable: true
      };

      this.tableColumns = this.options.tableColumns || favorites2TableColumns.deepClone();

      // Inheritors of this object start blocking actions in initialize().
      // Initializing of the blocking view has to happen before the parent
      // constructor gets called, or better, before initialize() is executed.
      // This is a result of breaking two rules:
      // 1. Nobody should inherit from widgets.
      // 2. constructor should not be overridden together with initialize.
      BlockingView.imbue(this);

      Favorites2TableView.__super__.constructor.call(this, options);

      this.propagateEventsToRegions(); // propagate dom:refresh to child views
    },

    initialize: function () {
      this.collection = new Favorite2Collection(undefined, {
        connector: this.connector,
        autoreset: true,
        skip: 0, // start at first item
        top: this.options.pageSize // page size
      });
      var defaultActionCommands = this.defaultActionController.actionItems.getAllCommandSignatures(
          commands);

      // Ask the server to check for permitted actions V2 - only default actions

      this.collection.setResourceScope(Favorite2CollectionFactory.getDefaultResourceScope());
      this.collection.setDefaultActionCommands(defaultActionCommands);
      this.collection.setEnabledDelayRestCommands(true);

      this.groups = this.options.groups ||
                    this.context.getCollection(Favorite2GroupsCollectionFactory, {
                      detached: true,
                      permanent: true
                    });
      // set the scope to use only default action commands and don't get additional actions delayed
      this.groups.favorites.setResourceScope(
          Favorite2CollectionFactory.getDefaultsOnlyResourceScope());
      this.groups.favorites.setEnabledDelayRestCommands(false);

      this.columns = this.collection.columns ||
                     new Favorite2ColumnCollection(undefined, {
                       connector: this.connector
                     });

      this._dragData = new Backbone.Model();
      this._allowDragging = true;

      if (this.collection.delayedActions) {
        this.listenTo(this.collection.delayedActions, 'error',
            function (collection, request, options) {
              var error = new base.Error(request);
              GlobalMessage.showMessage('error', error.message);
            });
      }

      this.listenTo(this.groups, 'request', this.blockActions);
      this.listenTo(this.groups, 'sync error destroy', this.unblockActions);
      this.listenTo(this.groups, 'reset', this._trySelectGroup);

      // event from the favorite star cell view on adding or removing a favorite
      this.listenTo(this.groups, 'bulk:update', function () {
        this._saveAllFavorites();
      });

      this.setGroupsView();
      this.setTableView();
      this.tableView.listenTo(this.groups, 'sync error destroy',
          this.tableView.enableEmptyViewText);
    },

    _setSelectedGroup: function (group) {
      this.selectedGroup = group;
      this.favoritesTableOptions.selectedGroup = group;
    },

    _trySelectGroup: function () {
      var groupToSelect;
      if (this.selectedGroup !== undefined) {
        groupToSelect = this.groups.get(this.selectedGroup);
      } else {
        // use first non-empty group or the ungrouped group if none was found
        groupToSelect = this.groups.find(function (group) {
          return (group.favorites && group.favorites.length > 0) || group.get('tab_id') === -1;
        });
      }

      if (groupToSelect) {
        if (this.columns.length === 0) {
          this.columns.reset(groupToSelect.favorites.columns.models, {
            silent: true
          });
        }
        this._setTableColumns(groupToSelect.favorites.columns, {
          silent: true
        });
        this.collection.populate(groupToSelect.favorites.models, {
          parse: false
        });
        this._setSelectedGroup(groupToSelect);
        this.groupsView.selectGroup(groupToSelect); // shows group as selected group
      } else {
        // if there is no firstNonEmptyGroup then render empty table again (at least test need that)
        delete this.selectedGroup;
        delete this.favoritesTableOptions.selectedGroup;
        // this.columns.reset([]);  // this would case the table.view to stay empty
        this.collection.populate([]);
      }
    },

    _setTableColumns: function (columns, options) {
      // don't change tableColumns if it was in the caller's options
      if (!this.options.tableColumns && columns && columns.models) {
        var self = this;
        var propertiesToMerge = ['permanentColumn', 'noTitleInHeader', 'title', 'align',
          'widthFactor', 'isNaming'
        ];
        var cols = _.map(columns.models, function (column) {
          var columnData = column.toJSON();
          var columnKey = column.get('column_key') || column.get('key');
          var tableColumn = self.tableColumns.findWhere({
            key: columnKey
          });
          if (tableColumn) {
            _.each(propertiesToMerge, function (propName) {
              var propToMergeValue = tableColumn.get(propName);
              // retain behavior of the existing client-side columns
              // merge when: 1)value defined and 2)destination column does not have this property
              if (propToMergeValue !== undefined && columnData[propName] === undefined) {
                columnData[propName] = propToMergeValue;
              }
            });
          }
          return columnData;
        });
        this.tableColumns.resetCollection(cols, options);
      }
    },

    _saveAllFavorites: function () {
      var self = this;
      var deferred = $.Deferred();
      this.blockActions();
      this._dragData.clear();
      this.groups.saveAll()
          .then(function () {
            log.debug("Complete set of favorite information saved") && console.log(log.last);
            self._updateTabIdsInSelectedGroup();
            deferred.resolve();
          })
          .fail(function (err) {
            // deferred.resolve();
            // return;
            // ignore rejected if no err provided, because then another save was already started
            if (err) {
              log.error(
                  "failed to save complete set of favorite information: " + err.statusText) &&
              console.log(log.last);
              GlobalMessage.showMessage('error', lang.errorFavoritesSaveFailed + ' ' +
                                                 err.statusText);

              self.groups.fetch({
                reload: true
              }); // re-fetch the groups in case save failed to
              // rollback any other changes
              deferred.reject();
            }
          })
          .always(function () {
            self.unblockActions();
          });
      return deferred.promise();
    },

    _updateTabIdsInSelectedGroup: function () {
      var favorites = this.collection;
      if (this.selectedGroup) {
        var selectedGroup = this.selectedGroup;
        var tabId = selectedGroup.get('tab_id');
        favorites.each(function (favoriteInTable, index) {
          var favorite = selectedGroup.favorites.at(index);
          // must remove before changing the tab_id and add it afterwards to let backbone update the
          // byId structure inside the collection correctly
          favorites.remove(favoriteInTable, {
            silent: true
          });
          favoriteInTable.set('favorite_tab_id', tabId, {
            silent: true
          });
          favorites.add(favoriteInTable, {
            at: index,
            silent: true
          });
        });
      }
    },

    _moveModel: function (collection, idSource, idDestination, moveAfterDestination) {
      var modelSource = collection.get(idSource);
      var modelDestination = collection.get(idDestination);
      var sourceIndex = collection.indexOf(modelSource);
      var targetIndex = collection.indexOf(modelDestination);
      if (sourceIndex < targetIndex) {
        targetIndex = targetIndex - 1;
      }
      if (moveAfterDestination) {
        targetIndex = targetIndex + 1;
      }
      if (sourceIndex != targetIndex) {
        collection.remove(modelSource);
        collection.add(modelSource, {
          at: targetIndex
        });
        return true;
      } else {
        return false;
      }
    },

    _moveAndSaveFavorites: function (sourceIds, targetId, dropAfter) {
      var selectedGroup = this.groups.get(this.selectedGroup);

      // todo blockActions is not working here
      this.blockActions();
      _.each(sourceIds, function (id) {
        var modelToMove = this.collection.get(id);
        if (modelToMove) {
          // must move the favorite in the current table.view collection and in the
          // favorites collection that is linked into the corresponding group
          this._moveModel(this.collection, id, targetId, dropAfter);
          this._moveModel(selectedGroup.favorites, id, targetId, dropAfter);
        }
      }, this);
      this.unblockActions();
      return this._saveAllFavorites();  // returns the promise from save call
    },

    setGroupsView: function () {
      this.groupsView = new FavoriteGroupsView(
          {
            connector: this.connector,
            collection: this.groups,
            dragData: this._dragData,
            blockingParentView: this,
            dragAndDropEnabled: this.options.dragAndDropEnabled
          });

      this.listenTo(this.groupsView, 'group:selected', function (groupView) {
        // console.log("Group " + groupView.model.get('name') + " selected");
        this.collection.populate(groupView.model.favorites.models, {
          parse: false
        });
        this._setSelectedGroup(groupView.model);
      });

      this.listenTo(this.groupsView, 'group:any:editing', function (args) {
        // stop drag&drop while groups-editing or single-group-editing mode
        this._allowDragging = !args.on;
        this._updateDraggable();
      });

      this.listenTo(this.groupsView, 'group:deleted', function (model) {
        // console.log("Group " + groupView.model.get('name') + " deleted");
        if (this.selectedGroup) {
          var id = model.get('tab_id');
          var selectedGroupId = this.selectedGroup.get('tab_id');
          if (selectedGroupId === id) {
            delete this.selectedGroup; // this is no more valid - choose new one
            this._trySelectGroup(); // select another group
          }
        }
      });

      this.listenTo(this.groupsView, 'group:dropped', function (args) {
        var self = this;
        // a group was dropped to move it to a different location within the list of groups
        var collection = this.groups;
        var idSource = args.tabIdSource;
        var idDestination = args.tabIdDestination;

        if (this._moveModel(collection, idSource, idDestination, args.dropAfter)) {

          var groupToFocus = this.groups.get(idSource);
          var groupToFocusIndex = this.groups.indexOf(groupToFocus);

          args.savePromise = this._saveAllFavorites().then(function () {
            self.groupsView._setFocusedByIndex(groupToFocusIndex);
            self.groupsView._tryReSetFocus();
          });
        }
      });

      this.listenTo(this.groupsView, 'dropped:favorite', function (args) {
        // favorites were dropped into a group

        var idSources = args.idSources;
        if (!_.isArray(idSources) || idSources.length === 0) {
          return; // nothing to do
        }
        var groups = this.groups;
        var favorites = this.collection;
        var idTarget = args.tabIdDestination;
        var sourceGroup = groups.get(args.tabIdSource);
        var selectedGroupId = this.selectedGroup.get('tab_id');

        _.each(idSources, function (idSource) {
          // move favorite model to destination group

          // the favorite to be moved is in two collections: in the favorites of the group to
          // which they belong (in in this scenario it is always the group which is currently
          // selected) and in the collection that is displayed by the table

          // 1) remove from favorites collection of source group and add it to target group
          var modelSource = sourceGroup.favorites.get(idSource);
          sourceGroup.favorites.remove(modelSource);
          var targetGroup = groups.get(idTarget);
          targetGroup.favorites.add(modelSource);

          // 2) update (add or remove) from favorite collection of table view, so the user sees
          // the change in the favorites table
          if (selectedGroupId === args.tabIdSource) {
            modelSource = favorites.get(idSource);
            favorites.remove(modelSource);

            // after dropping the selected item, it shouldn't be selected anymore
            modelSource.set('csuiIsSelected', false);
          } else {
            if (selectedGroupId === idTarget) {
              // target group is currently selected -> add the items to the  favorite collection
              // of tableView (currently displayed favorites)
              favorites.add(modelSource);
            }
          }

        });

        args.savePromise = this._saveAllFavorites();
      });
    },

    _removeDragline: function () {
      this.tableView.$el.find('.csui-dragline').remove();
      this.tableView.$el.find('tr.csui-no-border').removeClass('csui-no-border');
      delete this._dropAfter;
      // $el.removeClass("csui-dragline");
      // $el.removeClass("csui-dragline-top");
      // $el.removeClass("csui-dragline-bottom");
    },

    _updateDraggable: function () {
      if (this._allowDragging) {
        if (base.isAppleMobile() === false && this.options.dragAndDropEnabled) {
          var selectedRowsCount = this.tableView.getSelectedChildren().length;
          // if at least one row is selected, allow dragging only those rows, which are actually
          // selected
          if (selectedRowsCount > 0) {
            var rows = this.tableView.$el.find('tr[draggable=true]');
            rows.attr('draggable', false);
            rows = this.tableView.$el.find('tr.binf-active');
            rows.attr('draggable', true);
          } else {
            this.tableView.$el.find('tr:not(.csui-table-row-shows-inlineform)').attr('draggable',
                true);
          }
        }
      } else {
        var draggableRows = this.tableView.$el.find('tr[draggable=true]');
        draggableRows.attr('draggable', false);
      }
    },

    _handleKeydown: function (event, model) {

      var isMac = base.isMacintosh();
      var dragSourceFavoriteIds;

      switch (event.keyCode) {
      case 88:
        if (isMac && event.metaKey && !event.ctrlKey || !isMac && !event.metaKey &&
            event.ctrlKey) {

          // control-X or command-X (MacOS)

          event.preventDefault();
          event.stopPropagation();

          // save the id of the group even if a favorite is 'copied' to allow checking whether the
          // drop would be into the same group - which will be discarded.
          var dragSourceGroupId = this.selectedGroup.get('tab_id');
          dragSourceFavoriteIds = [];
          this._dragData.set({
            groupId: dragSourceGroupId,
            favorites: dragSourceFavoriteIds
          });

          var selected = this.tableView.getSelectedChildren();
          if (selected.length > 0) {
            _.each(selected, function (model) {
              dragSourceFavoriteIds.push(model.get('id'));
            });
          } else {
            var focused = this.tableView.getFocusedChild();
            if (focused) {
              dragSourceFavoriteIds.push(focused.get('id'));
            }
          }
          this.tableView.trigger('closeOther');
          this.tableView.cancelAnyExistingInlineForm.call(this.tableView);
        }
        break;
      case 86:
        if (isMac && event.metaKey && !event.ctrlKey || !isMac && !event.metaKey &&
            event.ctrlKey) {

          event.preventDefault();
          event.stopPropagation();

          dragSourceFavoriteIds = this._dragData.get('favorites');

          if (!dragSourceFavoriteIds || dragSourceFavoriteIds.length === 0) {
            // console.log("Ignoring to move zero items from clipboard");
            return;
          }

          var targetNode = model;
          var targetNodeId = targetNode.get('id');

          if (_.contains(dragSourceFavoriteIds, targetNodeId)) {
            // console.log("Ignoring to move items from clipbaord, because source items include" +
            //             " target item");
            return;
          }

          try {
            var dropAfter = false;
            this._moveAndSaveFavorites(this._dragData.get('favorites'), targetNodeId,
                dropAfter);
          } catch (error) {

          }
        }
        break;
      }
    },

    setTableView: function () {
      this.tableView = new InfiniteScrollingTableView({
        context: this.options.context,
        connector: this.connector,
        collection: this.collection,
        columns: this.columns,
        tableColumns: this.tableColumns,
        pageSize: this.options.pageSize,
        originatingView: this,
        columnsWithSearch: ["favorite_name"],
        orderBy: this.options.orderBy,
        filterBy: this.options.filterBy,
        nameEdit: false,
        favoritesTableOptions: this.favoritesTableOptions,
        actionItems: this.defaultActionController.actionItems,
        commands: this.defaultActionController.commands,
        blockingParentView: this,
        tableTexts: {
          zeroRecords: lang.emptyGroupText
        },
        inlineBar: {
          viewClass: TableActionBarView,
          options: _.extend({
            collection: this.options.toolbarItems.inlineActionbar,
            toolItemsMask: this.options.toolbarItemsMasks.toolbars.inlineActionbar,
            delayedActions: this.collection.delayedActions,
            container: this.collection.node,
            containerCollection: this.collection,
            commandExecutionOptions: {
              nameAttribute: 'favorite_name'
            }
          }, this.options.toolbarItems.inlineActionbar.options, {
            inlineBarStyle: this.options.inlineActionBarStyle,
            forceInlineBarOnClick: this.options.forceInlineActionBarOnClick,
            showInlineBarOnHover: this.options.showInlineActionBarOnHover
          })
        }
      });

      var self = this;

      this.listenTo(this.tableView, 'tableRowRendered', function (row) {
        var $row = $(row.target);
        $row.on('focusin', function (event) {
          self._tableRowWithFocus = row;
        });
        $row.on('focusout', function (event) {
          delete self._tableRowWithFocus;
        });
        $row.on('keydown', function (event) {
          self._handleKeydown.call(self, event, row.node);
        });
      });

      //
      // *** reorder favorites by drag&drop with mouse ***

      this.listenTo(this.tableView, 'tableRowRendered', function (row) {

        var $row = $(row.target);
        $row.find('a').attr('draggable', false);
        if (base.isAppleMobile() === false && this.options.dragAndDropEnabled) {
          if ($row.hasClass("csui-table-row-shows-inlineform") === false) {
            $row.attr('draggable', true);
          }
        }

        $row.on('dragstart', function (event) {
          // fired on the source element

          // save the id of the group to allow checking whether the drop would be
          // into the same group - which will be discarded.
          var dragSourceGroupId = self.selectedGroup.get('tab_id');
          var dragSourceFavorites = [];
          self._dragData.set({
            groupId: dragSourceGroupId,
            favorites: dragSourceFavorites,
            sourceIndex: event.currentTarget._DT_RowIndex
          });

          var selected = self.tableView.getSelectedChildren();
          if (selected.length > 0) {
            _.each(selected, function (model) {
              dragSourceFavorites.push(model.get('id'));
            });
          } else {
            var modelToMove = self.collection.at(self._dragData.get('sourceIndex'));
            dragSourceFavorites.push(modelToMove.get('id'));
            $(event.currentTarget).removeClass("csui-state-hover");
          }
          // must setData otherwise Firefox for example does not start drag&drop operation
          event.originalEvent.dataTransfer.setData('text', '');

          self.tableView.trigger('closeOther');
          self.tableView.cancelAnyExistingInlineForm.call(self.tableView);
        });

        $row.on('dragover', function (event) {
          // fired on the target element

          if (!self._dragData.get('favorites') || self._dragData.get('favorites').length === 0) {
            return; // don't show this element as drop target, because no favorite was dragged
          }

          var sourceIndex = self._dragData.get('sourceIndex');
          var targetIndex = event.currentTarget._DT_RowIndex;

          if (sourceIndex === undefined || sourceIndex === targetIndex) {
            return; // don't allow dropping to the same element and drag sources not from table
          }

          event.preventDefault(); // enables dropping to this element

          // remove any other dragline if it was not created by this group view
          // remove any dragline if  there was one before at the other side
          // add new dragline if there was none before or at the other side

          var dragline = $('<tr class="csui-dragline">');
          var h = $(event.currentTarget).height();
          if (event.offsetY > (h / 2)) {
            if (self._dropAfter === undefined || self._dropAfter === false) {
              // console.log("after, offset: " + event.offsetY + " _dropAfter: " + self._dropAfter);
              self._removeDragline.call(self);
              $(event.currentTarget).after(dragline);
              self._dropAfter = true;
            }
          } else {
            if (self._dropAfter === undefined || self._dropAfter === true) {
              // console.log("before, offset: " + event.offsetY + " _dropAfter: " + self._dropAfter);
              self._removeDragline.call(self);
              $(event.currentTarget).before(dragline);
              if (targetIndex === 0) {
                dragline.before('<tr class="csui-dragline csu-dragline-spacer">');
              }
              self._dropAfter = false;
            }
          }
          dragline.next().addClass('csui-no-border');
        });

        $row.on('drop', function (event) {
          // fired on the target element

          var sourceIndex = self._dragData.get('sourceIndex');
          var targetIndex = event.currentTarget._DT_RowIndex;
          var targetNode = row.node;
          var targetNodeId = targetNode.get('id');

          // console.log("DROP source: " + sourceIndex + ", target: " + targetIndex);
          if (sourceIndex === undefined || sourceIndex === targetIndex) {
            return; // don't allow dropping to the same element and drag sources not from table
          }

          event.preventDefault(); // enables dropping to this element

          try {
            if (self._dragData.get('favorites') && self._dragData.get('groupId')) {
              var h = $(event.currentTarget).height();
              var dropAfter = event.offsetY > (h / 2);
              self._moveAndSaveFavorites(self._dragData.get('favorites'), targetNodeId, dropAfter);
            }
          } catch (error) {}
          self._removeDragline();
        });

        $row.on('dragleave', function (event) {
          // fired on the target element
          self._removeDragline();
        });

        $row.on('dragend', function (event) {
          // fired on the source element
          event.preventDefault();
          self._removeDragline();
          self._dragData.clear();
        });

      });

      this.listenTo(this.tableView, 'tableRowSelected', this._updateDraggable);
      this.listenTo(this.tableView, 'tableRowUnselected', this._updateDraggable);

      this.listenTo(this, 'render', function () {
        // this._updateToolItems();
        this.groupsRegion.show(this.groupsView);
        this.tableRegion.show(this.tableView);

        this.groups.ensureFetched({
          reload: true
        }); // to make sure to have the latest node state
        // like reserved/unreserved

        this.options.showGroupsRegion === false && this.groupsRegion.$el.hide();

        delete this._tableRowWithFocus;
      });

      this.listenTo(this.tableView, 'execute:defaultAction', function (node) {
        var args = {
          node: node
        };
        this.trigger('before:defaultAction', args);
        if (!args.cancel) {
          var self = this;
          this.defaultActionController.executeAction(node, {
            context: this.options.context,
            originatingView: this
          }).done(function () {
            self.trigger('executed:defaultAction', args);
          });
        }
      });

      // this.listenTo(this.tableView, 'render', function () {
      // FIXME: Computing maximum column count (_adjustColumnsAfterWindowResize)
      // does not return the same value as set by rebuilding the table (rebuild)
      // unless an extra div is appended to the table.  Why?

      // this.tableView.$el.append($('<div>')[0]);
      // });

    },

    _addFavoriteAttribute: function (collection) {
      collection.each(function (node) {
        node.set('favorite', true);
      }, this);
      return true;
    }

  });

  _.extend(Favorites2TableView.prototype, LayoutViewEventsPropagationMixin);

  return Favorites2TableView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/myassignments/impl/myassignmentstable',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-myassignmentstable\">\r\n  <div id=\"tableviewMA\"></div>\r\n  <div id=\"paginationviewMA\"></div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_widgets_myassignments_impl_myassignmentstable', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/myassignments/impl/myassignmentstable',[],function(){});
csui.define('csui/widgets/myassignments/impl/myassignmentstable.view',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/backbone",
  "csui/lib/marionette", "csui/utils/log",
  'csui/utils/contexts/factories/myassignmentscolumns',
  'csui/utils/contexts/factories/myassignments',
  'csui/controls/table/rows/description/description.view',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/widgets/myassignments/myassignments.columns',
  'csui/widgets/nodestable/nodestable.view',
  'hbs!csui/widgets/myassignments/impl/myassignmentstable',
  'i18n!csui/widgets/myassignments/impl/nls/lang',
  'css!csui/widgets/myassignments/impl/myassignmentstable'
], function (module, $, _, Backbone, Marionette, log,
    MyAssignmentsColumnCollectionFactory, MyAssignmentsCollectionFactory,
    DescriptionRowView, LayoutViewEventsPropagationMixin,
    myAssignmentsTableColumns, NodesTable, template, lang) {
  'use strict';

  var accessibleTable = /\baccessibleTable\b(?:=([^&]*)?)?/i.exec(location.search);
  accessibleTable = accessibleTable && accessibleTable[1] !== 'false';

  var MyAssignmentsTableView = NodesTable.extend({

    template: template,

    className: '',

    regions: {
      tableRegion: '#tableviewMA',
      paginationRegion: '#paginationviewMA'
    },

    constructor: function MyAssignmentsTableView(options) {
      NodesTable.prototype.constructor.apply(this, arguments);

      this.propagateEventsToRegions();
    },

    initialize: function () {
      this.collection = this.options.collection ||
                        this.context.getCollection(MyAssignmentsCollectionFactory);
      this.columns = this.collection.columns ||
                     this.context.getCollection(MyAssignmentsColumnCollectionFactory);

      _.defaults(this.options, {
        orderBy: 'date_due asc',
        tableColumns: myAssignmentsTableColumns
      });

      this.setTableView({
        nameEdit: false,
        descriptionRowView: DescriptionRowView,
        descriptionRowViewOptions: {
          firstColumnIndex: 1, lastColumnIndex: 2,
          showDescriptions: !accessibleTable,
          collapsedHeightIsOneLine: false
        },
        selectRows: "none",
        selectColumn: false,
        haveDetailsRowExpandCollapseColumn: false,
        tableColumns: this.options.tableColumns,
        tableTexts: {
          zeroRecords: lang.emptyListText
        },
        inlineBar: {
          options: {}
        }
      });

      this.setPagination();

      if (this.options.collection) {
        this.collection.fetched = false;
      }

    },

    onDestroy: function () {
      // If the collection was passed from outside and might be of a limited scope
      if (this.options.collection) {
        // Restore the scope of the response
        this.collection.setResourceScope(this._originalScope);
      }
      NodesTable.prototype.onDestroy.call(this);
    },

    onRender: function () {
      // If the collection was passed from outside and might be of a limited scope
      if (this.options.collection && !this.collection.fetched) {
        // Cancel limiting the scope of the response
        this._originalScope = this.collection.getResourceScope();
        this.collection.setResourceScope(MyAssignmentsCollectionFactory.getDefaultResourceScope());
        this.collection.setExpand('assignments',
            ['from_user_id', 'location_id', 'workflow_id',
              'workflow_subworkflow_id', 'workflow_subworkflow_task_id']
        );
        this.collection.fetch({reload: true});
      }

      this.tableRegion.show(this.tableView);
      this.paginationRegion.show(this.paginationView);
    }

  });

  _.extend(MyAssignmentsTableView.prototype, LayoutViewEventsPropagationMixin);

  return MyAssignmentsTableView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/recentlyaccessed/impl/recentlyaccessedtable',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-recentlyaccessedtable\">\r\n  <div class=\"csui-rowselection-toolbar\"></div>\r\n  <div id=\"tableviewRA\"></div>\r\n  <div id=\"paginationviewRA\"></div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_widgets_recentlyaccessed_impl_recentlyaccessedtable', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/widgets/recentlyaccessed/impl/recentlyaccessedtable',[],function(){});
csui.define('csui/widgets/recentlyaccessed/impl/recentlyaccessedtable.view',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/backbone",
  "csui/lib/marionette", "csui/utils/log", 'csui/utils/base',
  'csui/utils/contexts/factories/recentlyaccessedcolumns',
  'csui/utils/contexts/factories/recentlyaccessed',
  'csui/widgets/recentlyaccessed/recentlyaccessed.columns',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'csui/widgets/nodestable/nodestable.view',
  'csui/utils/commands',
  'csui/controls/globalmessage/globalmessage',
  'csui/widgets/recentlyaccessed/toolbaritems',
  'csui/widgets/recentlyaccessed/toolbaritems.masks',
  'hbs!csui/widgets/recentlyaccessed/impl/recentlyaccessedtable',
  'i18n!csui/widgets/recentlyaccessed/impl/nls/lang',
  'csui/behaviors/table.rowselection.toolbar/table.rowselection.toolbar.behavior',
  'css!csui/widgets/recentlyaccessed/impl/recentlyaccessedtable'
], function (module, $, _, Backbone, Marionette, log, base,
  RecentlyAccessedColumnsCollectionFactory,
  RecentlyAccessedCollectionFactory,
  RecentlyAccessedTableColumns,
  LayoutViewEventsPropagationMixin,
  NodesTable,
  commands,
  GlobalMessage,
  toolbarItems,
  ToolbarItemsMasks,
  template,
  lang,
  TableRowSelectionToolbarBehavior) {
  'use strict';

  var RecentlyAccessedTableView = NodesTable.extend({

    template: template,

    className: '',

    regions: {
      toolbarRegion: '.csui-rowselection-toolbar',
      tableRegion: '#tableviewRA',
      paginationRegion: '#paginationviewRA'
    },

    constructor: function RecentlyAccessedTableView(options) {
      NodesTable.prototype.constructor.apply(this, arguments);
      this.propagateEventsToRegions();
    },

    behaviors: _.extend({
      TableRowSelectionToolbar: {
        behaviorClass: TableRowSelectionToolbarBehavior
      }
    }, NodesTable.prototype.behaviors),

    initialize: function () {
      this.collection = this.options.collection ||
        this.context.getCollection(RecentlyAccessedCollectionFactory);

      this._allCommands = this.defaultActionController.actionItems.getAllCommandSignatures(
        commands);

      // Ask the server to check for permitted actions V2 - only default actions
      this.collection.setResourceScope(RecentlyAccessedCollectionFactory.getDefaultResourceScope());
      this.collection.setDefaultActionCommands(this._allCommands);
      this.collection.setEnabledDelayRestCommands(true);

      if (this.collection.delayedActions) {
        this.listenTo(this.collection.delayedActions, 'error',
          function (collection, request, options) {
            var error = new base.Error(request);
            GlobalMessage.showMessage('error', error.message);
          });
      }

      this.columns = this.collection.columns ||
        this.context.getCollection(RecentlyAccessedColumnsCollectionFactory);

      _.defaults(this.options, {
        orderBy: 'access_date_last desc',
        tableColumns: RecentlyAccessedTableColumns,
        toolbarItems: toolbarItems
      });

      if (!this.options.toolbarItemsMasks) {
        this.options.toolbarItemsMasks = new ToolbarItemsMasks();
      }

      this.setTableView({
        orderBy: this.options.orderBy,
        filterBy: this.options.filterBy,
        nameEdit: false,
        haveDetailsRowExpandCollapseColumn: false,
        tableColumns: this.options.tableColumns,
        tableTexts: {
          zeroRecords: lang.emptyListText
        }
      });

      this.setPagination();

      if (this.options.collection) {
        this.collection.fetched = false;
      }
    },

    onRender: function () {
      // If the collection was passed from outside and might be of a limited scope
      if (this.options.collection && !this.options.collection.fetched) {
        // Cancel limiting the scope of the response
        this._originalScope = this.collection.getResourceScope();
        this.collection.setResourceScope(
          RecentlyAccessedCollectionFactory.getDefaultResourceScope());
        this.collection.setExpand('properties', ['parent_id', 'reserved_user_id']);

        this.collection.setDefaultActionCommands(this._allCommands);
        this.collection.setEnabledDelayRestCommands(true);

        this.collection.fetch({
          reload: true
        });
      }

      this.tableRegion.show(this.tableView);
      this.paginationRegion.show(this.paginationView);
    },

    onDestroy: function () {
      // If the collection was passed from outside and might be of a limited scope
      if (this.options.collection) {
        // Restore the scope of the response
        this.collection.setResourceScope(this._originalScope);
      }

      NodesTable.prototype.onDestroy.call(this);
    }
  });

  _.extend(RecentlyAccessedTableView.prototype, LayoutViewEventsPropagationMixin);

  return RecentlyAccessedTableView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/permissions.lookup/permissions.lookup',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div id=\"csui-permissions-user-picker\" class=\"csui-permissions-user-picker\"></div>\r\n<div id=\"user\"></div>";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_permissions.lookup_permissions.lookup', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/impl/permissions.lookup/permissions.lookup.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/base',
  'i18n!csui/widgets/permissions/impl/nls/lang',
  'hbs!csui/widgets/permissions/impl/permissions.lookup/permissions.lookup',
  'css!csui/widgets/permissions/impl/permissions'
], function (_, $, Marionette, base, lang, template) {

  var PermissionsLookupView = Marionette.ItemView.extend({

    className: 'cs-permissions-lookup',

    template: template,

    initialize: function (options) {
      this.options = options;
    },

    constructor: function PermissionsLookupView(options) {
      var self = this;
      options || (options = {});
      options.data || (options.data = {});
      this.options = options;
      Marionette.ItemView.prototype.constructor.call(this, options);

    },

    onShow: function () {
      var self = this;
      csui.require(['csui/controls/userpicker/userpicker.view'
      ], function (UserPickerView) {
        self.pickerView = new UserPickerView({
          context: self.options.context,
          memberFilter: {type: [0, 1]},
          widgetoptions: self.options,
          placeholder: lang.PermissionLookupPlaceHolder,
          prettyScrolling: true,
          limit: 20,
          model: self.options.userPickerModel,
          id_input: _.uniqueId("csui-permissions-user-picker-input")
        });
        var pickerRegion = new Marionette.Region({
          el: self.$el.find('#csui-permissions-user-picker')
        });
        pickerRegion.show(self.pickerView);
        self.listenTo(self.pickerView, "item:change", self.processItemChange);
        self.listenTo(self.pickerView, "item:clear", self.processItemChange);
      });
    },

    processItemChange: function () {
      var selectedModel = arguments.length > 0 && arguments[0].item;
      var param = {
        id: !!selectedModel ? selectedModel.get("id") : '',
        name: !!selectedModel ? selectedModel.get("name_formatted") : '',
        group_id: !!selectedModel && selectedModel.get("group_id") ?
                  selectedModel.get("group_id").id : '',
        initials: !!selectedModel ? selectedModel.get("initials") : '',
        photo_url: !!selectedModel ? selectedModel.get("photo_url") : ''
      };
      this.options.userPickerModel.set(param);
    }
  });

  return PermissionsLookupView;

});


csui.define('csui/widgets/permissions/impl/permissions.list/permissions.dropdown.menu.items',['csui/lib/underscore',
  //'i18n!csui/widgets/metadata/impl/nls/lang',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/permissions/impl/permissions.list/permissions.dropdown.menu.items'
  // Load extra tool items from the previous module location
], function (_, lang, ToolItemsFactory, TooItemModel, extraToolItems)
{
  'use strict';

  var toolbarItems = {
    dropdownMenuList: new ToolItemsFactory({
          main: [
            {signature: "adduserorgroup", name: lang.AddUserOrGroups},
            {signature: "addownerorgroup", name: lang.AddOwnerOrGroup},
            {signature: "restorepublicaccess", name: lang.RestorePublicAccess}
          ]
        },
        {
          maxItemsShown: 0, // force toolbar to immediately start with a drop-down list
          dropDownIcon: "icon icon-expandArrowDown"
        }
    )
  };

  if (extraToolItems) {
    // TODO: Issue deprecation warning
    addExtraToolItems(extraToolItems);
  }

  function addExtraToolItems(extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;

});

csui.define('csui/models/permission/permission.response.mixin',[
  'csui/lib/underscore', 'csui/utils/base'
], function (_, base) {
  'use strict';

  var PermissionResponseMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makePermissionResponse: function (options) {
          return this;
        },

        /**
         * This method update the response data for the following fields....
         * removes public access record if no permission data exists,
         * @param resp
         * @param options
         */
        parsePermissionResponse: function (resp, options, clearEmptyPermissionModel) {
          if (!!resp.results && !!resp.results.data && !!resp.results.data.permissions &&
              !_.isEmpty(resp.results.data.permissions)) {
            var permissionsList = resp.results.data.permissions;
            if (_.isArray(permissionsList)) {
              //Removing public access entry from response if there is no permissions available
              permissionsList = _.reject(permissionsList,
                  function (child) { return (child.type === 'public' && !child.permissions); });
              var ownerData = _.find(permissionsList, function (item) {
                    return item.type === 'owner';
                  }),
                  groupData = _.find(permissionsList, function (item) {
                    return item.type === 'group';
                  });
              //Removing group entry from response if owner is available and group is not available
              if ((ownerData && ownerData.permissions) && (groupData && !groupData.permissions)) {
                permissionsList = _.reject(permissionsList,
                    function (child) { return (child.type === 'group' && !child.permissions); });
              }
              //Removing owner entry from response if group is available and owner is not available
              if ((ownerData && !ownerData.permissions) && (groupData && groupData.permissions)) {
                permissionsList = _.reject(permissionsList,
                    function (child) { return (child.type === 'owner' && !child.permissions); });
              }
              //Removing group entry from response if there is no permissions available for owner
              // and owner group
              if ((ownerData && !ownerData.permissions) && (groupData && !groupData.permissions)) {
                permissionsList = _.reject(permissionsList,
                    function (child) { return (child.type === 'group' && !child.permissions); });
              }
            } else if (_.isObject(permissionsList)) {
              permissionsList = [];
              if (resp.results.data.permissions &&
                  resp.results.data.permissions.permissions.length > 0) {
                permissionsList.push(resp.results.data.permissions);
              }
            }
            resp.results.data.permissions = permissionsList;
          }
        }
      });
    }
  };

  return PermissionResponseMixin;
});

csui.define('csui/models/permission/nodeuserpermissions',['module',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/utils/url',
  'csui/models/permission/nodepermission.model',
  'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin',
  'csui/models/browsable/browsable.mixin',
  'csui/models/browsable/v2.response.mixin',
  'csui/models/mixins/v2.expandable/v2.expandable.mixin',
  'csui/models/permission/permission.response.mixin'
], function (module, $, _, Backbone, Url, NodePermissionModel,
    ConnectableMixin, FetchableMixin, BrowsableMixin,
    BrowsableV2ResponseMixin, ExpandableV2Mixin, PermissionResponseMixin) {
  'use strict';

  var config = module.config();
  _.defaults(config, {
    defaultPageSize: 30
  });

  var NodeUserPermissionCollection = Backbone.Collection.extend({

    model: NodePermissionModel,

    constructor: function NodeUserPermissionCollection(models, options) {
      options = _.defaults({}, options, {
        top: config.defaultPageSize
      }, options);

      Backbone.Collection.prototype.constructor.apply(this, arguments);

      this.makeFetchable(options);

      this.options = options;
      this.includeActions = options.includeActions;
      this.query = this.options.query;

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeBrowsable(options)
          .makeBrowsableV2Response(options)
          .makePermissionResponse(options);
    },

    isFetchable: function () {
      return true;
    },

    url: function () {
      var url = Url.combine(this.connector.connection.url, 'nodes',
          this.options.node.get('id')), query;
      url = url.replace("/v1", "/v2");
      if (!!this.options.memberId) {
        url += '/permissions/effective/' + this.options.memberId;
        query = Url.combineQueryString(
            {
              expand: 'permissions{right_id}'
            }, query);
      } else {
        query = Url.combineQueryString(
            {
              fields: ['properties{container, name, type, versions_control_advanced,' +
                       ' permissions_model}',
                'permissions{right_id, permissions, type}', 'versions{version_id}'],
              expand: ['permissions{right_id}']
            }, query);
      }
      if (query) {
        url += '?' + query;
      }

      return url;
    },

    parse: function (response, options) {
      if (!!response.results && !!response.results.data) {
        this.parsePermissionResponse(response, options, this.options.clearEmptyPermissionModel);
        //Add name in the permission collection
        if (!this.options.node.get("isNotFound")) {
          this.nodeName = response.results.data.properties ? response.results.data.properties.name :
                          "";
          if (this.isContainer === undefined || response.results.data.properties) {
            this.isContainer = response.results.data.properties ?
                               response.results.data.properties.container : true;
          }
          return response.results.data.permissions;
        }
      }
    },

    setOrder: function (attributes, fetch) {
      if (this.orderBy != attributes) {
        this.orderBy = attributes;
        if (fetch !== false) {
          this.fetch({skipSort: false});
        }
        return true;
      }
    },

    processForEmptyOwner: function () {
      if (!this.findWhere({type: 'owner'}) && !this.findWhere({type: 'group'})) {
        //Add dummy model at index 0, for no owner assigned row
        this.add({permissions: null, right_id: null, type: 'owner'}, {at: 0});
      }
    },

    addPublicAccess: function (publicAccessModel) {
      if (this.findWhere({type: 'owner'}) && this.findWhere({type: 'group'})) {
        //Add dummy model at index 0, for no owner assigned row
        this.add(publicAccessModel, {at: 2});
      } else {
        //Add public access at index 1, if anyone is present from owner or group
        this.add(publicAccessModel, {at: 1});
      }
    },

    addOwnerOrGroup: function (nodePermissionModel) {
      var owner = this.findWhere({type: 'owner'});
      if (owner && owner.get('permissions') === null) { //No owner or group
        var currentModel = this.at(0);
        this.remove(currentModel, {silent: true});
        this.add(nodePermissionModel, {at: 0});
      }
      else {
        this.add(nodePermissionModel, {at: (nodePermissionModel.get('type') === 'owner') ? 0 : 1});
      }
    }
  });

  FetchableMixin.mixin(NodeUserPermissionCollection.prototype);
  BrowsableMixin.mixin(NodeUserPermissionCollection.prototype);
  BrowsableV2ResponseMixin.mixin(NodeUserPermissionCollection.prototype);
  ConnectableMixin.mixin(NodeUserPermissionCollection.prototype);
  ExpandableV2Mixin.mixin(NodeUserPermissionCollection.prototype);
  PermissionResponseMixin.mixin(NodeUserPermissionCollection.prototype);

  return NodeUserPermissionCollection;

});


csui.define('csui/utils/contexts/factories/permission.list.factory',['require', 'module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/contexts/factories/factory', 'csui/utils/contexts/factories/connector',
  'csui/models/permission/nodeuserpermissions',
  'csui/utils/commands',
  'csui/utils/base'
], function (require, module, _, Backbone, CollectionFactory, ConnectorFactory,
    NodeUserPermissionCollection, commands, base) {

  var PermissionCollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'nodeUserPermissions',

    constructor: function PermissionCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      var nodeUserPermissions = this.options.nodeUserPermissions || {};
      if (!(nodeUserPermissions instanceof Backbone.Collection)) {
        var connector    = context.getObject(ConnectorFactory, options),
            query        = options.nodeUserPermissions.memberFilter,
            config       = module.config();
        nodeUserPermissions = new NodeUserPermissionCollection(nodeUserPermissions.models, _.extend({
          connector: connector,
          query: query,
          nodeId: this.options.model.get("id")
        }, nodeUserPermissions.options, config.options, {
          autofetch: true,
          autoreset: true
        }));
      }
      this.property = nodeUserPermissions;
    },

    isFetchable: function () {
      return this.property.isFetchable();
    },

    fetch: function (options) {
      this.property.fetch({
        success: _.bind(this._onNodeUserPermissionsFetched, this, options),
        error: _.bind(this._onNodeUserPermissionsFailed, this, options)
      });
    },

    _onNodeUserPermissionsFetched: function (options) {
      //nothing to-do for now upon success.
      return true;
    },

    _onNodeUserPermissionsFailed: function (model, request, message) {
      var error = new base.RequestErrorMessage(message);
      csui.require(['csui/dialogs/modal.alert/modal.alert'], function (ModalAlert) {
        ModalAlert.showError(error.toString());
      });
    }
  });

  return PermissionCollectionFactory;
});

csui.define('csui/widgets/permissions/impl/permissions.list/toolbaritems',['csui/lib/underscore', 'csui/utils/base',
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitem.model',
  // Load extra tool items to be added to this collection
  'csui-ext!csui/widgets/permissions/toolbaritems'
], function (_, base, lang, ToolItemsFactory, TooItemModel, extraToolItems) {
  'use strict';

  // Keep the keys in sync with csui/widgets/search.results/toolbaritems.masks
  var toolbarItems = {

    inlineToolbar: new ToolItemsFactory({
          other: [
            {
              signature: "ChangeOwnerPermission", name: lang.ToolbarItemChangeOwnerPermission,
              icon: "icon icon-owner-change"
            },
            {
              signature: "DeletePermission", name: lang.ToolbarItemDeletePermission,
              icon: "icon icon-toolbar-delete"
            },
            {
              signature: "EditPermission",
              name: lang.ToolbarItemEditPermission,
              icon: "icon icon-toolbar-edit"
            },
            {signature: "ApplyPermission", name: lang.ToolbarItemApplyPermission, icon: "icon" +
                                                                           " icon-toolbar-share"}
          ]
        },
        {
          maxItemsShown: base.isTouchBrowser() ? 1 : 3,
          dropDownText: lang.ToolbarItemMore,
          dropDownIcon: "icon icon-toolbar-more"
        })

  };

  if (extraToolItems) {
    addExtraToolItems(extraToolItems);
  }

  function addExtraToolItems(extraToolItems) {
    _.each(extraToolItems, function (moduleToolItems) {
      _.each(moduleToolItems, function (toolItems, key) {
        var targetToolbar = toolbarItems[key];
        if (!targetToolbar) {
          throw new Error('Invalid target toolbar: ' + key);
        }
        _.each(toolItems, function (toolItem) {
          toolItem = new TooItemModel(toolItem);
          targetToolbar.addItem(toolItem);
        });
      });
    });
  }

  return toolbarItems;

});

csui.define('csui/widgets/permissions/impl/permissions.list/toolbaritems.masks',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask',
  'csui/utils/toolitem.masks/global.toolitems.mask'
], function (module, _, ToolItemMask, GlobalMenuItemsMask) {
  'use strict';

  // Keep the keys in sync with csui/widgets/search.results/toolbaritems
  var toolbars = ['inlineToolbar'];

  function ToolbarItemsMasks() {
    var config = module.config(),
        globalMask = new GlobalMenuItemsMask();
    // Create and populate masks for every toolbar
    this.toolbars = _.reduce(toolbars, function (toolbars, toolbar) {
      var mask = new ToolItemMask(globalMask, {normalize: false});
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        source = source[toolbar];
        if (source) {
          mask.extendMask(source);
        }
      });
      // Enable restoring the mask to its initial state
      mask.storeMask();
      toolbars[toolbar] = mask;
      return toolbars;
    }, {});
  }

  ToolbarItemsMasks.toolbars = toolbars;

  return ToolbarItemsMasks;

});


csui.define('csui/widgets/permissions/impl/permissions.list/permission.table.columns',['csui/lib/underscore', "csui/lib/backbone",
  'csui/models/permission/permission.table.columns.model',
  'i18n!csui/widgets/permissions/impl/nls/lang',
  'csui-ext!csui/widgets/permissions/table.columns'
], function (_, Backbone, TableColumnModel, lang, extraTableColumns) {

  var TableColumnCollection = Backbone.Collection.extend({

    model: TableColumnModel,
    comparator: "sequence",

    getColumnKeys: function () {
      return this.pluck('key');
    },

    deepClone: function () {
      return new TableColumnCollection(
          this.map(function (column) {
            return column.attributes;
          }));
    }

  });

  // columns delivered from server get sequence set to 500

  var tableColumns = [
    {
      key: 'right_id',
      column_key: 'right_id',
      column_name: lang.right_id,
      sequence: 20,
      permanentColumn: true, // don't wrap column due to responsiveness into details row,
      containsInlineActions: true
    },
    {
      key: 'permissions',
      column_key: 'permissions',
      column_name: lang.permission_level,
      sequence: 40,
      permanentColumn: true // don't wrap column due to responsivenes into details row
    },
    {
      column_key: 'addpermissions',
      key: 'addpermissions',
      name: '',
      sortable: false,
      alignment: 'center',
      permanentColumn: true,
      isToolbar: true,
      sequence: 999,
      className: 'csui-inlinetoolbar-touch'
    }
  ];

  if (extraTableColumns) {
    _.each(extraTableColumns, function (moduleTableColumns) {
      _.each(moduleTableColumns, function (tableColumn, key) {
        tableColumns.push(tableColumn);
      });
    });
  }

  var tableColumnCollection = new TableColumnCollection(tableColumns);

  return tableColumnCollection;

});



/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/permissions.content',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"csui-permission-lookup-container\"></div>\r\n<div class=\"csui-permissions-list-container\"></div>\r\n<div class=\"csui-permissions-empty-actions binf-hidden\">\r\n  <div class=\"csui-addMember-container\">\r\n    <span class=\"csui-icon add_user\"></span>\r\n    <span class=\"csui-addMember\"></span>\r\n  </div>\r\n  <div class=\"csui-grantAccess-container binf-hidden\">\r\n    <span class=\"csui-icon icon_permmision_owner\"></span>\r\n    <span class=\"csui-grantAccess\"></span>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_permissions.content', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/permissions.list/permissions.empty',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<span>"
    + this.escapeExpression(((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"message","hash":{}}) : helper)))
    + "</span>";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_permissions.list_permissions.empty', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/impl/permissions.content.view',['csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/models/node/node.model',
  'csui/widgets/permissions/impl/permissions.lookup/permissions.lookup.view',
  'csui/controls/table.list/table.list.view',
  'csui/widgets/permissions/impl/permissions.list/permissions.dropdown.menu.items',
  'csui/controls/form/pub.sub',
  'csui/utils/commands',
  'csui/utils/contexts/factories/member',
  'csui/utils/contexts/factories/permission.list.factory',
  'csui/widgets/permissions/impl/permissions.list/toolbaritems',
  'csui/widgets/permissions/impl/permissions.list/toolbaritems.masks',
  'csui/widgets/permissions/impl/permissions.list/permission.table.columns',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/controls/progressblocker/blocker',
  'csui/dialogs/members.picker/members.picker.wizard',
  'i18n!csui/widgets/permissions/impl/nls/lang',
  'hbs!csui/widgets/permissions/impl/permissions.content',
  'hbs!csui/widgets/permissions/impl/permissions.list/permissions.empty',
  'css!csui/widgets/permissions/impl/permissions'
], function (_, $, Marionette, base, NodeModel, PermissionsLookupView,
    TableListView, dropdownMenuItems, PubSub, commands, MemberModelFactory,
    PermissionCollectionFactory, toolbarItems, ToolbarItemsMasks, permissionTableColumns,
    ViewEventsPropagationMixin, BlockingView, MembersPickerDialog, lang, template, emptyTemplate) {

  var NoPermissionsResultView = Marionette.ItemView.extend({

    className: 'csui-table-empty',
    template: emptyTemplate,

    templateHelpers: function () {
      var emptyText = _.str.sformat(lang.emptyPermissionListMsg, this.model.get('name'));
      return {
        message: emptyText
      };
    },

    constructor: function NoPermissionsResultView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }
  });

  var PermissionsContentView = Marionette.LayoutView.extend({

    className: 'cs-permissions-content',

    template: template,

    regions: {
      lookupRegion: ".csui-permission-lookup-container",
      listRegion: ".csui-permissions-list-container"
    },

    ui: {
      permissionList: '.csui-permissions-list-container',
      emptyActionsContainer: '.csui-permissions-empty-actions',
      addMemberToGroup: '.csui-addMember',
      grantAccessToMember: '.csui-grantAccess'
    },

    events: {
      'click @ui.addMemberToGroup': 'onClickAddMember'
    },

    onClickAddMember: function (e) {
      var self = this;
      var deferred = $.Deferred();
      // self.trigger('hide:parentDialog');
      var status = self.options.originatingView;
      var selectableMembers = self.originalCollection && self.originalCollection.models &&
                              self.originalCollection.models.length > 0 ?
                              self.originalCollection.models :
                              self.permissionCollection.models;
      selectableMembers = _.filter(selectableMembers, function (member) {
        return member.get("right_id_expand") && member.get("right_id_expand").type === 1;
      });
      var membersPickerDialog = new MembersPickerDialog({
        command: 'adduserorgroup',
        context: status.context,
        connector: status.model.connector,
        dialogClass: 'cs-permission-group-picker',
        displayName: lang.allUsersAndGroups,
        dialogTitle: lang.addUsersAndGroups,
        startLocation: 'acl.groups',
        displayStartLocation: true,
        selectedMember: self.memberFilter,
        showUserPicker: true,
        authUser: self.options.authUser,
        adduserorgroup: true,
        buttons: [
          {
            id: 'Add',
            label: lang.addButtonLabel,
            default: true,
            toolTip: lang.addButtonTooltip
          },
          {
            id: 'Cancel',
            label: lang.cancelButtonLabel,
            disabled: false,
            close: true,
            toolTip: lang.cancelButtonTooltip
          }
        ],
        nodeModel: status.model,
        availablePermissions: self.options.collection.availablePermissions,
        startLocations: ['acl.groups'],
        selectableMembers: selectableMembers
      }, self);
      membersPickerDialog
          .show()
          .done(function () {
            deferred.resolve.apply(deferred, arguments);
          }).fail(function (error) {
        deferred.reject.apply(deferred, arguments);
      });

    },

    constructor: function PermissionsContentView(options) {
      var self = this;
      options || (options = {});
      options.toolbarItems || (options.toolbarItems = toolbarItems);
      options.toolbarItemsMasks || (options.toolbarItemsMasks = new ToolbarItemsMasks());
      this.options = options;
      Marionette.LayoutView.prototype.constructor.call(this, options);

      // When this view is used alone on a perspective, if should offer
      // spinning sun to commands executed with it as originating view
      BlockingView.imbue(this);

      this.memberFilter = this.options.context.getModel(MemberModelFactory);

      this.collection = this.options.collection;

      this.listenTo(this.memberFilter, 'change', function () {
        if (this.collection.isFetchable()) {
          var self             = this,
              userPermissions  = this.permissionsListView.tableHeaderView.options.userPermissionsModel.get(
                  "permissions"),
              edit_permissions = this.options.authUser &&
                                 this.options.authUser.get("privilege_user_admin_rights");
          self.edit_permissions = edit_permissions;
          if (this.memberFilter.get("id")) {
            if (!this.originalCollection) {
              this.originalCollection = this.options.collection.clone();
            }
            this.options.filteredPermissions = true;
            var filteredCollection = _.filter(this.originalCollection.models, function (model) {
                  //TODO: enble below commented line to show members in hierarchical structure
                  /*if (model.get("right_id") === this.memberFilter.get("group_id")) {
                    model.selectedUser = this.memberFilter;
                  }
                  return model.get("right_id") === this.memberFilter.get("id") ||
                         model.get("right_id") === this.memberFilter.get("group_id");*/
                  return model.get("right_id") === this.memberFilter.get("id");
                }, this),
                availableGroups    = _.filter(self.originalCollection.models, function (model) {
                  return model.get("right_id_expand") && model.get("right_id_expand").type === 1;
                }, this);
            this.collection.models = filteredCollection;
            if (this.permissionsListView) {
              this.collection.options.memberId = this.memberFilter.get('id');
              //TODO: Remove the if-else statement to show the user/Group according to the ACL list
              if (filteredCollection.length > 0) {
                this.permissionsListView.trigger("update:table", this.collection);
              } else {
                this.collection.options.clearEmptyPermissionModel = true;
                this.collection.fetch().then(function (resp) {
                  if (resp.results.data && resp.results.data.permissions &&
                      resp.results.data.permissions.length === 0 && self.edit_permissions) {
                    self.ui.permissionList.addClass("empty-permission-list");
                    if (availableGroups.length > 0) {
                      self.ui.emptyActionsContainer.removeClass("binf-hidden");
                      var addMemberToGroup = _.str.sformat(lang.addMemberToGroup,
                          self.memberFilter.get('name'));
                      var grantAccessToMember = _.str.sformat(lang.grantAccessToMember,
                          self.memberFilter.get('name'));
                      self.ui.addMemberToGroup.text(addMemberToGroup);
                      self.ui.grantAccessToMember.text(grantAccessToMember);
                      self.ui.addMemberToGroup.attr("title", addMemberToGroup);
                      self.ui.grantAccessToMember.attr("title", grantAccessToMember);
                    }
                  }
                }, this);
              }
            } else {
              this.model.set("isNotFound", true);
              this.collection.options.memberId = this.memberFilter.get('id');
              this.collection.fetch();
              if (edit_permissions) {
                this.ui.permissionList.addClass("empty-permission-list");
                if (availableGroups.length > 0) {
                  this.ui.emptyActionsContainer.removeClass("binf-hidden");
                  var addMemberToGroup = _.str.sformat(lang.addMemberToGroup,
                      this.memberFilter.get('name'));
                  var grantAccessToMember = _.str.sformat(lang.grantAccessToMember,
                      this.memberFilter.get('name'));
                  this.ui.addMemberToGroup.text(addMemberToGroup);
                  this.ui.grantAccessToMember.text(grantAccessToMember);
                  this.ui.addMemberToGroup.attr("title", addMemberToGroup);
                  this.ui.grantAccessToMember.attr("title", grantAccessToMember);
                }
              }
            }
          } else {
            this.ui.emptyActionsContainer.addClass("binf-hidden");
            this.ui.permissionList.removeClass("empty-permission-list");
            this.model.set("isNotFound", false);
            this.options.filteredPermissions = false;
            this.originalCollection = undefined;
            this.collection.options.memberId = this.memberFilter.get('id');
            this.collection.fetch();
          }
        }
      });

      this.permissionsLookupView = new PermissionsLookupView(_.extend({
        originatingView: this.options.originatingView,
        userPickerModel: this.memberFilter
      }, this.options));
      this.admin_permissions = this.options.authUser &&
                               this.options.authUser.get("privilege_system_admin_rights");
      this.columnCollection = permissionTableColumns.clone();
      this.updateColumnsCollection();
      this.permissionsListView = new TableListView(_.extend({
        originatingView: this.options.originatingView,
        context: this.options.context,
        memberFilter: this.memberFilter,
        toolbarItems: this.options.toolbarItems,
        toolbarItemsMasks: this.options.toolbarItemsMasks,
        collection: this.collection,
        tableColumns: this.columnCollection,
        emptyView: NoPermissionsResultView,
        emptyViewModel: this.memberFilter,
        applyTo: this.options.applyTo,
        admin_permissions: this.admin_permissions,
        hasPermissionAction: this.options.hasPermissionAction
      }, this.options));

      if (this._isCollectionEditable()) {
        this.listenTo(this.permissionsListView, 'render', this.createPermissionDropDown);
      }
      this.listenTo(this.options.authenticatedUserPermissions, 'change',
          this._updatePermissionTable);
      this.listenTo(this.permissionsListView, 'render', this._resizePermissionTable);
      this.listenTo(this.permissionsListView, 'scroll', this._handleScroll);
      this.listenTo(this.permissionsListView, 'resizetable', this._resizePermissionTable);
      this.propagateEventsToViews(this.permissionsLookupView, this.permissionsListView);
    },

    updateColumnsCollection: function () {
      var models;
      if (this.options.hasPermissionAction) {
        if ((this.admin_permissions || this.options.authenticatedUserPermissions &&
                                       this.options.authenticatedUserPermissions.hasEditPermissionRights())) {
          models = permissionTableColumns.models;
        } else {
          models = permissionTableColumns.filter(function (model) {
            return !model.attributes.isToolbar;
          });
        }
      } else {
        models = permissionTableColumns.filter(function (model) {
          return !model.attributes.isToolbar;
        });
      }
      this.columnCollection.set(models, {remove: true});
    },

    _updatePermissionTable: function () {
      if (!this._isCollectionEditable()) {
        this.permissionsListView.$el.find('.csui-add-permission').addClass('binf-hidden');
        this.permissionsListView.$el.find('.csui-add-owner-or-group .csui-user-display-name').text(
            lang.NoOwnerAssigned);
      }
    },

    _resizePermissionTable: function (event) {
      // smartly display list view
      var tableEle = this.$el.find('.csui-table-body');

      if (tableEle) {
        if (tableEle.parents('.csui-table-list').hasClass('csui-table-list-no-scrollable')) {
          tableEle.parents('.csui-table-list').removeClass('csui-table-list-no-scrollable');
        }

        if (tableEle.height() > tableEle.parent().height()) {
          tableEle.parents('.csui-table-list').removeClass('csui-table-list-no-scrollable');
        } else {
          tableEle.parents('.csui-table-list').addClass('csui-table-list-no-scrollable');
        }

      }
    },

    _isCollectionEditable: function () {
      var userRights = this.collection.options.authenticatedUserPermissions;
      return (userRights && userRights.hasEditPermissionRights() || this.admin_permissions);
    },

    showAddPermissionDropDown: function (e) {
      if (e.target.getAttribute('aria-expanded') !== "true") {
        this.createMenuItems(e);
      }
    },

    createPermissionDropDown: function () {
      if (this._isCollectionEditable()) {
        var toggler     = this.permissionsListView.$el.find('.csui-add-permission').addClass(
            'icon-toolbarAdd').addClass('binf-dropdown-toggle'),
            togglerCell = toggler.closest('.csui-table-header-cell'),
            toolItems;
        toggler.attr({
          'data-binf-toggle': 'dropdown',
          'aria-expanded': 'false',
          'tabindex': '-1',
          'aria-label': lang.AddUserOrGroup,
          'title': lang.AddDropdownTitle,
          'role': 'button'
        });
        toggler.bind('click', _.bind(this.showAddPermissionDropDown, this));
        this.dropDownEl = toggler;
        togglerCell.bind('keydown', _.bind(this.onKeyInView, this));
      }
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        // space key or enter key
        if (this.$(event.target).hasClass('csui-toolitem')) {
          //for dropdown items
          this.$(event.target).click();
        } else {
          //for add button
          this.$el.find('.csui-add-permission').click();
        }
      }
    },

    createMenuItems: function (event) {
      var dropdownContainer = $(event.target).parent().addClass(
          'binf-dropdown');
      var listItems                                  = dropdownMenuItems.dropdownMenuList,
          ulEle, liEle, signature, toolItems, status = {};
      ulEle = $('<ul class="binf-dropdown-menu" role="menu"></ul>');
      if (this.options.filteredPermissions) {
        _.extend(this.originalCollection.options, this.collection.options);
        status.permissionCollection = this.originalCollection;
      } else {
        status.permissionCollection = this.collection;
      }

      listItems.collection.models.forEach(function (item_) {
        signature = item_.get('signature');
        var command = commands.findWhere({signature: signature});
        status.toolItem = item_;
        if (!!command && signature !== "disabled" && command.enabled(status)) {
          command.set('startLocation', status.startLocation);
          liEle = '<li data-csui-command="' + item_.get('signature') +
                  '"><a tabindex="-1" class="csui-toolitem">' + item_.get('name') + '</a></li>';
          ulEle.append(liEle);
        }
      });
      dropdownContainer.find('ul').remove();
      dropdownContainer.append(ulEle);
      toolItems = this.permissionsListView.$el.find('.csui-add-permission').parent().find(
          '.csui-toolitem');
      toolItems.bind('click', _.bind(this.executeToolItemAction, this));
    },

    executeToolItemAction: function (event) {
      var self = this;
      this.commands = commands;
      var signature = event.target.parentElement.getAttribute(
          'data-csui-command'),
          command   = this.commands.findWhere({signature: signature});
      var status = {
        startLocation: command.get('startLocation'),
        context: this.options.context,
        permissionCollection: this.collection,
        originalCollection: this.originalCollection,
        nodeModel: this.model,
        originatingView: this,
        connector: this.model.connector,
        nodeId: this.model.get('id'),
        applyTo: this.options.applyTo
      };
      if (command && command.enabled(status)) {
        this._ = _;
        command.execute(status).done(_.bind(function (resp) {
          if (self.permissionsLookupView.pickerView &&
              self.permissionsLookupView.pickerView.ui.searchclear.is(":visible")) {
            self.permissionsLookupView.pickerView.ui.searchclear.click();
          } else {
            if (resp.get("addOwnerGroup")) {
              self.collection.addOwnerOrGroup(resp);
            } else if (resp.get("publicAccess")) {
              self.collection.addPublicAccess(resp);
            } else {
              self.collection.add(resp);
            }
          }
          if (self.originalCollection && self.originalCollection.models) {
            var diffInCollection = this.collection.models.filter(function (item1) {
              for (var i in self.originalCollection.models) {
                if ((item1.get('right_id') === self.originalCollection.models[i].get('right_id') &&
                     item1.get('type') === self.originalCollection.models[i].get('type'))
                    || item1.get('type') === null) {
                  return false;
                }
              }
              return true;
            });
            if (diffInCollection.length > 0 && diffInCollection[0].get("type") === "owner" &&
                self.originalCollection.findWhere({type: 'owner'})) {
              self.originalCollection.remove(self.originalCollection.findWhere({type: 'owner'}));
            }
            self.originalCollection.models.push(diffInCollection[0]);
          }
        }, this)).always(function () {
          self.dropDownEl.focus();
        });
      }
    },

    onRender: function () {
      this.lookupRegion.show(this.permissionsLookupView);
      this.listRegion.show(this.permissionsListView);
    },

    onBeforeDestroy: function () {
      if (this.collection.options.memberId) {
        //Remove member id filter from collection & reset memberFilter to blank values
        delete this.collection.options.memberId;
        this.memberFilter.set({id: '', group_id: '', name: ''}, {silent: true});
      }
    },

    _blockActions: function () {
      var origView = this.options.originatingView;
      origView && origView.blockActions && origView.blockActions();
    },

    _unblockActions: function () {
      var origView = this.options.originatingView;
      origView && origView.unblockActions && origView.unblockActions();
    },

    _handleScroll: function (event) {
      this.options.originatingView && this.options.originatingView.trigger('scroll', event);
    }

  });

  _.extend(PermissionsContentView.prototype, ViewEventsPropagationMixin);

  return PermissionsContentView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/no.permissions',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<div class=\"csui-no-permission\">\r\n  "
    + this.escapeExpression(((helper = (helper = helpers.messages || (depth0 != null ? depth0.messages : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"messages","hash":{}}) : helper)))
    + "\r\n</div>";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_no.permissions', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/permissions.view',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/base', 'csui/models/node/node.model',
  'csui/widgets/permissions/impl/permissions.content.view',
  'csui/utils/contexts/factories/node', 'csui/utils/contexts/factories/user',
  'csui/utils/contexts/factories/permission.list.factory',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/utils/nodesprites', 'csui/utils/command.error',
  'csui/controls/progressblocker/blocker', 'csui/utils/commandhelper',
  'csui/models/nodechildren', 'csui/dialogs/modal.alert/modal.alert',
  'csui/utils/commands', 'csui/utils/contexts/factories/usernodepermission',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior', 'csui/utils/taskqueue',
  'hbs!csui/widgets/permissions/impl/no.permissions',
  'i18n!csui/widgets/permissions/impl/nls/lang',
  'css!csui/widgets/permissions/impl/permissions'
], function (module, _, $, Marionette, base, NodeModel, PermissionsContentView,
    NodeModelFactory, UserModelFactory, PermissionCollectionFactory, ViewEventsPropagationMixin,
    NodeSpriteCollection, CommandError, BlockingView, CommandHelper, NodeChildrenCollection,
    ModalAlert, commands, AuthenticatedUserNodePermissionFactory, TabableRegionBehavior,
    TaskQueue, NoPermssionsTemplate, lang) {

  var config = module.config();
  _.defaults(config, {
    parallelism: 3
  });

  var PermissionsView = Marionette.ItemView.extend({

    className: 'cs-permissions',

    behaviors: {
      TabablesBehavior: {
        behaviorClass: TabableRegionBehavior,
        recursiveNavigation: true,
        containTabFocus: true
      }
    },

    isTabable: function () {
      return this.$('*[tabindex]').length > 0;
    },

    currentlyFocusedElement: function (event) {
      var tabElements = this.$('*[tabindex]');
      if (!!event && event.shiftKey) {
        return $(tabElements[tabElements.length - 1]);
      } else {
        return $(tabElements[0]);
      }
    },

    template: false,

    events: {
      'focusin .csui-permissions-user-picker': 'onFocusInUserPicker'
    },

    constructor: function PermissionsView(options) {
      var self = this;
      options || (options = {});
      options.data || (options.data = {});
      if (!options.model) {
        options.model = options.context.getModel(NodeModelFactory, {
          attributes: options.data.id && {id: options.data.id},
          temporary: true
        });
      }
      this.options = options;
      this.context = options.context;
      this.user = this.options.context.getModel(UserModelFactory);

      Marionette.ItemView.prototype.constructor.call(this, options);

      // When this view is used alone on a perspective, if should offer
      // spinning sun to commands executed with it as originating view
      BlockingView.imbue(this);

      this.hasPermissionAction = options.model && options.model.actions &&
                                 !!options.model.actions.get({signature: "permissions"});

      if (this.hasPermissionAction) {
        if (this.options.model && this.options.model.models &&
            this.options.model.models.length > 0) {
          this.options.model = this.options.model.models[0];
        }

        this.collection = this.options.collection = this.options.context.getCollection(
            PermissionCollectionFactory, this.options);

        this.collection.options.node = this.options.model;
        var userNodePermissionsModel = this.context.getModel(
            AuthenticatedUserNodePermissionFactory);
        userNodePermissionsModel.node = this.options.model;
        userNodePermissionsModel.node.set("isNotFound", false);
        userNodePermissionsModel.fetch()
            .done(function () {
              self.collection.options.authenticatedUserPermissions = userNodePermissionsModel;
              self.collection.fetch({
                success: _.bind(self.onPermissionsRequestSuccess, self, self.options),
                error: _.bind(self.onPermissionsRequestFailed, self, self.options)
              });
            })
            .fail(function (cause) {
              var errMsg = new CommandError(cause);
            });

        this._blockActions();
        this.listenTo(this, "permission:level:clicked", this._handlePermissionLevelClicked);
        this.listenTo(this, "permission:level:focus", this._handlePermissionLevelFocus);
        this.listenTo(this, "permission:inlineaction:clicked", this._hidePopovers);
      }
    },

    onRender: function () {
      if (!this.hasPermissionAction) {
        var typeName            = this.model.get("type_name") ? this.model.get("type_name") :
                                  this.model.get("shortcutNode") &&
                                  this.model.get("shortcutNode").get("type_name"),
            noPermissionContent = $('<div />', {
              'class': 'csui-no-permissions-container',
              'html': NoPermssionsTemplate({
                'messages': _.str.sformat(lang.noPermissionsAvailable, typeName)
              })
            });
        this.$el.html(noPermissionContent);
      }
    },

    _hidePopovers: function () {
      if (this.$el.parents('body') &&
          this.$el.parents('body').find('.csui-edit-permission-popover-container' +
                                        ' .binf-popover')) {
        var popoverTarget = this.$el.parents('body').find(
            '.csui-edit-permission-popover-container' +
            ' .binf-popover');
        if (popoverTarget.data('binf.popover')) {
          popoverTarget.binf_popover('destroy');
        }
      }
    },

    onFocusInUserPicker: function (event) {
      var popoverTarget = this.$el.find('.binf-popover.binf-in');
      if (popoverTarget.data('binf.popover')) {
        popoverTarget.binf_popover('destroy');
      }
    },

    onPermissionsRequestSuccess: function (options) {
      var self = this;
      if (this.permissionsContentView) {
        this.cancelEventsToViewsPropagation(this.permissionsContentView);
        this.permissionsContentView.destroy();
      }
      var userHasEditPermissions = options.collection.options.authenticatedUserPermissions &&
                                   options.collection.options.authenticatedUserPermissions.get(
                                       "permissions") &&
                                   options.collection.options.authenticatedUserPermissions.get(
                                       "permissions").indexOf("edit_permissions"),
          isContainer            = options.model.get("container");
      if (userHasEditPermissions >= 0 && isContainer) {
        options.applyTo = {};
        this.fetchPermissionsPreCheck(options);
      }
      this.permissionsContentView = new PermissionsContentView(_.defaults({
        // If this widget is placed on a perspective, it becomes the originating view itself
        originatingView: this,
        context: options.context,
        collection: options.collection,
        applyTo: options.applyTo,
        authUser: this.user,
        authenticatedUserPermissions: options.collection &&
                                      options.collection.options.authenticatedUserPermissions,
        hasPermissionAction: this.hasPermissionAction
      }, options));

      this.propagateEventsToViews(this.permissionsContentView);
      this.renderContent();
      this._unblockActions();
    },

    onPermissionsRequestFailed: function (model, request, message) {
      var error = new base.RequestErrorMessage(message);
      ModalAlert.showError(error.toString());
      this._unblockActions();
    },

    fetchPermissionsPreCheck: function (options) {
      this.options = options;
      this.options.applyTo.subTypes = [];
      var self     = this,
          subTypes = [0, 204, 207, 215, 298, 3030202],
          queue    = new TaskQueue({
            parallelism: config.parallelism
          }),
          nodeID   = self.model.get('id'),
          url      = (self.model.connector.connection.url).replace("v1", "v2") + "/nodes/" +
                     nodeID + "/descendents/subtypes/exists?sub_types=",
          promises = _.map(subTypes, function (subType) {
            var deferred = $.Deferred();
            queue.pending.add({
              worker: function () {
                var permissionPreCheck = self.model.connector.extendAjaxOptions({
                  url: url + subType,
                  type: 'GET',
                  data: {
                    include_sub_items: false
                  }
                });
                $.ajax(permissionPreCheck).done(function (response) {
                  if (response.results.data.subtypes_info !== undefined) {
                    self.options.applyTo.subTypes.push(response.results.data.subtypes_info[0].id);
                  }
                  self.options.applyTo.thresholdExceeded = response.results.data.threshold_exceeded;
                  deferred.resolve(response);
                }).fail(function (response) {
                  deferred.reject(response);
                });
                return deferred.promise();
              }
            });
            return deferred.promise(promises);  // return promises
          });
      return $.whenAll.apply($, promises);
    },

    renderContent: function () {
      // don't render until the shortcut's original node has been fetched
      var fetching = this.options.model.fetching;
      if (fetching) {
        return fetching.done(_.bind(this.render, this));
      }
      if (this.permissionsContentView) {
        var permissionsContentView = this.permissionsContentView.render();
        Marionette.triggerMethodOn(permissionsContentView, 'before:show', permissionsContentView,
            this);
        this.$el.append(permissionsContentView.el);
        Marionette.triggerMethodOn(permissionsContentView, 'show', permissionsContentView, this);
      }
    },

    onBeforeDestroy: function () {
      if (this.permissionsContentView) {
        this.cancelEventsToViewsPropagation(this.permissionsContentView);
        this.permissionsContentView.destroy();
      }
    },

    _closePermissions: function () {
      var node = this.options.model;
      if (node.get('type') === 1 && node.original && node.original.get('type') === 0) {
        this.trigger("permissions:close");
      } else {
        this.trigger('permissions:close:without:animation');
      }
    },

    _blockActions: function () {
      var origView = this.options.originatingView &&
                     this.options.originatingView.$el.is('visible') ? this.options.originatingView :
                     this;
      origView && origView.blockActions && origView.blockActions();
    },

    _unblockActions: function () {
      var origView = this.options.originatingView &&
                     this.options.originatingView.$el.is('visible') ? this.options.originatingView :
                     this;
      origView && origView.unblockActions && origView.unblockActions();
    },

    _handlePermissionLevelClicked: function (args) {
      this._hidePopovers();
      var self     = this,
          cellView = args.cellView;
      if (cellView.$el.data('binf.popover')) { //Return if popover is already open
        return;
      }
      var cmd = commands.get('EditPermission');
      var status = {
        model: cellView.model,
        targetView: {permissions: cellView},
        originatingView: this,
        applyTo: this.options.applyTo,
        authUser: this.user,
        admin_permissions: this.user.get("privilege_user_admin_rights")
      };
      var tableRow = cellView.$el.closest('.csui-table-row');
      tableRow.addClass('active-row');
      self.trigger('block:view:actions');
      if (cmd.enabled(status)) {
        var promisesFromCommand = cmd.execute(status);

        CommandHelper.handleExecutionResults(promisesFromCommand, {
          command: cmd,
          suppressSuccessMessage: status.suppressSuccessMessage,
          suppressFailMessage: status.suppressFailMessage
        }).done(function (nodes) {
          // reducing performance to somewhat extent,
          // such that collection will be refetched iff it meets the following condtions
          // 1) if the current command allows to refetch from it's own implementation
          // 2) if the total count is > current page size.
          if (!!cmd.allowCollectionRefetch && self.collection.totalCount >
                                              self.collection.topCount) {
            self.collection.fetch();
          }
        }).always(function () {
          self.trigger('unblock:view:actions');
          tableRow.removeClass('active-row');
          self.unblockActions && self.unblockActions();
          //return focus to the cell after closing popover
          cellView.$el.focus();
        });
      } else {

        csui.require(['csui/widgets/permissions/impl/edit/edit.permission.helper'
        ], function (EditPermissionHelper) {
          self.editPermissionHelper = new EditPermissionHelper({
            permissionModel: cellView.model,
            popoverPlacement: "left",
            popoverAtBodyElement: self.options.originatingView ? !self.options.originatingView.options.isExpandedView : true,
            popoverTragetElement: cellView.$el,
            readonly: true,
            originatingView: self
          });

          self.editPermissionHelper.showCustomPermissionPopover();
          self.editPermissionHelper.listenTo(self.editPermissionHelper,
              "closed:permission:level:popover", function () {
                self.editPermissionHelper.destroy();
                self.trigger('unblock:view:actions');
                cellView.$el.closest('.csui-table-row').removeClass('active-row');
              });
        });
      }
    },

    _handlePermissionLevelFocus: function (args) {
      this._hidePopovers();
      var self     = this,
          cellView = args.cellView;
      if (cellView.$el.data('binf.popover')) { //Return if popover is already open
        return;
      }
      var status = {
        model: cellView.model,
        targetView: {permissions: cellView},
        originatingView: this,
        applyTo: this.options.applyTo,
        authUser: this.user,
        admin_permissions: this.user.get("privilege_user_admin_rights")
      };
      cellView.$el.closest('.csui-table-row').addClass('active-row');
      self.trigger('block:view:actions');
      csui.require(['csui/widgets/permissions/impl/edit/edit.permission.helper'
      ], function (EditPermissionHelper) {
        self.editPermissionHelper = new EditPermissionHelper({
          permissionModel: cellView.model,
          popoverPlacement: "left",
          popoverAtBodyElement: self.options.originatingView ? !self.options.originatingView.options.isExpandedView : true,
          popoverTragetElement: cellView.$el,
          readonly: true,
          originatingView: self
        });

        self.editPermissionHelper.showCustomPermissionPopover();
        self.editPermissionHelper.listenTo(self.editPermissionHelper,
            "closed:permission:level:popover", function () {
              self.editPermissionHelper.destroy();
              self.trigger('unblock:view:actions');
              cellView.$el.closest('.csui-table-row').removeClass('active-row');
              cellView.$el.focus();
            });
      });
    }
  });

  _.extend(PermissionsView.prototype, ViewEventsPropagationMixin);

  return PermissionsView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/widgets/permissions/impl/edit/apply.permission/impl/header/apply.permission.header',['module','hbs','csui/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var helper;

  return "<h4 class=\"binf-modal-title\">\r\n  <span class=\"icon icon-notification-information\"></span>\r\n  <span class=\"title-text csui-apply-permission-header-title\" title=\""
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "\">"
    + this.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{}}) : helper)))
    + "</span>\r\n</h4>";
}});
Handlebars.registerPartial('csui_widgets_permissions_impl_edit_apply.permission_impl_header_apply.permission.header', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/permissions/impl/edit/apply.permission/impl/header/apply.permission.header.view',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'hbs!csui/widgets/permissions/impl/edit/apply.permission/impl/header/apply.permission.header',
  'i18n!csui/widgets/permissions/impl/edit/apply.permission/impl/nls/lang',
  'css!csui/widgets/permissions/impl/permissions'
], function (_,
    $,
    Marionette,
    applyPermissionHeaderTemplate,
    lang) {
  "use strict";

  var ApplyPermissionHeaderView = Marionette.ItemView.extend({

    template: applyPermissionHeaderTemplate,

    templateHelpers: function () {
      var headerTitle = "";
      if (this.options.removePermission) {
        var memberName = this.options.permissionModel &&
                         this.options.permissionModel.get("right_id_expand") &&
                         this.options.permissionModel.get("right_id_expand").name_formatted;
        memberName = this.options.permissionModel &&
                     this.options.permissionModel.get("type") === "public" ? lang.publicAccess :
                     memberName;
        headerTitle = _.str.sformat(lang.removePermissionHeaderTitle, memberName);
      } else if (this.options.restorePublicAccess) {
        headerTitle = lang.restorePublicAccessHeaderTitle;
      } else {
        headerTitle = lang.applyPermissionHeaderTitle;
      }
      return {
        title: headerTitle
      };
    },

    constructor: function ApplyPermissionHeaderView(options) {
      options || (options = {});
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }
  });

  return ApplyPermissionHeaderView;
});
csui.define('csui/widgets/permissions/impl/edit/edit.permission.helper',[
  'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/controls/dialog/dialog.view',
  'i18n',
  'csui/models/permission/nodepermission.model',
  'csui/widgets/permissions/impl/edit/permission.level.selector/permission.level.selector.view',
  'csui/widgets/permissions/impl/edit/permission.attributes/permission.attributes.view',
  'csui/widgets/permissions/impl/edit/apply.permission/apply.permission.view',
  'csui/widgets/permissions/impl/edit/apply.permission/impl/header/apply.permission.header.view',
  'csui/controls/progressblocker/blocker',
  'i18n!csui/widgets/permissions/impl/nls/lang'
], function (_,
    $,
    Marionette,
    base,
    DialogView,
    i18n,
    NodePermissionModel,
    PermissionLevelSelectorView,
    PermissionAttributesView,
    ApplyPermissionView,
    ApplyPermissionHeaderView,
    BlockingView,
    lang) {
  "use strict";

  var EditPermissionHelper = Marionette.Object.extend({

    constructor: function EditPermissionHelper(options) {
      Marionette.Object.prototype.constructor.apply(this, arguments);
    },

    initialize: function (options) {
      this.uniqueViewId = 'view' + _.uniqueId();
      if (!this.options.readonly) {
        this._showSelectPermissionLevelPopover();
      }
    },

    _showSelectPermissionLevelPopover: function () {
      // show the permission level selector view in a popover
      this.permissionLevelSelectorView && this.permissionLevelSelectorView.destroy();
      this.permissionLevelSelectorView = new PermissionLevelSelectorView({
        permissionModel: this.options.permissionModel
      });
      this.permissionLevelSelectorView.render();
      this.listenTo(this.permissionLevelSelectorView, 'permission:level:selected',
          this._permissionLevelSelected);

      this.currentPopoverView = this.permissionLevelSelectorView;
      this.popoverContainerClassname = "";
      this.showPopover();
    },

    showCustomPermissionPopover: function () {
      // show the permission attributes view in a popover to view currently assigned
      // permissions or select custom permission
      this.permissionAttributesView && this.permissionAttributesView.destroy();
      this.permissionAttributesView = new PermissionAttributesView({
        model: this.options.permissionModel,
        readonly: this.options.readonly,
        node: this.options.originatingView && this.options.originatingView.model
      });
      this.permissionAttributesView.render();
      this.listenTo(this.permissionAttributesView, 'permission:attribute:save:clicked',
          this._permissionAttributesSelected);

      this.listenTo(this.permissionAttributesView, 'permission:attribute:cancel:clicked',
          this.closePopover);

      this.currentPopoverView = this.permissionAttributesView;
      this.popoverContainerClassname = "csui-permission-attribute-popover-container ";
      this.showPopover();
    },

    _permissionLevelSelected: function () {
      var selectedLevel = this.permissionLevelSelectorView.selected;
      if (selectedLevel !== NodePermissionModel.PERMISSION_LEVEL_CUSTOM) {
        //Close popover without raising any close popover event
        this.showingPopover && this.closePopover(true);
        this.permissions = NodePermissionModel.getPermissionsByLevelExceptCustom(selectedLevel, this.options.originatingView ?  this.options.originatingView.model.get('container') : true);
        //Check for the selected node is container and open apply permissions to sub-items dialog
        if (this.options.originatingView && this.options.originatingView.model &&
            this.options.originatingView.model.get("container") &&
            this.options.originatingView.model.get("permissions_model") === "advanced") {
          this._applyDialog = this.showApplyPermissionDialog();
          this._applyDialog.show();
        } else {
          this.triggerMethod('permissions:selected', {permissions: this.permissions});
        }
      } else {
        // Bootstrap popover has a bug: removing this too early will cause issue with next showing.
        // There is no event after destroy. The hidden event is not triggered for destroy.
        this.showCustomPermissionPopover();
      }
    },

    showApplyPermissionDialog: function () {
      var headerView = new ApplyPermissionHeaderView();
      this._view = new ApplyPermissionView({
        context: this.options.originatingView.context,
        model: this.options.originatingView.model,
        applyTo: this.options.applyTo,
        permissionModel: this.options.permissionModel
      });
      var dialog = new DialogView({
        headerView: headerView,
        view: this._view,
        className: "csui-permissions-apply-dialog",
        midSize: true,
        buttons: [
          {
            id: 'apply',
            label: lang.applyButtonLabel,
            toolTip: lang.applyButtonLabel,
            'default': true,
            click: _.bind(this.onClickApplyButton, this)
          },
          {
            label: lang.cancelButtonLabel,
            toolTip: lang.cancelButtonLabel,
            close: true
          }
        ]
      });
      dialog.listenTo(dialog, 'hide', _.bind(this.onHideDialog, this));
      BlockingView.imbue(dialog);
      return dialog;
    },

    onClickApplyButton: function (event) {
      var selectedSubItems = event.dialog.$el.find(".csui-subtypes-option:checked").map(
          function () {
            return this.value;
          }).toArray(),
          container        = event.dialog.options.view.model.get("container"),
          right_id         = event.dialog.options.view.options.permissionModel &&
                             event.dialog.options.view.options.permissionModel.get("right_id"),
          permissionModel  = event.dialog.options.view.model.get("permissions_model"),
          apply_to         = (container && permissionModel === "advanced") &&
                             event.dialog.options.view.subFolderSelected ? 2 :
                             (container && permissionModel === "advanced") ? 3 : 0;

      var deferredResp = this.triggerMethod('permissions:selected',
          {
            permissions: this.permissions,
            apply_to: apply_to,
            right_id: right_id,
            include_sub_types: selectedSubItems
          });
      this._applyDialog.destroy();
      this._blockActions();
    },

    onHideDialog: function () {
      var origView = this.options.originatingView;
      origView && origView.trigger("unblock:view:actions");
    },

    _blockActions: function () {
      var origView = this.options.originatingView;
      origView && origView.blockActions && origView.blockActions();
    },

    _unblockActions: function () {
      var origView = this.options.originatingView;
      origView && origView.unblockActions && origView.unblockActions();
    },

    unblockActions: function () {
      this._unblockActions();
    },

    _permissionAttributesSelected: function (permissions) {
      this.permissions = permissions;
      //Close popover without raising any close popover event
      this.showingPopover && this.closePopover(true);
      if (this.options.originatingView && this.options.originatingView.model &&
          this.options.originatingView.model.get("container")) {
        this._applyDialog = this.showApplyPermissionDialog();
        this._applyDialog.show();
      } else {
        this.triggerMethod('permissions:selected', {permissions: this.permissions});
      }
    },

    showPopover: function () {
      var placement = this.options.popoverPlacement,
          isRtl     = false;
      if (i18n && i18n.settings.rtl) {
        placement = (placement === 'left') ? 'right' : 'left';
        isRtl = true;
      }

      var popoverOptions = {
        html: true,
        content: _.bind(function () {
          return this.currentPopoverView.el;
        }, this),
        trigger: 'manual',
        placement: placement
      };

      if (this.options.popoverAtBodyElement) {
        this.popoverContainerClassname += 'csui-edit-permission-popover-container ' +
                                          this.uniqueViewId;
        this.popoverContainerSelector = '.csui-edit-permission-popover-container.' +
                                        this.uniqueViewId;
        // append a div element to the 'body'
        if (!this.$popoverEl) {
          $('body').append(
              '<div class="binf-widgets ' + this.popoverContainerClassname + '"></div>');
        } else {
          //adding class to permission attribute popover
          this._getPopoverParent().addClass(this.popoverContainerClassname);
        }
        popoverOptions = _.extend(popoverOptions, {container: this.popoverContainerSelector});
      }

      // creating the popover
      this.$popoverEl = this.options.popoverTragetElement;
      this.$popoverEl.binf_popover(popoverOptions).binf_popover('show');

      // adjusting popover top and arrow top as in UX specs
      var $popoverDiv  = this._getPopoverParent().find('.binf-popover'),
          adjustSplitsHeight,
          adjustSplitsRight,
          adjustSplitsSeparator,
          adjustSplits = this._getPopoverParent().find('.binf-popover').find(".csui-tree-split"),
          adjustedLeft;

      // adjusting split bar and separator positions
      for (var i = adjustSplits.length - 1, j = 0; i >= 0, j < adjustSplits.length; i--, j++) {
        adjustSplitsRight = $(adjustSplits[i]).width() * j;
        adjustSplitsSeparator = $(adjustSplits[i]).closest(".csui-tree-child").find(
            '.csui-separator');
        if (adjustSplits[i] === adjustSplits[adjustSplits.length - 1]) {
          adjustSplitsHeight = $popoverDiv.find('.csui-permission-attribute-tree').outerHeight();
        } else {
          adjustSplitsHeight = Math.round(($(adjustSplits[i]).closest("li").position().top) +
                                          $(adjustSplits[i]).closest(
                                              ".csui-tree-child").outerHeight());
          adjustSplitsRight = adjustSplitsRight + j;
        }
        if (isRtl) {
          $(adjustSplits[i]).css({'height': adjustSplitsHeight, 'left': adjustSplitsRight});
          adjustSplitsSeparator.css({
            'width': ($popoverDiv.find('.csui-tree-container').width() - adjustSplitsRight),
            'left': adjustSplitsRight
          });
          $(adjustSplits[i]).closest('.csui-tree-child').css(
              {'padding-left': adjustSplitsRight + $(adjustSplits[i]).width()});
        }
        else {
          $(adjustSplits[i]).css({'height': adjustSplitsHeight, 'right': adjustSplitsRight});
          adjustSplitsSeparator.css({
            'width': ($popoverDiv.find('.csui-tree-container').width() - adjustSplitsRight),
            'right': adjustSplitsRight
          });
          $(adjustSplits[i]).closest('.csui-tree-child').css(
              {'padding-right': adjustSplitsRight + $(adjustSplits[i]).width()});
        }
      }

      // adjusting popover left and right positions
      if (i18n && i18n.settings.rtl) {
        adjustedLeft = parseInt($popoverDiv.css('left')) + $popoverDiv.find('.binf-arrow').outerWidth();
      } else {
        adjustedLeft = parseInt($popoverDiv.css('left')) - $popoverDiv.find('.binf-arrow').outerWidth();
      }
      $popoverDiv.css('left', adjustedLeft);

      // on shown.binf.popover event that the popover is shown, set focus on view's field
      this.$popoverEl.on('shown.binf.popover', _.bind(function (event) {
        if (this.currentPopoverView && this.currentPopoverView.currentlyFocusedElement) {
          this.currentPopoverView.currentlyFocusedElement().focus();
        }
        $(document).on('mousedown.' + this.uniqueViewId, {view: this}, this._handleClickEvent);
        $(window).bind('resize.' + this.uniqueViewId, {view: this}, this._onWindowResize);
        if (this.options.popoverAtBodyElement) {
          $(document).on('scroll', {view: this}, this._handleScrollEvent);
          //Somethimes due to perfect scrollbar, document scroll is not triggered, so need to
          // listen originatingView scroll event
          this.options.originatingView &&
          this.listenToOnce(this.options.originatingView, 'scroll', function (event) {
            event.data = {view: this};
            this._handleScrollEvent(event);
          });
        }
        $('body').on('keydown.' + this.uniqueViewId, {view: this}, this._handleKeyEvents);
        this.triggerMethod('shown:permission:level:popover');
      }, this));

      this.$popoverEl.on('hidden.binf.popover', _.bind(function (event) {
        this.$popoverEl.focus();
        this.currentPopoverView && this.currentPopoverView.destroy();
        this.currentPopoverView = undefined;
        this.options.popoverAtBodyElement && $(this.popoverContainerSelector).remove();
      }, this));

      this.showingPopover = true;
    },

    _onWindowResize: function (event) {
      if (event && event.data && event.data.view) {
        var self = event.data.view;
        self.showingPopover && self.closePopover();
      }
    },

    _handleKeyEvents: function (event) {
      //Close popover on Esc or Enter
      if (event && event.data && event.data.view) {
        var self = event.data.view;
        if ((self.getOption("readonly") && (event.keyCode === 9 || event.keyCode === 13)) ||
            event.keyCode === 27) {
          self.showingPopover && self.closePopover();
        }
      }
    },

    _handleClickEvent: function (event) {
      // check to see if the click is NOT on the popover
      if (!$(event.target).closest('.binf-popover').length) {
        var self;
        if (event && event.data && event.data.view) {
          self = event.data.view;
          // always turn off the click event in case the popover was already closed
          $(document).off('mousedown.' + this.uniqueViewId, self._handleClickEvent);
        }
        // the click was outside of the popover, so find the popover and close it
        self && self.closePopover();
      }
    },

    _handleScrollEvent: function (event) {
      // check to see if the scroll event is NOT on the popover
      if (!$(event.target).closest('.binf-popover').length) {
        var self;
        if (event && event.data && event.data.view) {
          self = event.data.view;
          // always turn off the scroll event in case the popover was already closed
          $(document).off('scroll', self._handleScrollEvent);
        }
        self && self.closePopover();
      }
    },

    closePopover: function (triggerNoEvent) {
      // check if popover is currently open, close it
      if (this.$popoverEl && this.$popoverEl.data('binf.popover')) {
        $(document).off('mousedown.' + this.uniqueViewId, this._handleClickEvent);
        $(document).off('scroll', this._handleScrollEvent);
        $(window).unbind('resize.' + this.uniqueViewId, this._onWindowResize);
        this.currentPopoverView &&
        this.currentPopoverView.$el.off('keydown', this._handleKeyEvents);

        this.$popoverEl.binf_popover('destroy');
        this.showingPopover = false;

        if (!triggerNoEvent) {
          this.triggerMethod('closed:permission:level:popover');
        }
      }
      this.$popoverEl.focus();
    },

    _getPopoverParent: function () {
      return this.options.popoverAtBodyElement ? $(this.popoverContainerSelector) :
             this.$popoverEl.parent();
    },

    onBeforeDestroy: function () {
      this.closePopover(true);
    }
  });

  return EditPermissionHelper;

});


csui.define('json!csui/widgets/nodestable/nodestable.manifest.json',{
  "$schema": "http://opentext.com/cs/json-schema/draft-04/schema#",
  "title": "{{title}}",
  "description": "{{description}}",
  "kind": "fullpage",
  "schema": {
    "type": "object",
    "properties": {
      "containerId": {
        "title": "{{containerIdTitle}}",
        "description": "{{containerIdDescription}}",
        "type": "integer"
      },
      "pageSize": {
        "title": "{{pageSizeTitle}}",
        "description": "{{pageSizeDescription}}",
        "type": "integer",
        "minimum": 5,
        "maximum": 100,
        "default": 30
      },
      "pageSizes": {
        "title": "{{pageSizesTitle}}",
        "description": "{{pageSizesDescription}}",
        "type": "array",
        "minItems": 1,
        "maxItems": 6,
        "items": {
          "type": "integer",
          "minimum": 5,
          "maximum": 100
        },
        "default": [30, 50, 100]
      }
    }
  },
  "options": {
    "fields": {
      "containerId": {
        "type": "otcs_node_picker",
        "type_control": {
          "parameters": {
            "select_types": [-1]
          }
        }
      }
    }
  },
  "actions": [
    {
      "toolItems": "csui/widgets/nodestable/toolbaritems",
      "toolItemMasks": "csui/widgets/nodestable/toolbaritems.masks",
      "toolbars": [
        {
          "id": "tableHeaderToolbar",
          "title": "{{tableHeaderToolbarTitle}}",
          "description": "{{tableHeaderToolbarDescription}}"
        },
        {
          "id": "inlineActionbar",
          "title": "{{inlineActionbarTitle}}",
          "description": "{{inlineActionbarDescription}}"
        },
        {
          "id": "leftToolbar",
          "title": "{{leftToolbarTitle}}",
          "description": "{{leftToolbarDescription}}"
        },
        {
          "id": "rightToolbar",
          "title": "{{rightToolbarTitle}}",
          "description": "{{rightToolbarDescription}}"
        }
      ]
    },
    {
      "toolItems": "csui/widgets/nodestable/headermenuitems",
      "toolItemMasks": "csui/widgets/nodestable/headermenuitems.mask",
      "toolbars": [
        {
          "id": "headerMenuToolbar",
          "title": "{{headerMenuTitle}}",
          "description": "{{headerMenuDescription}}"
        }
      ]
    }
  ]
}
);

csui.define('csui/widgets/nodestable/impl/nls/nodestable.manifest',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/widgets/nodestable/impl/nls/root/nodestable.manifest',{
  "title": "Node Browsing Table",
  "description": "Provides a tabular view on objects stored in a container.",
  "containerIdTitle": "Container",
  "containerIdDescription": "A container object to browse children of.",
  "pageSizeTitle": "Default Page Size",
  "pageSizeDescription": "The maximum object count to be displayed in the table body by default.",
  "pageSizesTitle": "Available Page Sizes",
  "pageSizesDescription": "A list of maximum displayed object counts in the table body to be chosen from.",
  "leftToolbarTitle": "Left Header Toolbar",
  "leftToolbarDescription": "Toolbar on the left side of the name of the currently opened container.",
  "rightToolbarTitle": "Right Header Toolbar",
  "rightToolbarDescription": "Toolbar on the right side of the name of the currently opened container.",
  "tableHeaderToolbarTitle": "Table Header Toolbar",
  "tableHeaderToolbarDescription": "Toolbar, which is activated in the table header, once a table row is selected.",
  "inlineActionbarTitle": "Inline Action Bar",
  "inlineActionbarDescription": "Toolbar, which is displayed inside a table row, when the mouse cursor is moving above it.",
  "headerMenuTitle": "Container Context Menu",
  "headerMenuDescription": "Context menu, which is displayed when clicking on the arrow on the right side of the name of the currently opened container.",
});


csui.define('bundles/csui-browse',[
  // Behaviors
  'csui/behaviors/item.name/item.name.behavior',
  'csui/behaviors/table.rowselection.toolbar/table.rowselection.toolbar.behavior',
  // Controls
  'csui/controls/conflict.resolver/impl/conflict.dialog/conflict.dialog',
  'csui/controls/conflict.resolver/impl/collection.conflicts/collection.conflicts.view',
  'csui/controls/conflict.resolver/conflict.resolver',
  'csui/controls/dialog/dialog.view',
  'csui/controls/draganddrop/draganddrop.view',
  'csui/controls/fileupload/fileupload',
  // Loaded dynamically from the add version command
  'csui/controls/fileupload/impl/addversion.controller',
  'csui/controls/pagination/nodespagination.view',
  'csui/controls/tableactionbar/tableactionbar.view',
  'csui/controls/item.title/item.title.view',
  'csui/controls/table/table.columns',
  'csui/controls/table/table.view',
  'csui/controls/table.list/table.list.view',
  // Loaded dynamically from inlineedit command
  'csui/controls/table/inlineforms/inlineform.factory',
  'csui/controls/tabletoolbar/tabletoolbar.view',
  'csui/controls/table.configuration.toolbar/configuration.toolbar.dropdown.view',
  'csui/controls/table.rowselection.toolbar/table.rowselection.toolbar.view',
  // loaded dynamically from rename.favorite command
  'csui/controls/table/inlineforms/favorite/favorite.view',
  // Support external inline forms
  'csui/controls/table/inlineforms/generic/generic.view',
  'csui/controls/table/inlineforms/inlineform/impl/inlineform.view',
  'csui/controls/table/inlineforms/inlineform.registry',
  'csui/controls/table/inlineforms/permissions/user.picker/user.picker.view',

  // Table cells
  'csui/controls/table/cells/cell/cell.view',
  'csui/controls/table/cells/celleditor/celleditor.view',
  'csui/controls/table/cells/cell.factory',
  'csui/controls/table/cells/cell.registry',
  'csui/controls/table/cells/date/date.view',
  'csui/controls/table/cells/datetime/datetime.view',
  'csui/controls/table/cells/duedate/duedate.view',
  'csui/controls/table/cells/favorite/favorite.view',
  'csui/controls/table/cells/member/member.view',
  'csui/controls/table/cells/name/name.view',
  'csui/controls/table/cells/node.state/node.state.view',
  'csui/controls/table/cells/parent/parent.view',
  'csui/controls/table/cells/priority/priority.view',
  'csui/controls/table/cells/reservation/reservation.view',
  'csui/controls/table/cells/searchbox/searchbox.view',
  'csui/controls/table/cells/select/select.view',
  'csui/controls/table/cells/size/size.view',
  'csui/controls/table/cells/status/status.view',
  'csui/controls/table/cells/templated/templated.view',
  'csui/controls/table/cells/text/text.view',
  'csui/controls/table/cells/type.icon/type.icon.view',
  'csui/controls/table/cells/user/user.view',
  'csui/controls/table/cells/permission/permission.level.view',
  'csui/controls/tree/tree.view',

  // Node state cell icons implemented in csui
  'csui/controls/table/cells/node.state/impl/node.state.icons',

  // Table rows
  'csui/controls/table/rows/description/description.view',
  'csui/controls/table/rows/metadata/metadatarow.view',

  //Thumbnail Content
  'csui/controls/thumbnail/thumbnail.view',
  'csui/controls/thumbnail/thumbnail.content',
  'csui/controls/thumbnail/content/content.registry',
  'csui/controls/thumbnail/content/content.factory',
  'csui/controls/thumbnail/content/favorite/favorite.view',
  'csui/controls/thumbnail/content/node.state/node.state.view',
  'csui/controls/thumbnail/content/name/name.view',
  'csui/controls/thumbnail/content/member/member.view',
  'csui/controls/thumbnail/content/thumbnail.icon/thumbnail.icon.view',
  'csui/controls/thumbnail/content/overview/overview.view',
  'csui/controls/thumbnail/content/select/select.view',
  'csui/controls/thumbnail/content/size/size.view',
  'csui/controls/thumbnail/content/date/date.view',
  'csui/controls/thumbnail/content/node.state/node.state.view',
  'csui/controls/thumbnail/content/node.state/impl/node.state.icons',
  'csui/controls/thumbnail/content/node.state/impl/reservation/reservation.view',
  'csui/controls/thumbnail/content/overview/overview.content',
  'csui/controls/thumbnail/content/overview/properties.overview',

   //Wizard
   'csui/controls/wizard/wizard.view',

  // Dialogs
  'csui/dialogs/node.picker/node.picker',

  // Picker start locations to inherit from
  'csui/dialogs/node.picker/start.locations/location.base.factory',
  'csui/dialogs/node.picker/start.locations/node.base.factory',
  'csui/dialogs/node.picker/start.locations/start.location.collection',
  // Picker start location imnplementations (they are loaded dynamically;
  // that is why they need to be added to the published module list)
  'csui/dialogs/node.picker/start.locations/current.location/current.location.factory',
  'csui/dialogs/node.picker/start.locations/enterprise.volume/enterprise.volume.factory',
  'csui/dialogs/node.picker/start.locations/favorites/favorites.factory',
  'csui/dialogs/node.picker/start.locations/personal.volume/personal.volume.factory',
  'csui/dialogs/node.picker/start.locations/category.volume/category.volume.factory',
  'csui/dialogs/node.picker/start.locations/perspective.assets.volume/perspective.assets.volume.factory',
  'csui/dialogs/node.picker/start.locations/recent.containers/recent.containers.factory',
  'csui/dialogs/node.picker/start.locations/search.location/search.location.factory',
  'csui/dialogs/node.picker/start.locations/default.location/default.location.factory',

  'csui/dialogs/members.picker/members.picker.wizard',

  // Member Picker start locations to inherit from
  'csui/dialogs/members.picker/start.locations/location.base.factory',
  'csui/dialogs/members.picker/start.locations/start.location.collection',
  'csui/dialogs/members.picker/start.locations/current.group/current.group.factory',
  'csui/dialogs/members.picker/start.locations/all.members/all.members.factory',
  'csui/dialogs/members.picker/start.locations/member.groups/member.groups.factory',
  'csui/dialogs/members.picker/start.locations/recent.groups/recent.groups.factory',
  'csui/dialogs/members.picker/start.locations/all.groups/all.groups.factory',
  'csui/dialogs/members.picker/start.locations/acl.groups/acl.groups.factory',

  'csui/dialogs/members.picker/start.locations/acl.groups/impl/acl.groups.collection',

  // Integration widgets
  'csui/integration/folderbrowser/folderbrowser.widget',
  'csui/integration/target.picker/target.picker',
  'csui/integration/v1.widgets.wrapper',
   // Remove the below test integration file after the permission implementation
  'csui/integration/permission.header/permission.header.view',
  "csui/integration/permission/table/cells/security.permission.cell",
  "csui/integration/permission/table/permission.table.columns",

  //toolbaritems
  "csui/integration/folderbrowser/impl/nodestable.toolitems",

  // 3rd-party libraries
  'csui/lib/jquery.dataTables.bootstrap/js/dataTables.bootstrap',
  'csui/lib/jquery.dataTables/js/jquery.dataTables',
  'csui/lib/jquery.dataTables.tableTools/js/dataTables.tableTools',

  // factories
  //Search.results.factory has been moved to "utils/contexts/factories/search.results.factory".
  //To account for those still referencing the old location "widgets/search.results/...", the file
  //has been added to this bundle.
  'csui/widgets/search.results/impl/search.results.factory',

  // Client-side perspectives
  'json!csui/utils/contexts/perspective/impl/perspectives/metadata.json',
  'json!csui/utils/contexts/perspective/impl/perspectives/metadata.navigation.json',
  'json!csui/utils/contexts/perspective/impl/perspectives/document.overview.json',

  // Application widgets
  'csui/widgets/nodestable/nodestable.view',

  // TODO where should this be?
  'csui/utils/testutils/async.test.utils',

  // Tool items and tool item masks
  'csui/utils/toolitem.masks/children.toolitems.mask',
  'csui/utils/toolitem.masks/creation.toolitems.mask',
  'csui/widgets/favorites/toolbaritems',
  'csui/widgets/favorites/toolbaritems.masks',
  'csui/widgets/nodestable/headermenuitems',
  'csui/widgets/nodestable/headermenuitems.mask',
  'csui/widgets/nodestable/toolbaritems',
  'csui/widgets/nodestable/toolbaritems.masks',
  'csui/widgets/recentlyaccessed/toolbaritems',
  'csui/widgets/recentlyaccessed/toolbaritems.masks',
  'csui/widgets/favorites/tileview.toolbaritems',
  'csui/widgets/recentlyaccessed/tileview.toolbaritems',

  // Tables for expanded list views; they are loaded dynamically,
  // first when the user clicks to expand the list view
  'csui/widgets/favorites/impl/favorites2.table.view',
  'csui/widgets/favorites/favorite.star.view',
  'csui/widgets/myassignments/impl/myassignmentstable.view',
  'csui/widgets/recentlyaccessed/impl/recentlyaccessedtable.view',

  //Permission widgets
  'csui/widgets/permissions/permissions.view',
  'csui/widgets/permissions/impl/edit/permission.level.selector/permission.level.selector.view',
  'csui/widgets/permissions/impl/edit/edit.permission.helper',

  // TODO: Finalize the widget manifest bundling
  //
  // The widget manifests were initially planned for loading in
  // the widget editor only.  They would be loaded by the admin
  // UI only or included in an admin bundle.
  //
  // In the meanwhile, some properties from the manifest started to
  // be used by the flow perspective types during the runtime. Will
  // we make the widget view require the manifest or will we include
  // the manifests in addition here or in other bundle?  Should we
  // use the widget function object to avoid the manifest access?

  // Application widgets manifests
  'json!csui/widgets/nodestable/nodestable.manifest.json',
  'i18n!csui/widgets/nodestable/impl/nls/nodestable.manifest',

  // Shared for dropdown.menu.items and search/toolbaritems from csui-forms
  // FIXME: These strings should be moved to commands and server
  // as the default label there.  Only if the UI control needs a
  // different label, than the default one, it should declare its
  // own.  This is a private module, not meant to be shared.
  'i18n!csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/tabletoolbar/impl/nls/localized.strings',
  'csui/controls/tabletoolbar/impl/nls/root/localized.strings'
], {});

csui.require(['require', 'css'], function (require, css) {
  css.styleLoad(require, 'csui/bundles/csui-browse', true);
});

